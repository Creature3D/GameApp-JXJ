/**********************************************************************
*
*	文件:	   appMethod2.cpp
*
*	描述:	   
*
*	作者:	   李婧
*					
*
**********************************************************************/
#include <rbody/Creature3D/CreBody.h>
#include <JXJ/appMethod2.h>
#include <JXJ/appMethod.h>
#include <JXJ/appMethod16.h>
#include <JXJ/appDataParam.h>
#include <JXJ/appMsg.h>
#include <JXJ/appPackets.h>
#include <CRUI/crWidgetExtend.h>
#include <CRNetApp/appNetLogic.h>
#include <CRNetApp/appGlobalHandle.h>
#include <CRNetApp/appDBUpdate.h>
#include <CRProducer/crViewer.h>
#include <CRProducer/crSceneHandler.h>
#include <CRUtil/crAcceptGIVisitor.h>
#include <CRDataBase/crDataBaseManager.h>
#include <CRNetApp/appDBUpdate2.h>
#include <CRNetApp/appDBQuery2.h>
#include <CRIOManager/crConvertUTF.h>
#include <JXJ/appDBQuery.h>
#include <CRIOManager/crLoadManager.h>
#include <CRIOManager/crCookFile.h>
#include <CRIOManager/crReadFile.h>
#include <CREncapsulation/crNodeVisitors.h>
#include <sys/stat.h>
#include <CRCore/crTexMat.h>
#include <JXJ/appMethod9.h>
#include <CRCore/crStatistics.h>
using namespace CRCore;
using namespace CRNetApp;
using namespace CRDataBase;
using namespace CRNet;
using namespace CRProducer;
using namespace CRPhysics;
using namespace CREncapsulation;
using namespace CRUtil;
using namespace rbody;
using namespace JXJ;
using namespace CRIOManager;
using namespace CRUI;
#define RE_VALUE(type, value) (*((type *)value))

/////////////////////////////////////////
//
//crJXJUIOnClickRegisterMethod  点击创建角色按钮
//
/////////////////////////////////////////
crJXJUIOnClickRegisterMethod::crJXJUIOnClickRegisterMethod():
	m_this(NULL)
{
}
crJXJUIOnClickRegisterMethod::crJXJUIOnClickRegisterMethod(const crJXJUIOnClickRegisterMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJUIOnClickRegisterMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIOnClickRegisterMethod::addParam(int i, const std::string& str)
{

 }
void crJXJUIOnClickRegisterMethod::operator()(crHandle &handle)
{
	bool open = true;
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	if (canvas.valid())
	{
		crData *data = canvas->getDataClass();
		data->inputParam(WCHDATA_JXJRegisterMoveFlag,&open);
	}
	ref_ptr<crCanvasNode> powcanvas = crFilterRenderManager::getInstance()->findCanvas("UI_SelectPower");
	if(powcanvas.valid())
	{
		crData *power_data = powcanvas->getDataClass();
		power_data->inputParam(WCHDATA_JXJRegisterMoveFlag,&open);
	}


}
/////////////////////////////////////////
//
//crJXJUIRegisterMoveUpdateMethod
//
/////////////////////////////////////////
crJXJUIRegisterMoveUpdateMethod::crJXJUIRegisterMoveUpdateMethod():
	m_this(NULL),
	m_fStepLength(0.1)
{
}
crJXJUIRegisterMoveUpdateMethod::crJXJUIRegisterMoveUpdateMethod(const crJXJUIRegisterMoveUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_fStepLength(handle.m_fStepLength)
{
}
void crJXJUIRegisterMoveUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIRegisterMoveUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_eWindowType = (WindowType)atoi(str.c_str());
		break;
	case 1:
		m_fStepLength = atof(str.c_str());
		break;
	case 2:
		m_fEndPosition = atof(str.c_str());
		break;
	case 3:
		m_fArrowPosX = atof(str.c_str());
		break;
	case 4:
		m_fArrowPosY  =  atof(str.c_str());
		m_fArrowPosBack = m_fArrowPosY;
		break;
	case 5:
		m_fArrowShift = atof(str.c_str());
		break;
	}
}
void crJXJUIRegisterMoveUpdateMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJRegisterMoveFlag,param);
	bool open = *(bool *)param;
	if(open)
	{
		switch (m_eWindowType)
		{
		case REGISTER_CHARACTER:
			{
				crVector3 pos = m_this->getTrans();
				if ( pos[0] < m_fEndPosition)
				{
					return;
				}
				else
				{
					pos[0] -= m_fStepLength;
					m_this->setPosition(pos);

					///左下公告窗口
					ref_ptr<crCanvasNode>notice_canvas = crFilterRenderManager::getInstance()->findCanvas("UI_LogIn2_Backboard2");
					if (notice_canvas.valid())
					{
						crVector3 noticePos = notice_canvas->getTrans();
						noticePos[0] -= m_fStepLength;
						notice_canvas->setPosition(noticePos);
					}

				}
			}
			break;
		case SELECT_POWER:
			{
				crVector3 pos = m_this->getTrans();
				if ( pos[0] < 0)
				{
					////显示箭头
					ref_ptr<crCanvasNode>arrows_canvas = crFilterRenderManager::getInstance()->findCanvas("UI_LogIn2_Prompt");
					//arrows_canvas->postMult(crMatrix::scale(2.0f,2.0f,1.0f));
					if (arrows_canvas.valid())
					{
						crVector3 arrow_pos = arrows_canvas->getTrans();
						if (m_fArrowPosY > m_fArrowPosBack)
						{
							m_fArrowPosY = m_fArrowPosBack;
						}
						else
						{
							m_fArrowPosY += m_fArrowShift/10;
						}
						arrow_pos[0] = m_fArrowPosX;
						arrow_pos[1] = m_fArrowPosY;
						crMatrix mat = crMatrix::scale(2.0f,2.0f,1.0f);
						mat.setTrans(arrow_pos);
						arrows_canvas->setMatrix(mat);
						crFilterRenderManager::getInstance()->showCanvas(arrows_canvas.get(),"UI_LogIn2_Prompt",SH_Show);
						///显示对话框
						crFilterRenderManager::getInstance()->showCanvas("UI_LogIn_NT",SH_Show);
					}
					return;
				}
				else
				{
					pos[0] -= m_fStepLength;
					m_this->setPosition(pos);
				}
			}
			break;
		case DIALOG:
			{
				///执行操作
			}
			break;
		default:
			break;
		}
		

// 		crBoundingBox &bbox = m_this->getBoundBox();
// 		bbox.xLength();
// 		bbox.yLength();

	}
}


/////////////////////////////////////////
//
//crJXJUIRandomNameWhileConditionMethod
//
/////////////////////////////////////////
crJXJCheckPlayerNameMethod::crJXJCheckPlayerNameMethod(){}
crJXJCheckPlayerNameMethod::crJXJCheckPlayerNameMethod(const crJXJCheckPlayerNameMethod& handle):
	crMethod(handle)
{
}
void crJXJCheckPlayerNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJCheckPlayerNameMethod::addParam(int i, const std::string& str)
{

}

void crJXJCheckPlayerNameMethod::operator()(crHandle &handle)
{
	//获取名字
	ref_ptr<crTableIO>playerNameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerNameTab);
	int tableLines = playerNameTab->getRowCount();
	CRCore::rangei r(0,tableLines);
	int randomLineNum1 = r.get_random();  //姓 行号
	int randomLineNum2 = r.get_random();  //名 行号

	std::string playName = playerNameTab->getData(randomLineNum1,0);
	playName += playerNameTab->getData(randomLineNum2,1);

	if (!playName.empty())
	{
		//crWaitNetReturnStreamLogic::getLock();

		crJXJCheckPlayerGameNamePacket packet;
		crJXJCheckPlayerGameNamePacket::buildRequestPacket(packet,playName);
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		netConductor->getNetManager()->sendPacket("all",packet);
	
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crData *data = canvas->getDataClass();
		data->inputParam(WCHDATA_JXJRandomPlayName,&playName);
	}

}



/////////////////////////////////////////
//
//crJXJUIDisplayPlayerNameMethod
//
/////////////////////////////////////////
crJXJUIDisplayPlayerNameMethod::crJXJUIDisplayPlayerNameMethod(){}
crJXJUIDisplayPlayerNameMethod::crJXJUIDisplayPlayerNameMethod(const crJXJUIDisplayPlayerNameMethod& handle):
	crMethod(handle)
{
}
void crJXJUIDisplayPlayerNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIDisplayPlayerNameMethod::addParam(int i, const std::string& str)
{

}

void crJXJUIDisplayPlayerNameMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>parent = m_this->getParentCanvas();
	if (parent.valid())
	{
		ref_ptr<crEditWidgetNode> editWidget = (crEditWidgetNode*)parent->getWidget("Name");
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid() && editWidget.valid())
		{
			crData *data = canvas->getDataClass();
			if (data)
			{
				void *param;
				data->getParam(WCHDATA_JXJRandomPlayName,param);
				editWidget->setString(*(std::string*)param);

				bool flag = false;
				data->inputParam(WCHDATA_JXJHaveRandomed,&flag);
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIRandomNameConditionMethod
//
/////////////////////////////////////////
crJXJUIRandomNameConditionMethod::crJXJUIRandomNameConditionMethod(){}
crJXJUIRandomNameConditionMethod::crJXJUIRandomNameConditionMethod(const crJXJUIRandomNameConditionMethod& handle):
	crMethod(handle)
{
}
void crJXJUIRandomNameConditionMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIRandomNameConditionMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_InOutFlag = str;
		break;
	case 1:
		m_bCondition = (bool)atoi(str.c_str());
		break;
	}

}

void crJXJUIRandomNameConditionMethod::operator()(crHandle &handle)
{
	if (m_InOutFlag == "IN")
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			crData *data = canvas->getDataClass();
			if (data)
			{
				bool flag = m_bCondition;
				data->inputParam(WCHDATA_JXJHaveRandomed,&flag);
			}
		}
	}
	else
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			crData *data = canvas->getDataClass();
			if (data)
			{
				void *param;
				data->getParam(WCHDATA_JXJHaveRandomed,param);
				bool bHaveRandomed = *(bool *)param;
				handle.outputParam(0,&bHaveRandomed);
			}
		}
	}

}


/////////////////////////////////////////
//
//crJXJUIGetRandomNameMethod
//
/////////////////////////////////////////
crJXJUIGetRandomNameMethod::crJXJUIGetRandomNameMethod(){}
crJXJUIGetRandomNameMethod::crJXJUIGetRandomNameMethod(const crJXJUIGetRandomNameMethod& handle):
	crMethod(handle),
	m_radio(handle.m_radio)
{
}
void crJXJUIGetRandomNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIGetRandomNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_radio = str;
		break;
	}
}
void crJXJUIGetRandomNameMethod::operator()(crHandle &handle)
{
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(netConductor)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio));
			if (radio.valid())
			{
				void *param;
				unsigned char sex = 0;
				crTableIO::StrVec record;
				//ref_ptr<crTableIO>playerIconTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
				
				crData *data = crBrain::getInstance()->getDataClass();
				data->getParam(WCHDATA_JXJCurPlayerIconID,param);
				int curPlayerIconID = *(int *)param;
				sex = radio->getSelect();
				//int cursel = radio->getSelect();
				//if ((cursel + curPlayerIconID) < playerIconTable->getRowCount())
				//{
				//	sex = atoi((*playerIconTable)(cursel + curPlayerIconID,playerIconTable->getTitleIndex("性别")).c_str());
				//}
				crJXJRandomPlayerNamePacket packet;
				crJXJRandomPlayerNamePacket::buildRequestPacket(packet,sex);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJNetReturnRandomNameMethod
//
/////////////////////////////////////////
crJXJNetReturnRandomNameMethod::crJXJNetReturnRandomNameMethod(){}
crJXJNetReturnRandomNameMethod::crJXJNetReturnRandomNameMethod(const crJXJNetReturnRandomNameMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input),
	m_btn(handle.m_btn)
{
}
void crJXJNetReturnRandomNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_stream = NULL;
		}
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
		}
		break;
	}
}
void crJXJNetReturnRandomNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_btn = str;
		break;
	}
}
void crJXJNetReturnRandomNameMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		bool success = true;
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			ref_ptr<crEditWidgetNode> inputWidget = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input));
			ref_ptr<crButtonWidgetNode> namerandombtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_btn));
			if (inputWidget.valid())
			{
				std::string name = m_stream->_readString();
				ref_ptr<crTableIO>InvalidNameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInvalidWordTab);
				if (InvalidNameTab.valid())
				{
					std::wstring wname = CRIOManager::convertUTF8toUTF16(name.c_str());
					std::wstring invalidstring;
					int ipos = 0;
					int invalidwordsize;
					for (int i = 0; i < InvalidNameTab->getRowCount();i++)
					{
						invalidstring = CRIOManager::convertUTF8toUTF16(InvalidNameTab->getData(i,0).c_str());
						//invalidstring = InvalidNameTab->getData(i,0);
						invalidwordsize = invalidstring.length();
						if (invalidwordsize > 0 && invalidwordsize <=  name.length())
						{
							ipos = wname.find(invalidstring);
							if(ipos != std::string::npos)
							{
								success = false;
								break;
							}
						}
					}
				}
				if (success)
				{
					inputWidget->setString(name);
					inputWidget->setColor(crVector4f(45.0f,45.0f,45.0f,255.0f)/255.0f);
				}
				else
				{
					if(namerandombtn.valid())
					{
						namerandombtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
					}
				}
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJShowHeadCanvasMethod
//
/////////////////////////////////////////
crJXJShowHeadCanvasMethod::crJXJShowHeadCanvasMethod():
m_copiedCanvas(NULL){}
crJXJShowHeadCanvasMethod::crJXJShowHeadCanvasMethod(const crJXJShowHeadCanvasMethod& handle):
	crMethod(handle),
	m_headCanvasName(handle.m_headCanvasName),
	m_needCopy(handle.m_needCopy),
	m_copiedCanvas(NULL),
	m_buildingnameposz(handle.m_buildingnameposz),
	m_canvassw(handle.m_canvassw)
{
}
void crJXJShowHeadCanvasMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJShowHeadCanvasMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_headCanvasName = str;
		break;
	case 1:
		m_needCopy = (bool)atoi(str.c_str());
		break;
	case 2:
		m_inputid = str;
		break;
	case 3:
		m_buildingid =atoi(str.c_str());
		break;
	case 4:
		m_buildingnameposz = atoi(str.c_str());
		break;
	case 5:
		m_target_canvas = str;
		break;
	case 6:
		m_canvassw = str;
		break;
	default:
		break;
	}
}
void crJXJShowHeadCanvasMethod::operator()(crHandle &handle)
{
	//if(m_headCanvasName == "UI_Name_Gongshe")
	//{
	//	int i = 0;
	//}
	ref_ptr<crCanvasNode>headCanvas = crFilterRenderManager::getInstance()->findCanvas(m_headCanvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();

	if(headCanvas.valid() && myPlayer)
	{
		if(m_needCopy)
		{
			if(!m_copiedCanvas.valid())
			{
				crGroup *canvasRoot = crFilterRenderManager::getInstance()->getCanvasRoot();
				m_copiedCanvas = dynamic_cast<crCanvasNode *>(headCanvas->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
				//canvasRoot->addChild(m_copiedCanvas);
				crLoadManager::getInstance()->requestAddNode(canvasRoot,m_copiedCanvas.get(),false);
			}
			headCanvas = m_copiedCanvas;
		}
		crVector3 pos = m_this->getPosition();
		if (m_buildingnameposz == 0)
		{
			pos[2]+=m_this->getRelNode()->getBoundBox().zLength();
		}
		else
		{
			pos[2] += m_buildingnameposz;
		}
		//pos[2] += m_this->getRelNode()->getBoundBox().zLength() + m_buildingnameposz;
		if(crBrain::getInstance()->getCameraFrustum().contains(pos))
		{
			crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
			crVector3 window;
			if (bindview && bindview->isInited())
			{
				bindview->getDefaultSceneHandler()->getSceneView()->projectObjectIntoWindow(pos,window);
				pos = crFilterRenderManager::getInstance()->getIdenticPosition(window);
				pos[2] = 0.0f;
				headCanvas->setPosition(pos);
				//headCanvas->setVisiable(true);
				void *param;
				crData *data = myPlayer->getDataClass();
				data->getParam(m_buildingid,param);
				crData *data2 = headCanvas->getDataClass();
				if(data2)
				{
					data2->inputParam(WCHDATA_JXJBuildingID,&m_buildingid);
					data2->inputParam(WCHDATA_JXJCanvasBuildingItem, m_this);
				}
				unsigned char lv = *(unsigned char *)param;
				if(lv>0 && !headCanvas->getVisiable())
				{
					headCanvas->setCanvasPos(CANVAS_BOTTOM);
					crFilterRenderManager::getInstance()->showCanvas(headCanvas.get(),true);
				}
				ref_ptr<crStaticTextWidgetNode> lvtext = dynamic_cast<crStaticTextWidgetNode *>(headCanvas->getWidget(m_inputid));
				if(lvtext.valid())
				{
					std::string str = crArgumentParser::appItoa(lv)+"级";
					if (lv == 0)
					{
						str = "暂未开放";
					}
					//else
					//{
					//	if(!headCanvas->getVisiable()) 
					//	{
					//		headCanvas->setCanvasPos(CANVAS_BOTTOM);
					//		crFilterRenderManager::getInstance()->showCanvas(headCanvas.get(),true);
					//	}
					//}
					lvtext->setString(str);
					lvtext->setCanFocus(false);
				}
				ref_ptr<crMultiSwitch> lvsw = dynamic_cast<crMultiSwitch *>(headCanvas->getChildNode(m_canvassw));
				if (lvsw.valid() && lv>=1 && lv <=5)
				{
					lvsw->setActiveSwitchSet(lv - 1);
				}
			}
		}
		else
		{
			if(headCanvas->getVisiable()) 
			{
				crFilterRenderManager::getInstance()->closeCanvas(headCanvas.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBuildNameTouchMethod
//
/////////////////////////////////////////
crJXJBuildNameTouchMethod::crJXJBuildNameTouchMethod(){}
crJXJBuildNameTouchMethod::crJXJBuildNameTouchMethod(const crJXJBuildNameTouchMethod& handle):
	crMethod(handle)
{
}
void crJXJBuildNameTouchMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJBuildNameTouchMethod::addParam(int i, const std::string& str)
{
}
void crJXJBuildNameTouchMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	void *param;
	data->getParam(WCHDATA_JXJCanvasBuildingItem,param);
	crInstanceItem *item = (crInstanceItem *)(param);
	if(item)
	{
		item->doEvent(WCH_Touch);
	}
}

/////////////////////////////////////////
//
//crJXJChatTextSendMethod
//
/////////////////////////////////////////
crJXJGameChatTextSendMethod::crJXJGameChatTextSendMethod()
{
}
crJXJGameChatTextSendMethod::crJXJGameChatTextSendMethod(const crJXJGameChatTextSendMethod& handle):
	crMethod(handle),
	m_canvasChat(handle.m_canvasChat),
	m_chatText(handle.m_chatText),
	m_chatinfo(handle.m_chatinfo),
	m_chatMode(handle.m_chatMode),
	m_inRoom(handle.m_inRoom),
	m_sizesw(handle.m_sizesw),
	m_unfoldbtn(handle.m_unfoldbtn)
{
}
void crJXJGameChatTextSendMethod::inputParam(int i, void *param)
{}
void crJXJGameChatTextSendMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_canvasChat = str;
		break;
	case 1:
		m_chatText = str;
		break;
	case 2:
		m_chatinfo = str;
		break;
	case 3:
		m_chatMode = str;
		break;
	case  4:
		m_inRoom = atoi(str.c_str());
		break;
	case 5:
		m_sizesw = str;
		break;
	case 6:
		m_unfoldbtn = str;
		break;
	}
}
void crJXJGameChatTextSendMethod::operator()(crHandle &handle)
{
	// - - - - - - - - - - - - - - - - global defines - - - - - - - - - - - - - - - - 
	// entities
	ref_ptr<crCanvasNode>			chat_canvas		= crFilterRenderManager::getInstance()->findCanvas(m_canvasChat);	
	if (!chat_canvas.valid())
	{
		return;
	}
	ref_ptr<crEditWidgetNode>		chat_input			= dynamic_cast<crEditWidgetNode *>(chat_canvas->getWidget(m_chatText));
	ref_ptr<crHypertextWidgetNode>	chat_show			= dynamic_cast<crHypertextWidgetNode *>(chat_canvas->getWidget(m_chatinfo));
	ref_ptr<crMultiSwitch>			chat_select		= dynamic_cast<crMultiSwitch *>(chat_canvas->getChildNode(m_chatMode));

	// data
	crPlayerGameData		*player_data		= crMyPlayerData::getInstance()->getPlayerGameData();
	crData					*chat_canvas_data	= chat_canvas->getDataClass();
	ref_ptr<crMultiSwitch>			sizesw		= dynamic_cast<crMultiSwitch *>(chat_canvas->getChildNode(m_sizesw));
	ref_ptr<crButtonWidgetNode>		unfoldbtn			= dynamic_cast<crButtonWidgetNode *>(chat_canvas->getWidget(m_unfoldbtn));
	if (sizesw.valid() && sizesw->getActiveSwitchSet() == 0)
	{
		if (unfoldbtn.valid())
		{
			unfoldbtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
		}
	}
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	std::string reciverName;
	bool ifinroom = crMyPlayerData::getInstance()->getSelectedRoom() != NULL;
	int playerid = player_data->getPlayerID();
	crNetManager *netManager = netConductor->getNetManager();
	if (player_data)
	{
		void *param;
		crData *data = player_data->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJShiliID,param);
		unsigned char myShiliid = *(unsigned char *)param;
		bool isLoseCountry = false;
		player_data->doEvent(WCH_JXJCheckCountryLose,MAKECREPARAM(&isLoseCountry,&myShiliid));

		int max_deque_size = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitChatLine,viplv).c_str());
		// temp

		// get sending data
		// player name
		// chatting mode
		// chat text
		crRole *mainRole = player_data->getMainRole();
		crData *roleData = mainRole->getDataClass();
		roleData->getParam(WCHDATA_Level,param);
		unsigned char rolelv = *(unsigned char *)param;

		std::string name = crMyPlayerData::getInstance()->getCharacterName();
		int chat_mode = chat_select->getActiveSwitchSet()+1;
		if (chat_mode != ChatInCountry && chat_mode != ChatInTeam	
			&& chat_mode != ChatInGroup && chat_mode != ChatOneToOne && chat_mode != ChatInWorld)
		{
			chat_mode = ChatInWorld;
		}
		std::string chat_text;
		if(chat_input.valid())chat_text = chat_input->getUTF8String();
		if(chat_text.empty()) 
		{
			//this->display_message(std::string("发送信息不能为空！"));
			return;
		}
		if(chat_text.length()>100)
		{
			this->display_message(std::string("发送消息不能多于50个字符"));
			return;
		}
		if(chat_mode == ChatOneToOne || chat_mode == ChatInTeam)
		{			

			int gmorder = 0;
			std::string keystr;
			if(chat_text.find("/jxjthrow")==0)
			{
				//_asm   int   3   //只是为了让程序崩溃
				__debugbreak();
			}
			else if(chat_text.find("/givejxjitem ")==0)
			{
				keystr = "/givejxjitem ";
				gmorder = 1;
			}
			else if(chat_text.find("/pleaseletmestrong")==0)//升级
			{
				keystr = "/pleaseletmestrong";
				gmorder = 2;
			}
			else if(chat_text.find("/pleaseletmyhousestrong")==0)//建筑升级获得资源自动升满军备科技
			{
				keystr = "/pleaseletmyhousestrong";
				gmorder = 3;
			}
			else if(chat_text.find("/pleasegivemejunling")==0)//获得军令
			{
				keystr = "/pleasegivemejunling";
				gmorder = 4;
			}
			else if(chat_text.find("/robotformation")==0)//自动编队
			{
				keystr = "/robotformation";
				gmorder = 5;
			}
			else if(chat_text.find("/jxjinsertA ")==0)//生成帐号 帐号 密码 个数
			{
				keystr = "/jxjinsertA ";
				gmorder = 6;
			}
			else if(chat_text.find("/jxjcreatejhm")==0)//生成激活码
			{
				keystr = "/jxjcreatejhm";
				gmorder = 7;
			}
			else if(chat_text.find("/jxjmailshow")==0)//GM邮件界面
			{
				keystr = "/jxjmailshow";
				gmorder = 8;
			}
			else if(chat_text.find("/jxjgod")==0)//战场无敌
			{
				keystr = "/jxjgod";
				gmorder = 9;
			}
			else if(chat_text.find("/gg ")==0)//发送公告
			{
				keystr = "/gg ";
				gmorder = 10;
			}
			else if(chat_text.find("/opengamelogin")==0)
			{
				keystr = "/opengamelogin";
				gmorder = 11;
			}
			else if(chat_text.find("/jxjrechargetest")==0)//充值测试
			{
				keystr = "/jxjrechargetest";
				gmorder = 12;
			}
			else if(chat_text.find("/jxjgmtoolshow")==0)//打开GM统计面板
			{
				keystr = "/jxjgmtoolshow";
				gmorder = 14;
			}
			else if(chat_text.find("/jxjgmtool")==0)//加载GM专用场景
			{
				keystr = "/jxjgmtool";
				gmorder = 13;
			}
			else if(chat_text.find("/jxjresetchengchimap")==0)//重置城池表
			{
				keystr = "/jxjresetchengchimap";
				gmorder = 15;
			}
			else if(chat_text.find("/jxjcheckplayerdata")==0)//获取玩家数据
			{
				keystr = "/jxjcheckplayerdata";
				gmorder = 16;
			}
			else if(chat_text.find("/jxjreloadversion")==0)
			{
				keystr = "/jxjreloadversion";
				gmorder = 17;
			}
			else if(chat_text.find("/jxjpassallfuben")==0)//通关所有副本
			{
				keystr = "/jxjpassallfuben";
				gmorder = 18;
			}
			else if(chat_text.find("/jxjresetchengchiid")==0)//重置驻扎城池
			{
				keystr = "/jxjresetchengchiid";
				gmorder = 19;
			}
			else if(chat_text.find("/jxjpassbattle")==0)//战斗胜利
			{
				keystr = "/jxjpassbattle";
				gmorder = 20;
			}
			else if(chat_text.find("/jxjgotolv ")==0)//修改当前领主等级
			{
				keystr = "/jxjgotolv ";
				gmorder = 21;
			}
			else if (chat_text.find("/jxjaddGroupExp") == 0)
			{
				keystr = "/jxjaddGroupExp";
				gmorder = 22;
			}
			else if (chat_text.find("/jxjgroupaddactive") == 0)
			{
				keystr = "/jxjgroupaddactive ";
				gmorder = 23;
			}
			else if (chat_text.find("/jxjgroupDayZero") == 0)
			{
				keystr = "/jxjgroupDayZero ";
				gmorder = 24;
			}
			else if (chat_text.find("/jxjgroupWeekZero") == 0)
			{
				keystr = "/jxjgroupWeekZero ";
				gmorder = 25;
			}
			else if ( chat_text.find("/jxjcountryvote") == 0)
			{
				keystr = "/jxjcountryvote ";
				gmorder = 26;
			}
			else if ( chat_text.find("/jxjcountryweekzero") == 0)
			{
				keystr = "/jxjcountryweekzero ";
				gmorder = 27;
			}
						
			else if(chat_text.find("/jxjzerobenefittimes")==0)
			{
				keystr = "/jxjzerobenefittimes ";
				gmorder = 28;
			}
			else if(chat_text.find("/jxjzerobenefitstart")==0)
			{
				keystr = "/jxjzerobenefitstart ";
				gmorder = 29;
			}
			else if(chat_text.find("/jxjresetchangeshilitimes")==0)//重置叛国次数
			{
				keystr = "/jxjresetchangeshilitimes ";
				gmorder = 30;
				//playerData->getParam(WCHDATA_JXJPlayerChangeShiliTimes,param);
				//unsigned char *changeTimes = (unsigned char *)param;
			}
			else if(chat_text.find("/jxjgameserverthrow")==0)
			{
				gmorder = 31;
			}
			else if(chat_text.find("/jxjsceneserverthrow")==0)
			{
				gmorder = 32;
			}
			else if (chat_text.find("/jxjping") == 0)
			{
				keystr = "/jxjping ";
				gmorder = 33;
			}
			else if (chat_text.find("/showstats") == 0)
			{
				//CRProducer::crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
				//if(bindview)
				//{
				//	bindview->showStats(2);
				//}
				crStatistics::getInstance()->setStat(!crStatistics::getInstance()->getStat());
				return;
			}
			else if (chat_text.find("/showwaypoint") == 0)
			{
				crCamera *camera = crCameraManager::getInstance()->getCurrentCamera();
				crData *cameraData = camera->getAttachedNode()->getDataClass();
				if(cameraData)
				{
					crHandle *handle = cameraData->getHandle(WCH_UPDATE);
					crHandle *drive = handle->getHandle("MoreSlot");
					if(!drive->getHandle("WaypointLinkDraw"))
						drive->inputHandle(0,crHandleManager::getInstance()->getHandle("WaypointLinkDraw"));
				}
				return;
			}
			else if (chat_text.find("/closeAllUI") == 0)
			{
				crFilterRenderManager::getInstance()->closeAllCanvas();
				return;
			}
			else if (chat_text.find("/reloadhuodongtab") == 0)
			{
				gmorder = 34;
			}
			else if (chat_text.find("/robotlv") == 0)//机器人自动升级
			{
				keystr = "/robotlv";
				gmorder = 35;
			}
			else if (chat_text.find("/robotgiftgold") == 0)//机器人礼金
			{
				keystr = "/robotgiftgold";
				gmorder = 36;
			}
			else if(chat_text.find("/changedatatest") == 0)
			{
				keystr = "/changedatatest ";
				gmorder = 40;
			}
			else if(chat_text.find("/changepassword") == 0)
			{
				keystr = "/changepassword ";
				gmorder = 41;
			}
			else if(chat_text.find("/jxjqueryprogress") == 0)
			{
				gmorder = 42;
			}
			else if(chat_text.find("/jxjdbserverthrow")==0)
			{
				gmorder = 43;
			}
			else if (chat_text.find("/resetlingqufenglu") == 0)
			{
				gmorder = 50;
			}
			else if (chat_text.find("/startservercycle") == 0)
			{
				gmorder = 51;
			}
			else if (chat_text.find("/stopservercycle") == 0)
			{
				gmorder = 52;
			}
			else if (chat_text.find("/reloadnochat") == 0)
			{
				gmorder = 53;
			}
			else if (chat_text.find("/reloadgm") == 0)
			{
				gmorder = 54;
			}
			else if (chat_text.find("/resetwincity") == 0)
			{
				gmorder = 55;
			}
			else if (chat_text.find("/reloadgameglobaltable") == 0)
			{
				gmorder = 56;
			}
			else if (chat_text.find("/resetshili") == 0)
			{
				gmorder = 60;
			}
			else if (chat_text.find("/reloadrobottab") == 0)
			{
				gmorder = 61;
			}
			else if (chat_text.find("/setmaxplayercount") == 0)
			{
				gmorder = 62;
			}
			else if (chat_text.find("/setstartdate") == 0)
			{
				gmorder = 63;
			}
			else if (chat_text.find("/jxjsetcountrypost") == 0)
			{
				gmorder = 64;
			}
			else if(chat_text.find("/jxjsetprogress")==0)//
			{
				keystr = "/jxjsetprogress";
				gmorder = 65;
			}
			else if(chat_text.find("/jxjaddtaofadian")==0)//
			{
				keystr = "/jxjaddtaofadian";
				gmorder = 66;
			}
			else if(chat_text.find("/jxjgainhouxuanren")==0)//
			{
				keystr = "/jxjgainhouxuanren";
				gmorder = 67;
			}
			else if (chat_text.find("/jxjcleartreasoncooltime") == 0)
			{
				keystr = "/jxjcleartreasoncooltime";
				gmorder = 68;
			}
			else if (chat_text.find("/jxjclearcancelcantoncooltime") == 0)
			{
				keystr = "/jxjclearcancelcantoncooltime ";
				gmorder = 69;
			}
			else if (chat_text.find("/jxjaddgroupcontribute") == 0)
			{
				keystr = "/jxjaddgroupcontribute";
				gmorder = 70;
			}
			else if (chat_text.find("/jxjgainzhanquan") == 0)
			{
				keystr = "/jxjgainzhanquan";
				gmorder = 71;
			}
			else if (chat_text.find("/jxjdismissgroup") == 0)
			{
				keystr = "/jxjdismissgroup";
				gmorder = 72;
			}
			else if (chat_text.find("/jxjresetjuntuanfubenaward") == 0)
			{
				gmorder = 73;
			}
			else if(chat_text.find("/reloadonlinerewardtab") == 0)
			{
				gmorder = 74;
			}
			else if(chat_text.find("/reloadHuoyueduRewardtab") == 0)
			{
				gmorder = 75;
			}
			else if(chat_text.find("/reloaditemtab") == 0)
			{
				gmorder = 76;
			}
			else if(chat_text.find("/reloadjxjtasktitletab") == 0)
			{
				gmorder = 77;
			}
			else if(chat_text.find("/reloadlandreward") == 0)
			{
				gmorder = 78;
			}
			else if(chat_text.find("/reloadtable") == 0)
			{
				gmorder = 79;
			}
			else if(chat_text.find("/jxjresetconsortiapromotion") == 0)
			{
				gmorder = 80;
			}
			else if ("/jxjresetjuntuanhuodongaward" == 0)
			{
				gmorder = 81;
			}
			else if (chat_text.find("/jxjgainachievepoint") == 0)
			{
				keystr = "/jxjgainachievepoint";
				gmorder = 82;
			}
			else if(chat_text.find("/jxjshutdownservers")==0)
			{
				gmorder = 83;
			}
			else if (chat_text.find("/jxjsetcountrypower") == 0)
			{
				keystr = "/jxjsetcountrypower";
				gmorder = 84;
			}
			else if (chat_text.find("/jxjsetcountrystrength") == 0)
			{
				keystr = "/jxjsetcountrystrength";
				gmorder = 85;
			}
			else if (chat_text.find("/jxjactivesuperequip") == 0)
			{
				keystr = "/jxjactivesuperequip";
				gmorder = 86;
			}
			else if (chat_text.find("/jxjclearsuperequip") == 0)
			{
				keystr = "/jxjclearsuperequip";
				gmorder = 87;
			}
			//if (gmorder == 16)
			//{
			//	crPlayerDataEventPacket packet;
			//	crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCheckPlayerData,NULL);
			//	netConductor->getNetManager()->sendPacket("all",packet);
			//}
			if (gmorder == 10)
			{
				rcfg::ConfigScript cfg_script;
				struct stat buf;
				int keysize = keystr.size();
				chat_text.erase(0,keysize);
				std::string filename = chat_text;
				filename = crGlobalHandle::getInstance()->getGameDir()+"ggedit/"+filename;
				if (stat( filename.c_str(), &buf )) 
				{
					return;
				}
				if (!cfg_script.Open(filename.c_str(),""))
				{
					CRCore::notify(CRCore::FATAL)<<"loadConfigScript(): "<<cfg_script.GetLastError()<<std::endl;
					//sprintf(gDebugInfo->buf(),"loadConfigScript %s error:%s\n\0",filename.c_str(),cfg_script.GetLastError().c_str());
					//gDebugInfo->debugInfo(CRCore::FATAL);
					return;
				}
				
				ref_ptr<crStreamBuf> rushinfoBuffer = new crStreamBuf;
				//cfg_script.Write("1111111111.cfg");
				crGlobalHandle::getInstance()->getScriptStream(cfg_script,rushinfoBuffer);
				if (netConductor)
				{
					chat_text = keystr;
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4 + chat_text.size()+rushinfoBuffer->getBufSize());
					stream->_writeString(chat_text);
					stream->write(rushinfoBuffer->getPtr(),rushinfoBuffer->getRemainSize());
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGMOrder,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				
				return;
			}
			if(gmorder == 8)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4 + chat_text.size());
				stream->_writeString(chat_text);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGMOrder,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);

				return;
			}
			if(ifinroom && (gmorder == 9||gmorder==20||gmorder==32||gmorder==42||gmorder==65))
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(chat_text.length()+5);
				stream->_writeChar(chat_mode);
				stream->_writeString(chat_text);
				crPlayerDataSceneEventPacket packet;
				crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvRoomChatMessage,stream.get());
				netManager->sendPacket("all",packet);
				return;
			}
			if (gmorder == 33)
			{
				CRCore::Timer_t start_tick = CRCore::Timer::instance()->tick();
				chat_text += crArgumentParser::appI64toa(start_tick);
				//data->inputParam(WCHDATA_JXJPingStartTick,&start_tick);
				{
					// 发到gameserver
					//ref_ptr<crStreamBuf> stream = new crStreamBuf;
					//stream->createBuf(chat_text.length()+5);
					////stream->_writeUChar(chat_mode);
					//stream->_writeString(chat_text);

					//crPlayerDataEventPacket packet;
					//crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGMOrder,stream.get());
					//netConductor->getNetManager()->sendPacket("all",packet);


					crJXJGameChatPacket packet;
					crJXJGameChatPacket::buildRequestPacket(packet,chat_mode,reciverName,chat_text);
					//crJXJGameChatPacket::buildRequestPacket(packet,chat_mode,chat_text);
					netConductor->getNetManager()->sendPacket("all",packet);
					//net_conductor->getNetManager()->sendPacket("all",packet);
				}
				{
					//sceneServer发包

					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(chat_text.length()+5);
					stream->_writeChar(chat_mode);
					stream->_writeString(chat_text);
					crPlayerDataSceneEventPacket packet;
					crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvRoomChatMessage,stream.get());
					netManager->sendPacket("all",packet);
				}
				return;
			}
			if(gmorder > 0)
			{
				if(netConductor)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4 + chat_text.size());
					stream->_writeString(chat_text);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGMOrder,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				return;
			}
		}
		if(chat_text.find("/") == 0)
		{//检测到斜杠就返回,防止GM输错频道
			return;
		}
		if (rolelv < 7)
		{
			this->display_message(std::string("七级之前不能在聊天栏说话哦！"));
			return;
		}
		int typeIndexF = chat_text.find_first_of("^");
		int typeIndexB = chat_text.find_last_of("^");
		bool needCheck = true;
		int textValue = atoi(chat_text.substr(typeIndexF+1,typeIndexB-typeIndexF-1).c_str());
		if(typeIndexF>=0 && typeIndexB >0 && 0 <= textValue && textValue <= 100)
		{
			needCheck = false; //系统转义内容不需要检查屏蔽字符
		}
		if (needCheck)
		{
			ref_ptr<crTableIO> invalidTextTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInvalidTextTab);
			if (invalidTextTab.valid())
			{//广告词屏蔽
				int count = invalidTextTab->getRowCount();
				for (int i = 0; i < count; ++i)
				{
					if (chat_text.find((*invalidTextTab)(i,0)) == 0)
					{
						return ;
					}
				}
			}
			ref_ptr<crTableIO>InvalidNameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInvalidWordTab);
			if (InvalidNameTab.valid())
			{
				std::wstring wtext = CRIOManager::convertUTF8toUTF16(chat_text.c_str());
				std::wstring invalidstring;
				int ipos = 0;
				int invalidwordsize;
				std::string replacestr = "****";
				for (int i = 0; i < InvalidNameTab->getRowCount();i++)
				{
					//invalidstring = InvalidNameTab->getData(i,0);
					invalidstring = CRIOManager::convertUTF8toUTF16(InvalidNameTab->getData(i,0).c_str());
					invalidwordsize = invalidstring.length();
					if (invalidwordsize > 0 && invalidwordsize <=  wtext.length())
					{
						ipos = wtext.find(invalidstring);
						if(ipos != std::string::npos)
						{
							wtext.replace(ipos,invalidwordsize,std::wstring(CRIOManager::convertUTF8toUTF16(replacestr.c_str())));
							//for(j = 0; j < invalidwordsize;++j)
							//	chat_text[ipos+j]='*';
							//this->display_message(std::string("不能含有敏感词汇！"));
							//return;
						}
					}
				}
				chat_text =  CRIOManager::convertUTF16toUTF8(wtext.c_str());
			}
		}
		chat_canvas_data->getParam(WCHDATA_JXJChatInputRecordDeque,param);
		ChatInputRecordDeque *inputRecordDeq = (ChatInputRecordDeque *)param;
		if(inputRecordDeq->size()>=max_deque_size)
			inputRecordDeq->pop_front();
		ChatInputRecordDeque::iterator itr_input =inputRecordDeq->begin();
		while ( itr_input!=inputRecordDeq->end())
		{
			if(itr_input->compare(chat_text) == 0)
				break;
			itr_input++;
		}
		if(itr_input == inputRecordDeq->end())
			inputRecordDeq->push_back(chat_text);

		int string_pos = chat_text.find_first_of(' ')+1;
		if(chat_mode == ChatOneToOne )
		{
			if(chat_text.find_first_of('\\')!=0 || chat_text.find_first_of(' ')>13)
			{
				this->display_message(std::string("请正确输入玩家昵称,(例如：\\玩家1+空格,玩家昵称不能超过六个中文字符)"));
				return;
			}
			else if(chat_text.size() == string_pos)
			{
				this->display_message(std::string("发送信息不能为空！"));
				return;
			}
		}
		// check for \ chat
		int search_index = -1;
		for(int index = 0; index < chat_text.size(); index++)
		{
			if(chat_text[index] == ' ')
			{
				continue;
			}

			if(chat_text[index] != '\\')
			{
				break;
			}
			else
			{
				search_index = index;
				break;
			}
		}

		// turn to chat one to one
		if(search_index > 0)
		{
			chat_text = chat_text.erase(0, search_index);
			chat_input->setString(chat_text);
		}
		if(search_index>=0 && chat_mode == ChatOneToOne)
		{
			reciverName = chat_text.substr(1,chat_text.find_first_of(' ')-1);
// 			crData *braindata = crBrain::getInstance()->getDataClass();
// 			if(braindata) 
// 				braindata->inputParam(WCHDATA_JXJChatOneToOneReciverName,&reciverName);
			chat_text = chat_text.erase(0, 2 + reciverName.size());
			chat_select->setActiveSwitchSet(ChatOneToOne-1);
		}
// 		if(search_index >= 0 && (chat_mode != ChatOneToOne))
// 		{
// 			
// 			chat_text = "悄悄说:"+chat_text;
// 			
// // 			if (m_inRoom == 1)
// // 			{
// // 				chat_mode = ChatInRoomOneToOne;
// // 			}
// // 			else if(m_inRoom == 0)
// // 			{
// // 				chat_mode = ChatOneToOne;
// // 			}
// 		}
		// time check
		if(chat_mode == ChatInWorld)
		{
			int minLevel = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJProhibitChattingLevel,viplv).c_str());
			if (rolelv < minLevel)
			{//20级之前不能在世界频道聊天
				this->display_message(std::string("二十级之前不能在世界频道聊天！"));
				return;
			}
			chat_canvas_data->getParam(WCHDATA_JXJChatTimer1, param);
			if(RE_VALUE(float, param) > 0.0f)
			{
				this->display_message(std::string("发言间隔为5秒！"));
				chat_input->clearString();

				chat_canvas_data->getParam(WCHDATA_JXJIsToShowItems,param);
				bool *isToshow = (bool *)param;
				 *isToshow = false;
				chat_canvas_data->getParam(WCHDATA_JXJAboutToShowItemIDVec,param);
				ShowItemIDVec *itemidVec = (ShowItemIDVec *)param;
				itemidVec->clear();
				chat_canvas_data->getParam(WCHDATA_JXJIsToShowAchieve,param);
				bool *isshowachieve = (bool *)param;
				*isshowachieve = false;
				chat_canvas_data->getParam(WCHDATA_JXJShowAchieveIDVec,param);
				ShowAchieveIDVec *achieveidVec = (ShowAchieveIDVec *)param;
				achieveidVec->clear();

				return;
			}
			else
			{
				RE_VALUE(float, param) = 5.0f;
			}
		}
		else if(chat_mode == ChatInCountry)
		{
			chat_canvas_data->getParam(WCHDATA_JXJChatTimer1, param);
			if(RE_VALUE(float, param) > 0.0f || isLoseCountry)
			{
				if(isLoseCountry)
				{
					this->display_message(std::string("你所在势力已灭亡，暂时无法在此频道发言，重新选择势力后可再次使用！"));
				}
				else
				{
					this->display_message(std::string("发言间隔为5秒！"));

					chat_canvas_data->getParam(WCHDATA_JXJIsToShowItems,param);
					bool *isToshow = (bool *)param;
					*isToshow = false;
					chat_canvas_data->getParam(WCHDATA_JXJAboutToShowItemIDVec,param);
					ShowItemIDVec *itemidVec = (ShowItemIDVec *)param;
					itemidVec->clear();
					chat_canvas_data->getParam(WCHDATA_JXJIsToShowAchieve,param);
					bool *isshowachieve = (bool *)param;
					*isshowachieve = false;
					chat_canvas_data->getParam(WCHDATA_JXJShowAchieveIDVec,param);
					ShowAchieveIDVec *achieveidVec = (ShowAchieveIDVec *)param;
					achieveidVec->clear();
				}
				
				chat_input->clearString();
				return;
			}
			else
			{
				RE_VALUE(float, param) = 5.0f;
			}
		}else if(chat_mode == ChatInGroup)
		{
			chat_canvas_data->getParam(WCHDATA_JXJChatTimer2, param);
			if(RE_VALUE(float, param) > 0.0f || isLoseCountry)
			{
				if(isLoseCountry)
				{
					this->display_message(std::string("你所在势力已灭亡，暂时无法在此频道发言，重新选择势力后可再次使用！"));
				}
				else
				{
					this->display_message(std::string("发言间隔为1秒！"));
				}
				return;
			}
			else
			{
				RE_VALUE(float, param) = 1.0f;
			}
		}else if(chat_mode == ChatInTeam)
		{
			chat_canvas_data->getParam(WCHDATA_JXJChatTimer3, param);
			if(RE_VALUE(float, param) > 0.0f)
			{
				this->display_message(std::string("发言间隔为1秒！"));
				return;
			}
			else
			{
				RE_VALUE(float, param) = 1.0f;
			}
		}else if(chat_mode == ChatOneToOne)
		{
			chat_canvas_data->getParam(WCHDATA_JXJChatTimer4, param);
			if(RE_VALUE(float, param) > 0.0f)
			{
				this->display_message(std::string("发言间隔为0.5秒！"));
				return;
			}
			else
			{
				if (name.compare(reciverName) == 0)
				{
					this->display_message(std::string("聊天对象不能是自己！"));
					return;
				}
				RE_VALUE(float, param) = .5f;
			}
		}

		chat_canvas_data->getParam(WCHDATA_JXJIsToShowItems,param);
		bool *isToshow = (bool *)param;
		if(*isToshow)
		{
			chat_canvas_data->getParam(WCHDATA_JXJAboutToShowItemIDVec,param);
			ShowItemIDVec *itemidVec = (ShowItemIDVec *)param;
			if(itemidVec->size()>0)
			{
				chat_text += std::string("{");
				ShowItemIDVec::iterator itr_item = itemidVec->begin();
				for (;itr_item!=itemidVec->end();itr_item++)
				{
					if(itr_item->first >0)
					{
						chat_text+=std::string("(")+crArgumentParser::appItoa(itr_item->first)+std::string("|")+crArgumentParser::appItoa(itr_item->second)+std::string(")");
					}
				}
				chat_text += std::string("}");
				itemidVec->clear();
			}
			*isToshow = false;
		}

		chat_canvas_data->getParam(WCHDATA_JXJIsToShowAchieve,param);
		bool *isshowachieve = (bool *)param;
		if(*isshowachieve)
		{
			chat_canvas_data->getParam(WCHDATA_JXJShowAchieveIDVec,param);
			ShowAchieveIDVec *achieveidVec = (ShowAchieveIDVec *)param;
			char count1=0;
			char count2=0;
			int pos = -1;
			do 
			{
				pos = chat_text.find_first_of("[",pos+1);
				if(pos >= 0)
					count1++;
				else
					break;

			} while (1);
			pos = -1;
			do 
			{
				pos = chat_text.find_first_of("]",pos+1);
				if(pos >= 0)
					count2++;
				else
					break;

			} while (1);
			
			if (count1==count2 && count1 == achieveidVec->size())
			{
				if(achieveidVec->size()>0)
				{
					chat_text = "^8^" + chat_text;
					chat_text += std::string("{");
					ShowAchieveIDVec::iterator itr_item = achieveidVec->begin();
					for (;itr_item!=achieveidVec->end();itr_item++)
					{
						if(itr_item->first >0)
						{
							chat_text+=std::string("(")+crArgumentParser::appItoa(itr_item->first)+std::string("|")+crArgumentParser::appItoa(itr_item->second)+std::string(")");
						}
					}
					chat_text += std::string("}");
					achieveidVec->clear();
				}
				*isshowachieve = false;
			}
			else
			{
				*isshowachieve = false;
				achieveidVec->clear();
			}

		}

		ref_ptr<crStreamBuf> packetStream = new crStreamBuf;
		// parse and send packet
		if (chat_mode == ChatInWorld)
		{
			int chatprice = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJWorldChatPrice, viplv).c_str());
			data->getParam(WCHDATA_JXJCoppercash, param);
			int coppercash = *(int *)param;
			data->getParam(WCHDATA_JXJTechWorldTalkPriceLv, param);
			unsigned char techlv = *(unsigned char *)param;
			if (techlv > 0)
			{
				int chatpricereducepercent = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJTechWorldTalkPriceReduce, viplv).c_str());
				chatprice = chatprice * (100 - chatpricereducepercent) / 100;
			}
			
			//gameserver发包
			if (coppercash >= chatprice)
			{
				chat_input->clearString();
				crNetConductor *net_conductor;
				net_conductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				crJXJGameChatPacket packet;
				crJXJGameChatPacket::buildRequestPacket(packet,chat_mode,chat_text);
				net_conductor->getNetManager()->sendPacket("all",packet);
			}
			else
			{
				player_data->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2032,NULL));//铜钱不足
				return;
			}
		}
		if(chat_mode == ChatInCountry || chat_mode == ChatInGroup)
		{
			//gameserver发包
			chat_input->clearString();
			crNetConductor *net_conductor;
			net_conductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			crJXJGameChatPacket packet;
			crJXJGameChatPacket::buildRequestPacket(packet,chat_mode,chat_text);
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
		if(chat_mode == ChatOneToOne)
		{
			//gameserver发包
			chat_input->setString("\\"+reciverName+" ");
			crNetConductor *net_conductor;
			net_conductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			crJXJGameChatPacket packet;
			crJXJGameChatPacket::buildRequestPacket(packet,chat_mode,reciverName,chat_text);
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
		else if(chat_mode == ChatInTeam && !ifinroom)
		{
			//gameserver发包
			chat_input->clearString();
			crNetConductor *net_conductor;
			net_conductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			crJXJGameChatPacket packet;
			crJXJGameChatPacket::buildRequestPacket(packet,chat_mode,chat_text);
			net_conductor->getNetManager()->sendPacket("all",packet);
			////sceneServer发包
			//// send packet
			//packetStream->createBuf(chat_text.length()+5);
			//packetStream->_writeUChar(chat_mode);
			//packetStream->_writeString(chat_text);
			//crPlayerDataSceneEventPacket packet;
			//crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvRoomChatMessage,packetStream.get());
			//netManager->sendPacket("all",packet);
		}
		else if(chat_mode == ChatInTeam && ifinroom)
		{
			//sceneServer发包
			// send packet
			chat_input->clearString();
			packetStream->createBuf(chat_text.length()+5);
			packetStream->_writeChar(chat_mode);
			packetStream->_writeString(chat_text);
			crPlayerDataSceneEventPacket packet;
			crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvRoomChatMessage,packetStream.get());
			netManager->sendPacket("all",packet);
		}
// 		else if(chat_mode == ChatInRoomOneToOne)
// 		{
// 			chat_input->setString("\\"+reciverName+" ");
// 			packetStream->createBuf(chat_text.length()+reciverName.length()+9);
// 			packetStream->_writeChar(chat_mode);
// 			packetStream->_writeString(chat_text);
// 			packetStream->_writeString(reciverName);
// 			crPlayerDataSceneEventPacket packet;
// 			crPlayerDataSceneEventPacket::buildRequestPacket(packet,WCH_JXJRecvRoomChatMessage,packetStream.get());
// 			netManager->sendPacket("all",packet);
// 		}

		ref_ptr<crJXJChatRecord> record = new crJXJChatRecord();
		record->setSenderName(name);
		record->setChatText(chat_text);
		record->setReciverName(reciverName);

		switch (chat_mode)
		{
		case ChatInCountry:
			record->setChatChannelName("[国家]");
			break;
		case ChatInWorld:
			record->setChatChannelName("[世界]");
			break;
		case ChatInGroup:
			record->setChatChannelName("[军团]");
			break;
		case ChatInTeam:
			if(crRunGameHandle::getInstance()->isInManor())
				record->setChatChannelName("[组队]");
			else
				record->setChatChannelName("[战场]");
			break;
		case ChatOneToOne:
			record->setChatChannelName("[私聊]");
			break;
		}
// 		crMyPlayerData *me = crMyPlayerData::getInstance();
// 		if(me && me->getPlayerGameData())
// 		{
// 			crData *playerData = me->getPlayerGameData()->getDataClass();
// 			if(playerData)
// 			{
// 				playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
// 				playerData->getParam(WCHDATA_JXJChatRecordMap,param);
// 				ChatRecordMap *chat_records = (ChatRecordMap *)param;
// 				ChatRecordDeque &deque = (*chat_records)[(JXJChatMode)chat_mode];
// 				if (deque.size() >= max_deque_size)
// 				{
// 					deque.pop_front();
// 				}
// 				deque.push_back(record.get());
// 
// 				ChatRecordDeque &alldeque = (*chat_records)[ChatAll];
// 				if (alldeque.size() >= max_deque_size)
// 				{
// 					alldeque.pop_front();
// 				}
// 				alldeque.push_back(record.get());
// 
// 				playerData->excHandle(MAKECREPARAM(WCH_LockData,0));
// 			}
// 		}
		crBrain::getInstance()->doEvent(WCH_JXJPutInChatRecordDeque, MAKECREPARAM(record.get(),NULL));
	}
}
void crJXJGameChatTextSendMethod::display_message(std::string &msg)
{
	// get control 
	if(m_strLastDisplayMessage.compare(msg)== 0) return;
	m_strLastDisplayMessage = msg;
	ref_ptr<crCanvasNode>chat_canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasChat);
	if (!chat_canvas.valid())
	{
		return;
	}
	crData *chat_canvas_data = chat_canvas->getDataClass();
	ref_ptr<crHypertextWidgetNode> chat_show = dynamic_cast<crHypertextWidgetNode *>(chat_canvas->getWidget(m_chatinfo));
	crMultiSwitch *chat_select = dynamic_cast<crMultiSwitch *>(chat_canvas->getChildNode(m_chatMode));
	JXJChatMode chat_mode = JXJChatMode(chat_select->getActiveSwitchSet()+1);

	// player data
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	std::string name = player->getCharacterName();


	// record chat message
	ref_ptr<crJXJChatRecord> chat_record = new crJXJChatRecord;
	//chat_record->setSenderName(std::string("[系统]"));
	chat_record->setChatText(msg);
	chat_record->setTextColor(crVector4(255.0,0.0,0.0,255.0));
	chat_record->setChatChannelName(std::string("[系统]"));
	// insert record
// 	void *param;
// 	crMyPlayerData *me = crMyPlayerData::getInstance();
// 	if(me && me->getPlayerGameData())
// 	{
// 		crData *data = me->getPlayerGameData()->getDataClass();
// 		if(data)
// 		{
// 			data->excHandle(MAKECREPARAM(WCH_LockData,1));
// 			data->getParam(WCHDATA_JXJChatRecordMap,param);
// 			ChatRecordMap *chat_record_map = (ChatRecordMap *)param;
// 
// 			// set display style
// 			data -> getParam(WCHDATA_JXJVipLv,param);
// 			unsigned char viplv = *(unsigned char *)param;
// 			int max_deque_size = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitChatLine,viplv).c_str());
// 			ChatRecordMap::iterator itr_map = chat_record_map->begin();
// 
// 			for (;itr_map!=chat_record_map->end();itr_map++)
// 			{
// 				if(itr_map->second.size() >= max_deque_size)
// 					itr_map->second.pop_front();
// 				itr_map->second.push_back(chat_record.get());
// 			}			
// 
// 			data->excHandle(MAKECREPARAM(WCH_LockData,0));
// 		}
// 	}
	
	crBrain::getInstance()->doEvent(WCH_JXJPutInChatRecordDeque, MAKECREPARAM(chat_record.get(),NULL));
	//crBrain::getInstance()->doEvent(WCH_JXJUIUpdateChatMessageList);
}


/////////////////////////////////////////
//
//crJXJGameChatTextSuccessMethod
//
/////////////////////////////////////////
crJXJGameChatTextSuccessMethod::crJXJGameChatTextSuccessMethod()
{
}
crJXJGameChatTextSuccessMethod::crJXJGameChatTextSuccessMethod(const crJXJGameChatTextSuccessMethod& handle):
	crMethod(handle),
	m_canvasChat(handle.m_canvasChat),
	m_chatinfo(handle.m_chatinfo),
	m_chattext(handle.m_chattext),
	m_curmode(handle.m_curmode)
{
}
void crJXJGameChatTextSuccessMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJGameChatTextSuccessMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_chatinfo = str;
		break;
	case 1:
		m_canvasChat = str;
		break;
	case 2:
		m_chattext = str;
		break;
	case 3:
		m_curmode = str;
		break;
	}
}
void crJXJGameChatTextSuccessMethod::operator()(crHandle &handle)
{
	//bool cancelTask = true;
	//crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	//ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	//std::string name = crMyPlayerData::getInstance()->getCharacterName();
	//crMultiSwitch *curmodeSW = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_curmode));
	//ref_ptr<crEditWidgetNode> input = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_chattext));
	//std::string chattext = input->getUTF8String();
	//int chatmode = curmodeSW->getActiveSwitchSet();

	//if(myPlayer)
	//{
	//	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasChat);
	//	crData *canvasData = canvas->getDataClass();
	//	ref_ptr<crHypertextWidgetNode> chatmsg = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_chatinfo));
	//	if (chatmsg)
	//	{

	//		ref_ptr<crJXJChatRecord> chatrecord = new crJXJChatRecord;
	//		chatrecord->setSenderName(name);
	//		chatrecord->setChatText(chattext);
	//		void *param;
	//		canvasData->excHandle(MAKECREPARAM(WCH_LockData,1));
	//		canvasData->getParam(WCHDATA_JXJChatRecordMap,param);
	//		ChatRecordMap *chatRecordMap = (ChatRecordMap *)param;
	//		ChatRecordDeque &deque = (*chatRecordMap)[(JXJChatMode)chatmode];
	//		deque.push_back(chatrecord.get());
	//		std::string str = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitChatLine);
	//		int maxdequsize = atoi(str.c_str());
	//		while (deque.size()>maxdequsize)
	//		{
	//			deque.pop_front();
	//		}
	//		chatmsg->clearText();
	//		int i = 0;
	//		for (ChatRecordDeque::iterator itr = deque.begin();
	//			itr != deque.end();
	//			++itr)
	//		{
	//			chatrecord = deque[i];
	//			i++;
	//			std::string name2 = chatrecord->getSenderName();
	//			std::string chattext2 = chatrecord->getChattext();
	//			std::vector<float>v_i;
	//			ItemMap itemMap;
	//			rcfg::ConfigScript cfg_script(&itemMap);
	//			cfg_script.Add("Hypertext");
	//			cfg_script.Push("Hypertext");
	//			cfg_script.Add("Font","simhei.ttf");
	//			cfg_script.Add("CharacterSize",15);
	//			v_i.clear();
	//			v_i.push_back(255);
	//			v_i.push_back(255);
	//			v_i.push_back(255);
	//			v_i.push_back(255);
	//			cfg_script.Add("Color",v_i);
	//			cfg_script.Add("Content");
	//			cfg_script.Push("Content",1);
	//			if(name!=name2)cfg_script.Add("DrawMode","TEXT|UNDERLINE");
	//			cfg_script.Add("Text",name2);
	//			if(name!=name2)cfg_script.Add("Link",1);
	//			cfg_script.Pop();
	//			cfg_script.Add("Content");
	//			cfg_script.Push("Content",2);
	//			cfg_script.Add("Text",":" + chattext2 +"\n");
	//			cfg_script.Pop();
	//			cfg_script.Pop();
	//			chatmsg->setHypertext(cfg_script,true);
	//		}
	//		input->clearString();
	//		canvasData->excHandle(MAKECREPARAM(WCH_LockData,0));
	//	}
	//}
	//handle.outputParam(0,&cancelTask);
}


/////////////////////////////////////////
//
//crJXJGameChatTextFailureMethod
//
/////////////////////////////////////////
crJXJGameChatTextFailureMethod::crJXJGameChatTextFailureMethod()
{

}
crJXJGameChatTextFailureMethod::crJXJGameChatTextFailureMethod(const crJXJGameChatTextFailureMethod& handle):
	crMethod(handle),
	m_chatinfo(handle.m_chatinfo)
{

}
void crJXJGameChatTextFailureMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJGameChatTextFailureMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_chatinfo = str;
		break;
	}
}
void crJXJGameChatTextFailureMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crHypertextWidgetNode> chatmsg = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_chatinfo));
		if (chatmsg.valid())
		{
			std::vector<float>v_i;
			ItemMap itemMap;
			rcfg::ConfigScript cfg_script(&itemMap);
			cfg_script.Add("Hypertext");
			cfg_script.Push("Hypertext");
			cfg_script.Add("Font","simhei.ttf");
			cfg_script.Add("CharacterSize",15);
			v_i.clear();
			v_i.push_back(255);
			v_i.push_back(255);
			v_i.push_back(255);
			v_i.push_back(255);
			cfg_script.Add("Color",v_i);
			cfg_script.Add("Content");
			cfg_script.Push("Content",1);
			cfg_script.Add("Text","（信息发送失败）\n");
			cfg_script.Pop();
			cfg_script.Pop();
			chatmsg->setHypertext(cfg_script,true);
		}
	}
	handle.outputParam(0,&cancelTask);
}


/////////////////////////////////////////
//
//crJXJRecvGameChatMethod
//
/////////////////////////////////////////
crJXJRecvGameChatMethod::crJXJRecvGameChatMethod():
	m_netType(GameClient_Game){}
crJXJRecvGameChatMethod::crJXJRecvGameChatMethod(const crJXJRecvGameChatMethod& handle):
	crMethod(handle),
	m_chat_canvas(handle.m_chat_canvas),
	m_chat_console(handle.m_chat_console),
	m_chat_select(handle.m_chat_select),
	m_chat_input(handle.m_chat_input)
{}
void crJXJRecvGameChatMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvGameChatMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chat_canvas = str;
		break;
	case 1:
		m_chat_console = str;
		break;
	case 2:
		m_chat_select = str;
		break;
	case 3:
		m_chat_input = str;
		break;
	case 4:
		m_RoomChatCanvas = str;
	default:
		break;
	}
}
void crJXJRecvGameChatMethod::operator()(crHandle &handle)
{
	//void *param;
	int senderShiliID = 0;
	CRNetApp::crPlayerGameData		*player				= CRNetApp::crMyPlayerData::getInstance()->getPlayerGameData(); // player entity
	ref_ptr<crCanvasNode>				chat_canvas		= crFilterRenderManager::getInstance()->findCanvas(m_chat_canvas);
	if(!chat_canvas.valid()) chat_canvas = crFilterRenderManager::getInstance()->findCanvas(m_RoomChatCanvas);

	if(!player || !chat_canvas.valid()) return;
	ref_ptr<crHypertextWidgetNode>			chat_console		= dynamic_cast<crHypertextWidgetNode *>(chat_canvas->getWidget(m_chat_console));
	ref_ptr<crMultiSwitch		>			chat_mode_slt		= dynamic_cast<crMultiSwitch *>(chat_canvas->getChildNode(m_chat_select));
	ref_ptr<crEditWidgetNode	>			chat_input			= dynamic_cast<crEditWidgetNode *>(chat_canvas->getChildNode(m_chat_input));
	crData							*chat_canvas_data	= chat_canvas->getDataClass();

	int cur_mode = chat_mode_slt->getActiveSwitchSet();
	int chat_mode = cur_mode+1;
	std::string senderName; 
	ref_ptr<crJXJChatRecord> record = new crJXJChatRecord();

	if(m_stream->eof())
	{
		std::string str;
		record->setSenderName(std::string("[系统]"));
		switch (chat_mode)
		{
		//case ChatInWorld:
		//	str = "信息发送失败！";
		//	break;
		//case ChatInCountry:
		//	str = "信息发送失败！";
		//	break;
		case ChatInGroup:
			str = "没有加入军团！";
			break;
		case ChatInTeam:
			str = "没有加入队伍！";
			break;
		case ChatOneToOne:
			str = "该玩家不在线或玩家名称错误！";
			break;
		default:
			break;
		}
		record->setChatText(str);
		record->setTextColor(crVector4(255.0,0.0,0.0,255.0));
	}
	else
	{
		char uchar = m_stream->_readChar();
		if(uchar == -1)
		{//被禁言
			std::string str="你被禁言了!";
			record->setSenderName(std::string("[系统]"));
			record->setChatText(str);
			record->setTextColor(crVector4(255.0,0.0,0.0,255.0));
		}
		else
		{
			chat_mode = uchar;
			if(chat_mode==ChatInWorld || chat_mode == ChatNull)
			{
				senderShiliID = m_stream->_readUChar();
				record->setSenderShiliID(senderShiliID);
			}
			senderName = m_stream->_readString();
			record->setChatText(m_stream->_readString());
		}
	}
// 	crMyPlayerData *me = crMyPlayerData::getInstance();
// 	if(me && me->getPlayerGameData())
// 	{
// 		crData *data = me->getPlayerGameData()->getDataClass();
// 		if(data)
// 		{
// 			data->excHandle(MAKECREPARAM(WCH_LockData,1));
// 			data->getParam(WCHDATA_JXJChatRecordMap,param);
// 			ChatRecordMap *chat_records = (ChatRecordMap *)param;
// 						
// 			data -> getParam(WCHDATA_JXJVipLv,param);
// 			std::string str = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitChatLine,*(unsigned char *)param);
// 			int max_dequ_size = atoi(str.c_str());
// 
// 			ChatRecordMap::iterator itr_map = chat_records->begin();
// 
// 			
// 
// 
// 			data->excHandle(MAKECREPARAM(WCH_LockData,0));
// 		}
// 	}
	// insert data
	if(senderName.compare("[游戏]")==0 )
	{
		record->setChatChannelName("[游戏]");
	}
	else if(senderName.compare("[通告]")==0)
	{
		record->setChatChannelName("[通告]");
	}
	else if(senderName.compare("[系统]")==0)
	{
		record->setChatChannelName("[系统]");
	}
	else
	{
		switch (chat_mode)
		{
		case ChatInCountry:
			record->setChatChannelName("[国家]");
			break;
		case ChatInWorld:
			record->setChatChannelName("[世界]");
			break;
		case ChatInGroup:
			record->setChatChannelName("[军团]");
			break;
		case ChatInTeam:
			if(crRunGameHandle::getInstance()->isInManor())
				record->setChatChannelName("[组队]");
			else
				record->setChatChannelName("[战场]");
			break;
		case ChatOneToOne:
			record->setChatChannelName("[私聊]");
			break;
		}
		record->setSenderName(senderName);
	}

	crBrain::getInstance()->doEvent(WCH_JXJPutInChatRecordDeque,MAKECREPARAM(record.get(),NULL));
	//crBrain::getInstance()->doEvent(WCH_JXJUIUpdateChatMessageList);
}


/////////////////////////////////////////
//
//crJXJGameChatModeSelectMethod
//
/////////////////////////////////////////
crJXJGameChatModeSelectMethod::crJXJGameChatModeSelectMethod()
{

}
crJXJGameChatModeSelectMethod::crJXJGameChatModeSelectMethod(const crJXJGameChatModeSelectMethod& handle):
	crMethod(handle),
	m_ModeList(handle.m_ModeList)
{
}
void crJXJGameChatModeSelectMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJGameChatModeSelectMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_ModeList = str;
		break;
	}
}
void crJXJGameChatModeSelectMethod::operator()(crHandle &handle)
{

	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	crMultiSwitch *chatmodeSW;
	chatmodeSW = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_ModeList));
	if(chatmodeSW)
	{
		int i = chatmodeSW->getActiveSwitchSet();
		if (i != ChatModeSelectClose)
		{
			chatmodeSW->setActiveSwitchSet(ChatModeSelectClose);
		}
		else
		{
			chatmodeSW->setActiveSwitchSet(ChatModeSelectOpen);
		}
	}
}


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  
// chat mode set
crJXJGameChatModeSetMethod::crJXJGameChatModeSetMethod()
{

}
crJXJGameChatModeSetMethod::crJXJGameChatModeSetMethod(const crJXJGameChatModeSetMethod& handle):
	crMethod(handle),
	m_ModeList(handle.m_ModeList),
	m_mode(handle.m_mode),
	m_curmode(handle.m_curmode),
	m_chatinfo(handle.m_chatinfo)
{

}
void crJXJGameChatModeSetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJGameChatModeSetMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_mode = str;
		break;
	case 1:
		m_ModeList = str;
		break;
	case 2:
		m_curmode = str;
		break;
	case 3:
		m_chatinfo = str;
		break;
	case 4:
		m_transversemode = str;
		break;
	}
}
void crJXJGameChatModeSetMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	crMultiSwitch *chatmodeSW = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_ModeList));
	crMultiSwitch *curmodeSW = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_curmode));
	ref_ptr<crRadioGroupWidgetNode> transversemodeSW = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getChildNode(m_transversemode));
	//crData *data = canvas->getDataClass();
	int mode;
	if(chatmodeSW)
	{
		int i = chatmodeSW->getActiveSwitchSet();
		if (i != ChatModeSelectClose)
		{
			chatmodeSW->setActiveSwitchSet(ChatModeSelectClose);
		}
	}
	if (m_mode == "SJ")
	{
		mode = ChatInWorld;
	}
	if (m_mode == "GL")
	{
		mode = ChatInCountry;
	}
	if (m_mode == "TL")
	{
		mode = ChatInGroup;
	}
	if (m_mode == "DL")
	{
		mode = ChatInTeam;
	}
	if (m_mode == "SL")
	{
		mode = ChatOneToOne;
	}
	if(m_mode == "RoomSL")
	{
		mode = ChatOneToOne;
	}
	
	curmodeSW->setActiveSwitchSet(mode-1);
}


/////////////////////////////////////////
//
//crJXJCheckResBuildingLevelMethod
//
/////////////////////////////////////////
crJXJCheckResBuildingLevelMethod::crJXJCheckResBuildingLevelMethod()
{
}
crJXJCheckResBuildingLevelMethod::crJXJCheckResBuildingLevelMethod(const crJXJCheckResBuildingLevelMethod& handle):
	crMethod(handle)
{
}
void crJXJCheckResBuildingLevelMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	}
}
void crJXJCheckResBuildingLevelMethod::addParam(int i, const std::string& str)
{
}
void crJXJCheckResBuildingLevelMethod::operator()(crHandle &handle)
{
	void *param;
	int playerid = m_this->getPlayerID();
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	ref_ptr<crGameServerPlayerData> player = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
	if(player.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
	{
		std::map< int,unsigned char > diflvmap;
		crData *playerData = m_this->getDataClass();
		crRole *mainRole = m_this->getMainRole();
		crData *mainRoleData = mainRole->getDataClass();
		mainRoleData->getParam(WCHDATA_Level,param);
		unsigned char mylv = *(unsigned char *)param;
		crTableIO::StrVec record;
		ref_ptr<crTableIO>lordlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordlvTab);
		if(lordlvtab->queryOneRecord(0,crArgumentParser::appItoa(mylv),record) >= 0 )
		{
			int minjuid = lordlvtab->getTitleIndex("民居");
			int nongtianid = lordlvtab->getTitleIndex("农田");
			int muchangid = lordlvtab->getTitleIndex("牧场");
			int lindiid = lordlvtab->getTitleIndex("林地");
			int kuangshanid = lordlvtab->getTitleIndex("矿山");
			int shijiindex = lordlvtab->getTitleIndex("市集");
			int gongfangindex = lordlvtab->getTitleIndex("工坊");
			int jiusiindex = lordlvtab->getTitleIndex("酒肆");
			//
			unsigned char minjuqua = (unsigned char)(atoi(record[minjuid].c_str()));
			unsigned char nongtianqua = (unsigned char)(atoi(record[nongtianid].c_str()));
			unsigned char muchangqua = (unsigned char)(atoi(record[muchangid].c_str()));
			unsigned char lindiqua = (unsigned char)(atoi(record[lindiid].c_str()));
			unsigned char kuangshanqua = (unsigned char)(atoi(record[kuangshanid].c_str()));
			unsigned char shijiqua = (unsigned char)(atoi(record[shijiindex].c_str()));
			unsigned char gongfangqua = (unsigned char)(atoi(record[gongfangindex].c_str()));
			unsigned char jiusiqua = (unsigned char)(atoi(record[jiusiindex].c_str()));

			unsigned char minju[8];
			playerData->getParam(WCHDATA_JXJMingjulv1,param);
			minju[0] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMingjulv2,param);
			minju[1] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMingjulv3,param);
			minju[2] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMingjulv4,param);
			minju[3] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMingjulv5,param);
			minju[4] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMingjulv6,param);
			minju[5] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMingjulv7,param);
			minju[6] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMingjulv8,param);
			minju[7] = *(unsigned char *)param;
			unsigned char nongtian[8];
			playerData->getParam(WCHDATA_JXJNongtianlv1,param);
			nongtian[0] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJNongtianlv2,param);
			nongtian[1] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJNongtianlv3,param);
			nongtian[2] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJNongtianlv4,param);
			nongtian[3] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJNongtianlv5,param);
			nongtian[4] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJNongtianlv6,param);
			nongtian[5] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJNongtianlv7,param);
			nongtian[6] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJNongtianlv8,param);
			nongtian[7] = *(unsigned char *)param;
			unsigned char muchang[4];
			playerData->getParam(WCHDATA_JXJMuchanglv1,param);
			muchang[0] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMuchanglv2,param);
			muchang[1] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMuchanglv3,param);
			muchang[2] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJMuchanglv4,param);
			muchang[3] = *(unsigned char *)param;
			unsigned char lindi[4];
			playerData->getParam(WCHDATA_JXJLingdilv1,param);
			lindi[0] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJLingdilv2,param);
			lindi[1] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJLingdilv3,param);
			lindi[2] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJLingdilv4,param);
			lindi[3] = *(unsigned char *)param;
			unsigned char kuangshan[4];
			playerData->getParam(WCHDATA_JXJKuangshanlv1,param);
			kuangshan[0] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJKuangshanlv2,param);
			kuangshan[1] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJKuangshanlv3,param);
			kuangshan[2] = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJKuangshanlv4,param);
			kuangshan[3] = *(unsigned char *)param;
			////////
			playerData->getParam(WCHDATA_JXJShijilv,param);
			unsigned char shijilv = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJGongfanglv,param);
			unsigned char gongfanglv = *(unsigned char *)param;
			playerData->getParam(WCHDATA_JXJJiusilv,param);
			unsigned char jiusilv = *(unsigned char *)param;
			/////

			if (shijilv==0 && shijiqua == 1)
			{
				playerData->inputParam(WCHDATA_JXJShijilv,&shijiqua);
				diflvmap.insert(std::make_pair(WCHDATA_JXJShijilv,shijiqua));
			}
			if (gongfanglv == 0 && gongfangqua == 1)
			{
				playerData->inputParam(WCHDATA_JXJGongfanglv,&gongfangqua);
				diflvmap.insert(std::make_pair(WCHDATA_JXJGongfanglv,gongfangqua));
			}
			if (jiusilv == 0 && jiusiqua == 1)
			{
				playerData->inputParam(WCHDATA_JXJJiusilv,&jiusiqua);
				diflvmap.insert(std::make_pair(WCHDATA_JXJJiusilv,jiusiqua));
			}
			int minjucur = 0;
			int nongtiancur = 0;
			int muchangcur = 0;
			int lindicur = 0;
			int kuangshancur = 0;
			unsigned char lv = 1;
			int curbuildingid = 0;
			for (int i = 0; i < 8; i++)
			{
				if (minju[i] > 0)minjucur++;
				if (nongtian[i] > 0)nongtiancur++;
			}
			for (int i = 0; i < 4; i++)
			{
				if (muchang[i] > 0)muchangcur++;
				if (lindi[i] > 0)lindicur++;
				if (kuangshan[i] > 0)kuangshancur++;
			}
			while (minjucur<minjuqua)
			{
				int i;
				for (i = 0;i < 8;i++)
				{
					if (minju[i] == 0)
					{
						minju[i] = 1;
						break;
					}
				}
				switch (i)
				{
				case 0:
					curbuildingid = WCHDATA_JXJMingjulv1;
					break;
				case 1:
					curbuildingid = WCHDATA_JXJMingjulv2;
					break;
				case 2:
					curbuildingid = WCHDATA_JXJMingjulv3;
					break;
				case 3:
					curbuildingid = WCHDATA_JXJMingjulv4;
					break;
				case 4:
					curbuildingid = WCHDATA_JXJMingjulv5;
					break;
				case 5:
					curbuildingid = WCHDATA_JXJMingjulv6;
					break;
				case 6:
					curbuildingid = WCHDATA_JXJMingjulv7;
					break;
				case 7:
					curbuildingid = WCHDATA_JXJMingjulv8;
					break;
				}
				if (curbuildingid > 0)
				{
					playerData->inputParam(curbuildingid,&lv);
					diflvmap.insert(std::make_pair(curbuildingid,lv));
				}
				minjucur++;
			}
			while (nongtiancur<nongtianqua)
			{
				int i;
				for (i = 0;i < 8;i++)
				{
					if (nongtian[i] == 0)
					{
						nongtian[i] = 1;
						break;
					}
				}
				switch (i)
				{
				case 0:
					curbuildingid = WCHDATA_JXJNongtianlv1;
					break;
				case 1:
					curbuildingid = WCHDATA_JXJNongtianlv2;
					break;
				case 2:
					curbuildingid = WCHDATA_JXJNongtianlv3;
					break;
				case 3:
					curbuildingid = WCHDATA_JXJNongtianlv4;
					break;
				case 4:
					curbuildingid = WCHDATA_JXJNongtianlv5;
					break;
				case 5:
					curbuildingid = WCHDATA_JXJNongtianlv6;
					break;
				case 6:
					curbuildingid = WCHDATA_JXJNongtianlv7;
					break;
				case 7:
					curbuildingid = WCHDATA_JXJNongtianlv8;
					break;
				}
				if (curbuildingid > 0)
				{
					playerData->inputParam(curbuildingid,&lv);
					diflvmap.insert(std::make_pair(curbuildingid,lv));
				}
				nongtiancur++;
			}
			while (muchangcur<muchangqua)
			{
				int i;
				for (i = 0;i < 4;i++)
				{
					if (muchang[i] == 0)
					{
						muchang[i] = 1;
						break;
					}
				}
				switch (i)
				{
				case 0:
					curbuildingid = WCHDATA_JXJMuchanglv1;
					break;
				case 1:
					curbuildingid = WCHDATA_JXJMuchanglv2;
					break;
				case 2:
					curbuildingid = WCHDATA_JXJMuchanglv3;
					break;
				case 3:
					curbuildingid = WCHDATA_JXJMuchanglv4;
					break;
				}
				if (curbuildingid > 0)
				{
					playerData->inputParam(curbuildingid,&lv);
					diflvmap.insert(std::make_pair(curbuildingid,lv));
				}
				muchangcur++;
			}
			while (lindicur<lindiqua)
			{
				int i;
				for (i = 0;i < 4;i++)
				{
					if (lindi[i] == 0)
					{
						lindi[i] = 1;
						break;
					}
				}
				switch (i)
				{
				case 0:
					curbuildingid = WCHDATA_JXJLingdilv1;
					break;
				case 1:
					curbuildingid = WCHDATA_JXJLingdilv2;
					break;
				case 2:
					curbuildingid = WCHDATA_JXJLingdilv3;
					break;
				case 3:
					curbuildingid = WCHDATA_JXJLingdilv4;
					break;
				}
				if (curbuildingid > 0)
				{
					playerData->inputParam(curbuildingid,&lv);
					diflvmap.insert(std::make_pair(curbuildingid,lv));
				}
				lindicur++;
			}
			while (kuangshancur<kuangshanqua)
			{
				int i;
				for (i = 0;i < 4;i++)
				{
					if (kuangshan[i] == 0)
					{
						kuangshan[i] = 1;
						break;
					}
				}
				switch (i)
				{
				case 0:
					curbuildingid = WCHDATA_JXJKuangshanlv1;
					break;
				case 1:
					curbuildingid = WCHDATA_JXJKuangshanlv2;
					break;
				case 2:
					curbuildingid = WCHDATA_JXJKuangshanlv3;
					break;
				case 3:
					curbuildingid = WCHDATA_JXJKuangshanlv4;
					break;
				}
				if (curbuildingid > 0)
				{
					playerData->inputParam(curbuildingid,&lv);
					diflvmap.insert(std::make_pair(curbuildingid,lv));
				}
				kuangshancur++;

			}
			if (!diflvmap.empty())
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(diflvmap.size() * 5 + 1);
				stream->_writeUChar(diflvmap.size());
				for (std::map< int,unsigned char > ::iterator itr = diflvmap.begin();
					itr != diflvmap.end();
					++itr)
				{
					stream->_writeInt(itr->first);
					stream->_writeUChar(itr->second);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCheckResBuildingLv,stream.get());
				gameServer->getNetManager()->sendPacket(player->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCheckResBuildingLevelMethod
//
/////////////////////////////////////////
crJXJRecvCheckResBuildingLevelMethod::crJXJRecvCheckResBuildingLevelMethod():
	m_this(NULL)
{
}
crJXJRecvCheckResBuildingLevelMethod::crJXJRecvCheckResBuildingLevelMethod(const crJXJRecvCheckResBuildingLevelMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCheckResBuildingLevelMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvCheckResBuildingLevelMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvCheckResBuildingLevelMethod::operator()(crHandle &handle)
{	
	if(m_this && m_netType == GameClient_Game)
	{
		crData *data = m_this->getDataClass();
		unsigned char size = m_stream->_readUChar();
		int buildingid = 0;
		unsigned char buildinglv = 0;
		for (int i = 0; i<size;i++)
		{
			buildingid = m_stream->_readInt();
			buildinglv = m_stream->_readUChar();
			data->inputParam(buildingid,&buildinglv);
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckIFBuildingOpenMethod
//
/////////////////////////////////////////
crJXJCheckIFBuildingOpenMethod::crJXJCheckIFBuildingOpenMethod():
m_this(NULL)
{
}
crJXJCheckIFBuildingOpenMethod::crJXJCheckIFBuildingOpenMethod(const crJXJCheckIFBuildingOpenMethod& handle):
	crMethod(handle)
{
}
void crJXJCheckIFBuildingOpenMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crInstanceItem*)param;
		break;
	}
}
void crJXJCheckIFBuildingOpenMethod::addParam(int i, const std::string& str)
{
}
void crJXJCheckIFBuildingOpenMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this &&playerGameData)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->getParam(WCHDATA_JXJBuildingID,param);
		int buildingid = *(int *)param;
		crData *data = playerGameData->getDataClass();
		data->getParam(buildingid,param);
		unsigned char buildinglv = *(unsigned char *)param;
		if (buildinglv == 0)
		{
			bool cancleTask = false;
			cancleTask = true;
			handle.outputParam(0,&cancleTask);
		}
	}
}
///////////////////////////////////////////
////
////crJXJCheckIFBuildingOpen2Method
////
///////////////////////////////////////////
//crJXJCheckIFBuildingOpen2Method::crJXJCheckIFBuildingOpen2Method():
//	m_this(NULL)
//{
//}
//crJXJCheckIFBuildingOpen2Method::crJXJCheckIFBuildingOpen2Method(const crJXJCheckIFBuildingOpen2Method& handle):
//	crMethod(handle)
//{
//}
//void crJXJCheckIFBuildingOpen2Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crJXJCheckIFBuildingOpen2Method::addParam(int i, const std::string& str)
//{
//}
//void crJXJCheckIFBuildingOpen2Method::operator()(crHandle &handle)
//{	
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && playerGameData && m_this->getParentCanvas())
//	{
//		void *param;
//		crData *thisData = m_this->getParentCanvas()->getDataClass();
//		if (thisData)
//		{
//			thisData->getParam(WCHDATA_JXJBuildingID,param);
//			int buildingid = *(int *)param;
//			crData *data = playerGameData->getDataClass();
//			data->getParam(buildingid,param);
//			unsigned char buildinglv = *(unsigned char *)param;
//			if (buildinglv == 0)
//			{
//				bool cancleTask = false;
//				cancleTask = true;
//				handle.outputParam(0,&cancleTask);
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIMarketSaleChangePageMethod
//
/////////////////////////////////////////
crJXJUIMarketSaleChangePageMethod::crJXJUIMarketSaleChangePageMethod():
	m_this(NULL)
{
}
crJXJUIMarketSaleChangePageMethod::crJXJUIMarketSaleChangePageMethod(const crJXJUIMarketSaleChangePageMethod& handle):
	crMethod(handle),
	m_step(handle.m_step)
{
}
void crJXJUIMarketSaleChangePageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIMarketSaleChangePageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = str;
		break;
	}
}
void crJXJUIMarketSaleChangePageMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if(m_this &&playerGameData)
	{
		void *param;
		int curpagenum,totalpage;
		crData *data = playerGameData->getDataClass();
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJCurSalePageNum,param);
		curpagenum = *(int *)param;
		brainData->getParam(WCHDATA_JXJSaleTotal,param);
		totalpage = *(int *)param;
		data -> getParam(WCHDATA_JXJVipLv,param);
		int countPrePage = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJQuerySaleCount,*(unsigned char *)param).c_str());
		int pageCount = ceil((float)totalpage/(float)countPrePage*2.0);
		if (m_step == "L")
		{
			curpagenum = 1;
		}
		else if (m_step == "R")
		{
			curpagenum = pageCount;
		}
		else
		{
			curpagenum += atoi(m_step.c_str());
			if (curpagenum <= 0 || curpagenum>pageCount)
			{
				curpagenum -=atoi(m_step.c_str());
			}
		}
		brainData->inputParam(WCHDATA_JXJCurSalePageNum,&curpagenum);
		brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIMarketSaleChangePageMethod
//
/////////////////////////////////////////
crJXJUIMarketMySaleChangePageMethod::crJXJUIMarketMySaleChangePageMethod():
	m_this(NULL)
{
}
crJXJUIMarketMySaleChangePageMethod::crJXJUIMarketMySaleChangePageMethod(const crJXJUIMarketMySaleChangePageMethod& handle):
	crMethod(handle),
	m_step(handle.m_step)
{
}
void crJXJUIMarketMySaleChangePageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIMarketMySaleChangePageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = str;
		break;
	}
}
void crJXJUIMarketMySaleChangePageMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if(m_this &&playerGameData)
	{
		void *param;
		int curpagenum,totalpage;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJMyCurSalePageNum,param);
		curpagenum = *(int *)param;
		brainData->getParam(WCHDATA_JXJMySaleTotal,param);
		totalpage = *(int *)param;
		if (m_step == "L")
		{
			curpagenum = 1;
		}
		else if (m_step == "R")
		{
			curpagenum = totalpage;
		}
		else
		{
			curpagenum += atoi(m_step.c_str());
			if (curpagenum <= 0 || curpagenum>totalpage)
			{
				curpagenum -=atoi(m_step.c_str());
			}
		}
		brainData->inputParam(WCHDATA_JXJMyCurSalePageNum,&curpagenum);
		brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIGotoMakeEquipMethod
//
/////////////////////////////////////////
crJXJUIGotoMakeEquipMethod::crJXJUIGotoMakeEquipMethod():
	m_this(NULL)
{
}
crJXJUIGotoMakeEquipMethod::crJXJUIGotoMakeEquipMethod(const crJXJUIGotoMakeEquipMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_equiplist(handle.m_equiplist),
	m_radio(handle.m_radio),
	m_scrollbar(handle.m_scrollbar),
	m_armyradio(handle.m_armyradio)
{
}
void crJXJUIGotoMakeEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIGotoMakeEquipMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_equiplist = str;
		break;
	case 2:
		m_scrollbar = str;
		break;
	case 3:
		m_radio = str;
		break;
	case 4:
		m_armyradio = str;
		break;
	}
}
void crJXJUIGotoMakeEquipMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);//工坊
	if (!canvas.valid())
	{
		return;
	}
	ref_ptr<crListControlWidgetNode> equipList = dynamic_cast<crListControlWidgetNode *>(canvas->getWidget(m_equiplist));
	ref_ptr<crListControlNode> listNode;
	ref_ptr<crScrollBarWidgetNode> Vscrollbar = dynamic_cast<crScrollBarWidgetNode *>(canvas->getWidget(m_scrollbar));
	ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio));

	ref_ptr<crCanvasNode>canvas2 = m_this->getParentCanvas();//兵营
	ref_ptr<crRadioGroupWidgetNode> armyradio = dynamic_cast<crRadioGroupWidgetNode *>(canvas2->getWidget(m_armyradio));
	crData *data = m_this->getDataClass();
	int gongfangid = WCHDATA_JXJGongfanglv;
	data->inputParam(WCHDATA_JXJBuildingID,&gongfangid);
	if(m_this &&playerGameData)
	{
		void *param;
		unsigned short equipID;
		crData *data = playerGameData->getDataClass();
		crData *data2 = crBrain::getInstance()->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		data2->getParam(WCHDATA_JXJEquipID,param);
		equipID = *(unsigned short *)param;
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
		int sel = armyradio -> getSelect();
		radio->select(sel);
		short count = equipList->getListNodeCount();
		crListControlWidgetNode::ListNodeVec& listNodeVec = equipList->getListNodeVec();
		
		for(short i = 0; i < count ;++i )
		{
			int eid = listNodeVec[i]->getData();
			if (eid == equipID)
			{
				equipList->setDefaultScrollPos(2);
				equipList->select(i);
				//int linevalue = Vscrollbar->getLineValue();

				////NodeArray &childArray = Vscrollbar->getChildArray();
				////CRCore::ref_ptr<CRCore::crMatrixTransform> m_scrollBar;
				////for( NodeArray::iterator itr = childArray.begin();
				////	itr != childArray.end();
				////	++itr )
				////{
				////	if(!m_scrollBar.valid() && (*itr)->getName().compare("Bar") == 0)
				////		m_scrollBar = dynamic_cast<crMatrixTransform *>(itr->get());
				////}
				//Vscrollbar->initWindow();
				//Vscrollbar->setValue(linevalue * i);
				//m_scrollBar->set
				//Vscrollbar->setEnable(true);
				//Vscrollbar->updateData();
				break;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckScrollBarPosMethod
//
/////////////////////////////////////////
crJXJCheckScrollBarPosMethod::crJXJCheckScrollBarPosMethod():
	m_this(NULL)
{
}
crJXJCheckScrollBarPosMethod::crJXJCheckScrollBarPosMethod(const crJXJCheckScrollBarPosMethod& handle):
	crMethod(handle),
	m_equiplist(handle.m_equiplist),
	m_scrollbar(handle.m_scrollbar)
{
}
void crJXJCheckScrollBarPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJCheckScrollBarPosMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equiplist = str;
		break;
	case 1:
		m_scrollbar = str;
		break;
	}
}
void crJXJCheckScrollBarPosMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	ref_ptr<crListControlWidgetNode> equipList = dynamic_cast<crListControlWidgetNode *>(canvas->getWidget(m_equiplist));
	ref_ptr<crListControlNode> listNode;
	ref_ptr<crScrollBarWidgetNode> Vscrollbar = dynamic_cast<crScrollBarWidgetNode *>(canvas->getWidget(m_scrollbar));
	if(m_this && equipList.valid() && Vscrollbar.valid())
	{
		short count = equipList->getListNodeCount();
		crListControlWidgetNode::ListNodeVec& listNodeVec = equipList->getListNodeVec();
		if (equipList->getSelectNode())
		{
			int seletdata = equipList->getSelectNode()->getData();
			for(short i = 0; i < count ;++i )
			{
				int eid = listNodeVec[i]->getData();
				equipList->setDefaultScrollPos(2);
				if(eid == seletdata)
				{
					int linevalue = Vscrollbar->getLineValue();
					Vscrollbar->setValue(linevalue * i);
					break;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBuildBackPackListMethod
//
/////////////////////////////////////////
crJXJBuildBackPackListMethod::crJXJBuildBackPackListMethod(){}
crJXJBuildBackPackListMethod::crJXJBuildBackPackListMethod(const crJXJBuildBackPackListMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_listName(handle.m_listName)
{
}
void crJXJBuildBackPackListMethod::inputParam(int i, void *param)
{
}
void crJXJBuildBackPackListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_listName = str;
		break;
	}
}
void crJXJBuildBackPackListMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid())
	{
		ref_ptr<crListControlWidgetNode> backPackList = dynamic_cast<crListControlWidgetNode *>(canvasNode->getWidget(m_listName));
		if(backPackList.valid())
		{
			crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
			void *param;
			crData *myData = me->getDataClass();
			myData->excHandle(MAKECREPARAM(WCH_LockData,1));
			myData->getParam(WCHDATA_BackPackMap,param);
			BackPackMap* backPackMap = (BackPackMap* )param;
			crItemChild *itemchild;
			crInstanceItem *item;
			crData *itemData;
			std::string iconfile;
			myData->getParam(WCHDATA_ItemCountMap,param);
			ItemCountMap* itemCountMap = (ItemCountMap* )param;
			ItemCountMap::iterator citr;
			unsigned char count;
			std::string title,title2;
			std::map<int,int> FindCount;
			std::map<int,int>::iterator FindCountItr;
			int offset;
			backPackList->setListNodeCount(backPackMap->size());
			crListControlWidgetNode::ListNodeVec& listNodeVec = backPackList->getListNodeVec();
			int i = 0;
			for( BackPackMap::iterator itr = backPackMap->begin();
				itr != backPackMap->end();
				++itr,++i )
			{
				listNodeVec[i]->setVisiable(false);
				if(itr->second!=0)
				{
					itemchild = me->findChildItem(itr->second);
					if(itemchild && itemchild->isLoaded())
					{
						item = itemchild->getInstanceItem();
						itemData = item->getDataClass();
						if(!itemData)
							continue;
						itemData->getParam(WCHDATA_ItemIcon,param);
						iconfile = *(std::string *)param;

						title = item->getIName();
						title2.clear();
						if(itr->second<0)
						{
							citr = itemCountMap->find(itr->first);
							if(citr!=itemCountMap->end())
							{
								FindCountItr = FindCount.find(itr->first);
								if(FindCountItr==FindCount.end())
								{
									FindCount[itr->first] = 1;
									count = citr->second;
								}
								else
								{
									offset = FindCountItr->second;
									for(citr++;citr!=itemCountMap->end()&&citr->first==itr->first;citr++)
									{
										offset--;
										if(offset==0)
											break;
									}
									if(offset==0)
									{
										count = citr->second;
										FindCountItr->second++;
									}
									else
									{
										count = 1;
									}
								}
								title2 = crArgumentParser::appItoa((int)count);
							}
							else
								title2 = crArgumentParser::appItoa(1);
						}
						listNodeVec[i]->setTitle(title);
						listNodeVec[i]->setTitle2(title2);
						listNodeVec[i]->setData(item);
						listNodeVec[i]->setImageName(iconfile);
						listNodeVec[i]->setVisiable(true);
					}
				}
			}
			myData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFriendChangePageMethod
//
/////////////////////////////////////////
crJXJUIFriendChangePageMethod::crJXJUIFriendChangePageMethod():
	m_this(NULL),
	m_curpageid(0),
	m_totalpageid(0)
{
}
crJXJUIFriendChangePageMethod::crJXJUIFriendChangePageMethod(const crJXJUIFriendChangePageMethod& handle):
	crMethod(handle),
	m_step(handle.m_step),
	m_curpageid(handle.m_curpageid),
	m_totalpageid(handle.m_totalpageid)
{
}
void crJXJUIFriendChangePageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIFriendChangePageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = str;
		break;
	case 1:
		m_curpageid = atoi(str.c_str());
		break;
	case 2:
		m_totalpageid = atoi(str.c_str());
		break;
	}
}
void crJXJUIFriendChangePageMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if(m_this && playerGameData && m_curpageid > 0 && m_totalpageid > 0)
	{
		void *param;
		int curpagenum,totalpage;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		brainData->getParam(m_curpageid,param);
		curpagenum = *(int *)param;
		brainData->getParam(m_totalpageid,param);
		totalpage = *(int *)param;
		if (m_step == "L")
		{
			curpagenum = 1;
		}
		else if (m_step == "R")
		{
			curpagenum = totalpage;
		}
		else
		{
			curpagenum += atoi(m_step.c_str());
			if (curpagenum <= 0 || curpagenum>totalpage)
			{
				curpagenum -=atoi(m_step.c_str());
			}
		}
		brainData->inputParam(m_curpageid,&curpagenum);
		brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUISendMsgToFriendMethod
//
/////////////////////////////////////////
crJXJUISendMsgToFriendMethod::crJXJUISendMsgToFriendMethod():
	m_this(NULL),
	m_index(0)
{
}
crJXJUISendMsgToFriendMethod::crJXJUISendMsgToFriendMethod(const crJXJUISendMsgToFriendMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_input(handle.m_input),
	m_chatmode(handle.m_chatmode),
	m_friendlist(handle.m_friendlist),
	m_index(handle.m_index)
{
}
void crJXJUISendMsgToFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISendMsgToFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_chatmode = str;
		break;
	case 3:
		m_friendlist = str;
		break;
	case 4:
		m_radio = str;
		break;
	case 5:
		m_battleCanvasName = str;
		break;
	case 6:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJUISendMsgToFriendMethod::operator()(crHandle &handle)
{	
	void *param;
	ref_ptr<crCanvasNode>canvasNode = NULL;
	if(crRunGameHandle::getInstance()->isInBattle())
	{
		canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_battleCanvasName);
	}
	else
		canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(canvasNode.valid())
	{
		std::string name;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crMultiSwitch *curmodeSW = dynamic_cast<crMultiSwitch *>(canvasNode->getChildNode(m_chatmode));
		ref_ptr<crTableWidgetNode> friendList = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_friendlist));
		ref_ptr<crEditWidgetNode> input = dynamic_cast<crEditWidgetNode *>(canvasNode->getWidget(m_input));
		ref_ptr<crRadioGroupWidgetNode>  radioGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvasNode->getWidget(m_radio));
		if(friendList.valid())
		{
			if (m_index == 0)
			{
				crFriend *myfriend = (crFriend *)(friendList->getSelectData());
				if(myfriend)
				{
					name = myfriend->getName();
				}
			}
			else if (m_index == 1)
			{
				crData *canvasdata = m_this->getParentCanvas()->getDataClass();
				if (canvasdata)
				{
					canvasdata->getParam(WCHDATA_JXJMyGroupSelPlayData,param);
					crJXJConsortiaMember *playerData = (crJXJConsortiaMember *)param;
					name = playerData->getName();
				}
			}
			
			if (input.valid() && !name.empty())
			{
				input -> setString("\\" + name  + " ");
				input->updateData();
				//input->setFocusPos(input->getUTF8String().size());
			}
		}
		else
		{
			void *param;
			crData *brain = crBrain::getInstance()->getDataClass();
			brain->getParam(WCHDATA_JXJAddFriendName,param);
			std::string name = *(std::string *)param;
			if(input.valid())
			{
				input->setString("\\" + name  + " ");
				//input->setFocusPos(input->getUTF8String().size());
				input->updateData();
			}	
		}
		if (curmodeSW)
		{
			curmodeSW->setActiveSwitchSet(ChatOneToOne-1);
		}
		if(radioGroup.valid())
		{
			radioGroup->select(ChatOneToOne);
		}
	}
}


/////////////////////////////////////////
//
//crJXJAddFriendPromptMethod
//
/////////////////////////////////////////
crJXJAddFriendPromptMethod::crJXJAddFriendPromptMethod():
	m_this(NULL)
{
}
crJXJAddFriendPromptMethod::crJXJAddFriendPromptMethod(const crJXJAddFriendPromptMethod& handle):
	crMethod(handle),
	m_input(handle.m_input)
{
}
void crJXJAddFriendPromptMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJAddFriendPromptMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	}
}
void crJXJAddFriendPromptMethod::operator()(crHandle &handle)
{	
	if(m_this)
	{
		ref_ptr<crEditWidgetNode> input = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_input));
		if (input.valid())
		{
			std::string str = "请输入玩家昵称^_^";
			input -> setString(str);
		}
	}
}
/////////////////////////////////////////
//
//crJXJGameAddFriendMethod
//
/////////////////////////////////////////
crJXJGameAddFriendMethod::crJXJGameAddFriendMethod():
	m_this(NULL)
{
}
crJXJGameAddFriendMethod::crJXJGameAddFriendMethod(const crJXJGameAddFriendMethod& handle):
	crMethod(handle),
	m_input(handle.m_input),
	m_tipsinput(handle.m_tipsinput)
{
}
void crJXJGameAddFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJGameAddFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	case 1:
		m_tipsinput = str;
		break;
	}
}
void crJXJGameAddFriendMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		int maxsize = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPlayerNameSizeMax,*(unsigned char *)param).c_str()));
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		ref_ptr<crEditWidgetNode> input = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_input));
		ref_ptr<crStaticTextWidgetNode> tipsinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_tipsinput));
		if (input.valid() && netConductor)
		{
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->getParam(WCHDATA_JXJAddFriendOrBlack,param);
			unsigned char addfriendorblack = *(unsigned char *)param;
			std::string nickname,nameprompt;
			nickname = input->getUTF8String();
			std::string myname = crMyPlayerData::getInstance()->getCharacterName();
			if(!nickname.empty() && nickname.length()<13 && myname!=nickname)
			{
				//for (int i = 0; i< 3; i++)
				//{//test
				if (addfriendorblack == JXJAddFriendType_Friend)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(4+nickname.length());
					stream->_writeString(nickname);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGameAddFriend,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				else
				{
					std::string blackname = nickname;
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data -> getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					int blacknamemax = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBlackNameSetMax,viplv).c_str());
					data->getParam(WCHDATA_JXJBlackNameSet,param);
					BlackNameSet *blacknameset = (BlackNameSet *)param;
					BlackNameSet::iterator finditr = blacknameset->find(blackname);
					if (blacknameset->size() < blacknamemax)
					{
						if (finditr == blacknameset->end())
						{
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(4 + blackname.size());
							stream->_writeString(blackname);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvAddBlackName,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
							blacknameset->insert(blackname);
						}
						else
						{
							myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKECREPARAM(2084,NULL));//已在黑名单中
						}
					}
					else
					{
						myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKECREPARAM(2086,NULL));//黑名单已满
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				//}
			}
			else if(nickname.empty())
			{
				nameprompt = "玩家昵称不能为空";
				if(input.valid())input->setString(nameprompt);
			}
			else if(nickname.length() > maxsize)
			{
				nameprompt = "昵称不超过6个字";
				if(input.valid())input->setString(nameprompt);
			}
			else if(myname==nickname)
			{

				if (addfriendorblack == JXJAddFriendType_Friend)
				{
					nameprompt = "不能加自己为好友";
				}
				else
				{
					nameprompt = "不能加自己到黑名单";
				}
				if(input.valid())input->setString(nameprompt);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvGameAddFriendMethod
//
/////////////////////////////////////////
crJXJRecvGameAddFriendMethod::crJXJRecvGameAddFriendMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvGameAddFriendMethod::crJXJRecvGameAddFriendMethod(const crJXJRecvGameAddFriendMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input),
	m_addcanvas(handle.m_addcanvas)
{
}
void crJXJRecvGameAddFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvGameAddFriendMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_addcanvas = str;
		break;
	}
}
void crJXJRecvGameAddFriendMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			if(!m_this->getMainRole())
				return;
			std::string nickname = m_stream->_readString();
			int myplayerid = m_this->getPlayerID();
			unsigned char lv2 = 0;
			unsigned char iconid2 = 0;
			crData *data = m_this->getDataClass();
			std::string myname = m_this->getMainRole()->getIName2();
			unsigned char result = 0;
			int playerid2 = 0;
			void *param;
			std::string playername;
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			if (myname != nickname)
			{
				ref_ptr<crGameServerPlayerData> playerData2;
				bool found = false;
				netDataManager->lockPlayerDataMap();//WCH 根据CharacterName找玩家
				crNetDataManager::PlayerDataMap &playerDataMap = netDataManager->getPlayerDataMap();
				for( crNetDataManager::PlayerDataMap::iterator itr = playerDataMap.begin();
					itr != playerDataMap.end();++itr )
				{
					playerData2 = dynamic_cast<crGameServerPlayerData *>(itr->second.get());
					if(!playerData2.valid())
					{
						continue;
					}
					if(playerData2->getCharacterName() == nickname)
					{
						found = true;
						break;
					}
				}
				netDataManager->unLockPlayerDataMap();
				if(found)
				{
					do 
					{
						playerid2 = playerData2->getPlayerID();
						crData *data2 = playerData2->getPlayerGameData()->getDataClass();
						if (playerData2->getPlayerGameData()->getMainRole() == NULL)
						{
							break;
						}
						data->excHandle(MAKECREPARAM(WCH_LockData,1));
						data->getParam(WCHDATA_JXJFriendList,param);
						FriendVec *myfriend = (FriendVec *)param;
						FriendVec::iterator itr2;
						for (itr2 = myfriend->begin();itr2 != myfriend->end();++itr2)
						{
							if ((*itr2)->getPlayerID() == playerid2)
							{
								result = 3;//我的好友列表已存在该玩家
								break;
							}
						}
						data->getParam(WCHDATA_JXJShiliID,param);
						unsigned char shiliid = *(unsigned char *)param;
						data->excHandle(MAKECREPARAM(WCH_LockData,0));
						if(result == 3)break;

						data2->excHandle(MAKECREPARAM(WCH_LockData,1));
						data2->getParam(WCHDATA_JXJShiliID,param);
						unsigned char shiliid2 = *(unsigned char *)param;
						data2->getParam(WCHDATA_JXJFriendList,param);
						FriendVec *friendlist2 = (FriendVec *)param;
						FriendVec::iterator itr3;
						for (itr3 = friendlist2->begin();itr3 != friendlist2->end();++itr3)
						{
							if ((*itr3)->getPlayerID() == myplayerid)
							{
								crData *RoleData2 = playerData2->getPlayerGameData()->getMainRole()->getDataClass();
								data2->getParam(WCHDATA_PlayerIconID,param);//nickname
								iconid2 = *(unsigned char *)param;
								RoleData2->getParam(WCHDATA_Level,param);
								lv2 = *(unsigned char *)param;
								result = 4;//对方好友列表已存在我的数据
								break;
							}
						}
						data2->excHandle(MAKECREPARAM(WCH_LockData,0));
						if(result == 4)break;
						if (shiliid!=shiliid2)
						{
							result = 2;//势力不同
							break;
						}
						crPlayerDataEventPacket recvpacket;
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(8+myname.length());
						stream->_writeInt(myplayerid);
						stream->_writeString(myname);
						crPlayerDataEventPacket::buildReplyPacket(recvpacket,playerid2,WCH_JXJRecvRequestAddFriend,stream.get());
						netManager->sendPacket(playerData2->getPlayerConnectServerAddress(),recvpacket);
						result = 1;
					} while (0);
				}
			}
			if(result != 4)
			{
				crPlayerDataEventPacket replypacket;
				ref_ptr<crStreamBuf> stream1 = new crStreamBuf;
				stream1->createBuf(1);
				stream1->_writeUChar(result);
				ref_ptr<crGameServerPlayerData> senderPlayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(myplayerid));
				if (senderPlayerData.valid())
				{
					crPlayerDataEventPacket::buildReplyPacket(replypacket,myplayerid,WCH_JXJRecvGameAddFriend,stream1.get());
					netManager->sendPacket(senderPlayerData->getPlayerConnectServerAddress(),replypacket);
				}
			}
			else
			{
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				//从黑名单中删除（如果存在）
				data->getParam(WCHDATA_JXJBlackNameSet,param);
				BlackNameSet *blacknameset = (BlackNameSet*)param;
				BlackNameSet::iterator bitr = blacknameset->find(nickname);
				if (bitr != blacknameset->end())
				{
					blacknameset->erase(bitr);
				}
				//加入好友列表
				data->getParam(WCHDATA_JXJFriendList,param);
				FriendVec *myfriend = (FriendVec *)param;
				ref_ptr<crFriend> newfriend2 = new crFriend;
				newfriend2 -> setPlayerID(playerid2);
				newfriend2 -> setName(nickname);
				newfriend2 -> setLevel(lv2);
				newfriend2 -> setIconID(iconid2);
				myfriend -> push_back(newfriend2.get());
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				////////////////////////////////////////////////////
				result = 2;
				crPlayerDataEventPacket replypacket;
				ref_ptr<crStreamBuf> stream1 = new crStreamBuf;
				stream1->createBuf(11+nickname.length());
				stream1->_writeUChar(result);
				stream1->_writeInt(playerid2);
				stream1->_writeString(nickname);
				stream1->_writeUChar(lv2);
				stream1->_writeUChar(iconid2);
				ref_ptr<crGameServerPlayerData> senderPlayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(myplayerid));
				if (senderPlayerData.valid())
				{
					crPlayerDataEventPacket::buildReplyPacket(replypacket,myplayerid,WCH_JXJRecvGameSendYesToAddFriend,stream1.get());
					netManager->sendPacket(senderPlayerData->getPlayerConnectServerAddress(),replypacket);
				}
			}
			///游戏日志
			std::string logdata = "加好友（result，好友id）：" + crArgumentParser::appVectoa(crVector2i(result,playerid2));
			GameLogData gamelog(Log_AddFriend,logdata);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(myplayerid,&gamelog));
		}

		if(m_netType == GameClient_Game)
		{
			unsigned char result =m_stream->_readUChar();
			std::string str = "添加好友失败";
			ref_ptr<crCanvasNode>addCanvas = crFilterRenderManager::getInstance()->findCanvas(m_addcanvas);
			if(addCanvas.valid())
			{
				switch (result)
				{
				case 0:
					str = "对方不在线或昵称错误";
					break;
				case 1:
					str = "添加好友信息发送成功！";
					crFilterRenderManager::getInstance()->closeCanvas(addCanvas.get());
					break;
				case 2:
					str = "只能添加同势力玩家";
					break;
				case 3:
					str = "该玩家已存在好友列表中";
					crFilterRenderManager::getInstance()->closeCanvas(addCanvas.get());
					break;
				}
				ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if (msgCanvas.valid())
				{
					ref_ptr<crStaticTextWidgetNode> msg = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_input));
					msg->setString(str);
					crFilterRenderManager::getInstance()->showCanvas(msgCanvas.get(),true);
				}
			}
			

			//crGlobalHandle::getInstance()->doEvent(WCH_NetReturnStream,MAKEINT64(m_stream.get(),NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJIFAddFriendSuccessMethod
//
/////////////////////////////////////////
crJXJIFAddFriendSuccessMethod::crJXJIFAddFriendSuccessMethod():
	m_netType(GameClient_Game)
{
}
crJXJIFAddFriendSuccessMethod::crJXJIFAddFriendSuccessMethod(const crJXJIFAddFriendSuccessMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input),
	m_text(handle.m_text)
{
}
void crJXJIFAddFriendSuccessMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJIFAddFriendSuccessMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_text = str;
		break;
	}
}
void crJXJIFAddFriendSuccessMethod::operator()(crHandle &handle)
{	
	ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(canvasNode.valid())
	{
		ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvasNode->getWidget(m_input));
		std::string str;
		if (m_text == "1")
		{
			str = "好友请求发送成功！";
			input->setString(str);
		}
		else if (m_text == "0")
		{
			str = "对方不在线或昵称错误。";
			input->setString(str);
		}
		else if (m_text == "3")
		{
			str = "好友添加成功！";
			input->setString(str);
		}
		else if (m_text == "2")
		{
			str = "好友添加失败！";
			input->setString(str);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvRequestAddFriendMethod
//
/////////////////////////////////////////
crJXJRecvRequestAddFriendMethod::crJXJRecvRequestAddFriendMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvRequestAddFriendMethod::crJXJRecvRequestAddFriendMethod(const crJXJRecvRequestAddFriendMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_sendname(handle.m_sendname),
	m_text(handle.m_text),
	m_lastname(handle.m_lastname)
{
}
void crJXJRecvRequestAddFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvRequestAddFriendMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_sendname = str;
		break;
	case 2:
		m_text = str;
		break;
	}
}
void crJXJRecvRequestAddFriendMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			bool canshow = false;
			int playerid = m_stream->_readInt();
			std::string nickname = m_stream->_readString();
			m_lastname = nickname;
			ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvasNode.valid())
			{
				if (canvasNode->getVisiable() && nickname.compare(m_lastname) != 0)
				{
					canshow = true;
				}
				if (!canvasNode->getVisiable())
				{
					canshow = true;
				}
				if (canshow)
				{
					ref_ptr<crStaticTextWidgetNode> inputname = dynamic_cast<crStaticTextWidgetNode *>(canvasNode->getWidget(m_sendname));
					ref_ptr<crStaticTextWidgetNode> inputtext = dynamic_cast<crStaticTextWidgetNode *>(canvasNode->getWidget(m_text));
					std::string str = "请求加你为好友";
					//if(inputname)inputname->setString(nickname);
					//if(inputtext)inputtext->setString(str);
					if(inputname.valid())inputname->setString("玩家【"+ nickname+"】" + str);
					void *param;
					crData *data = canvasNode ->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJFriendRequestDeq,param);
					AddFriendRequestDeq *addFriendRequest = (AddFriendRequestDeq *)param;
					addFriendRequest->push_back(std::make_pair(playerid,nickname));
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}
			//addFriendRequest->pop_front();
			//canvasNode->getVisiable();
		}//JXJAddFriendRequestUpdate
	}
}
/////////////////////////////////////////
//
//crJXJAddFriendRequestUpdateMethod
//
/////////////////////////////////////////
crJXJAddFriendRequestUpdateMethod::crJXJAddFriendRequestUpdateMethod()
{
}
crJXJAddFriendRequestUpdateMethod::crJXJAddFriendRequestUpdateMethod(const crJXJAddFriendRequestUpdateMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_sendname(handle.m_sendname),
	m_text(handle.m_text),
	m_title(handle.m_title),
	m_sequence(handle.m_sequence),
	m_addfriendsw(handle.m_addfriendsw)
{
}
void crJXJAddFriendRequestUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crMatrixTransform*)param;
		break;
	}
}
void crJXJAddFriendRequestUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_sendname = str;
		break;
	case 2:
		m_text = str;
		break;
	case 3:
		m_title = str;
		break;
	case 4:
		m_taskbarcanvas = str;
		break;
	case 5:
		m_addfriendhint = str;
		break;
	case 6:
		m_sequence = str;
		break;
	case 7:
		m_addfriendsw = str;
		break;
	}
}
void crJXJAddFriendRequestUpdateMethod::operator()(crHandle &handle)
{	
	if(m_this)
	{
		void *param;
		int count = 0;
		std::string str1 = "好友申请";
		std::string str2 = "申请加你为好友";
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		ref_ptr<crCanvasNode>taskbarcanvas = crFilterRenderManager::getInstance()->findCanvas(m_taskbarcanvas);
		ref_ptr<crWidgetNode> addfriendhint = NULL;
		ref_ptr<crMultiSwitch> addfriendsw  = NULL;
		if (taskbarcanvas.valid())
		{
			addfriendhint = dynamic_cast<crWidgetNode *>(taskbarcanvas->getWidget(m_addfriendhint));
			addfriendsw = dynamic_cast<crMultiSwitch *>(taskbarcanvas->getChildNode(m_addfriendsw));
		}
		//bool ifshow = canvas->getVisiable();
		if (canvas.valid() && canvas->getDataClass()/* && ifshow*/)
		{
			ref_ptr<crStaticTextWidgetNode> name = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_sendname));
			//ref_ptr<crStaticTextWidgetNode> text = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_text));
		//	ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_title));

			crData *data = canvas ->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJFriendRequestDeq,param);
			AddFriendRequestDeq *addFriendRequest = (AddFriendRequestDeq *)param;
			AddFriendRequestDeq::iterator itr;
			if (!addFriendRequest->empty())
			{
				if (addfriendsw.valid())
				{
					addfriendsw->setActiveSwitchSet(1);
				}
				ref_ptr<crSequence> sequence = dynamic_cast<crSequence *>(taskbarcanvas->getChildNode(m_sequence));
				if(sequence.valid() && sequence->getMode() == crSequence::STOP)
				{
					//sequence->setDuration(0.1f, -1);
					sequence->startEffect();
				}
				if (addfriendhint.valid())
				{
					addfriendhint->setVisiable(true);
				}
				itr = addFriendRequest->begin();
				if (name.valid())
				{
					name->setString("玩家【"+itr->second+"】"+ str2);
				}
				//if(text)text->setString(str2);
				//if(!ifshow)
				//{
					//crFilterRenderManager::getInstance()->showCanvas(canvas,true);
				//}
				for (itr;itr!= addFriendRequest->end();++itr)
				{
					count++;
				}
			//	if(title)title->setString(str1 + "(" + crArgumentParser::appItoa(count) + ")");
			}
			else
			{
				if (addfriendsw.valid())
				{
					addfriendsw->setActiveSwitchSet(0);
				}
				if (addfriendhint.valid() && addfriendhint->getVisiable())
				{
					addfriendhint->setVisiable(false);
				}
				crFilterRenderManager::getInstance()->showCanvas(canvas.get(),false);
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJGameSendYesToAddFriendMethod
//
/////////////////////////////////////////
crJXJGameSendYesToAddFriendMethod::crJXJGameSendYesToAddFriendMethod():
	m_this(NULL)
{
}
crJXJGameSendYesToAddFriendMethod::crJXJGameSendYesToAddFriendMethod(const crJXJGameSendYesToAddFriendMethod& handle):
	crMethod(handle),
	m_input(handle.m_input),
	m_yesorno(handle.m_yesorno)
{
}
void crJXJGameSendYesToAddFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJGameSendYesToAddFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	case 1:
		m_yesorno = str;
		break;
	}
}
void crJXJGameSendYesToAddFriendMethod::operator()(crHandle &handle)
{	
	bool cancelTask = true;
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
		if (/*input && */netConductor)
		{
			std::string nickname,nameprompt;
			//nickname = input->getUTF8String();
			crData *data = canvas->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJFriendRequestDeq,param);
			AddFriendRequestDeq *addFriendRequest = (AddFriendRequestDeq *)param;
			AddFriendRequestDeq::iterator itr = addFriendRequest -> begin();
			int playerid = itr->first;
			nickname = itr->second;
			if(nickname.length()>0&&nickname.length()<15)
			{
				addFriendRequest->pop_front();
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				cancelTask = false;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(8+nickname.length());
				stream->_writeInt(playerid);
				stream->_writeString(nickname);
				crPlayerDataEventPacket packet;
				if(m_yesorno == "1")crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGameSendYesToAddFriend,stream.get());
				else crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGameSendNoToAddFriend,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			else data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJRecvGameSendYesToAddFriendMethod
//
/////////////////////////////////////////
crJXJRecvGameSendYesToAddFriendMethod::crJXJRecvGameSendYesToAddFriendMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvGameSendYesToAddFriendMethod::crJXJRecvGameSendYesToAddFriendMethod(const crJXJRecvGameSendYesToAddFriendMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input),
	m_addcanvas(handle.m_addcanvas)
{
}
void crJXJRecvGameSendYesToAddFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvGameSendYesToAddFriendMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_addcanvas = str;
		break;
	}
}
void crJXJRecvGameSendYesToAddFriendMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int myplayerid =m_this->getPlayerID();
			int playerid2 = m_stream->_readInt();//好友ID
			std::string nickname = m_stream->_readString();//好友姓名
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> senderPlayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(myplayerid));
			ref_ptr<crGameServerPlayerData> playerData2 = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid2));
			if (!playerData2.valid() || !senderPlayerData.valid())
			{
				return;
			}
			std::string myname = senderPlayerData->getCharacterName();//我的姓名
			unsigned char result = 0;
			unsigned char mylv = 0;
			unsigned char myiconid = 0;
			unsigned char lv2 = 0;
			unsigned char iconid2 = 0;
			std::string playername = playerData2->getCharacterName();
			if (myname != nickname && playername == nickname && m_this->getMainRole() && m_this->getMainRole()->getDataClass()
				&& playerData2->getPlayerGameData()->getMainRole())
			{
				void *param;
				//我的数据
				crData *mydata = m_this->getDataClass();
				crData *myRoleData = m_this->getMainRole()->getDataClass();
				mydata->getParam(WCHDATA_PlayerIconID,param);
				myiconid = *(unsigned char *)param;
				myRoleData->getParam(WCHDATA_Level,param);
				mylv = *(unsigned char *)param;
				//好友数据
				crData *data2 = playerData2->getPlayerGameData()->getDataClass();
				crData *RoleData2 = playerData2->getPlayerGameData()->getMainRole()->getDataClass();
				data2->getParam(WCHDATA_PlayerIconID,param);
				iconid2 = *(unsigned char *)param;
				RoleData2->getParam(WCHDATA_Level,param);
				lv2 = *(unsigned char *)param;

				mydata->excHandle(MAKECREPARAM(WCH_LockData,1));
				mydata->getParam(WCHDATA_JXJFriendList,param);
				FriendVec *myfriend = (FriendVec *)param;
				FriendVec::iterator itr;
				bool ifadd = true;
				for (itr = myfriend->begin();itr != myfriend->end();++itr)
				{
					if ((*itr)->getPlayerID() == playerid2)
					{
						ifadd = false;
						result = 3;
						break;
					}
				}
				if (ifadd)
				{
					//从我的黑名单中删除对方（如果存在）
					mydata->getParam(WCHDATA_JXJBlackNameSet,param);
					BlackNameSet *blacknameset = (BlackNameSet*)param;
					BlackNameSet::iterator bitr = blacknameset->find(nickname);
					if (bitr != blacknameset->end())
					{
						blacknameset->erase(bitr);
					}
					//加入我的好友列表
					ref_ptr<crFriend> newfriend = new crFriend;
					newfriend -> setPlayerID(playerid2);
					newfriend -> setName(nickname);
					newfriend -> setLevel(lv2);
					newfriend -> setIconID(iconid2);
					myfriend -> push_back(newfriend.get());
					result = 1;
				}
				mydata->excHandle(MAKECREPARAM(WCH_LockData,0));
				if (result)
				{
					data2->excHandle(MAKECREPARAM(WCH_LockData,1));
					data2->getParam(WCHDATA_JXJFriendList,param);
					FriendVec *friend2 = (FriendVec *)param;
					FriendVec::iterator itr;
					for (itr = friend2->begin();itr != friend2->end();++itr)
					{
						if ((*itr)->getPlayerID() == myplayerid)
						{
							ifadd = false;
							result = 3;		//好友列表已有该好友
							break;
						}
					}
					if (ifadd)
					{
						//从对方的黑名单中删除我（如果存在）
						data2->getParam(WCHDATA_JXJBlackNameSet,param);
						BlackNameSet *blacknameset = (BlackNameSet*)param;
						BlackNameSet::iterator bitr = blacknameset->find(myname);
						if (bitr != blacknameset->end())
						{
							blacknameset->erase(bitr);
						}
						//加入对方的好友列表
						ref_ptr<crFriend> newfriend2 = new crFriend;
						newfriend2 -> setPlayerID(myplayerid);
						newfriend2 -> setName(myname);
						newfriend2 -> setLevel(mylv);
						newfriend2 -> setIconID(myiconid);
						friend2 -> push_back(newfriend2.get());
						result = 2;
					}
					data2->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}

			if (result == 2)
			{
				crPlayerDataEventPacket replypacket2;
				ref_ptr<crStreamBuf> stream2 = new crStreamBuf;
				stream2->createBuf(11+myname.length());
				stream2->_writeUChar(result);
				stream2->_writeInt(myplayerid);
				stream2->_writeString(myname);
				stream2->_writeUChar(mylv);
				stream2->_writeUChar(myiconid);
				crPlayerDataEventPacket::buildReplyPacket(replypacket2,playerid2,WCH_JXJRecvGameSendYesToAddFriend,stream2.get());
				netManager->sendPacket(playerData2->getPlayerConnectServerAddress(),replypacket2);
			}
			crPlayerDataEventPacket replypacket;
			ref_ptr<crStreamBuf> stream1 = new crStreamBuf;
			stream1->createBuf(11+nickname.length());
			stream1->_writeUChar(result);
			stream1->_writeInt(playerid2);
			stream1->_writeString(nickname);
			stream1->_writeUChar(lv2);
			stream1->_writeUChar(iconid2);
			crPlayerDataEventPacket::buildReplyPacket(replypacket,myplayerid,WCH_JXJRecvGameSendYesToAddFriend,stream1.get());
			netManager->sendPacket(senderPlayerData->getPlayerConnectServerAddress(),replypacket);
		}

		if(m_netType == GameClient_Game)
		{
			void *param;
			unsigned char result =m_stream->_readUChar();
			int playerid = m_stream->_readInt();
			std::string name = m_stream->_readString();
			unsigned char lv =m_stream->_readUChar();
			unsigned char iconid =m_stream->_readUChar();
			crData *data = m_this->getDataClass();
			std::string str = "添加好友失败";
			ref_ptr<crFriend> newfriend3 = new crFriend;
			FriendVec *friend3 = NULL;
			BlackNameSet *blacknameset = NULL;
			BlackNameSet::iterator bitr;
			ref_ptr<crCanvasNode>addCanvas = crFilterRenderManager::getInstance()->findCanvas(m_addcanvas);
			switch (result)
			{
			case 2:
				str = "添加好友成功！";
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				//从黑名单中删除（如果存在）
				data->getParam(WCHDATA_JXJBlackNameSet,param);
				blacknameset = (BlackNameSet*)param;
				bitr = blacknameset->find(name);
				if (bitr != blacknameset->end())
				{
					blacknameset->erase(bitr);
				}
				//加入好友列表
				data->getParam(WCHDATA_JXJFriendList,param);
				friend3 = (FriendVec *)param;
				newfriend3 -> setPlayerID(playerid);
				newfriend3 -> setName(name);
				newfriend3 -> setLevel(lv);
				newfriend3 -> setIconID(iconid);
				newfriend3 -> setOnline(true);
				friend3 -> push_back(newfriend3.get());
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				if(addCanvas.valid())crFilterRenderManager::getInstance()->showCanvas(addCanvas.get(),false);
				break;
			case 3:
				str = "该玩家已存在好友列表中！";
				break;
			}
			ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (msgCanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> msg = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_input));
				if(msg.valid())msg->setString(str);
				if(msgCanvas.valid())crFilterRenderManager::getInstance()->showCanvas(msgCanvas.get(),true);
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJRecvGameSendNoToAddFriendMethod
//
/////////////////////////////////////////
crJXJRecvGameSendNoToAddFriendMethod::crJXJRecvGameSendNoToAddFriendMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvGameSendNoToAddFriendMethod::crJXJRecvGameSendNoToAddFriendMethod(const crJXJRecvGameSendNoToAddFriendMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input)
{
}
void crJXJRecvGameSendNoToAddFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvGameSendNoToAddFriendMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	}
}
void crJXJRecvGameSendNoToAddFriendMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int myplayerid =m_this->getPlayerID();
			int playerid2 = m_stream->_readInt();//好友ID
			std::string nickname = m_stream->_readString();//好友姓名
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> senderPlayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(myplayerid));
			ref_ptr<crGameServerPlayerData> playerData2 = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid2));
			if(!playerData2.valid()||!senderPlayerData.valid())
			{
				return;
			}
			std::string myname = senderPlayerData->getCharacterName();//我的姓名
			std::string playername = playerData2->getCharacterName();
			unsigned char result = 0;
			if(playername != nickname)
			{
				result = 2;
			}
			crPlayerDataEventPacket replypacket;
			ref_ptr<crStreamBuf> stream1 = new crStreamBuf;
			stream1->createBuf(5+nickname.length());
			stream1->_writeUChar(result);
			stream1->_writeString(nickname);
			crPlayerDataEventPacket::buildReplyPacket(replypacket,myplayerid,WCH_JXJRecvGameSendNoToAddFriend,stream1.get());
			netManager->sendPacket(senderPlayerData->getPlayerConnectServerAddress(),replypacket);

			result +=1;
			crPlayerDataEventPacket replypacket2;
			ref_ptr<crStreamBuf> stream2 = new crStreamBuf;
			stream2->createBuf(5+myname.length());
			stream2->_writeUChar(result);
			stream2->_writeString(myname);
			crPlayerDataEventPacket::buildReplyPacket(replypacket2,playerid2,WCH_JXJRecvGameSendNoToAddFriend,stream2.get());
			netManager->sendPacket(playerData2->getPlayerConnectServerAddress(),replypacket2);
		}

		if(m_netType == GameClient_Game)
		{
			unsigned char result =m_stream->_readUChar();
			std::string name = m_stream->_readString();
			std::string str = "添加好友失败";
			switch (result)
			{
			case 0:
				str = "你拒绝添加" + name + "为好友！";
				break;
			case 1:
				str = name + "拒绝添加你为好友！";
				break;
			}
			ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if(msgCanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> msg = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_input));
				if(msg.valid())msg->setString(str);
				crFilterRenderManager::getInstance()->showCanvas(msgCanvas.get(),true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIQueryFriendListMethod
//
/////////////////////////////////////////
crJXJUIQueryFriendListMethod::crJXJUIQueryFriendListMethod():
	m_this(NULL)
{
}
crJXJUIQueryFriendListMethod::crJXJUIQueryFriendListMethod(const crJXJUIQueryFriendListMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_mySaleList(handle.m_mySaleList),
	m_pagenum(handle.m_pagenum),
	m_icon1(handle.m_icon1),
	m_icon2(handle.m_icon2),
	m_icon3(handle.m_icon3),
	m_icon4(handle.m_icon4),
	m_icon5(handle.m_icon5),
	m_icon6(handle.m_icon6),
	m_icon7(handle.m_icon7),
	m_fsxxBtn(handle.m_fsxxBtn),
	m_fsyjBtn(handle.m_fsyjBtn),
	m_schyBtn(handle.m_schyBtn)
{
}
void crJXJUIQueryFriendListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIQueryFriendListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mySaleList = str;
		break;
	case 1:
		m_pagenum = str;
		break;
	case 2:
		m_icon1 = str;
		break;
	case 3:
		m_icon2 = str;
		break;
	case 4:
		m_icon3 = str;
		break;
	case 5:
		m_icon4 = str;
		break;
	case 6:
		m_icon5 = str;
		break;
	case 7:
		m_icon6 = str;
		break;
	case 8:
		m_icon7 = str;
		break;
	case 9:
		m_fsxxBtn = str;
		break;
	case 10:
		m_fsyjBtn = str;
		break;
	case 11:
		m_schyBtn = str;
		break;
	case 13:
		m_hmdTitleSwitch = str;
		break;
	case 14:
		m_contentSwitch = str;
		break;
	}
}
void crJXJUIQueryFriendListMethod::operator()(crHandle &handle)
{

	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		//int updatesec = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJUpdateFriendDataSec,viplv).c_str()));
		int listcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFriendListCount,viplv).c_str()));
		//time_t timep;  
		//struct tm *p;  
		//time(&timep);  
		//p=localtime(&timep);
		//int sec = p->tm_hour * 3600 + p->tm_min * 60 + p->tm_sec;
		//if ((sec - m_lastsec)>updatesec)
		//{
		//	//给服务器发包
		//	m_lastsec = sec;
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor)
			{
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUpdateFriendData,NULL);
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		//}

		ref_ptr<crTableWidgetNode> friendList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_mySaleList));
		if (friendList.valid())
		{
			{
				// 初始化为好友界面
				ref_ptr<crCanvasNode>this_canvas = m_this; //crFilterRenderManager::getInstance()->findCanvas(m_mainCanvas);
				if (!this_canvas)
					return;

				crMultiSwitch* hmdTitleSwitch = dynamic_cast<crMultiSwitch *>(this_canvas->getChildNode(m_hmdTitleSwitch));
				crMultiSwitch* contentSwitch = dynamic_cast<crMultiSwitch *>(this_canvas->getChildNode(m_contentSwitch));
				if (!hmdTitleSwitch || !contentSwitch)
					return;

				hmdTitleSwitch->setActiveSwitchSet(0);
				contentSwitch->setActiveSwitchSet(0);
			}
			ref_ptr<crStaticTextWidgetNode> pagenum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
			//ref_ptr<crImageBoxWidgetNode> icon1 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon1));
			//ref_ptr<crImageBoxWidgetNode> icon2 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon2));
			//ref_ptr<crImageBoxWidgetNode> icon3 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon3));
			//ref_ptr<crImageBoxWidgetNode> icon4 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon4));
			//ref_ptr<crImageBoxWidgetNode> icon5 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon5));
			//ref_ptr<crImageBoxWidgetNode> icon6 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon6));
			//ref_ptr<crImageBoxWidgetNode> icon7 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon7));
			ref_ptr<crButtonWidgetNode> fsxxBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_fsxxBtn));
			ref_ptr<crButtonWidgetNode> fsyjBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_fsyjBtn));
			ref_ptr<crButtonWidgetNode> schyBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_schyBtn));
			if(fsxxBtn.valid())fsxxBtn->setEnable(false);
			if(fsyjBtn.valid())fsyjBtn->setEnable(false);
			if(schyBtn.valid())schyBtn->setEnable(false);
			int pagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFriendListCount,viplv).c_str()));
			int myid = myPlayer->getPlayerID();
			int firstpagenum = 1;
			crData *brainData = crBrain::getInstance()->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJFriendList,param);//WCHDATA_JXJFriendListCount
			FriendVec *myfriend = (FriendVec *)param;
			FriendVec::iterator itr;
			//int row = 0;
			//unsigned char iconid[7] = {0};
			if (friendList.valid())
			{
				if(myfriend->size() > 0)
				{
					friendList->selectRow(0);
					if(fsxxBtn.valid())fsxxBtn->setEnable(true);
					if(fsyjBtn.valid())fsyjBtn->setEnable(true);
					if(schyBtn.valid())schyBtn->setEnable(true);
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
			int totalpage = ceil((float)myfriend->size()/(float)pagecount);
			if(totalpage == 0)totalpage = 1;
			brainData->inputParam(WCHDATA_JXJMyCurFriendPageNum,&firstpagenum);
			brainData->inputParam(WCHDATA_JXJMyFriendPageTotal,&totalpage);
			if(pagenum.valid())pagenum->setString(crArgumentParser::appItoa(firstpagenum)+"/"+crArgumentParser::appItoa(totalpage));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFriendListUpdateMethod
//
/////////////////////////////////////////
crJXJUIFriendListUpdateMethod::crJXJUIFriendListUpdateMethod():
	m_this(NULL)
{
}
crJXJUIFriendListUpdateMethod::crJXJUIFriendListUpdateMethod(const crJXJUIFriendListUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_mySaleList(handle.m_mySaleList),
	m_pagenum(handle.m_pagenum),
	m_buttonsw(handle.m_buttonsw)
{
	for (int i = 0;i<7;i++)
	{
		m_icon[i] = handle.m_icon[i];
	}
}
void crJXJUIFriendListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIFriendListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mySaleList = str;
		break;
	case 1:
		m_pagenum = str;
		break;
	case 2:
		m_icon[0] = str;
		break;
	case 3:
		m_icon[1] = str;
		break;
	case 4:
		m_icon[2] = str;
		break;
	case 5:
		m_icon[3] = str;
		break;
	case 6:
		m_icon[4] = str;
		break;
	case 7:
		m_icon[5] = str;
		break;
	case 8:
		m_icon[6] = str;
		break;
	case 9:
		m_buttonsw = str;
		break;
	}
}
void crJXJUIFriendListUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		int myid = myPlayer->getPlayerID();
		int totalpage = 1;
		ref_ptr<crTableWidgetNode> friendList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_mySaleList));
		ref_ptr<crStaticTextWidgetNode> pagenum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
		ref_ptr<crImageBoxWidgetNode> icon[7] = {NULL};
		for (int i = 0; i < 7; i++)
		{
			icon[i]= dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon[i]));
			if (icon[i].valid())
			{
				icon[i]->setVisiable(false);
			}
		}
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int pagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFriendListCount,viplv).c_str()));
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->getParam(WCHDATA_JXJMyCurFriendPageNum,param);
		if(!param)return;
		int curpagenum = *(int * )param;
		data->getParam(WCHDATA_JXJFriendList,param);//WCHDATA_JXJFriendListCount
		if(!param)return;
		FriendVec *myfriend = (FriendVec *)param;
		FriendVec::iterator itr,itr2,itr3;
		int row = - pagecount * (curpagenum - 1);
		int row2 = - pagecount * (curpagenum - 1);
		unsigned char iconid[7] = {0,0,0,0,0,0,0};
		FriendVec myfriendonline;
		FriendVec myfriendoffline;
		crTableIO::StrVec record;
		ref_ptr<crTableIO>playerIconTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
		for (itr = myfriend->begin();itr != myfriend->end();++itr)
		{
			if ((*itr)!=NULL)
			{
				if((*itr)->getOnline())
				{
					myfriendonline.push_back(itr->get());
				}
				else
				{
					myfriendoffline.push_back(itr->get());
				}
			}
		}
		crMultiSwitch* buttonsw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_buttonsw));
		int selectpage = 0;
		if(buttonsw)selectpage = buttonsw->getActiveSwitchSet();
		if (friendList.valid())
		{
			friendList->clearData();
			//////////////////
			//	   好友		//
			//////////////////
			if (selectpage == 0)
			{
				for (itr2 = myfriendonline.begin();itr2 != myfriendonline.end() && row < pagecount;++itr2,row++)
				{
					if (row >= 0)
					{
						iconid[row] = (*itr2)->getIconID();
						friendList->addData(0,row,(*itr2)->getName());
						friendList->addData(1,row,crArgumentParser::appItoa((*itr2)->getLevel())+"级");
						friendList->addData(row,(int)(itr2->get()));
						if(icon[row].valid())
						{
							if (iconid[row] > 0)
							{
								icon[row]->setVisiable(true);
								if(playerIconTable->queryOneRecord(0,crArgumentParser::appItoa(iconid[row]),record) >= 0 )
								{
									icon[row]->setImageName(record[1]);
								}
							}
							else icon[row]->setVisiable(false);
						}
					}
				}
				int iconoffindex = playerIconTable->getTitleIndex("icon灰");
				for (itr3 = myfriendoffline.begin();itr3 != myfriendoffline.end() && row < pagecount;++itr3,row++)
				{
					if (row >= 0)
					{
						iconid[row] = (*itr3)->getIconID();
						friendList->addData(0,row,(*itr3)->getName());
						friendList->addData(1,row,crArgumentParser::appItoa((*itr3)->getLevel())+"级");
						friendList->addData(row,(int)(itr3->get()));
						if(icon[row].valid())
						{
							if (iconid[row] > 0)
							{
								icon[row]->setVisiable(true);
								if(playerIconTable->queryOneRecord(0,crArgumentParser::appItoa(iconid[row]),record) >= 0 )
								{
									icon[row]->setImageName(record[iconoffindex]);
								}
							}
							else icon[row]->setVisiable(false);
						}
					}
				}
				totalpage = ceil((float)myfriend->size()/(float)pagecount);
			}
			//////////////////
			//	  黑名单	//
			//////////////////
			else if (selectpage == 2)
			{
				data->getParam(WCHDATA_JXJBlackNameSet,param);//
				BlackNameSet *blacknameset = (BlackNameSet *)param;
				for (BlackNameSet::iterator bitr = blacknameset->begin();bitr != blacknameset->end() && row < pagecount;++bitr,row++)
				{
					if (row >= 0)
					{
						friendList->addData(0,row,(*bitr));
					}
				}
				totalpage = ceil((float)blacknameset->size()/(float)pagecount);
			}
			friendList->selectRow(0);
		}
		//totalpage = ceil((float)myfriend->size()/(float)pagecount);
		if(totalpage == 0)totalpage = 1;
		brainData->inputParam(WCHDATA_JXJMyFriendPageTotal,&totalpage);
		if(pagenum.valid())pagenum->setString(crArgumentParser::appItoa(curpagenum)+"/"+crArgumentParser::appItoa(totalpage));
	}
}
/////////////////////////////////////////
//
//crJXJGameDeleteFriendMethod
//
/////////////////////////////////////////
crJXJGameDeleteFriendMethod::crJXJGameDeleteFriendMethod():
	m_this(NULL),
	m_index(0)
{
}
crJXJGameDeleteFriendMethod::crJXJGameDeleteFriendMethod(const crJXJGameDeleteFriendMethod& handle):
	crMethod(handle),
	m_friendlist(handle.m_friendlist),
	m_index(handle.m_index),
	m_groupcanvas(handle.m_groupcanvas)
{
}
void crJXJGameDeleteFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJGameDeleteFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_friendlist = str;
		break;
	case 1:
		m_index = atoi(str.c_str());
		break;
	case 2:
		m_groupcanvas = str;
		break;
	}
}
void crJXJGameDeleteFriendMethod::operator()(crHandle &handle)
{	
	void *param;
	int playerid = 0;
	if (m_index == 0)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crTableWidgetNode> friendList = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_friendlist));
		if (friendList.valid())
		{
			crFriend *myfriend = (crFriend *)(friendList->getSelectData());
			if(myfriend)
			{
				playerid = myfriend->getPlayerID();
			}
		}
	}
	else if (m_index == 1)
	{
		ref_ptr<crCanvasNode>groupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_groupcanvas);
		if (groupcanvas.valid())
		{
			crData *canvasdata = groupcanvas->getDataClass();
			canvasdata->getParam(WCHDATA_JXJMyGroupSelPlayData,param);
			crJXJConsortiaMember *memberplayerData = (crJXJConsortiaMember *)param;
			playerid = memberplayerData->getPlayerID();
		}
	}
	if (playerid > 0)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(playerid);
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGameDeleteFriend,stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJUIRecvGameDeleteFriendMethod
//
/////////////////////////////////////////
crJXJUIRecvGameDeleteFriendMethod::crJXJUIRecvGameDeleteFriendMethod():
	m_netType(GameClient_Game)
{
}
crJXJUIRecvGameDeleteFriendMethod::crJXJUIRecvGameDeleteFriendMethod(const crJXJUIRecvGameDeleteFriendMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_text(handle.m_text)
{
}
void crJXJUIRecvGameDeleteFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJUIRecvGameDeleteFriendMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_text = str;
		break;
	}
}
void crJXJUIRecvGameDeleteFriendMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			void *param;
			unsigned char result = 0;
			int playerid = m_stream -> _readUInt();
			int myplayerid = m_this -> getPlayerID();
			crData *data = m_this->getDataClass();
			ref_ptr<crGameServerPlayerData> senderPlayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(myplayerid));
			if (senderPlayerData.valid())
			{
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJFriendList,param);
				FriendVec *myfriend = (FriendVec *)param;
				FriendVec::iterator itr = myfriend->begin();
				for (itr;itr!=myfriend->end();++itr)
				{
					if ((*itr)->getPlayerID() == playerid)
					{
						itr = myfriend->erase(itr);
						result = 1;
						break;
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				crPlayerDataEventPacket replypacket;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeUChar(result);
				stream->_writeInt(playerid);
				crPlayerDataEventPacket::buildReplyPacket(replypacket,myplayerid,WCH_JXJRecvGameDeleteFriend,stream.get());
				netManager->sendPacket(senderPlayerData->getPlayerConnectServerAddress(),replypacket);
				///游戏日志
				std::string logdata = "删除好友（result，playerid）：" + crArgumentParser::appVectoa(crVector2i(result,playerid));
				GameLogData gamelog(Log_DeleteFriend,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(myplayerid,&gamelog));
			}
		}
		if(m_netType == GameClient_Game)
		{
			unsigned char result =m_stream->_readUChar();
			int playerid = m_stream ->_readInt();
			ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if(canvasNode.valid())
			{
				ref_ptr<crStaticTextWidgetNode> inputtext = dynamic_cast<crStaticTextWidgetNode *>(canvasNode->getWidget(m_text));
				std::string str = "好友删除失败";
				if(result)
				{
					str = "好友删除成功";
					void *param;
					crData *data = m_this ->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJFriendList,param);
					FriendVec *myfriend = (FriendVec *)param;
					FriendVec::iterator itr = myfriend->begin();
					for (itr;itr!=myfriend->end();++itr)
					{
						if ((*itr)->getPlayerID() == playerid)
						{
							itr = myfriend->erase(itr);
							break;
						}
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				if(inputtext.valid())inputtext->setString(str);
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJIfClickOtherNameMethod
//
/////////////////////////////////////////
crJXJIfClickOtherNameMethod::crJXJIfClickOtherNameMethod():
m_this(NULL),
m_text(NULL){}
crJXJIfClickOtherNameMethod::crJXJIfClickOtherNameMethod(const crJXJIfClickOtherNameMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_text(NULL),
	m_canvas(handle.m_canvas)
{
}
void crJXJIfClickOtherNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_text = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_text = (CRText::crText *)(LOCREPARAM(param64));
		}
		break;
	}
}

void crJXJIfClickOtherNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	}
}

void crJXJIfClickOtherNameMethod::operator()(crHandle &handle)
{
	if(!m_text)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if(canvas.valid())crFilterRenderManager::getInstance()->showCanvas(canvas.get(),false);
	}
}
/////////////////////////////////////////
//
//crJXJGameAddFriend2Method
//
/////////////////////////////////////////
crJXJGameAddFriend2Method::crJXJGameAddFriend2Method():
	m_this(NULL)
{
}
crJXJGameAddFriend2Method::crJXJGameAddFriend2Method(const crJXJGameAddFriend2Method& handle):
	crMethod(handle)
{
}
void crJXJGameAddFriend2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJGameAddFriend2Method::addParam(int i, const std::string& str)
{
}
void crJXJGameAddFriend2Method::operator()(crHandle &handle)
{	
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if (netConductor)
		{
			void *param;
			crData *brain = crBrain::getInstance()->getDataClass();
			brain->excHandle(MAKECREPARAM(WCH_LockData,1));
			brain->getParam(WCHDATA_JXJAddFriendName,param);
			std::string nickname = *(std::string *)param;
			brain->excHandle(MAKECREPARAM(WCH_LockData,0));
			std::string myname = crMyPlayerData::getInstance()->getCharacterName();
			if(nickname.length()>0&&nickname.length()<15&&myname!=nickname)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4+nickname.length());
				stream->_writeString(nickname);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGameAddFriend,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJFriendOtherOnShowMethod
//
/////////////////////////////////////////
crJXJFriendOtherOnShowMethod::crJXJFriendOtherOnShowMethod()
{
}

crJXJFriendOtherOnShowMethod::crJXJFriendOtherOnShowMethod(const crJXJFriendOtherOnShowMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}

void crJXJFriendOtherOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
			m_linkInfo = (CRUI::crHypertextWidgetNode::LinkInfoPair *)(HICREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}

void crJXJFriendOtherOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	}
}

void crJXJFriendOtherOnShowMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if (canvas.valid())
	{
		if(m_ea && m_linkInfo)
		{
			std::string str = CRIOManager::convertUTF16toUTF8(m_linkInfo->first);
			crData *brain = crBrain::getInstance()->getDataClass();
			brain->excHandle(MAKECREPARAM(WCH_LockData,1));
			brain->inputParam(WCHDATA_JXJAddFriendName,&str);
			brain->excHandle(MAKECREPARAM(WCH_LockData,0));
			const crBoundingBox &bbox = canvas->getBoundBox();
			crVector3f mouse(m_ea->getXnormalized() + (bbox.xLength()*0.5),m_ea->getYnormalized() + (bbox.yLength()*0.5),0.0f);
			//canvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
			canvas->setPosition(mouse);
			//canvas->setCanFocus(false);
			canvas->setCanCaptureMouse(true);
			crFilterRenderManager::getInstance()->doModal(canvas.get());
		}
		else
		{
			if (canvas->getVisiable())
			{
				crFilterRenderManager::getInstance()->showCanvas(canvas.get(),false);
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJChatTimerUpdateMethod
//
/////////////////////////////////////////
crJXJChatTimerUpdateMethod::crJXJChatTimerUpdateMethod():
	m_dt(NULL)
{
}
crJXJChatTimerUpdateMethod::crJXJChatTimerUpdateMethod(const crJXJChatTimerUpdateMethod& handle):
	crMethod(handle),
	m_dt(NULL)
{
}
void crJXJChatTimerUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = (float *)(LOCREPARAM(param64));
		}
		break;
	}
}
void crJXJChatTimerUpdateMethod::addParam(int i, const std::string& str)
{

}
void crJXJChatTimerUpdateMethod::operator()(crHandle &handle)
{
	crData *data = m_this->getDataClass();
	data->excHandle(MAKECREPARAM(WCH_LockData,1));
	void *param;
	data->getParam(WCHDATA_JXJChatTimer1,param);
	float *timer = (float *)param;
	*timer = *timer > 0.0f ? *timer - *m_dt : 0.0f;
	data->getParam(WCHDATA_JXJChatTimer2,param);
	timer = (float *) param;
	*timer = *timer > 0.0f ? *timer - *m_dt : 0.0f;
	data->getParam(WCHDATA_JXJChatTimer3,param);
	timer = (float *) param;
	*timer = *timer > 0.0f ? *timer - *m_dt : 0.0f;
	data->getParam(WCHDATA_JXJChatTimer4,param);
	timer = (float *) param;
	*timer = *timer > 0.0f ? *timer - *m_dt : 0.0f;
	data->getParam(WCHDATA_JXJChatTimer5,param);
	timer = (float *) param;
	*timer = *timer > 0.0f ? *timer - *m_dt : 0.0f;
	data->excHandle(MAKECREPARAM(WCH_LockData,0));
}


/////////////////////////////////////////
//
//crJXJUIKnapsackListOnShowMethod
//
/////////////////////////////////////////
crJXJUIKnapsackListOnShowMethod::crJXJUIKnapsackListOnShowMethod(){}
crJXJUIKnapsackListOnShowMethod::crJXJUIKnapsackListOnShowMethod(const crJXJUIKnapsackListOnShowMethod& handle):
	crMethod(handle),
	m_itemtype(handle.m_itemtype),
	m_curpagenum(handle.m_curpagenum)
{
}
void crJXJUIKnapsackListOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIKnapsackListOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemtype = str;
		break;
	case 1:
		m_curpagenum = str;
		break;
	}
}
void crJXJUIKnapsackListOnShowMethod::operator()(crHandle &handle)
{
	if(!m_this) return;

	ref_ptr<crRadioGroupWidgetNode> itemtype = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_itemtype));
	ref_ptr<crRadioGroupWidgetNode> curpagenum = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_curpagenum));

	if (itemtype.valid())
	{
		itemtype->select(0);
	}

	if (curpagenum.valid())
	{
		curpagenum->select(0);
	}

	if(m_this->getName().compare("UI_Jk") == 0)
	{
		crData *brainData = crBrain::getInstance()->getDataClass();
		if(brainData)
		{
			int curpage = 1;
			brainData->inputParam(WCHDATA_JXJCurJiangkaBagPageNum,&curpage);
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIKnapsackListUpdateMethod
//
/////////////////////////////////////////
crJXJUIKnapsackListUpdateMethod::crJXJUIKnapsackListUpdateMethod(){}
crJXJUIKnapsackListUpdateMethod::crJXJUIKnapsackListUpdateMethod(const crJXJUIKnapsackListUpdateMethod& handle):
	crMethod(handle),
	m_myBagList(handle.m_myBagList),
	m_pagenum(handle.m_pagenum),
	m_itemtype(handle.m_itemtype),
	m_curpagenum(handle.m_curpagenum),
	m_defaulticon(handle.m_defaulticon)
{
}
void crJXJUIKnapsackListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIKnapsackListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_myBagList = str;
		break;
	case 1:
		m_pagenum = str;
		break;
	case 2:
		m_itemtype = str;
		break;
	case 3:
		m_curpagenum = str;
		break;
	case 4:
		m_defaulticon = str;
		break;
	}
}
void crJXJUIKnapsackListUpdateMethod::operator()(crHandle &handle)
{
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(m_this)
	{
		bool ifshow = false;
		int typeitem,curpage;
		ref_ptr<crListControlWidgetNode> backPackList = dynamic_cast<crListControlWidgetNode *>(m_this->getWidget(m_myBagList));
		ref_ptr<crStaticTextWidgetNode> pagenum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
		ref_ptr<crRadioGroupWidgetNode> itemtype = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_itemtype));
		ref_ptr<crRadioGroupWidgetNode> curpagenum = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_curpagenum));
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		if(backPackList.valid() && itemtab.valid())
		{
			void *param;
			crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int totalcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBagNumMax,viplv).c_str()));
			int onepagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBagOnePage,viplv).c_str()));
			if(itemtype.valid())
			{
				typeitem = itemtype->getSelect();
			}
			if (curpagenum.valid())
			{
				curpage = curpagenum->getSelect();
			}
			ref_ptr<crTableIO>itemtab2 = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
			crTableIO::StrVec itemrecord,itemrecord2;
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJItemBagVec,param);
			JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
			data->getParam(WCHDATA_JXJOpenBagNum,param);
			unsigned char openbagnum = *(unsigned char *)param;
			std::string iconfile;
			std::string title,title2;
			//backPackList->clearList();
			backPackList->setListNodeCount(totalcount);
			//const crBoundingBox &bbox = backPackList->getBoundBox();
			//float posy = (bbox.m_max[1]-bbox.m_min[1])*curpage;
			backPackList->setStartYPos(curpage);
			crListControlWidgetNode::ListNodeVec& listNodeVec = backPackList->getListNodeVec();
			int i = 0;
			int count = 0;
			//itembagvec->resize(openbagnum);
			if(!typeitem)
			{
				for( JXJItemBagVec::iterator itr = itembagvec->begin();
					itr != itembagvec->end();
					++itr,++i )
				{
					if(i>=0 && i<openbagnum)
					{
						if((*itr)!=NULL && (*itr)->getItemID()!=0)
						{
							int nameid = itemtab->getTitleIndex("name");
							int iconid = itemtab->getTitleIndex("icon");
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
							{
								int nowcount = (*itr)->getItemCount();
								title = itemrecord[nameid];
								if (nowcount > 1)
								{
									title2 = crArgumentParser::appItoa(nowcount) + std::string(" ");
								}
								else
								{
									title2.clear();
								}
								iconfile = itemrecord[iconid];
								listNodeVec[i]->setFont("simhei.ttf");
								//listNodeVec[i]->setTitle(title);
								listNodeVec[i]->setTitle2(title2);
								listNodeVec[i]->setData(/*curpage*onepagecount+*/i);
								listNodeVec[i]->setImageName(iconfile);
								listNodeVec[i]->setVisiable(true);
								listNodeVec[i]->setEnable(true);
								count++;
							}
						}
						else
						{
							listNodeVec[i]->setTitle("");
							listNodeVec[i]->setTitle2("");
							listNodeVec[i]->setData(i);
							listNodeVec[i]->setImageName(m_defaulticon);
							listNodeVec[i]->setVisiable(true);
							listNodeVec[i]->setEnable(false);
						}
					}
				}
			}
			else
			{
				int newdata = 0;
				for( JXJItemBagVec::iterator itr = itembagvec->begin();
					itr != itembagvec->end();
					++itr,++i,++newdata )
				{
					ifshow = true;
					if(i>=0 && i<openbagnum)
					{
						if((*itr)!=NULL && (*itr)->getItemID()!=0)
						{
							int nameid = itemtab->getTitleIndex("name");
							int iconid = itemtab->getTitleIndex("icon");
							int attrid = itemtab->getTitleIndex("类型");
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
							{
								int nowcount = (*itr)->getItemCount();
								if (typeitem == IT_Material)
								{
									if (atoi(itemrecord[attrid].c_str())!=IT_Material && atoi(itemrecord[attrid].c_str())!=IT_SmeltMaterial)
									{
										ifshow = false;
									}
								}
								else if (typeitem == IT_Other)
								{
									if (atoi(itemrecord[attrid].c_str())!=IT_Other && atoi(itemrecord[attrid].c_str())!=IT_Gemstone)
									{
										ifshow = false;
									}
								}
								else if (atoi(itemrecord[attrid].c_str())!=typeitem)
								{
									ifshow = false;
								}

								if (nowcount == 0)
								{
									ifshow = false;
								}
								if (!ifshow)
								{
									i--;
									continue;
								}
								title = itemrecord[nameid];
								iconfile = itemrecord[iconid];
								//	listNodeVec[i]->setTitle(title);
								listNodeVec[i]->setFont("simhei.ttf");
								if (nowcount > 1)
								{
									title2 = crArgumentParser::appItoa(nowcount) + std::string(" ");;
								}
								else
								{
									title2.clear();
								}
								listNodeVec[i]->setTitle2(title2);
								listNodeVec[i]->setData(/*curpage*onepagecount+*/newdata);
								listNodeVec[i]->setImageName(iconfile);
								listNodeVec[i]->setVisiable(true);
								listNodeVec[i]->setEnable(true);
								count++;
							}
						}
						else
						{
							i--;
						}
					}
				}
				for(i;i<openbagnum;i++)
				{
					listNodeVec[i]->setTitle("");
					listNodeVec[i]->setTitle2("");
					listNodeVec[i]->setData(-1);
					listNodeVec[i]->setImageName(m_defaulticon);
					listNodeVec[i]->setVisiable(true);
					listNodeVec[i]->setEnable(false);
				}
			}
			for(int j = openbagnum; j < totalcount; j++)
			{
				listNodeVec[j]->setData(j);
				listNodeVec[j]->setImageName("");
				//title = "暂未购买";
				listNodeVec[j]->setTitle("");
				//title = "点击购买";
				listNodeVec[j]->setTitle2("");
				listNodeVec[j]->setEnable(true);
				listNodeVec[j]->setVisiable(false);
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
			//if(i<0)i=0;
			if (!typeitem)
			{
				if(pagenum.valid())pagenum->setString(crArgumentParser::appItoa(count)+"/"+crArgumentParser::appItoa(openbagnum));
			}
			else
			{
				if(pagenum.valid())pagenum->setString(crArgumentParser::appItoa(count));
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIArrangeKnapsackListMethod
//
/////////////////////////////////////////
crJXJUIArrangeKnapsackListMethod::crJXJUIArrangeKnapsackListMethod(){}
crJXJUIArrangeKnapsackListMethod::crJXJUIArrangeKnapsackListMethod(const crJXJUIArrangeKnapsackListMethod& handle):
	crMethod(handle),
	m_myBagList(handle.m_myBagList),
	m_pagenum(handle.m_pagenum),
	m_itemtype(handle.m_itemtype),
	m_curpagenum(handle.m_curpagenum)
{
}
void crJXJUIArrangeKnapsackListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIArrangeKnapsackListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemtype = str;
		break;
	}
}
void crJXJUIArrangeKnapsackListMethod::operator()(crHandle &handle)
{//背包整理
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(m_this && net_conductor)
	{
		int typeitem = 1;
		CRNetApp::crPlayerDataEventPacket packet;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crRadioGroupWidgetNode> itemtype = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_itemtype));
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(1);
		if(itemtype.valid())
		{
			typeitem = itemtype->getSelect();
			//if(!typeitem)
			//{
				stream->_writeUChar(ArrangeType_ItemBag);
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvArrangeKnapsackList,stream.get());
				net_conductor->getNetManager()->sendPacket("all",packet);
			//}
		}
		else
		{
			stream->_writeUChar(ArrangeType_CardBag);
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvArrangeKnapsackList,stream.get());
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
		////
		//int typeitem;
		//ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		//ref_ptr<crRadioGroupWidgetNode> itemtype = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_itemtype));
		//if(itemtype)
		//{
		//	typeitem = itemtype->getSelect();
		//}
		//if(!typeitem)
		//{
		//	void *param;
		//	JXJItemBagVec newitembagvec;
		//	BagItemMultiMap bagitemmap;
		//	crTableIO::StrVec itemrecord,itemrecord2;
		//	crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		//	data->excHandle(MAKECREPARAM(WCH_LockData,1));
		//	data->getParam(WCHDATA_JXJItemBagVec,param);
		//	JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
		//	ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		//	for (JXJItemBagVec::iterator itr = itembagvec->begin();
		//		itr != itembagvec->end();
		//		++itr)
		//	{
		//		if((*itr)!= NULL)
		//		{
		//			bagitemmap.insert(std::make_pair((*itr)->getItemID(),(*itr).get()));
		//		}
		//	}

		//	for (BagItemMultiMap::iterator itr2 = bagitemmap.begin();
		//		itr2 != bagitemmap.end();
		//		++itr2 )
		//	{
		//		if(newitembagvec.empty())
		//			newitembagvec.push_back(itr2->second);
		//		else
		//		{
		//			crBagItemData *backitem;
		//			backitem = (newitembagvec.back()).get();
		//			if(backitem->getItemID() == itr2->first)
		//			{
		//				int maxnum = itemtab->getTitleIndex("叠加数量");
		//				itemtab->queryOneRecord(0,crArgumentParser::appItoa(backitem->getItemID()),itemrecord);
		//				int totalcount = backitem->getItemCount() + itr2->second->getItemCount();
		//				if(totalcount>atoi(itemrecord[maxnum].c_str()))
		//				{
		//					backitem->setItemCount(maxnum);
		//					itr2->second->setItemCount(totalcount-maxnum);
		//					newitembagvec.push_back(itr2->second);
		//				}
		//				else
		//				{
		//					backitem->setItemCount(totalcount);
		//					continue;
		//				}
		//			}
		//			else
		//			{
		//				newitembagvec.push_back(itr2->second);
		//			}

		//		}
		//	}
		//	//itembagvec = newitembagvec;
		//	newitembagvec.resize(itembagvec->size());
		//	itembagvec->swap(newitembagvec);
		//	data->excHandle(MAKECREPARAM(WCH_LockData,0));
		//}
	}
}
/////////////////////////////////////////
//
//crJXJRecvArrangeKnapsackListMethod
//
/////////////////////////////////////////
crJXJRecvArrangeKnapsackListMethod::crJXJRecvArrangeKnapsackListMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvArrangeKnapsackListMethod::crJXJRecvArrangeKnapsackListMethod(const crJXJRecvArrangeKnapsackListMethod& handle):
	crMethod(handle),
	m_jkCanvas(handle.m_jkCanvas)
{
	//for (int i = 0;i < 4; i++)
	//{
	//	m_canvas[i] = handle.m_canvas[i];
	//}
}
void crJXJRecvArrangeKnapsackListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvArrangeKnapsackListMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_jkCanvas = str;
		break;
	}
}
void crJXJRecvArrangeKnapsackListMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			if(!itemtab.valid()) return;
			unsigned char arragetype =  m_stream->_readUChar();
			void *param;
			BagItemMultiMap2 bagitemmap;
			BagItemMultiMap2 bagitemmap2;
			crTableIO::StrVec itemrecord,itemrecord2;
			crData *data = m_this->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJItemBagVec,param);
			JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
			data->getParam(WCHDATA_JXJJiangkaBagVec,param);
			JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
			crTableIO::StrVec record;
			int colorindex = itemtab->getTitleIndex("品质");
			int typeindex = itemtab->getTitleIndex("类型");
			unsigned char detype = 0;
			if(arragetype == ArrangeType_ItemBag)
			{
				for (JXJItemBagVec::iterator itr = itembagvec->begin();
					itr != itembagvec->end();
					++itr)
				{
					if((*itr)!= NULL)
					{
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itr->get()->getItemID()),record) >= 0 )
						{
							detype = UCHAR_MAX - (unsigned char)atoi(record[typeindex].c_str());
							bagitemmap.insert(std::make_pair(MAKEINT64((*itr)->getItemID(),MAKEINT32((unsigned char)atoi(record[colorindex].c_str()),detype)),(*itr).get()));
							(*itr) = NULL;
						}
					}
				}

				for (BagItemMultiMap2::iterator itr2 = bagitemmap.begin();
					itr2 != bagitemmap.end();
					++itr2 )
				{
					m_this->doEvent(WCH_JXJPutItemInBag, MAKECREPARAM(itr2->second.get(),1));
				}
			}
			else
			{
				for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
					itr != jiangkabagvec->end();
					++itr)
				{
					if((*itr)!= NULL)
					{
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itr->get()->getItemID()),record) >= 0 )
						{
							bagitemmap2.insert(std::make_pair(MAKEINT64((*itr)->getItemID(),atoi(record[colorindex].c_str())),(*itr).get()));
							(*itr) = NULL;
						}
					}
				}

				for (BagItemMultiMap2::iterator itr2 = bagitemmap2.begin();
					itr2 != bagitemmap2.end();
					++itr2 )
				{
					m_this->doEvent(WCH_JXJPutItemInBag,MAKECREPARAM(itr2->second.get(),1));
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
			////////////////////////////////////////////////
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();

			ref_ptr<crGameServerPlayerData> senderPlayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if (senderPlayerData.valid())
			{
				crPlayerDataEventPacket replypacket;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				unsigned char size = 0;
				if (arragetype == ArrangeType_ItemBag)
				{
					for (JXJItemBagVec::iterator itr = itembagvec->begin(); itr!= itembagvec->end(); ++itr)
					{
						if ((*itr)!=NULL)
						{
							size++;
						}
						else
						{
							break;
						}
					}
					stream->createBuf(2+size*9);
					stream->_writeUChar(arragetype);
					stream->_writeUChar(size);
					for (JXJItemBagVec::iterator itr = itembagvec->begin(); itr!= itembagvec->end(); ++itr)
					{
						if ((*itr)!=NULL)
						{
							stream->_writeInt((*itr)->getItemID());
							stream->_writeInt((*itr)->getEquipMagic());
							stream->_writeUChar((*itr)->getItemCount());
						}
						else
						{
							break;
						}
					}
				}
				else
				{
					for (JXJItemBagVec::iterator itr = jiangkabagvec->begin(); itr!= jiangkabagvec->end(); ++itr)
					{
						if ((*itr)!=NULL)
						{
							size++;
						}
						else
						{
							break;
						}
					}
					stream->createBuf(2+size*5);
					stream->_writeUChar(arragetype);
					stream->_writeUChar(size);
					for (JXJItemBagVec::iterator itr = jiangkabagvec->begin(); itr!= jiangkabagvec->end(); ++itr)
					{
						if ((*itr)!=NULL)
						{
							stream->_writeInt((*itr)->getItemID());
							stream->_writeUChar((*itr)->getItemCount());
						}
						else
						{
							break;
						}
					}
				}
				crPlayerDataEventPacket::buildReplyPacket(replypacket,playerid,WCH_JXJRecvArrangeKnapsackList,stream.get());
				netManager->sendPacket(senderPlayerData->getPlayerConnectServerAddress(),replypacket);
				///游戏日志
				std::string logodata = "整理背包";
				GameLogData gamelog(Log_ArrangeKnapsackList,logodata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			unsigned char arrangetype = m_stream->_readUChar();
			unsigned char size = m_stream->_readUChar();
			JXJItemBagVec newitembagvec;
			ref_ptr<crBagItemData> backitem;
			if (arrangetype == ArrangeType_ItemBag)
			{
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				newitembagvec.resize(itembagvec->size());
				for (int i = 0; i< size;i++)
				{
					backitem = new crBagItemData;
					backitem->setItemID(m_stream->_readInt());
					backitem->setEquipMagic(m_stream->_readInt());
					backitem->setItemCount(m_stream->_readUChar());
					newitembagvec[i] = backitem;
				}
				itembagvec->swap(newitembagvec);
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			else
			{
				//bool ifshow = true;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				newitembagvec.resize(itembagvec->size());
				for (int i = 0; i< size;i++)
				{
					backitem = new crBagItemData;
					backitem->setItemID(m_stream->_readInt());
					backitem->setItemCount(m_stream->_readUChar());
					newitembagvec[i] = backitem;
				}
				itembagvec->swap(newitembagvec);
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_jkCanvas);
				if (canvas.valid() && canvas->getVisiable())
				{
					crFilterRenderManager::getInstance()->showCanvas(m_jkCanvas,true);
				}
				//for (int i = 0; i < 4; i++)
				//{
				//	canvas [i] = crFilterRenderManager::getInstance()->findCanvas(m_canvas[i]);
				//	if (canvas[i].valid() && canvas[i]->getVisiable())
				//	{
				//		crFilterRenderManager::getInstance()->showCanvas(canvas[i].get(),ifshow[i]);
				//	}
				//}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvGMOrderMethod
//
/////////////////////////////////////////
crJXJRecvGMOrderMethod::crJXJRecvGMOrderMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvGMOrderMethod::crJXJRecvGMOrderMethod(const crJXJRecvGMOrderMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input)
{
}
void crJXJRecvGMOrderMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvGMOrderMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_strBattleCanvas = str;
		break;
	case 3:
		m_strServerCycleInfoFile = str;
		break;
	}
}
void crJXJRecvGMOrderMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			int playerid = m_this->getPlayerID();
			short quanxian = crGlobalHandle::gData()->getGMAuthority(playerid);
			if(quanxian<=0 || quanxian>=JXJGMPermission_newer)
				return;
			////if(!crGlobalHandle::gData()->gEnableRobotTest())
			////{
			//	crTableIO::StrVec record;
			//	CRCore::ref_ptr<CREncapsulation::crTableIO> gmTab = crGlobalHandle::gData()->gGMTable();
			//	if(!gmTab.valid())
			//		return;
			//	if(gmTab->queryOneRecord(0,crArgumentParser::appItoa(playerid),record)<0)
			//		return;
			//	int quanxianindex = gmTab->getTitleIndex("权限");
			//	quanxian = atoi(record[quanxianindex].c_str());
			////}

			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(!playerData.valid())
				return;
			//
			std::string chat_text = m_stream->_readString();
			
			std::string logdata = "(" + m_this->getCharacterName() + ")" +  "输入了GM指令：" + chat_text;
			GameLogData gamelog(Log_GMOrder,logdata);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));

			int gmorder = 0;
			std::string keystr;
			if(chat_text.find("/givejxjitem ")==0)
			{
				keystr = "/givejxjitem ";
				gmorder = 1;
			}
			else if(chat_text.find("/pleaseletmestrong")==0)
			{
				keystr = "/pleaseletmestrong";
				gmorder = 2;
			}
			else if(chat_text.find("/pleaseletmyhousestrong")==0)
			{
				keystr = "/pleaseletmyhousestrong";
				gmorder = 3;
			}
			else if(chat_text.find("/pleasegivemejunling")==0)
			{
				keystr = "/pleasegivemejunling";
				gmorder = 4;
			}
			else if(chat_text.find("/robotformation")==0)
			{
				keystr = "/robotformation";
				gmorder = 5;
			}
			else if(chat_text.find("/jxjinsertA ")==0)
			{
				keystr = "/jxjinsertA ";
				gmorder = 6;
			}
			else if(chat_text.find("/jxjcreatejhm")==0)
			{
				keystr = "/jxjcreatejhm";
				gmorder = 7;
			}
			else if(chat_text.find("/gg ")==0)
			{
				keystr = "/gg ";
				gmorder = 8;
			}
			else if(chat_text.find("/opengamelogin")==0)
			{
				keystr = "/opengamelogin";
				gmorder = 9;
			}
			else if(chat_text.find("/jxjmailshow")==0)
			{
				keystr = "/jxjmailshow";
				gmorder = 10;
			}
			else if(chat_text.find("/jxjrechargetest")==0)
			{
				keystr = "/jxjrechargetest ";
				gmorder = 11;
			}
			else if(chat_text.find("/jxjgmtoolshow")==0)
			{
				keystr = "/jxjgmtoolshow";
				gmorder = 13;
			}
			else if(chat_text.find("/jxjgmtool")==0)
			{
				keystr = "/jxjgmtool";
				gmorder = 12;
			}
			else if(chat_text.find("/jxjresetchengchimap")==0)
			{
				keystr = "/jxjresetchengchimap";
				gmorder = 14;
			}
			//else if(chat_text.find("/jxjresetchengchimap")==0)
			//{
			//	keystr = "/jxjresetchengchimap";
			//	gmorder = 14;
			//}
			else if(chat_text.find("/jxjcheckplayerdata")==0)
			{
				keystr = "/jxjcheckplayerdata";
				gmorder = 15;
			}
			else if(chat_text.find("/jxjreloadversion")==0)
			{
				keystr = "/jxjreloadversion";
				gmorder = 16;
			}
			else if(chat_text.find("/jxjpassallfuben")==0)
			{
				keystr = "/jxjpassallfuben";
				gmorder = 17;
			}
			else if(chat_text.find("/jxjresetchengchiid2")==0)
			{
				keystr = "/jxjresetchengchiid2";
				gmorder = 18;
			}
			else if(chat_text.find("/jxjresetchengchiid")==0)
			{
				keystr = "/jxjresetchengchiid";
				gmorder = 19;
			}
			else if(chat_text.find("/jxjgotolv ")==0)
			{
				keystr = "/jxjgotolv ";
				gmorder = 20;
			}
			else if (chat_text.find("/jxjaddGroupExp") == 0)
			{
				keystr = "/jxjaddGroupExp";
				gmorder = 22;
			}
			else if (chat_text.find("/jxjgroupaddactive") == 0)
			{
				keystr = "/jxjgroupaddactive ";
				gmorder = 23;
			}
			else if (chat_text.find("/jxjgroupDayZero") == 0)
			{
				keystr = "/jxjgroupDayZero ";
				gmorder = 24;
			}
			else if (chat_text.find("/jxjgroupWeekZero") == 0)
			{
				keystr = "/jxjgroupWeekZero ";
				gmorder = 25;
			}
			else if ( chat_text.find("/jxjcountryvote") == 0)
			{
				keystr = "/jxjcountryvote ";
				gmorder = 26;
			}
			else if ( chat_text.find("/jxjcountryweekzero") == 0)
			{
				keystr = "/jxjcountryweekzero ";
				gmorder = 27;
			}
						
			//else if(chat_text.find("/jxjzerobenefittimes")==0)
			//{
			//	keystr = "/jxjzerobenefittimes ";
			//	gmorder = 28;
			//}
			//else if(chat_text.find("/jxjzerobenefitstart")==0)
			//{
			//	keystr = "/jxjzerobenefitstart ";
			//	gmorder = 29;
			//}
			else if(chat_text.find("/jxjresetchangeshilitimes")==0)
			{//叛国
				keystr = "/jxjresetchangeshilitimes ";
				gmorder = 30;
			}
			else if(chat_text.find("/reloadhuodongtab") == 0)
			{
				gmorder = 34;
			}
			else if (chat_text.find("/robotlv") == 0)//机器人自动升级
			{
				keystr = "/robotlv";
				gmorder = 35;
			}
			else if (chat_text.find("/robotgiftgold") == 0)//机器人礼金
			{
				keystr = "/robotgiftgold";
				gmorder = 36;
			}
			else if(chat_text.find("/changedatatest") == 0)
			{
				keystr = "/changedatatest ";
				gmorder = 40;
			}
			else if(chat_text.find("/changepassword") == 0)
			{
				keystr = "/changepassword ";
				gmorder = 41;
			}
			else if (chat_text.find("/resetlingqufenglu") == 0)
			{
				gmorder = 50;
			}
			else if (chat_text.find("/startservercycle") == 0)
			{
				gmorder = 51;
			}
			else if (chat_text.find("/stopservercycle") == 0)
			{
				gmorder = 52;
			}
			else if (chat_text.find("/reloadnochat") == 0)
			{
				gmorder = 53;
			}
			else if (chat_text.find("/reloadgm") == 0)
			{
				gmorder = 54;
			}
			else if (chat_text.find("/resetwincity") == 0)
			{
				keystr = "/resetwincity";
				gmorder = 55;
			}
			else if(chat_text.find("/jxjgameserverthrow")==0)
			{
				//ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
				//crThrowServerPacket packet;
				//callback->sendPacketToSceneServer("all",packet);
				//crThread::sleep(10);
				//_asm   int   3   //只是为了让程序崩溃
				__debugbreak();
			}
			else if(chat_text.find("/jxjshutdownservers")==0)
			{
				ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
				callback->shutDown();
			}
			else if(chat_text.find("/jxjdbserverthrow")==0)
			{
				crNetConductor *dbserver = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
				if(dbserver)
				{
					crThrowServerPacket packet;
					dbserver->getNetManager()->sendPacket("all",packet);
				}
			}
			else if(chat_text.find("/jxjsceneserverthrow")==0)
			{
				keystr = "/jxjsceneserverthrow ";
				int keysize = keystr.size();
				chat_text.erase(0,keysize);
				if(!chat_text.empty())
				{
					ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					crThrowServerPacket packet;
					callback->sendPacketToSceneServer(chat_text,packet);
				}
			}
			else if (chat_text.find("/reloadgameglobaltable") == 0)
			{
				gmorder = 56;
			}
			else if (chat_text.find("/resetshili") == 0)
			{
				keystr = "/resetshili ";
				gmorder = 60;
			}
			else if (chat_text.find("/reloadrobottab") == 0)
			{
				keystr = "/reloadrobottab ";
				gmorder = 61;
			}
			else if (chat_text.find("/setmaxplayercount") == 0)
			{
				keystr = "/setmaxplayercount ";
				gmorder = 62;
			}
			else if (chat_text.find("/setstartdate") == 0)
			{
				keystr = "/setstartdate ";
				gmorder = 63;
			}
			else if (chat_text.find("/jxjsetcountrypost") == 0)
			{
				keystr = "/jxjsetcountrypost ";
				gmorder = 64;
			}
			else if (chat_text.find("/jxjaddtaofadian") == 0)
			{
				keystr = "/jxjaddtaofadian ";
				gmorder = 66;
			}
			else if (chat_text.find("/jxjgainhouxuanren") == 0)
			{
				keystr = "/jxjgainhouxuanren ";
				gmorder = 67;
			}
			else if (chat_text.find("/jxjcleartreasoncooltime") == 0)
			{
				keystr = "/jxjcleartreasoncooltime ";
				gmorder = 68;
			}
			else if (chat_text.find("/jxjclearcancelcantoncooltime") == 0)
			{
				keystr = "/jxjclearcancelcantoncooltime ";
				gmorder = 69;
			}
			else if (chat_text.find("/jxjaddgroupcontribute") == 0)
			{
				keystr = "/jxjaddgroupcontribute";
				gmorder = 70;
			}
			else if (chat_text.find("/jxjgainzhanquan") == 0)
			{
				keystr = "/jxjgainzhanquan ";
				gmorder = 71;
			}
			else if (chat_text.find("/jxjdismissgroup") == 0)
			{
				keystr = "/jxjdismissgroup ";
				gmorder = 72;
			}
			else if (chat_text.find("/jxjresetjuntuanfubenaward") == 0)
			{
				gmorder = 73;
			}
			else if(chat_text.find("/reloadonlinerewardtab") == 0)
			{
				gmorder = 74;
			}
			else if(chat_text.find("/reloadHuoyueduRewardtab") == 0)
			{
				gmorder = 75;
			}
			else if(chat_text.find("/reloaditemtab") == 0)
			{
				gmorder = 76;
			}
			else if(chat_text.find("/reloadjxjtasktitletab") == 0)
			{
				gmorder = 77;
			}
			else if (chat_text.find("/reloadlandreward") == 0)
			{
				gmorder = 78;
			}
			else if (chat_text.find("/reloadtable") == 0)
			{
				keystr = "/reloadtable ";
				gmorder = 79;
			}
			else if (chat_text.find("/jxjresetconsortiapromotion") == 0)
			{
				keystr = "/jxjresetconsortiapromotion ";
				gmorder = 80;
			}
			else if(chat_text.find("/jxjresetjuntuanhuodongaward") == 0)
			{
				keystr = "/jxjresetjuntuanhuodongaward";
				gmorder = 81;
			}
			else if (chat_text.find("/jxjgainachievepoint") == 0)
			{
				keystr = "/jxjgainachievepoint ";
				gmorder = 82;
			}
			else if (chat_text.find("/jxjsetcountrypower") == 0)
			{
				keystr = "/jxjsetcountrypower ";
				gmorder = 84;
			}
			else if (chat_text.find("/jxjsetcountrystrength") == 0)
			{
				keystr = "/jxjsetcountrystrength ";
				gmorder = 85;
			}
			else if (chat_text.find("/jxjactivesuperequip") == 0)
			{
				keystr = "/jxjactivesuperequip";
				gmorder = 86;
			}
			else if (chat_text.find("/jxjclearsuperequip") == 0)
			{
				keystr = "/jxjclearsuperequip";
				gmorder = 87;
			}
			//std::string keystr = "/givejxjitem ";
			//int firstshow = chat_text.find(keystr);
			//std::string keystr2 = "/pleaseletmestrong";
			//int firstshow2 = chat_text.find(keystr2);
			//std::string keystr3 = "/pleaseletmyhousestrong";
			//int firstshow3 = chat_text.find(keystr3);
			//std::string keystr4 = "/pleasegivemejunling";
			//int firstshow4 = chat_text.find(keystr4);
			//std::string keystr5 = "/hahahahahehehehe";
			//int firstshow5 = chat_text.find(keystr5);
			//std::string keystr6 = "/jxjinsertA ";
			//int firstshow6 = chat_text.find(keystr6);
			//std::string keystr7 = "/jxjcreatejhm";
			//int firstshow7 = chat_text.find(keystr7);
			//std::string keystr8 = "/gg ";
			//int firstshow8 = chat_text.find(keystr8);
			//std::string keystr9 = "/openserver ";
			//int firstshow8 = chat_text.find(keystr9);

			crData *data = m_this->getDataClass();
			CRCore::ScopedLock<crData> lock(*data);
			//data->excHandle(MAKECREPARAM(WCH_LockData,1));
			switch (gmorder)
			{
			case 1:
				{
					int itemid = 0;
					int count = 1;
					unsigned char itemresult = 0;
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					const char spacestr = ' ';
					int spaceint = chat_text.find(spacestr);
					ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					if(spaceint!=std::string::npos && itemtab.valid())
					{
						int maxnum = itemtab->getTitleIndex("叠加数量");
						int typeindex = itemtab->getTitleIndex("类型");
						crTableIO::StrVec itemrecord;
						std::string itemidstr = chat_text;
						itemidstr.erase(spaceint,itemidstr.size());
						itemid = atoi(itemidstr.c_str());
						std::string countstr = chat_text;
						countstr.erase(0,spaceint);
						count = atoi(countstr.c_str());
						if (maxnum > 0 && typeindex > 0 && itemid > 0 && itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),itemrecord) >= 0 )
						{
							if (atoi(itemrecord[typeindex].c_str()) != IT_Jiangka)
							{
								data->getParam(WCHDATA_JXJItemBagVec,param);
								JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
								JXJItemBagVec::iterator itr;
								for (itr = itembagvec->begin();itr!=itembagvec->end();++itr)
								{
									if ((*itr)==NULL)
									{
										if(count > atoi(itemrecord[maxnum].c_str()))
										{
											count = atoi(itemrecord[maxnum].c_str());
										}
										ref_ptr<crBagItemData> itemdata = new crBagItemData;
										itemdata->setItemID(itemid);
										itemdata->setItemCount(count);
										(*itr) = itemdata;
										itemresult = 1;
										break;
									}
								}
							}
							else
							{
								count = 1;
								data->getParam(WCHDATA_JXJJiangkaBagVec,param);
								JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
								JXJItemBagVec::iterator itr;
								for (itr = itembagvec->begin();itr!=itembagvec->end();++itr)
								{
									if ((*itr)==NULL)
									{
										ref_ptr<crBagItemData> itemdata = new crBagItemData;
										itemdata->setItemID(itemid);
										itemdata->setItemCount(count);
										(*itr) = itemdata;
										itemresult = 1;
                                        m_this->doEvent(WCH_JXJCheck7Day);
										break;
									}
								}
							}
						}
					}
					if (playerData.valid() && itemid > 0)
					{
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf = new crStreamBuf;
						streamBuf->createBuf(7);
						packet2.setStreamBuf(streamBuf.get());
						streamBuf->_writeUChar(0);
						streamBuf->_writeInt(itemid);
						streamBuf->_writeUChar(count);
						streamBuf->_writeUChar(itemresult);
						crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
					}
				}
				break;
			case 2:
				{
					crRole *mainRole = m_this->getMainRole();
					if (mainRole)
					{
						int experience = 23000;
						mainRole->doEvent(WCH_JXJRecvExperience, MAKECREPARAM(experience,NULL));
						int exploit = 50000;
						mainRole->doEvent(WCH_JXJRecvExploit, MAKECREPARAM(exploit,NULL));
						int achievement = 50000;
						mainRole->doEvent(WCH_JXJRecvAchievement, MAKECREPARAM(achievement,NULL));
					}
				}
				break;
			case 3:
				{
					for (int i = 20024; i <= 20029; i++)
					{
						data->getParam(i,param);
						unsigned char *buildinglv = (unsigned char *)param;
						*buildinglv = 80;
					}
					for (int i = 20106; i <= 20133; i++)
					{
						data->getParam(i,param);
						unsigned char *buildinglv = (unsigned char *)param;
						*buildinglv = 80;
					}
					int resourse = 99999999;

					for (int i = 20010; i <= 20016; i++)
					{
						if (i != 20011)
						{
							data->getParam(i,param);
							int *curresourse = (int *)param;
							*curresourse = resourse;
						}
					}
					//兵种科技升满
					data->getParam(WCHDATA_JXJTroopsTechMap,param);
					TroopsTechMap *troopstechmap = (TroopsTechMap *)param;
					troopstechmap->clear();
					ref_ptr<crTableIO>troopstechTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTechTab);
					ref_ptr<crTableIO>troopstechlvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTechLvTab);
					crTableIO::DataVec troopstechlvrecords;
					unsigned short troopstechid = 0;
					unsigned char troopstechlv = 0;
					for (int i = 0; i < troopstechTab->getRowCount();++i)
					{
						troopstechid = atoi((*troopstechTab)(i,0).c_str());
						troopstechlvTab->queryRecords(0,(*troopstechTab)(i,0),troopstechlvrecords);
						troopstechlv = troopstechlvrecords.size() - 1;
						troopstechmap->insert(std::make_pair(troopstechid,troopstechlv));
					}
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					packet2.setStreamBuf(streamBuf2.get());
					streamBuf2->_writeUChar(1);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 4:
				{
					data -> getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					unsigned short maxcount = (unsigned short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str()) * 100);
					data->inputParam(WCHDATA_JXJJunling,&maxcount);

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					packet2.setStreamBuf(streamBuf2.get());
					streamBuf2->_writeUChar(2);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 5:
				{//机器人指令
					//crRole *mainRole = m_this->getMainRole();
					//if (mainRole)
					//{
					//	int experience = 23000;
					//	mainRole->doEvent(WCH_JXJRecvExperience,MAKECREPARAM(experience,NULL));
					//	int exploit = 50000;
					//	mainRole->doEvent(WCH_JXJRecvExploit,MAKECREPARAM(exploit,NULL));
					//	int achievement = 50000;
					//	mainRole->doEvent(WCH_JXJRecvAchievement,MAKECREPARAM(achievement,NULL));
					//}
					crVector2i armycountvec,jkvec[3];
					crTableIO::StrVec troopsrecord;
					//crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRobotFormationCountVec, 0).c_str(),armycountvec);
					//data->getParam(WCHDATA_JXJShiliID,param);
					//unsigned char shili = *(unsigned char *)param;
					data->getParam(WCHDATA_JXJFormationInfoVec,param);
					FormationInfoVec *troop_infors = (FormationInfoVec *)param;
					troop_infors->resize(3);
					ref_ptr<crTableIO>RobotTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJRobotTab);
					int troopsid = RobotTab->getTitleIndex("troopsid");
					int countvecindex = RobotTab->getTitleIndex("数量");
					int jkindex = RobotTab->getTitleIndex("将卡");
					//jkindex += shili - c_startShiliID;
					ref_ptr<crTableIO>TroopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
					crTableIO::DataVec records;
					RobotTab->queryRecords(0, crArgumentParser::appItoa(playerid), records);
					int count = records.size();
					if (count > 0)
					{
						CRCore::rangei r(0, count);
						int randomrow = 0;
						int armid[3] = { 0 };
						randomrow = r.get_random();
						for (int i = 0; i < 3; ++i)
						{
							/*						randomrow = r.get_random();*/
							if (randomrow < count - 1)
							{
								randomrow += 1;
							}
							else if (randomrow - 2 >= 0)
							{
								randomrow -= 2;
							}
							armid[i] = atoi(records[randomrow][troopsid].c_str());
							crArgumentParser::appAtoVec(records[randomrow][countvecindex].c_str(), armycountvec);
							crArgumentParser::appAtoVec(records[randomrow][jkindex], jkvec[i]);
							if (TroopsTab->queryOneRecord(0, records[randomrow][troopsid], troopsrecord) < 0)
							{
								armid[i] = atoi((*TroopsTab)(0, 0).c_str());
							}
						}
						unsigned short armcount = CRCore::rangei(armycountvec[0], armycountvec[1]).get_random();
						//crVector2i equips = crVector2i(10180,10000);
						for (int i = 0; i < 3; i++)
						{
							ref_ptr	<crFormationInfo > fomation = new crFormationInfo;
							fomation->setAbstractID(armid[i]);
							fomation->setCount(armcount);
							fomation->setEquips(jkvec[i]);
							(*troop_infors)[i] = fomation;
						}
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(33);
						streamBuf2->_writeUChar(3);
						for (int i = 0; i < 3; ++i)
						{
							streamBuf2->_writeInt(armid[i]);
						}
						streamBuf2->_writeUShort(armcount);
						for (int i = 0; i < 3; ++i)
						{
							streamBuf2->_writeVec2i(jkvec[i]);
						}
						crPlayerDataEventPacket::buildReplyPacket(packet2, playerid, WCH_JXJRecvGMOrder, streamBuf2.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet2);
					}
				}
				break;
			case 6:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					const char spacestr = ' ';
					int spaceint = chat_text.find(spacestr);
					if(spaceint!=std::string::npos)
					{
						std::string accountnew;
						std::string account = chat_text.substr(0,spaceint);
						chat_text.erase(0,spaceint+1);
						spaceint = chat_text.find(spacestr);
						if(spaceint!=std::string::npos)
						{
							std::string password = chat_text.substr(0,spaceint);
							chat_text.erase(0,spaceint+1);
							int accountcount = atoi(chat_text.c_str());
							/////注册帐号
							ref_ptr<crInsertAccount> insertAccount = new crInsertAccount;
							std::string email,nickname,relname;
							char sex = 0;
							crDataBase *db = crDataBaseManager::getInstance()->getAccountDB();//getGlobalDB();
							ref_ptr<crDataBase> globalSession = db->beginSession();
							for (int i = 1; i<=accountcount;i++)
							{
								accountnew = account + crArgumentParser::appItoa(i);
								insertAccount->buildUpdateSql(accountnew,password,0,email,nickname,relname,sex);
								if(globalSession->executeUpdate(insertAccount.get()))
								{//插入成功
									globalSession->commit();
									//sucess = true;
								}
							}
							db->endSession(globalSession.get());
						}
					}
				}
				break;
			case 7:
				{//生成激活码
					std::string validdate;
					crArgumentParser::readKeyValue(chat_text,keystr.c_str(),validdate);
					std::string code;
					std::set<std::string>CodeSet;
					crDataBase *globaldb = crDataBaseManager::getInstance()->getGlobalDB();
					ref_ptr<crDataBase> dbSession = globaldb->beginSession();
					ref_ptr<crJXJInsertActiveCode> insertActiveCode = new crJXJInsertActiveCode;
					for (int i = 0; i<100;)
					{
						code = CRNet::gainCode(10);
						if(CodeSet.find(code) == CodeSet.end())
						{
							insertActiveCode->buildUpdateSql(code,validdate);
							if(dbSession->executeUpdate(insertActiveCode.get()))
							{
								dbSession->commit();
								CodeSet.insert(code);
								i++;
							}
						}
					}
					globaldb->endSession(dbSession.get());
					/////
					crPlayerDataEventPacket packet3;
					ref_ptr<crStreamBuf> streamBuf3 = new crStreamBuf;
					streamBuf3->createBuf((14+validdate.length()+4) * CodeSet.size() + 2);
					streamBuf3->_writeUChar(4);
					streamBuf3->_writeUChar(CodeSet.size());
					for (std::set<std::string>::iterator itr = CodeSet.begin();
						itr != CodeSet.end();
						++itr)
					{
						streamBuf3->_writeString(*itr);
						streamBuf3->_writeString(validdate);
					}
					crPlayerDataEventPacket::buildReplyPacket(packet3,playerid,WCH_JXJRecvGMOrder,streamBuf3.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet3);
					/////
				}
				break;
			case 8:
				{
					crServerBrainHandle * gameServerBrain = crServerBrainHandle::getInstance();
					crData *gsbraindata = gameServerBrain->getDataClass();
					//rcfg::ConfigScript cfg_script;
					//crGlobalHandle::getInstance()->getStreamScript(m_stream.get(),cfg_script);
					//cfg_script.Write("232425.cfg");
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(m_stream->getRemainSize());
					stream->write(m_stream->getPtr(),m_stream->getRemainSize());
					crPlayerDataEventPacket packetpk;
					crPlayerDataEventPacket::buildReplyPacket(packetpk,0,WCH_JXJRecvClientNotice,stream.get());
					stream->seekBegin();
					gsbraindata->inputParam(WCHDATA_JXJCenterNotice,stream.get());
					crStreamBuf *pkgstream = packetpk.getStreamBuf();
					int size = pkgstream->getBufSize();
					ref_ptr<crGameServerPlayerData> recvPlayerData;
					crNetDataManager *netDataManager = gameServer->getNetDataManager();
					crNetManager *netManager = gameServer->getNetManager();
					if(netDataManager && netManager)
					{
						netDataManager->lockPlayerDataMap();
						crNetDataManager::PlayerDataMap &playerDataMap = netDataManager->getPlayerDataMap();
						for( crNetDataManager::PlayerDataMap::iterator itr = playerDataMap.begin();
							itr != playerDataMap.end();
							++itr )
						{
							//if(itr->first == playerid) continue;
							recvPlayerData = dynamic_cast<crGameServerPlayerData *>(itr->second.get());
							if (recvPlayerData.valid())
							{
								pkgstream->seekBegin();
								pkgstream->_writeInt(recvPlayerData->getPlayerID());
								pkgstream->setBufSize(size);
								gameServer->getNetManager()->sendPacket(recvPlayerData->getPlayerConnectServerAddress(),packetpk);
							}
						}
						netDataManager->unLockPlayerDataMap();
					}
				}
				break;
			case 9:
				{
					int int1 = 0;
					crArgumentParser::readKeyValue(chat_text,keystr.c_str(),int1);
					crGlobalHandle::gSetOpenGameLogin(int1);
					if(int1 == 0)
					{
						crServerBrainHandle * gameServerBrain = crServerBrainHandle::getInstance();
						gameServerBrain->doEvent(WCH_JXJRankingSave);
					}
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 10:
				{
					if (quanxian == JXJGMPermission_manager)
					{
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(1);
						streamBuf2->_writeUChar(5);
						crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
					}
				}
				break;
			case 11:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					crVector2i vec2;
					crArgumentParser::appAtoVec(chat_text,vec2);
					int _playerid = vec2[0]==0?playerid:vec2[0];
					int getmoney = vec2[1];//atoi(chat_text.c_str());
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					ref_ptr<crJXJInsertRechargerecord> insertRecharge = new crJXJInsertRechargerecord;
					insertRecharge->buildUpdateSql(_playerid,callback->getServerID(),getmoney,"GM充值测试");
					crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
					crDBSavePacket packet;
					crDBSavePacket::buildRequestPacket(packet,insertRecharge.get());
					dbConductor->getNetManager()->sendPacket("all",packet);

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 12:
				if (quanxian == JXJGMPermission_manager)
				{
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(7);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 13:
				if (quanxian == JXJGMPermission_manager)
				{
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(8);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 14:
				if (quanxian == JXJGMPermission_manager)
				{//重置chengchimap
					ref_ptr<crTableIO>chengchiTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
					crTableIO::StrVec chengchirecord;
					int deshiliindex = chengchiTable->getTitleIndex("默认势力");
					int dechengfangindex = chengchiTable->getTitleIndex("城防值");
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					gsBrainData->getParam(WCHDATA_JXJChengChiMap,param);
					ChengchiMap *chengchimap = (ChengchiMap *)param;

					unsigned short chengchiid = 0;
					unsigned char shiliid = 0;
					unsigned short chengfang = 0;
					if (deshiliindex > 0 && dechengfangindex > 0)
					{
						for (ChengchiMap::iterator itr = chengchimap->begin();
							itr != chengchimap->end();
							++itr)
						{
							chengchiid = itr->first;
							if (chengchiTable->queryOneRecord(0,crArgumentParser::appItoa(chengchiid),chengchirecord) >= 0 )
							{
								shiliid = atoi(chengchirecord[deshiliindex].c_str());
								chengfang = atoi(chengchirecord[dechengfangindex].c_str());
								//itr->second.first = shiliid;
								//itr->second.second = chengfang;
								itr->second->reset(shiliid,chengfang);
								gsBrainData->inputParam(WCHDATA_JXJChengchiModifySet,&chengchiid);
							}
						}
						for (ChengchiMap::iterator itr = chengchimap->begin();
							itr != chengchimap->end();
							++itr)
						{
							//if (itr->second.first >= c_startShiliID )
							{
								//刷新国家所属州
								crServerBrainHandle::getInstance()->doEvent(WCH_JXJCountryCantonMapRefresh,MAKECREPARAM(itr->first,itr->second->getChengzhuShili()));
							}
						}
					}
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
					/////////////////////////////////////////////////
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(9);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 15:
				{
					m_this->doEvent(WCH_JXJRecvCheckPlayerData);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(10);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 16:
				{//重新读取版本信息，适用于客户端发补丁包，服务器不更新的情况
					int ver = 0;
					if( CRIOManager::fileExists( "jxjversion.ini" ))
					{
						std::ifstream fin("jxjversion.ini", std::ios_base::in|std::ios::binary);
						fin.seekg(0, std::ios::end); 
						int count  =  fin.tellg();
						fin.seekg(0, std::ios::beg);
						char *buf = new char[count+1];
						memset(buf,0,count+1);
						fin.read(buf,count);
						crArgumentParser::readKeyValue(buf,"version",ver);
						fin.close();
						delete [] buf;
					}
					crGlobalHandle::setVersion(ver);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
					CRCore::notify(CRCore::ALWAYS)<<"ReloadVersion Version:"<<crGlobalHandle::getVersion()<<std::endl;
					//sprintf(gDebugInfo->buf(),"ReloadVersion Version:%d\n\0",crGlobalHandle::getVersion());
					//gDebugInfo->debugInfo(CRCore::ALWAYS);
				}
				break;
			case 17:
				if (quanxian == JXJGMPermission_manager)
				{
					ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
					data->getParam(WCHDATA_JXJFubenProgressMap,param);
					FubenProgressMap *fubenprogressmap = (FubenProgressMap *)param;
					ref_ptr<crFubenInfo> fubeninfo = NULL;
					for (int i = 0; i < fubentab->getRowCount(); ++i)
					{
						fubeninfo = new crFubenInfo;
						fubeninfo->setComplete(1);
						fubenprogressmap->insert(std::make_pair(atoi((*fubentab)(i,0).c_str()),fubeninfo));
					}
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(11);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 18:
			case 19:
				if (quanxian == JXJGMPermission_manager || quanxian == JXJGMPermission_Robot)
				{
					crTableIO::StrVec shilirecord;
					ref_ptr<crTableIO>shilitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
					int shilititleindex = 0;
					if (gmorder == 18)
					{
						shilititleindex = shilitab->getTitleIndex("陪都");
					}
					else if (gmorder == 19)
					{
						shilititleindex = shilitab->getTitleIndex("国都");
					}
					
					data->getParam(WCHDATA_JXJShiliID,param);
					unsigned char myshili = *(unsigned char *)param;
					//data->getParam(WCHDATA_JXJChengchiID,param);
					//unsigned short *chengchiid = (unsigned short *)param;
					if (shilitab->queryOneRecord(0,crArgumentParser::appItoa(myshili),shilirecord) >= 0 && shilititleindex)
					{
						unsigned short nowchengchiid = atoi(shilirecord[shilititleindex].c_str());

						data->inputParam(WCHDATA_JXJChengchiID,&nowchengchiid);
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(3);
						streamBuf2->_writeUChar(12);
						streamBuf2->_writeUShort(nowchengchiid);
						crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
					}
				}
				break;
			case 20:
			case 35:
				if (quanxian == JXJGMPermission_manager || quanxian == JXJGMPermission_Robot)
				{
					crRole *mainRole = m_this->getMainRole();
					if (mainRole)
					{
						crData *mainroledata = mainRole->getDataClass();
						mainroledata->getParam(WCHDATA_Level, param);
						unsigned char mylv = *(unsigned char *)param;
						int keysize = keystr.size();
						chat_text.erase(0,keysize);
						unsigned char lv = atoi(chat_text.c_str());
						if (gmorder == 35)
						{
							crVector2i robotlvvec;
							crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRobotRandomlvVec, 0).c_str(), robotlvvec);
							lv = (unsigned char)CRCore::rangei(robotlvvec[0], robotlvvec[1]).get_random();
						}
						if (mylv != lv)
						{
							ref_ptr<crTableIO>lordlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordlvTab);
							int lvindex = lordlvtab->getTitleIndex("lv");
							int expindex = lordlvtab->getTitleIndex("经验");
							crTableIO::StrVec record;
							if (lordlvtab->queryOneRecord(lvindex, crArgumentParser::appItoa(lv), record) >= 0)
							{
								int nowexp = atoi(record[expindex].c_str());
								mainroledata->inputParam(WCHDATA_Experience, &nowexp);
								mainroledata->inputParam(WCHDATA_Level, &lv);
								//mainRole->doEvent(WCH_JXJRecvExperience,MAKECREPARAM(experience,NULL));
								crPlayerDataEventPacket packet2;
								ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
								streamBuf2->createBuf(6);
								streamBuf2->_writeUChar(13);
								streamBuf2->_writeUChar(lv);
								streamBuf2->_writeInt(nowexp);
								crPlayerDataEventPacket::buildReplyPacket(packet2, playerid, WCH_JXJRecvGMOrder, streamBuf2.get());
								gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet2);
							}
						}
					}
				}
				break;
			case 22:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					int addexp = atoi(chat_text.c_str());

					data-> getParam(WCHDATA_JXJConsortiaID,param);
					int mygroupid = *( int *)param;

					int testExp = addexp;
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJGroupFundsUpgrade,MAKECREPARAM(&testExp,mygroupid));

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 23:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					int addVal = atoi(chat_text.c_str());

					data-> getParam(WCHDATA_JXJConsortiaID,param);
					int mygroupid = *( int *)param;
					crData * gsBrainData = crServerBrainHandle::getInstance()->getDataClass();

					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					ref_ptr<crData>condata;
					gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
					ConsortiaMap *consortiamap = (ConsortiaMap *)param;
					ConsortiaMap::iterator mapitr = consortiamap->find(mygroupid);
					if (mapitr != consortiamap->end() && mapitr->second.valid())
					{
						condata = mapitr->second->getDataClass();
					}
					if(condata.valid())
					{
						condata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
						ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
						ConsortiaMemberMap::iterator cmmItr = membermap->find(playerid);
						if (cmmItr != membermap->end() && cmmItr->second.valid())
						{
							cmmItr->second->setActiveValue(cmmItr->second->getActiveVaule() + addVal);
							cmmItr->second->setTodayWeekActive(cmmItr->second->getTodayWeekActive() + addVal);
						}
					}
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 24:
				{
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJServerDayZero);

					// 国家福利投资重置
					unsigned char feteTimes = 0;
					data->inputParam(WCHDATA_JXJCountryBenefitFeteTimes	,&feteTimes);
					unsigned char enrichTimes = 0;
					data->inputParam(WCHDATA_JXJCountryBenefitEnrichTimes	,&enrichTimes);
					unsigned char enrichType = 0;
					data->inputParam(WCHDATA_JXJCountryBenefitEnrichType,&enrichType);

					// 军团捐献重置
					unsigned char val = 0;
					data->inputParam(WCHDATA_JXJGroupContributeiType	,&val);
					data->inputParam(WCHDATA_JXJGroupContributeiTimes,&val);

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 25:
				{
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJGameServerGroupWeekZero);
					data-> getParam(WCHDATA_JXJHadWonGroupFuBenSet,param);
					HadWonGroupFuBenSet * hadWonGroupFuBenSet = (HadWonGroupFuBenSet *)param;
					hadWonGroupFuBenSet->clear();

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 26:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					CRCore::ref_ptr<crJXJCountryVoteGMData> voteData = new crJXJCountryVoteGMData;
					voteData->m_this = m_this;
					int i = chat_text.find(' ');
					if(i != std::string::npos)
					{
						voteData->m_name = chat_text.substr(0,i);
						chat_text.erase(0,i + 1);
						voteData->m_voteNum = atoi(chat_text.c_str());

						crServerBrainHandle::getInstance()->doEvent(WCH_JXJGMOrderCountryVote,MAKECREPARAM(voteData.get(),NULL));
					}
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 27:
				{
					// 清空投票列表
					data->getParam(WCHDATA_JXJSelectLeaderSet,param);
					SelectLeaderIdSet * selectLeaderSet = (SelectLeaderIdSet *)param;
					selectLeaderSet->clear();
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJGameServerGroupWeekZero);

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			//case 28:
			//	{
			//		//m_this->doEvent(WCH_JXJGameServerUpdate);
			//	}
			//	break;
			//case 29:
			//	{
			//		crServerBrainHandle::getInstance()->doEvent(WCH_JXJGameServerGroupWeekZero);
			//	}
			//	break;
			case 30:
				{
					unsigned char maxGetCount = (unsigned char)atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLandRewardGetCount,0).c_str());
					data->getParam(WCHDATA_JXJSeriesLandDay,param);
					unsigned short * seriesDays = (unsigned short *)param;
					data->getParam(WCHDATA_JXJLandRewardGetCount,param);
					unsigned char * rewardCount = (unsigned char *)param;
					//连续登陆时间
					*seriesDays += 1;
					//登陆奖励次数
					if(*seriesDays <= maxGetCount)
						*rewardCount = *seriesDays;
					else
						*rewardCount = maxGetCount;
					if(*rewardCount == 0)
					{
						*rewardCount = 1;
					}
					data->inputParam(WCHDATA_JXJPlayerChangeShiliTimes,0);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(14);
					streamBuf2->_writeUChar(* rewardCount);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 34:
				{
					//crGlobalHandle::gData()->reloadGlobalTable(WCHDATA_JXJHuodongTab	,"JXJ/script/table/huodong.crb");
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJReloadHuodongTab);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(74);
					streamBuf2->_writeUChar(1);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
					
				}
				break;
			case 36:
				{
					   //int robotlijincount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRobotGiftGold, 0).c_str());
					//MoneyChangeData  moneydata;//(itr->second,str);
					data->getParam(WCHDATA_JXJGiftGold, param);
					int *giftgold = (int *)param;
					*giftgold += 100;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(4);
					streamBuf2->_writeInt(*giftgold);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet, playerid, WCH_JXJClientRecvGiftgold, streamBuf2.get());
				}
				break;
			case 40:
				{
					int changeplayerid = 0;
					int datatype = 0;
					int itemid = 0;
					int count = 0;
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					//const char spacestr = ' ';
					//int spaceint = chat_text.find(spacestr);
					//std::string playeridstr = chat_text;
					//playeridstr.erase(spaceint,playeridstr.size());
					//changeplayerid = atoi(playeridstr.c_str());
					//chat_text.erase(0,spaceint+1);
					////
					//spaceint = chat_text.find(spacestr);
					//std::string datatypestr = chat_text;
					//datatypestr.erase(spaceint,datatypestr.size());
					//datatype = atoi(datatypestr.c_str());
					//chat_text.erase(0,spaceint+1);
					////
					//spaceint = chat_text.find(spacestr);
					//std::string itemidstr = chat_text;
					//itemidstr.erase(spaceint,itemidstr.size());
					//itemid = atoi(itemidstr.c_str());
					//chat_text.erase(0,spaceint+1);
					////
					//std::string countstr = chat_text;
					//count = atoi(countstr.c_str());
					//
					crVector4i vec4;
					if(crArgumentParser::appAtoVec(chat_text,vec4,' '))
					{
						changeplayerid = vec4[0];
						datatype = vec4[1];
						itemid = vec4[2];
						count = vec4[3];
						crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
						ref_ptr<crJXJInsertPlayerdataChangeList> insertRecharge = new crJXJInsertPlayerdataChangeList;
						insertRecharge->buildUpdateSql(changeplayerid, callback->getServerID(), playerid,datatype, itemid, count, "修改玩家数据测试");
						crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
						crDBSavePacket packet;
						crDBSavePacket::buildRequestPacket(packet,insertRecharge.get());
						dbConductor->getNetManager()->sendPacket("all",packet);

						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(1);
						streamBuf2->_writeUChar(40);
						crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
					}
				}
				break;
			case 41:
				{
					bool success = false;
					int changeplayerid = 0;
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					const char spacestr = ' ';
					int spaceint = chat_text.find(spacestr);
					if(spaceint!=std::string::npos)
					{
						std::string playeridstr = chat_text;
						playeridstr.erase(spaceint,playeridstr.size());
						changeplayerid = atoi(playeridstr.c_str());
						chat_text.erase(0,spaceint+1);
						//
						std::string password = chat_text;
						//
						crNetManager *netManager = gameServer->getNetManager();
						crNetDataManager *netDataManager = gameServer->getNetDataManager();
						crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
						crDataBase *accountdb = crDataBaseManager::getInstance()->getAccountDB();
						ref_ptr<crDataBase> accountSession = accountdb->beginSession();
						ref_ptr<crJXJUpdatePlayerPassword> updateplayerpassword = new crJXJUpdatePlayerPassword;
						updateplayerpassword->buildUpdateSql(changeplayerid,password);
						if(accountdb->executeUpdate(updateplayerpassword.get()))
						{//插入成功
							accountSession->commit();
							success = true;
						}
						else
						{
							accountSession->rollback();
						}
						accountdb->endSession(accountSession.get());
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(2);
						streamBuf2->_writeUChar(60);
						streamBuf2->_writeBool(success);
						crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
					}
				}
				break;
			case 60:
				{
					   int keysize = keystr.size();
					   chat_text.erase(0, keysize);
					   unsigned char changeshiliid = atoi(chat_text.c_str());
					   data->getParam(WCHDATA_JXJShiliID, param);
					   unsigned char * shiliid = (unsigned char *)param;
					   if (changeshiliid != (*shiliid))
					   {
						   //处理国民列表
						   crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
						   serverData->excHandle(MAKECREPARAM(WCH_LockData, 1));
						   serverData->getParam(WCHDATA_JXJShiliWei, param);
						   crJXJShili *shiliWei = (crJXJShili *)param;
						   serverData->getParam(WCHDATA_JXJShiliShu, param);
						   crJXJShili *shiliShu = (crJXJShili *)param;
						   serverData->getParam(WCHDATA_JXJShiliWu, param);
						   crJXJShili *shiliWu = (crJXJShili *)param;
						   int weiID = shiliWei->getID();
						   int shuID = shiliShu->getID();
						   int wuID = shiliWu->getID();
						   crData *shiliData = NULL;
						   crData *newshiliData = NULL;
						   if (*shiliid == weiID)
						   {
							   shiliData = shiliWei->getDataClass();
						   }
						   else if (*shiliid == shuID)
						   {
							   shiliData = shiliShu->getDataClass();
						   }
						   else if (*shiliid == wuID)
						   {
							   shiliData = shiliWu->getDataClass();
						   }
						   if (changeshiliid == weiID)
						   {
							   newshiliData = shiliWei->getDataClass();
						   }
						   else if (changeshiliid == shuID)
						   {
							   newshiliData = shiliShu->getDataClass();
						   }
						   else if (changeshiliid == wuID)
						   {
							   newshiliData = shiliWu->getDataClass();
						   }
						   if (shiliData && newshiliData)
						   {
							   //CRCore::ref_ptr<PeopleInfo > peopleInfo;
							   shiliData->excHandle(MAKECREPARAM(WCH_LockData, 1));
							   shiliData->getParam(WCHDATA_JXJPeopleMap, param);
							   PeopleMap *peopleMap = (PeopleMap *)param;
							   PeopleMap::iterator itrInfo = peopleMap->find(playerid);
							   if (itrInfo != peopleMap->end())
							   {
								   itrInfo->second->setShili(changeshiliid);
								   newshiliData->excHandle(MAKECREPARAM(WCH_LockData, 1));
								   newshiliData->getParam(WCHDATA_JXJPeopleMap, param);
								   PeopleMap *newpeopleMap = (PeopleMap *)param;
								   if (newpeopleMap)
									   newpeopleMap->insert(std::make_pair(playerid, itrInfo->second));
								   newshiliData->excHandle(MAKECREPARAM(WCH_LockData, 0));

								   peopleMap->erase(playerid);
							   }

							   shiliData->getParam(WCHDATA_JXJModifyPlayerSet, param);
							   ModifyPlayerSet * oldModifyPlayerSet = (ModifyPlayerSet *)param;
							   shiliData->getParam(WCHDATA_JXJInsertPlayerSet, param);
							   InsertPlayerSet * oldInsertPlayerSet = (InsertPlayerSet *)param;

							   newshiliData->getParam(WCHDATA_JXJModifyPlayerSet, param);
							   ModifyPlayerSet * newModifyPlayerSet = (ModifyPlayerSet *)param;
							   newshiliData->getParam(WCHDATA_JXJInsertPlayerSet, param);
							   InsertPlayerSet * newInsertPlayerSet = (InsertPlayerSet *)param;

							   if (oldModifyPlayerSet->find(playerid) != oldModifyPlayerSet->end())
							   {
								   oldModifyPlayerSet->erase(playerid);
								   newModifyPlayerSet->insert(playerid);
							   }
							   if (oldInsertPlayerSet->find(playerid) != oldInsertPlayerSet->end())
							   {
								   oldInsertPlayerSet->erase(playerid);
								   newInsertPlayerSet->insert(playerid);
							   }

							   // 如果在投票列表中
							   shiliData->getParam(WCHDATA_JXJCountryCandidateVecT, param);
							   CandidateVec *candidateVec = (CandidateVec *)param;
							   CandidateVec::iterator cvItr = candidateVec->begin();
							   for (; cvItr != candidateVec->end(); ++cvItr)
							   {
								   if (cvItr->valid() && (*cvItr)->nPlayerID == playerid)
								   {
									   candidateVec->erase(cvItr);
									   break;
								   }
							   }

							   shiliData->getParam(WCHDATA_JXJCountryCandidateVecL, param);
							   CandidateVec*candidateVecL = (CandidateVec*)param;

							   for (CandidateVec::iterator cvLItr = candidateVecL->begin();
								   cvLItr != candidateVecL->end(); ++cvLItr)
							   {
								   if (cvLItr->valid() && (*cvLItr)->nPlayerID == playerid)
								   {
									   char log[128];
									   memset(log, 0, sizeof(log));
									   sprintf(log, "%d %s 叛国 从国家官员候补列表中删除\0", (*cvLItr)->nPlayerID, (*cvLItr)->playerName.c_str());

									   std::string logdata(log);
									   GameLogData gamelog(Log_RemoveFromCandidateL, logdata);
									   crServerBrainHandle::getInstance()->doEvent(WCH_GameLog, MAKECREPARAM((*cvLItr)->nPlayerID, &gamelog));

									   candidateVecL->erase(cvLItr);
									   break;
								   }
							   }
							   bool modify = true;
							   shiliData->inputParam(WCHDATA_JXJShiliModify, &modify);
							   shiliData->excHandle(MAKECREPARAM(WCH_LockData, 0));
						   }
						   serverData->excHandle(MAKECREPARAM(WCH_LockData, 0));

						   ref_ptr<crPlayerGameData> myplayerdata = playerData->getPlayerGameData();
						   if(myplayerdata.valid() && myplayerdata->getDataClass())
						   {
							   ref_ptr<crData> dat = myplayerdata->getDataClass();
							   int time = 0;
							   data->inputParam(WCHDATA_JXJTreasonPunishTimer,&time);
						   }

						   m_this->doEvent(WCH_JXJChangeShili,MAKECREPARAM(&changeshiliid,NULL));
						   
						   unsigned short mychengchiID = 0;

						   ref_ptr<crTableIO>shiliTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
						   crTableIO::StrVec record;
						   if(shiliTab->queryOneRecord(0,crArgumentParser::appItoa(changeshiliid),record)>=0)
						   {
							   int chengchiindex = shiliTab->getTitleIndex("默认城池");
							   mychengchiID = (unsigned short)(atoi(record[chengchiindex].c_str()));
							   data->inputParam(WCHDATA_JXJChengchiID,&mychengchiID);
						   }

						   crPlayerDataEventPacket packet2;
						   ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						   streamBuf2->createBuf(2);
						   streamBuf2->_writeUChar(60);
						   streamBuf2->_writeUChar(changeshiliid);
						   crPlayerDataEventPacket::buildReplyPacket(packet2, playerid, WCH_JXJRecvGMOrder, streamBuf2.get());
						   gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet2);
					   }
				}
				break;
			case 50:
				{
					   data->inputParam(WCHDATA_JXJLingqufengluFlag, 0);
					   crPlayerDataEventPacket packet2;
					   ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					   streamBuf2->createBuf(1);
					   streamBuf2->_writeUChar(50);
					   crPlayerDataEventPacket::buildReplyPacket(packet2, playerid, WCH_JXJRecvGMOrder, streamBuf2.get());
					   gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet2);
				}
				break;
			case 51:
			case 52:
				{
					crData * serverBrainData = crServerBrainHandle::getInstance()->getDataClass();
					if (serverBrainData)
					{
						bool bStart = false;
						float cycleTime = 0;
						if (gmorder == 51)
						{
							bStart = true;
							cycleTime = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJServerCycleTotalTime, 0).c_str());
						}
						   
						serverBrainData->inputParam(WCHDATA_JXJIsServerCycling, &bStart);
						serverBrainData->inputParam(WCHDATA_JXJServerCycleTimer, &cycleTime);

						crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
						crNetDataManager *netDataManager = netConductor->getNetDataManager();
						crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
						int serverid = callback->getServerID();
						ref_ptr<crUpdateServerStats> updateServerStats = new crUpdateServerStats();
						updateServerStats->buildUpdateSql(serverid, bStart?1:0);
						crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
						crDBSavePacket dbpacket;
						crDBSavePacket::buildRequestPacket(dbpacket, updateServerStats.get());
						dbConductor->getNetManager()->sendPacket("all", dbpacket);

						//通知所有玩家
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(5);
						stream->_writeBool(bStart);
						stream->_writeInt(cycleTime);
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildReplyPacket(packet, 0, WCH_JXJRecvServerCycleStart, stream.get());
						netDataManager->sendPacketToAllPlayer(packet);

						CRNetApp::crGameServerCallback *netCallback = dynamic_cast<CRNetApp::crGameServerCallback *>(netDataManager->getNetCallback());
						std::string filepath = crArgumentParser::getFilePath(m_strServerCycleInfoFile);
						std::string filename = crArgumentParser::getSimpleFileName(m_strServerCycleInfoFile);
						std::string relFileName = filepath + "/" + netCallback->getServerName() + "/" + filename;
						stream->seekBegin();
						stream->saveToFile2(relFileName);
					}
				}
				break;
			case 53:
				{
					crGameServerCallback *netcallback = dynamic_cast<crGameServerCallback* >(gameServer->getNetDataManager()->getNetCallback());
					int serverid = netcallback->getServerID();
					crData *gameData = crServerBrainHandle::getInstance()->getDataClass();
					gameData->excHandle(MAKECREPARAM(WCH_LockData,1));

					crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
					ref_ptr<crDataBase> globalSession = db->beginSession();

					ref_ptr<crJXJNoChatQueryData> noChatQueryQuery = new crJXJNoChatQueryData;
					noChatQueryQuery->buildQuerySql(serverid);
					globalSession->executeQuery(noChatQueryQuery.get());
					crDataBase::QueryResultVec& noChatQueryQueryResultVec = globalSession->getQueryResult();

					void *param;
					gameData->getParam(WCHDATA_JXJNoChatSet,param);
					NoChatSet *noChatSet = (NoChatSet *)param;
					noChatSet->clear();
					for( crDataBase::QueryResultVec::iterator itr = noChatQueryQueryResultVec.begin();
						itr != noChatQueryQueryResultVec.end();
						++itr )
					{
						noChatQueryQuery = dynamic_cast<crJXJNoChatQueryData *>(itr->get());
						noChatSet->insert(noChatQueryQuery->getPlayerID());
					}

					globalSession->releaseQuery();
					db->endSession(globalSession.get());

					gameData->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				break;
			case 54:
				{
					crGameServerCallback *netcallback = dynamic_cast<crGameServerCallback* >(gameServer->getNetDataManager()->getNetCallback());
					int serverid = netcallback->getServerID();
					crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
					ref_ptr<crDataBase> globalSession = db->beginSession();
					//查询并返回GameList
					ref_ptr<crJXJGmQueryData> gmQueryQuery = new crJXJGmQueryData;
					gmQueryQuery->buildQuerySql(serverid);
					globalSession->executeQuery(gmQueryQuery.get());
					crDataBase::QueryResultVec gmQueryQueryResultVec = globalSession->getQueryResult();
					globalSession->releaseQuery();
					db->endSession(globalSession.get());

					crGlobalHandle::gData()->lockGMMap();
					GMMap &gmMap = crGlobalHandle::gData()->getGMMap();
					gmMap.clear();
					for( crDataBase::QueryResultVec::iterator itr = gmQueryQueryResultVec.begin();
						itr != gmQueryQueryResultVec.end();
						++itr )
					{
						gmQueryQuery = dynamic_cast<crJXJGmQueryData *>(itr->get());
						gmMap[gmQueryQuery->getPlayerID()] = gmQueryQuery->getAuthorityid();
					}
					crGlobalHandle::gData()->unlockGMMap();
				}
				break;
			case 55:
				{
					bool success = false;
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					const char spacestr = ' ';
					int spaceint = chat_text.find(spacestr);
					if(spaceint >= 0)
					{
						chat_text.erase(0,spaceint+1);
						unsigned char winCityBit = atoi(chat_text.c_str());
						if (winCityBit < 8)
						{
							crData * gsBrainData = crServerBrainHandle::getInstance()->getDataClass();

							data->getParam(WCHDATA_JXJShiliID,param);
							unsigned char myshili = *(unsigned char *)param;
							gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));

							gsBrainData->getParam(WCHDATA_JXJShiliWei + myshili - c_startShiliID,param);
							crJXJShili *shili = (crJXJShili *)param;
							if(shili && shili->getDataClass())
							{
								crData * shiliData = shili->getDataClass();
								shiliData->getParam(WCHDATA_JXJShiliFoundCountryWinCity,param);
								unsigned char winCity = *(unsigned char *)param;
								winCity &= ~(unsigned char)(1 << winCityBit);
								shiliData->inputParam(WCHDATA_JXJShiliFoundCountryWinCity,&winCity);
								success = true;
							}

							gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
						}
					}
					//data->getParam(WCHDATA_JXJFoundCountryGetAward,param);
					//unsigned char getAward = *(unsigned char *)param;
					//getAward &= ~(unsigned char)(1 << winCityBit);
					data->inputParam(WCHDATA_JXJFoundCountryGetAward,NULL);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(55);
					streamBuf2->_writeBool(success);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				
				}
				break;
			case 56:
				{
					crGlobalHandle::gData()->reloadGameGlobalTable("JXJ/GlobalTable.crb");
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(6);
					streamBuf2->_writeBool(true);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 62:
				{
					crGameServerCallback *netcallback = dynamic_cast<crGameServerCallback* >(gameServer->getNetDataManager()->getNetCallback());
					int keysize = keystr.size();
					chat_text.erase(0, keysize);
					short count = atoi(chat_text.c_str());
					netcallback->setMaxPlayerCount(count);
					count = netcallback->getRemainPlayerCount();
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(3);
					streamBuf2->_writeUChar(62);
					streamBuf2->_writeShort(count);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 63:
				{
					int keysize = keystr.size();
					chat_text.erase(0, keysize);
					crGlobalHandle::gData()->gStartDate() = chat_text;
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(crGlobalHandle::gData()->gStartDate().length()+5);
					streamBuf2->_writeUChar(63);
					streamBuf2->_writeString(crGlobalHandle::gData()->gStartDate());
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 64:
				{
					bool success = false;
					int keysize = keystr.size();
					chat_text.erase(0,keysize);

					int shiliid = atoi(chat_text.c_str());

					int i = chat_text.find(' ');
					if(i!=std::string::npos && shiliid>=10 && shiliid<=12)
					{
						chat_text.erase(0,i+1);
						int post = atoi(chat_text.c_str());

						i = chat_text.find(' ');
						if(i!=std::string::npos && post>=1 && post<=3)
						{
							chat_text.erase(0,i+1);
							std::string name = chat_text;
							crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
							if(gameServer)
							{
								crNetDataManager *netManager = gameServer->getNetDataManager();
								if(netManager)
								{
									crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netManager->getNetCallback());
									if(callback)
									{
										int playerid = crGlobalHandle::getInstance()->gameServerQueryPlayerID(name,callback->getServerID());
										if(playerid>0)
										{
											crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
											serverData->excHandle(MAKECREPARAM(WCH_LockData, 1));
											serverData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID, param);
											crJXJShili *shili = (crJXJShili *)param;
											crData *shiliData = shili->getDataClass();
											shiliData->excHandle(MAKECREPARAM(WCH_LockData, 1));

											shiliData->getParam(WCHDATA_JXJCountryHistory,param);
											CountryHistory *history = (CountryHistory *)param;
											CRCore::ref_ptr<CountryHistoryOfficalChange > chocPtr = new CountryHistoryOfficalChange;
											chocPtr->m_playerName = name;
											if(post == 1)
											{
												shiliData->inputParam(WCHDATA_JXJChengxiang,&playerid);
												shiliData->inputParam(WCHDATA_JXJChengxiangName,&name);
												chocPtr->m_officalName = "丞相";
											}
											else if(post == 2)
											{
												shiliData->inputParam(WCHDATA_JXJDasima,&playerid);
												shiliData->inputParam(WCHDATA_JXJDasimaName,&name);
												chocPtr->m_officalName = "大司马";
											}
											else if(post == 3)
											{
												shiliData->inputParam(WCHDATA_JXJDajiangjun,&playerid);
												shiliData->inputParam(WCHDATA_JXJDajiangjunName,&name);
												chocPtr->m_officalName = "大将军";
											}
											history->push_back(chocPtr.get());
											char log[128];
											memset(log,0,sizeof(log));
											sprintf(log,"%d %s 成为 %s\0",playerid,name.c_str(),chocPtr->m_officalName.c_str());

											std::string logdata(log);
											GameLogData gamelog(Log_GenerateCountryOfficial,logdata);
											crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));

											shiliData->excHandle(MAKECREPARAM(WCH_LockData, 0));
											serverData->excHandle(MAKECREPARAM(WCH_LockData, 0));
											success = true;
										}
									}
								}
							}
						}
					}
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(41);
					streamBuf2->_writeBool(success);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 66:
				{

					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					int addexp = atoi(chat_text.c_str());
					time_t t = time(0);
					data->inputParam(WCHDATA_UpdateTimer,&t);
					data-> getParam(WCHDATA_JXJConsortiaID,param);
					int mygroupid = *( int *)param;
					int testExp = addexp;
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					ref_ptr<crData> groupData;
					gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
					ConsortiaMap *consortiamap = (ConsortiaMap *)param;
					ConsortiaMap::iterator cmItr = consortiamap->find(mygroupid);
					if (cmItr != consortiamap->end() && cmItr->second.valid())
					{
						groupData = cmItr->second->getDataClass();
					}
					if (groupData.valid())
					{
						groupData->inputParam(WCHDATA_JXJConquest,&testExp);
						groupData->getParam(WCHDATA_JXJConsortiaMemberMap,param);
						ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
						ConsortiaMemberMap::iterator cmmitr = membermap->find(m_this->getPlayerID());
						if (cmmitr != membermap->end() && cmmitr->second.valid())
						{
							cmmitr->second->setNewer(false);
						}
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(1);
						streamBuf2->_writeUChar(6);
						crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);

					}
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				break;
			case 67:
				{
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJGainCountryCandidateVecT);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 68:
				{
					int coolingtime = 0;
					data->inputParam(WCHDATA_JXJTreasonCoolingTimer,&coolingtime);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(68);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 69:
				{
					time_t nowTime_t = time(0);
					struct  tm  nowTm = *localtime(&nowTime_t); //服务器当前时间
					int cancelCantonTimer = nowTime_t - 24*3600;
					data->inputParam(WCHDATA_JXJCancelCantonTimer, &cancelCantonTimer);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(5);
					streamBuf2->_writeUChar(69);
					streamBuf2->_writeInt(cancelCantonTimer);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 70:
				{

					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					crVector2i vec2;
					crArgumentParser::appAtoVec(chat_text,vec2);
					int _playerid = vec2[0]==0?playerid:vec2[0];
					int addcontri = vec2[1];
					int groupid = 0;
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					ref_ptr<crGameServerPlayerData> _playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(_playerid));
					if (_playerData.valid() && _playerData->getPlayerGameData() && _playerData->getPlayerGameData()->getDataClass())
					{
						crData *_data = _playerData->getPlayerGameData()->getDataClass();
						_data->getParam(WCHDATA_JXJConsortiaID,param);
						groupid = *(int *)param;
					}
					else
					{
						for (int i = WCHDATA_JXJShiliWei; i <= WCHDATA_JXJShiliWu; ++ i)
						{
							gsBrainData->getParam(i,param);
							crJXJShili *shili = (crJXJShili *)param;
							if (shili && shili->getDataClass())
							{
								crData *shiliData = shili->getDataClass();	
								CRCore::ScopedLock<crData> lock(*shiliData);
								shiliData->getParam(WCHDATA_JXJPeopleMap,param);
								PeopleMap *peopleMap = (PeopleMap *)param;
								PeopleMap::iterator itr = peopleMap->find(_playerid);
								if (itr != peopleMap->end() && itr->second.valid())
								{
									groupid = itr->second->getConsortiaId();
									break;
								}
							}
						}
					}
					if (groupid > 0)
					{
						ref_ptr<crData> groupData;
						gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
						ConsortiaMap *consortiamap = (ConsortiaMap *)param;
						ConsortiaMap::iterator cmItr = consortiamap->find(groupid);
						if (cmItr != consortiamap->end() && cmItr->second.valid())
						{
							groupData = cmItr->second->getDataClass();
						}
						if (groupData.valid())
						{
							groupData->getParam(WCHDATA_JXJConsortiaMemberMap,param);
							ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
							ConsortiaMemberMap::iterator cmmitr = membermap->find(_playerid);
							if (cmmitr != membermap->end() && cmmitr->second.valid())
							{
								cmmitr->second->setGroupContribute(cmmitr->second->getGroupContribute() + addcontri);
							}
							crPlayerDataEventPacket packet2;
							ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
							streamBuf2->createBuf(1);
							streamBuf2->_writeUChar(6);
							crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
						}
					}
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				break;
			case 71:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					std::string strplayerid = chat_text.substr(0,chat_text.find(' '));
					chat_text.erase(0,strplayerid.size()+1);
					int zhanquancount = atoi(chat_text.c_str());
					int giveplayerid = atoi(strplayerid.c_str());

					ref_ptr<crGameServerPlayerData> giveplayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(giveplayerid));
					if(giveplayerData.valid() && giveplayerData->getPlayerGameData() && giveplayerData->getPlayerGameData()->getDataClass())
					{
						ref_ptr<crData> givedata =  giveplayerData->getPlayerGameData()->getDataClass();
						givedata->excHandle(MAKECREPARAM(WCH_LockData, 1));
						givedata->getParam(WCHDATA_JXJZhengZhanQuan,param);
						int * count = (int *)param;
						*count = *count + zhanquancount;
						givedata->excHandle(MAKECREPARAM(WCH_LockData, 0));
					
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(5);
						streamBuf2->_writeUChar(71);
						streamBuf2->_writeInt(zhanquancount);
						crPlayerDataEventPacket::buildReplyPacket(packet2,giveplayerid,WCH_JXJRecvGMOrder,streamBuf2.get());
						gameServer->getNetManager()->sendPacket(giveplayerData->getPlayerConnectServerAddress(),packet2);
					}
				}
				break;
			case 72:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					int dismissTime = atoi(chat_text.c_str());

					void *param;
					unsigned char success = 0;
					int playerid = m_this->getPlayerID();
					crData *data = m_this->getDataClass();
					crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
					ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
					if (playerData.valid() )
					{
						data-> getParam(WCHDATA_JXJConsortiaID,param);
						int mygroupid = *( int *)param;
						if(mygroupid > 0)
						{
							crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
							gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
							ref_ptr<crData>consortiaData;
							gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
							ConsortiaMap *consortiamap = (ConsortiaMap *)param;
							ConsortiaMap::iterator itr;
							itr = consortiamap->find(mygroupid);
							if (itr != consortiamap->end())
							{
								consortiaData = itr->second->getDataClass();
							}
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							if(consortiaData.valid())
							{
								consortiaData->getParam(WCHDATA_JXJConsortiaDismissTime,param);
								int lastTime = *(int *)param;	
								consortiaData->inputParam(WCHDATA_JXJConsortiaDismissTime,&dismissTime);
								success = 1;
								//删除playerdata 里的 城池特产
								data->getParam(WCHDATA_JXJGroupCantonSpecialtyVec,param);
								GroupCantonSpecialtyVec *gcspecialtyVec = (GroupCantonSpecialtyVec *)param;
								for( GroupCantonSpecialtyVec::iterator gvitr = gcspecialtyVec->begin();
									gvitr != gcspecialtyVec->end();
									++gvitr )
								{
									*gvitr = NULL;
								}
								//删除已通关副本
								data->getParam(WCHDATA_JXJHadWonGroupFuBenSet,param);
								HadWonGroupFuBenSet * hadWonGroupFuBenSet = (HadWonGroupFuBenSet *)param;
								hadWonGroupFuBenSet->clear();					
							}
							int size = 1;
							if (success) 
							{
								size += 4;
							}

							stream->createBuf(size);
							stream->_writeUChar(success);
							if (1 == success)
							{
								stream->_writeInt(dismissTime);
							}
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvDismissGroup,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
						}
						///游戏日志
						std::string logdata = crArgumentParser::appItoa(success);
						GameLogData gamelog(Log_DimissGroup,logdata);
						crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
					}
				}
				break;
			case 73:
				{
					bool hadwontoday = false;
					data->inputParam(WCHDATA_JXJHadWonJunTuanFBT,&hadwontoday);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(73);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 74:
				{
					ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					crJXJSceneServerReloadTabPacket packet;
					crJXJSceneServerReloadTabPacket::buildRequestPacket(packet,WCHDATA_JXJOnlineRewardTab);
					callback->sendPacketToSceneServer("all",packet);

					crGlobalHandle::gData()->reloadGlobalTable(WCHDATA_JXJOnlineRewardTab/*,"JXJ/script/table/onlinereward.crb"*/);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(74);
					streamBuf2->_writeUChar(2);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);

				}
				break;
			case 75:
				{
					ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					crJXJSceneServerReloadTabPacket packet;
					crJXJSceneServerReloadTabPacket::buildRequestPacket(packet,WCHDATA_JXJHuoyueduRewardTab);
					callback->sendPacketToSceneServer("all",packet);

					crGlobalHandle::gData()->reloadGlobalTable(WCHDATA_JXJHuoyueduRewardTab/*,"JXJ/script/table/HuoyueduReward.crb"*/);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(74);
					streamBuf2->_writeUChar(3);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);

				}
				break;
			case 76:
				{
					ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					crJXJSceneServerReloadTabPacket packet;
					crJXJSceneServerReloadTabPacket::buildRequestPacket(packet,WCHDATA_JXJItemTab);
					callback->sendPacketToSceneServer("all",packet);

					crGlobalHandle::gData()->reloadGlobalTable(WCHDATA_JXJItemTab/*,"JXJ/script/table/item.crb"*/);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(74);
					streamBuf2->_writeUChar(4);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);

				}
				break;
			case 77:
				{
					ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					crJXJSceneServerReloadTabPacket packet;
					crJXJSceneServerReloadTabPacket::buildRequestPacket(packet,WCHDATA_JXJTaskTitleTab);
					callback->sendPacketToSceneServer("all",packet);

					crGlobalHandle::gData()->reloadGlobalTable(WCHDATA_JXJTaskTitleTab/*,"JXJ/script/table/jxjtasktitle.crb"*/);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(2);
					streamBuf2->_writeUChar(74);
					streamBuf2->_writeUChar(5);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);

				}
				break;
			case 78:
				{
					ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					crJXJSceneServerReloadTabPacket packet;
					crJXJSceneServerReloadTabPacket::buildRequestPacket(packet,WCHDATA_JXJLandRewardTab);
					callback->sendPacketToSceneServer("all",packet);

					crGlobalHandle::gData()->reloadGlobalTable(WCHDATA_JXJLandRewardTab/*,"JXJ/script/table/landreward.crb"*/);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);

				}
				break;
			case 79:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					int tableid = atoi(chat_text.c_str());

					ref_ptr<crGameServerCallback> callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					crJXJSceneServerReloadTabPacket packet;
					crJXJSceneServerReloadTabPacket::buildRequestPacket(packet,tableid);
					callback->sendPacketToSceneServer("all",packet);

					crGlobalHandle::gData()->reloadGlobalTable(tableid);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 80:
				{
					crServerBrainHandle::getInstance()->doEvent(WCH_JXJConsortiaPromotionUpdate);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(6);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 81:
				{
					bool hadGotten = false;
					data->inputParam(WCHDATA_JXJHadGottenConsortiaPromotionReward,&hadGotten);
					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(81);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 82:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					std::string strplayerid = chat_text.substr(0,chat_text.find(' '));
					chat_text.erase(0,strplayerid.size()+1);
					int zhanquancount = atoi(chat_text.c_str());
					int giveplayerid = atoi(strplayerid.c_str());

					ref_ptr<crGameServerPlayerData> giveplayerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(giveplayerid));
					if(giveplayerData.valid() && giveplayerData->getPlayerGameData() && giveplayerData->getPlayerGameData()->getDataClass())
					{
						ref_ptr<crData> givedata =  giveplayerData->getPlayerGameData()->getDataClass();
						givedata->excHandle(MAKECREPARAM(WCH_LockData, 1));
						givedata->getParam(WCHDATA_JXJAchievePointsCount,param);
						int * count = (int *)param;
						*count = *count + zhanquancount;
						givedata->excHandle(MAKECREPARAM(WCH_LockData, 0));

						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(5);
						streamBuf2->_writeUChar(82);
						streamBuf2->_writeInt(zhanquancount);
						crPlayerDataEventPacket::buildReplyPacket(packet2,giveplayerid,WCH_JXJRecvGMOrder,streamBuf2.get());
						gameServer->getNetManager()->sendPacket(giveplayerData->getPlayerConnectServerAddress(),packet2);
					}
				}
				break;
			case 84:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					std::string strshiliid = chat_text.substr(0,chat_text.find(' '));
					chat_text.erase(0,strshiliid.size()+1);
					crVector3i canshu;
					crArgumentParser::appAtoVec(chat_text,canshu);
					int shiliid = atoi(strshiliid.c_str());

					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
					crJXJShili *shili = (crJXJShili *)param;
					crData *shiliData = shili->getDataClass();
					if(shiliData)
					{
						shiliData->excHandle(MAKECREPARAM(WCH_LockData,1));
						shiliData->getParam(WCHDATA_JXJTodayHaveLandedPlayerSet,param);
						std::set<int> *landedplayerset = (std::set<int> *)param;
						landedplayerset->clear();
						for (int i=0;i<canshu[0];i++)
						{
							landedplayerset->insert(i+1);
						}

						shiliData->getParam(WCHDATA_JXJYesterdayConqueredTity,param);
						unsigned char *chavecityold = (unsigned char*)param;
						*chavecityold = canshu[1];

						shiliData->getParam(WCHDATA_JXJTodayConqueredTity,param);
						unsigned char *cConqueredcitynew = (unsigned char*)param;
						*cConqueredcitynew = canshu[2];

						shiliData->excHandle(MAKECREPARAM(WCH_LockData,0));
					}

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(84);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 85:
				{
					int keysize = keystr.size();
					chat_text.erase(0,keysize);
					std::string strshiliid = chat_text.substr(0,chat_text.find(' '));
					chat_text.erase(0,strshiliid.size()+1);
					int shiliid = atoi(strshiliid.c_str());
					unsigned char strength = atoi(chat_text.c_str());

					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
					crJXJShili *shili = (crJXJShili *)param;
					crData *shiliData = shili->getDataClass();
					if(shiliData)
					{
						void *param;
						shiliData->getParam(WCHDATA_JXJCountryStrength, param);
						unsigned char curstrength = *(unsigned char *)param;
						if (curstrength != strength)
						{
							shiliData->inputParam(WCHDATA_JXJCountryStrength, &strength);
							bool modify = true;
							shiliData->inputParam(WCHDATA_JXJShiliModify, &modify);
						}
					}

					crPlayerDataEventPacket packet2;
					ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
					streamBuf2->createBuf(1);
					streamBuf2->_writeUChar(84);
					crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvGMOrder,streamBuf2.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
				}
				break;
			case 86:
				{
					crRole *role = m_this->getMainRole();
					if (role)
						role->doEvent(WCH_JXJActiveSuperEquip);
				}
				break;
			case 87:
				{
					crRole *role = m_this->getMainRole();
					if (role)
					{
						crData *roledata = role->getDataClass();
						void *param;
						roledata->lock();
						roledata->inputParam(WCHDATA_JXJSuperEquipLvupPoint, NULL);
						roledata->inputParam(WCHDATA_JXJExpPelletBuyTimes, NULL);
						roledata->inputParam(WCHDATA_JXJSuperEquipZhulingData, NULL);
						roledata->getParam(WCHDATA_JXJSuperEquipDataVec, param);
						SuperEquipDataVec *superEquipDataVec = (SuperEquipDataVec*)param;
						superEquipDataVec->clear();
						roledata->unlock();
						crPlayerDataEventPacket packet2;
						ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
						streamBuf2->createBuf(1);
						streamBuf2->_writeUChar(87);
						crPlayerDataEventPacket::buildReplyPacket(packet2, playerid, WCH_JXJRecvGMOrder, streamBuf2.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(), packet2);
					}
				}
				break;
			}

			//data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}		
		if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			ref_ptr<crCanvasNode>ChatCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (!ChatCanvas) ChatCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strBattleCanvas);
			ref_ptr<crEditWidgetNode> input;
			if(ChatCanvas.valid())
			{
				input = dynamic_cast<crEditWidgetNode *>(ChatCanvas->getWidget(m_input));
			}
			unsigned char type =m_stream->_readUChar();
			if (type == 0)
			{
				crTableIO::StrVec record;
				int itemid = m_stream->_readInt();
				unsigned char count = m_stream->_readUChar();
				unsigned char result = m_stream->_readUChar();
				std::string str = "指令有误";
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				int typeindex = itemtab->getTitleIndex("类型");
				
				if(result && itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0)
				{
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					if (atoi(record[typeindex].c_str()) != IT_Jiangka)
					{
						data->getParam(WCHDATA_JXJItemBagVec,param);
					}
					else
					{
						data->getParam(WCHDATA_JXJJiangkaBagVec,param);
						count = 1;
					}
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					JXJItemBagVec::iterator itr;
					for (itr = itembagvec->begin();itr!=itembagvec->end();++itr)
					{
						if ((*itr)==NULL)
						{
							ref_ptr<crBagItemData> itemdata = new crBagItemData;
							itemdata->setItemID(itemid);
							itemdata->setItemCount(count);
							(*itr) = itemdata;
							break;
						}
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					str = "指令已执行！";
					if(input.valid())input->setString(str+crArgumentParser::appItoa(itemid)+","+crArgumentParser::appItoa(count));
				}
				else if(input.valid())input->addString(str);
			}
			else if (type == 1)
			{
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				for (int i = 20024; i <= 20029; i++)
				{
					data->getParam(i,param);
					unsigned char *buildinglv = (unsigned char *)param;
					*buildinglv = 80;
				}
				for (int i = 20106; i <= 20133; i++)
				{
					data->getParam(i,param);
					unsigned char *buildinglv = (unsigned char *)param;
					*buildinglv = 80;
				}
				int resourse = 99999999;

				for (int i = 20010; i <= 20016; i++)
				{
					if (i != 20011)
					{
						data->getParam(i,param);
						int *curresourse = (int *)param;
						*curresourse = resourse;
					}
				}
				//兵种科技升满
				data->getParam(WCHDATA_JXJTroopsTechMap,param);
				TroopsTechMap *troopstechmap = (TroopsTechMap *)param;
				troopstechmap->clear();
				ref_ptr<crTableIO>troopstechTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTechTab);
				ref_ptr<crTableIO>troopstechlvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTechLvTab);
				crTableIO::DataVec troopstechlvrecords;
				unsigned short troopstechid = 0;
				unsigned char troopstechlv = 0;
				for (int i = 0; i < troopstechTab->getRowCount();++i)
				{
					troopstechid = atoi((*troopstechTab)(i,0).c_str());
					troopstechlvTab->queryRecords(0,(*troopstechTab)(i,0),troopstechlvrecords);
					troopstechlv = troopstechlvrecords.size() - 1;
					troopstechmap->insert(std::make_pair(troopstechid,troopstechlv));
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if (type == 2)
			{
				data -> getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				unsigned short maxcount = (unsigned short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str()) * 100);
				data->inputParam(WCHDATA_JXJJunling,&maxcount);
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if(type == 3)
			{
				int armid[3] = {0};
				for (int i = 0;i < 3; ++i)
				{
					armid[i] = m_stream->_readInt();
				}
				unsigned short armcount = m_stream->_readUShort();
				crVector2i jkvec[3];
				for (int i = 0; i < 3; ++i)
				{
					jkvec[i] = m_stream->_readVec2i();
				}					
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJFormationInfoVec,param);
				FormationInfoVec *troop_infors = (FormationInfoVec *)param;
				troop_infors->resize(3);
				//crVector2i equips = crVector2i(10180,10000);
				for (int i = 0;i<3;i++)
				{
					ref_ptr	<crFormationInfo > fomation = new crFormationInfo;
					fomation->setAbstractID(armid[i]);
					fomation->setCount(armcount);
					fomation->setEquips(jkvec[i]);
					(* troop_infors)[i] = fomation;
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if(type == 4)
			{
				std::string code;
				std::string validdate;
				unsigned char size = m_stream->_readUChar();
				std::vector< std::pair<std::string,std::string> >CodeVec;
				for (int i = 0; i< size ;i++)
				{
					code = m_stream->_readString();
					validdate = m_stream->_readString();
					CodeVec.push_back(std::make_pair(code,validdate));
				}
				ref_ptr<crTableIO> table = new crTableIO;
				crTableIO::StrVec strVec;
				strVec.resize(3);
				strVec[0] = "id";
				strVec[1] = "激活码";
				strVec[2] = "生效日期";
				table->setTitleVec(strVec);
				size = CodeVec.size();
				int i = 0;
				for( std::vector< std::pair<std::string,std::string> >::iterator itr = CodeVec.begin();
					itr != CodeVec.end();
					++itr, i++)
				{
					strVec[0] = crArgumentParser::appItoa(i);
					strVec[1] = itr->first;
					strVec[2] = itr->second;
					table->addData(strVec);
				}
				table->saveToFileNoCook("激活码.tab");
				std::string str = "已生成：激活码.tab";
				if(input.valid())input->setString(str);
			}
			else if(type == 5)
			{
				ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas("UI_GM");
				if(canvasNode.valid())
					crFilterRenderManager::getInstance()->showCanvas(canvasNode.get(),true);
			}
			else if(type == 6)
			{
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if(type == 7)
			{
				ref_ptr<crGroup> uiroot = dynamic_cast<crGroup *>(CRIOManager::readNodeFile("uiscene/jxjcheck.cru"));
				if(uiroot.valid())
				{
					crLoadUISceneVisitor visitor;
					visitor.init(uiroot.get());
					uiroot->accept(visitor);
				}
				//ref_ptr<crGroup> uiroot = dynamic_cast<crGroup *>(CRIOManager::readNodeFile("uiscene/jxjcheck.cru"));
				//if(uiroot.valid())
				//{
				//	addUINodeToScene(uiroot.get());
				//}
				std::string str = "场景加载完毕！";
				if(input.valid())input->setString(str);
				//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas("UI_GM");
				//if(canvasNode)
				//	crFilterRenderManager::getInstance()->showCanvas(canvasNode,true);
			}
			else if(type == 8)
			{
				ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas("UI_Operation");
				if(canvasNode.valid())
					crFilterRenderManager::getInstance()->showCanvas(canvasNode.get(),true);
			}
			else if(type == 9)
			{
				std::string str = "城池已重置！";
				if(input.valid())input->setString(str);
			}
			else if(type == 10)
			{
				std::string str = "正在生成，请查看根目录下《玩家信息列表.tab》！";
				if(input.valid())input->setString(str);
			}
			else if(type == 11)
			{
				ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
				data->getParam(WCHDATA_JXJFubenProgressMap,param);
				FubenProgressMap *fubenprogressmap = (FubenProgressMap *)param;
				ref_ptr<crFubenInfo> fubeninfo = NULL;
				for (int i = 0; i < fubentab->getRowCount(); ++i)
				{
					fubeninfo = new crFubenInfo;
					fubeninfo->setComplete(1);
					fubenprogressmap->insert(std::make_pair(atoi((*fubentab)(i,0).c_str()),fubeninfo));
				}
				std::string str = "副本通关";
				if(input.valid())input->setString(str);
			}
			else if(type == 12)
			{
				unsigned short chengchiid = m_stream->_readUShort();
				data -> inputParam(WCHDATA_JXJChengchiID, &chengchiid);
				std::string str = "副本通关";
				if(input.valid())input->setString("已重置，城池ID：" + crArgumentParser::appItoa(chengchiid));
			}
			else if(type == 13)
			{
				unsigned char lv = m_stream->_readUChar();
				int exp = m_stream->_readInt();
				crRole *mainRole = m_this->getMainRole();
				if (mainRole)
				{
					crData *mainroledata = mainRole->getDataClass();
					mainroledata->inputParam(WCHDATA_Experience,&exp);
					mainroledata->inputParam(WCHDATA_Level,&lv);
					std::string str = "已经执行";
					if(input.valid())input->setString(str);
				}
			}
			else if(type == 14)
			{
				data->inputParam(WCHDATA_JXJPlayerChangeShiliTimes,0);
				unsigned char rewardcount = m_stream->_readUChar();
				data->inputParam(WCHDATA_JXJLandRewardGetCount,&rewardcount);
				std::string str = "叛国次数和登录奖励已经重置";
				if(input.valid())input->setString(str);
			}
			else if(type == 40)
			{
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if(type == 41)
			{
				bool success = m_stream->_readBool();
				std::string str;
				if (success)
				{
					str= "指令已执行！";
				}
				else
				{
					str= "修改失败！";
				}
				if(input.valid())input->setString(str);
			}
			else if(type == 42)
			{
				short progress = m_stream->_readShort();
				if(input.valid())input->setString("关卡进度:"+crArgumentParser::appItoa(progress));
			}
			else if (type == 50)
			{
				data->inputParam(WCHDATA_JXJLingqufengluFlag, 0);
			}
			else if(type == 55)
			{
				data->inputParam(WCHDATA_JXJFoundCountryGetAward,NULL);
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if (type == 60)
			{
				unsigned char changeshiliid = m_stream->_readUChar();
				std::string str = "指令已执行！势力ID已变为" + crArgumentParser::appItoa(changeshiliid);
				if (input.valid())input->setString(str);
				data->inputParam(WCHDATA_JXJShiliID, &changeshiliid);
				int time = 0;
				data->inputParam(WCHDATA_JXJTreasonPunishTimer, &time);

				
				unsigned short  mychengchiID = 0;

				ref_ptr<crTableIO>shiliTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
				crTableIO::StrVec record;
				if(shiliTab->queryOneRecord(0,crArgumentParser::appItoa(changeshiliid),record)>=0)
				{
					int chengchiindex = shiliTab->getTitleIndex("默认城池");
					mychengchiID = (unsigned short)(atoi(record[chengchiindex].c_str()));
					data->inputParam(WCHDATA_JXJChengchiID,&mychengchiID);
				}
			}
			else if (type == 62)
			{
				short count = m_stream->_readShort();
				std::string str = "指令已执行(该设置不要超过5000)，剩余玩家数量:" + crArgumentParser::appItoa(count);
				if (input.valid())input->setString(str);
			}
			else if (type == 63)
			{
				std::string date = m_stream->_readString();
				std::string str = "指令已执行，开服时间为：" + date;
				if (input.valid())input->setString(str);
			}
			else if (type == 68)
			{
				int coolingtime = 0;
				data->inputParam(WCHDATA_JXJTreasonCoolingTimer,&coolingtime);
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if (type == 69)
			{
				int cancelCantonTimer = m_stream->_readInt();
				data->inputParam(WCHDATA_JXJCancelCantonTimer, &cancelCantonTimer);
				std::string str = "指令已执行！";
				if (input.valid())
				{
					input->setString(str);
				}
			}
			else if (type == 71)
			{
				void *param;
				int zhanquancount = m_stream->_readInt();
				data->excHandle(MAKECREPARAM(WCH_LockData, 1));
				data->getParam(WCHDATA_JXJZhengZhanQuan,param);
				int * count = (int *)param;
				*count = *count + zhanquancount;
				data->excHandle(MAKECREPARAM(WCH_LockData, 0));
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Zhanquan,zhanquancount));
				/*std::string str = "指令已执行！";
				if(input.valid())input->setString(str);*/
			}
			else if (type == 73)
			{
				bool hadwontoday = false;
				data->inputParam(WCHDATA_JXJHadWonJunTuanFBT,&hadwontoday);
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if (type == 74)
			{
				//unsigned char loadtype = m_stream->_readUChar();
				//crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
				//if(netConductor)
				//{
				//	crPlayerDataEventPacket packet;
				//	ref_ptr<crStreamBuf> stream = new crStreamBuf;
				//	stream->createBuf(4);
				//	int id = 0;
				//	switch (loadtype)
				//	{
				//	case JXJFileD_HuodongTab:
				//		id = WCHDATA_JXJHuodongTab;
				//		break;
				//	case JXJFileD_OnlinerewardTab:
				//		id = WCHDATA_JXJOnlineRewardTab;
				//		break;
				//	case JXJFileD_HuoyueduRewardTab:
				//		id = WCHDATA_JXJHuoyueduRewardTab;
				//		break;
				//	case JXJFileD_itemTab:
				//		id = WCHDATA_JXJItemTab;
				//		break;
				//	case JXJFileD_jxjtasktitleTab:
				//		id = WCHDATA_JXJTaskTitleTab;
				//		break;
				//	case JXJFileD_SiteTab:
				//		id = WCHDATA_JXJSiteTab;
				//		break;
				//	case JXJFileD_ForeignCardTab:
				//		id = WCHDATA_JXJForeignCardTab;
				//		break;
				//	case JXJFileD_7DayNewTab:
				//		id = WCHDATA_JXJ7DayTab;
				//		break;
				//	default:
				//		break;
				//	}
				//	ref_ptr<crTableIO> updateTab = crGlobalHandle::gData()->gGlobalTable(id);
				//	if (updateTab.valid())
				//	{
				//		int tabVersionIdx = updateTab->getTitleIndex("TAB_VERSION");
				//		int tabVersion = atoi((*updateTab)(0,tabVersionIdx).c_str()); 
				//		if (tabVersion > 0)
				//		{
				//			stream->_writeInt(id);
				//			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryTabVersion,stream.get());
				//			netConductor->getNetManager()->sendPacket("all",packet);
				//			std::string str = "指令已执行！";
				//			if(input.valid())input->setString(str);
				//		}
				//	}
				//}
				std::string str = "指令已执行！";
				if (input.valid())input->setString(str);
			}
			else if (type == 81)
			{
				bool hadGotten = false;
				data->inputParam(WCHDATA_JXJHadGottenConsortiaPromotionReward,&hadGotten);
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if (type == 82)
			{
				void *param;
				int zhanquancount = m_stream->_readInt();
				data->excHandle(MAKECREPARAM(WCH_LockData, 1));
				data->getParam(WCHDATA_JXJAchievePointsCount,param);
				int * count = (int *)param;
				*count = *count + zhanquancount;
				data->excHandle(MAKECREPARAM(WCH_LockData, 0));
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_AchievePoint,zhanquancount));
				/*std::string str = "指令已执行！";
				if(input.valid())input->setString(str);*/
			}
			else if (type == 84)
			{
				std::string str = "指令已执行！";
				if(input.valid())input->setString(str);
			}
			else if (type == 87)
			{
				std::string str = "指令已执行！";
				if (input.valid())input->setString(str);
				crRole *mainRole = m_this->getMainRole();
				if (mainRole)
				{
					crData *roledata = mainRole->getDataClass();
					void *param;
					roledata->lock();
					roledata->inputParam(WCHDATA_JXJSuperEquipLvupPoint, NULL);
					roledata->inputParam(WCHDATA_JXJExpPelletBuyTimes, NULL);
					roledata->inputParam(WCHDATA_JXJSuperEquipZhulingData, NULL);
					roledata->getParam(WCHDATA_JXJSuperEquipDataVec, param);
					SuperEquipDataVec *superEquipDataVec = (SuperEquipDataVec*)param;
					superEquipDataVec->clear();
					roledata->unlock();
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIKnapsackItemTipInfoMethod
//
/////////////////////////////////////////
crJXJUIKnapsackItemTipInfoMethod::crJXJUIKnapsackItemTipInfoMethod():
	m_ea(NULL),
	m_this(NULL),
	m_index(0)
{
}
crJXJUIKnapsackItemTipInfoMethod::crJXJUIKnapsackItemTipInfoMethod(const crJXJUIKnapsackItemTipInfoMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_name(handle.m_name),
	m_info1(handle.m_info1),
	m_info2(handle.m_info2),
	m_itemlv(handle.m_itemlv),
	m_itemicon(handle.m_itemicon),
	m_itemequipon(handle.m_itemequipon),
	m_canvas(handle.m_canvas),
	m_colorred(handle.m_colorred),
	m_infocanvas(handle.m_infocanvas),
	m_infobk(handle.m_infobk),
	m_infodi(handle.m_infodi),
	m_offsets(handle.m_offsets),
	m_ea(NULL),
	m_this(NULL),
	m_index(0)
{
}
void crJXJUIKnapsackItemTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIKnapsackItemTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_name = str;
		break;
	case 2:
		m_info1 = str;
		break;
	case 3:
		m_info2 = str;
		break;
	case 4:
		m_itemlv = str;
		break;
	case 5:
		m_itemicon = str;
		break;
	case 6:
		m_itemequipon = str;
		break;
	case 7:
		m_canvas = str;
		break;
	case 8:
		m_infocanvas = str;
		break;
	case 9:
		m_infobk = str;
		break;
	case 10:
		m_infodi = str;
		break;
	case 11:
		crArgumentParser::appAtoVec(str,m_offsets);
		break;
	case 12:
		crArgumentParser::appAtoVec(str,m_colorred);//red
		m_colorred /= 255.0f;
		break;
	case 13:
		m_index = atof(str.c_str());
		break;
	}
}
void crJXJUIKnapsackItemTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	ref_ptr<crCanvasNode>infocanvas = crFilterRenderManager::getInstance()->findCanvas(m_infocanvas);
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(tipsCanvas.valid() && playerData && infocanvas.valid())
	{
		void *param;
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		ref_ptr<crTableIO>qualitytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJQualityTab);
		ref_ptr<crTableIO>lordequiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		crTableIO::StrVec record,lordrecord,equiprecord;
		ref_ptr<crStaticTextWidgetNode> name = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_name));
		//ref_ptr<crStaticTextWidgetNode> info1 = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_info1));
		ref_ptr<crStaticTextWidgetNode> itemlv = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_itemlv));
		ref_ptr<crImageBoxWidgetNode> itemicon = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_itemicon));
		ref_ptr<crStaticTextWidgetNode> itemequipon = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_itemequipon));
		//
		ref_ptr<crHypertextWidgetNode> info2 = dynamic_cast<crHypertextWidgetNode *>(infocanvas->getWidget(m_info2));
		crMatrixTransform *infobk = dynamic_cast<crMatrixTransform *>(infocanvas->getChildNode(m_infobk));
		crMatrixTransform *infodi = dynamic_cast<crMatrixTransform *>(infocanvas->getChildNode(m_infodi));
		if (name.valid())
		{
			name->clearString();
		}
		//if (info1)
		//{
		//	info1->clearString();
		//}
		if (info2.valid())
		{
			info2->clearText();
		}
		if (itemlv.valid())
		{
			itemlv->clearString();
		}
		if (itemicon.valid())
		{
			itemicon->clearImage();
		}
		if (itemequipon.valid())
		{
			itemequipon->clearString();
		}
		crRole *mainRole = playerData->getMainRole();
		crData *roleData = mainRole->getDataClass();
		roleData->getParam(WCHDATA_Level,param);
		unsigned char rolelv = *(unsigned char *)param;
		ref_ptr<crListControlNode> selectNode = m_this->getSelectNode();
		crData *data = playerData->getDataClass();
		data->getParam(WCHDATA_JXJOpenBagNum,param);
		unsigned char openbagnum = *(unsigned char *)param;
		int itemid = 0;
		_crInt32 equipmagic = 0;
		crVector4f colormode;//white,green,blue,purple,orange
		crTableIO::StrVec colorrecord;
		int qualityindex = qualitytab->getTitleIndex("color");
		if(selectNode.valid() && canvas.valid())
		{
			int selectid = selectNode->getData();
			if (selectid>=0 && selectid<openbagnum && !canvas->getVisiable())
			{
				void *param;
				int ifequipvalid = -1;
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				roleData->getParam(WCHDATA_JXJLordEquipVec,param);
				JXJLordEquipVec lordequipvec = *(JXJLordEquipVec *)param;
				if ((*itembagvec)[selectid]!=NULL)
				{
					itemid = (*itembagvec)[selectid]->getItemID();
					if(itemid>0)
					{
						equipmagic = (*itembagvec)[selectid]->getEquipMagic();
						//int tnameindex = lordequiptab->getTitleIndex("称号");

						int iconindex = itemtab->getTitleIndex("icon");
					//	int info2index = itemtab->getTitleIndex("功能");
						int nameindex = itemtab->getTitleIndex("name");
						int typeindex = itemtab->getTitleIndex("类型");
						int colorindex = itemtab->getTitleIndex("品质");
						int needlvindex = itemtab->getTitleIndex("人物等级");
						//int shuxingindex = itemtab->getTitleIndex("物品描述");
						int partidindex = lordequiptab->getTitleIndex("partid");
						
						if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
						{
							if (m_index == 0)
							{
								ifequipvalid = 1;
							}
							else if(m_index == 1 && atoi(record[typeindex].c_str()) == IT_Equip)
							{
								if(lordequiptab->queryOneRecord(0,crArgumentParser::appItoa(itemid),equiprecord) >= 0 )
								{
									int partid = atoi(equiprecord[partidindex].c_str());
									if (partid < lordequipvec.size())
									{
										if((lordequipvec)[partid].first!=NULL)
										{
											itemid = (lordequipvec)[partid].first;
											equipmagic = (lordequipvec)[partid].second;
											ifequipvalid = itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record);
										}
									}
								}
							}
							if (ifequipvalid >= 0)
							{
								if(qualitytab->queryOneRecord(0,record[colorindex],colorrecord) >= 0 )
								{
									crArgumentParser::appAtoVec(colorrecord[qualityindex],colormode);
									colormode /= 255.0f;
								}
								int colormodeid = atoi(record[colorindex].c_str());
								if(name.valid())
								{
									name->setColor(colormode);
									name->setBackdropType(CRText::crText::OUTLINE);
									//name->setBackdropOffset(crVector2f(0.008f,0.008f));
									//name->setBackdropColor(colormode[colormodeid]);
									name->setString(record[nameindex]);
								}
								std::string file;
								if (itemlv.valid())
								{
									if (rolelv < atoi(record[needlvindex].c_str()))//人物等级不足时显示红字
									{
										itemlv->setColor(FCOLOR_RED);
										if (itemequipon.valid())
										{
											itemequipon->setColor(FCOLOR_RED);
										}
									}
									else
									{
										itemlv->setColor(FCOLOR_BLACK);
										if (itemequipon.valid())
										{
											itemequipon->setColor(FCOLOR_GREEN);
										}
									}
									itemlv->setString(record[needlvindex]);
								}
								if (itemicon.valid())
								{
									itemicon->setImageName(record[iconindex]);
								}
								if (itemequipon.valid())
								{
									std::string str;// = "未使用";
									if (atoi(record[typeindex].c_str()) == IT_Equip)
									{
										if (m_index == 1)
										{
											str = "已装备";
										}
										else
										{
											str = "未装备";
										}
										//if (lordequiptab->queryOneRecord(0,crArgumentParser::appItoa(itemid),lordrecord) >= 0 )
										//{
											//if(info1)
											//{
											//	info1->setColor(colormode[colormodeid]);
											//	info1->setString(lordrecord[tnameindex]);
											//}
										//}
									}
									itemequipon->setString(str);
								}
								if(info2.valid())
								{
									ItemMap itemMap;
									rcfg::ConfigScript outscript(&itemMap);
									crVector2i item(itemid,equipmagic);
									playerData->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
									info2->setHypertext(outscript);
								}

								/////////////////////////////////////////

								///////////计算缩放
								float boxYlength = infobk->getChild(0)->getBoundBox().yLength()/**crDisplaySettings::instance()->getUIViewScale()[1]*/;
								info2->updateData();
								const crBoundingBox &bbox = info2->getTextObject()->getBoundBox();
								const crBoundingBox &bbox2 = info2->getBoundBox();
								float texheight = 0.0f;
								float needmove = 0.0f;
								if(bbox.valid())
								{
									texheight = bbox.yLength();
									texheight *= crDisplaySettings::instance()->getUIPixelMeter() * crDisplaySettings::instance()->getUIHeightScale()/crDisplaySettings::instance()->getUIScaleFactor();
									if(texheight<boxYlength) texheight = boxYlength;
									float scale = texheight/boxYlength;

									float needmove ;
									const crBoundingBox &tipsbb = tipsCanvas->getBoundBox();
									crVector3 centerTansTar = info2->getBound().center();

									float tmpLength = bbox2.yLength();
									if(infodi)
									{
										float diYlength = infodi->getChild(0)->getBoundBox().yLength();
										centerTansTar[1] += 0.5f * (tmpLength - texheight) + 0.125f * diYlength;
										//centerTansTar[1] += 0.5f * (tmpLength - texheight);
									}
									else
										centerTansTar[1] += 0.5f * (tmpLength - texheight);
									// 源中心点
									crVector3 centerTansSrc = infobk->getChild(0)->getBoundBox().center();
									// 将源中心点平移到原点
									crMatrix put_mat = crMatrix::translate(centerTansSrc);
									crMatrix inv_put = crMatrix::inverse(put_mat);
									crMatrix rotmat;
									rotmat.postMult(inv_put);
									rotmat.postMult(crMatrix::scale(1.0f,scale,1.0f));
									rotmat.postMult(crMatrix::translate(centerTansTar));
									if(infobk)infobk->setMatrix(rotmat);

									if(infodi)
									{
										float diYlength = infodi->getChild(0)->getBoundBox().yLength();
										needmove = boxYlength - texheight + diYlength * 0.125f;
										//needmove = diYlength*0.5f*(scale-1.0f) - needmove;
										//needmove = boxYlength - texheight;
										infodi->setMatrix(crMatrix::translate(0.0f,needmove/*+c_tipsoffsets[2]*scale*/,0.0f));
									}
								}
								else
								{
									infobk->setMatrix(crMatrix::scale(1.0f,1.0f/*m_expandnum*/,1.0f) * crMatrix::translate(0.0f,0.0f,0.0f));
									if(infodi) infodi->setMatrix(crMatrix::translate(0.0f,0.0f,0.0f));
								}
								////计算窗口坐标位置
								crVector4f rect = selectNode->getRect();
								const crBoundingBox &tips = tipsCanvas->getBoundBox();
								float posx = (tips.m_max[0]-tips.m_min[0])*0.5;
								float posy = (tips.m_max[1]-tips.m_min[1])*0.5;
								//const crMatrix &mat = crListControlWidgetNode::getMvpwNode()->getMatrix();
								CRCore::crMatrixTransform *m_mvpwNode = m_this->getMvpwNode();
								const crMatrix &mat = m_mvpwNode->getMatrix() * m_this->getParentCanvas()->getMatrix();
								crVector4f rectoffset = m_this->getRectOffset();
								//crMatrix invmat = crMatrix::inverse(mat);
								crVector3 pos(rect[2] + rect[0]  + rectoffset[0],rect[1] - rect[3] - rectoffset[1],0.0f);
								crVector3 ipos = pos * mat;
								/////////////////////////////////////////
								crVector3 pos2(rect[0] ,rect[1],0.0f);
								crVector3 ipos2 = pos2 * mat;
								float posx2,posy2;
								//const crBoundingBox &infos = infobk->getBoundBox();
								//float posinfox = infos.xLength();//(infos.m_max[0]-infos.m_min[0]);
								//float posinfoy = infos.yLength();//infos.m_max[1]-infos.m_min[1]);
								float boxXlength = infobk->getChild(0)->getBoundBox().xLength();
								if (ipos2[0] >= 0)
								{
									boxXlength = -boxXlength;
									posx2 = ipos2[0] - posx;
								}
								else
								{
									posx2 = ipos[0] + posx;
								}
								if (ipos2[1] >= 0)
								{
									posy2 = ipos[1] - posy;
								}
								else
								{
									posy2 = ipos2[1] + posy - needmove;// + posinfoy;
								}
								crVector2 mouse(crVector2(posx2,posy2));
								/////////////////////////////////////////
								float needmovex = 0;
								if (m_index == 1)
								{
									needmovex += boxXlength;
								}
								//////////////////////////
								//crVector2 mouse(m_ea->getXnormalized()-posx,m_ea->getYnormalized()-posy);
								tipsCanvas->setMatrix(crMatrix::translate(mouse[0] + needmovex,mouse[1],0.0f));
								tipsCanvas->setCanFocus(false);
								infocanvas->setCanFocus(false);

								infocanvas->setMatrix(crMatrix::translate(mouse[0] + needmovex,mouse[1],0.0f));//(crMatrix::translate(mouse[0],mouse[1]-posy*2.0f-tipsCanvas->getBoundBox().yLength()*0.5f,0.0f));
								crFilterRenderManager::getInstance()->showCanvas(infocanvas.get(),true);
								crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
							}
							else
							{
								crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
								crFilterRenderManager::getInstance()->showCanvas(infocanvas.get(),false);
							}
						}
					}
				}
				else
				{
					crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
					crFilterRenderManager::getInstance()->showCanvas(infocanvas.get(),false);
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			else
			{
				crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
				crFilterRenderManager::getInstance()->showCanvas(infocanvas.get(),false);
			}
		}
		else
		{
			crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
			crFilterRenderManager::getInstance()->showCanvas(infocanvas.get(),false);
		}
	}
}	


/////////////////////////////////////////
//
//crJXJUILordEquipUpdateMethod
//
/////////////////////////////////////////
crJXJUILordEquipUpdateMethod::crJXJUILordEquipUpdateMethod()
{
}
crJXJUILordEquipUpdateMethod::crJXJUILordEquipUpdateMethod(const crJXJUILordEquipUpdateMethod& handle):
	crMethod(handle),
	m_armyRadio(handle.m_armyRadio)
{
}
void crJXJUILordEquipUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crJXJUILordEquipUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_armyRadio = str;
		break;
	}
}
void crJXJUILordEquipUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
	if(playerData && itemTab.valid())
	{
		crData *data = playerData->getDataClass();
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crRadioGroupWidgetNode> armyRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_armyRadio));
		crRadioGroupWidgetNode::RadioGroup &radioGroup = armyRadioGroup->getRadioGroup();
		int armType;
		if (armyRadioGroup.valid())
		{
			armType = armyRadioGroup->getSelect();
		}
		ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		int equiptitleid = itemTab->getTitleIndex("itemid");
		int lvid = itemTab->getTitleIndex("等级");
		int paperid = troopsEquipTab->getTitleIndex("图纸");
		crTableIO::DataVec recordVec;
		crTableIO::StrVec record,record2;
		itemTab->queryRecords(lvid,crArgumentParser::appItoa(armType),recordVec);
		std::set<int>EquipSet;
		int equipid;
		for( crTableIO::DataVec::iterator itr = recordVec.begin();
			itr != recordVec.end();
			++itr )
		{
			equipid = atoi((*itr)[equiptitleid].c_str());
			if(equipid>0)
				EquipSet.insert(equipid);
		}
		int iconid = itemTab->getTitleIndex("icon");
		int nameid = itemTab->getTitleIndex("name");
		m_this->setListNodeCount(EquipSet.size());
		crListControlWidgetNode::ListNodeVec& listNodeVec = m_this->getListNodeVec();
		std::string iconfile;
		ref_ptr<crListControlNode> listNode;
		int i = 0;
		int result = 0;
		void *param;
		for( std::set<int>::iterator itr = EquipSet.begin();
			itr != EquipSet.end();
			++itr,++i )
		{
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			if (
				troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(*itr),record) >= 0
				&& itemTab->queryOneRecord(0,crArgumentParser::appItoa(*itr),record2) >= 0 )
			{
				int paperid2 = atoi(record[paperid].c_str());
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				JXJItemBagVec::iterator itr2;
				for (itr2 = itembagvec->begin();itr2!=itembagvec->end();++itr2)
				{
					if(*itr2!=NULL)
					{
						if((*itr2)->getItemID() == paperid2 && (*itr2)->getItemCount()>0)
						{
							result = 1;
							break;
						}
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				iconfile = record2[iconid];
				listNodeVec[i]->setData(*itr);
				listNodeVec[i]->setImageName(iconfile);
				listNodeVec[i]->setTitle(record2[nameid]);
				listNodeVec[i]->setVisiable(true);
				listNodeVec[i]->setEnable(true);
				if (!result)
				{
					listNodeVec[i]->setEnable(false);
				}
			}
		}
		m_this->select(0);
	}
}
/////////////////////////////////////////
//
//crJXJUILairdEquipUpdateMethod
//
/////////////////////////////////////////
crJXJUILairdEquipUpdateMethod::crJXJUILairdEquipUpdateMethod():
m_characterSize(15),
m_textColor(120.0f,220.0f,50.0f,255.0f)
{}
crJXJUILairdEquipUpdateMethod::crJXJUILairdEquipUpdateMethod(const crJXJUILairdEquipUpdateMethod& handle):
	crMethod(handle),
	m_GLList(handle.m_GLList),
	m_money(handle.m_money),
	m_material1(handle.m_material1),
	m_material2(handle.m_material2),
	m_material3(handle.m_material3),
	m_moneycount(handle.m_moneycount),
	m_matecount1(handle.m_matecount1),
	m_matecount2(handle.m_matecount2),
	m_matecount3(handle.m_matecount3),
	m_equippic(handle.m_equippic),
	m_makeBtn(handle.m_makeBtn),
	m_info(handle.m_info),
	m_tips(handle.m_tips),
	m_tiptext(handle.m_tiptext),
	m_characterSize(handle.m_characterSize),
	m_textColor(handle.m_textColor),
	m_lordEquipLv1(handle.m_lordEquipLv1),
	m_lordEquipLv2(handle.m_lordEquipLv2),
	m_lordEquipLv3(handle.m_lordEquipLv3),
	m_lordEquipLv4(handle.m_lordEquipLv4),
	m_lordEquipLv5(handle.m_lordEquipLv5),
	m_lordEquipLv6(handle.m_lordEquipLv6)
{
	for(int i = 0; i < 3; i++)
	{
		m_buybtn[i] = handle.m_buybtn[i];
	}
}
void crJXJUILairdEquipUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUILairdEquipUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_GLList = str;
		break;
	case 1:
		m_money = str;
		break;
	case 2:
		m_material1 = str;
		break;
	case 3:
		m_material2 = str;
		break;
	case 4:
		m_material3 = str;
		break;
	case 5:
		m_moneycount = str;
		break;
	case 6:
		m_matecount1 = str;
		break;
	case 7:
		m_matecount2 = str;
		break;
	case 8:
		m_matecount3 = str;
		break;
	case 9:
		m_equippic = str;
		break;
	case 10:
		m_makeBtn = str;
		break;
	case 11:
		m_info = str;
		break;
	case 12:
		m_tips = str;
		break;
	case 13:
		m_tiptext = str;
		break;
	case 14:
		m_lordEquipLv1 = str;
		break;
	case 15:
		m_lordEquipLv2 = str;
		break;
	case 16:
		m_lordEquipLv3 = str;
		break;
	case 17:
		m_lordEquipLv4 = str;
		break;
	case 18:
		m_lordEquipLv5 = str;
		break;
	case 19:
		m_lordEquipLv6 = str;
		break;
	case 20:
		m_buybtn[0] = str;
		break;
	case 21:
		m_buybtn[1] = str;
		break;
	case 22:
		m_buybtn[2] = str;
		break;
	}
}
void crJXJUILairdEquipUpdateMethod::operator()(crHandle &handle)
{
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && player)
	{
		ref_ptr<crRadioGroupWidgetNode> GLList = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_GLList));
		ref_ptr<crStaticTextWidgetNode> money = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_money));
		ref_ptr<crStaticTextWidgetNode> material1 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_material1));
		ref_ptr<crStaticTextWidgetNode> material2 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_material2));
		ref_ptr<crStaticTextWidgetNode> material3 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_material3));
		ref_ptr<crStaticTextWidgetNode> moneycount = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_moneycount));
		ref_ptr<crStaticTextWidgetNode> matecount1 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_matecount1));
		ref_ptr<crStaticTextWidgetNode> matecount2 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_matecount2));
		ref_ptr<crStaticTextWidgetNode> matecount3 = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_matecount3));
		ref_ptr<crImageBoxWidgetNode> equippic = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_equippic));
		ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_makeBtn));
		ref_ptr<crHypertextWidgetNode> info = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_info));
		ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
		if(!tips.valid())
			return;
		ref_ptr<crStaticTextWidgetNode> tipsText = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_tiptext));
		ref_ptr<crRadioWidgetNode> lordEquipLv1 = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_lordEquipLv1));
		ref_ptr<crRadioWidgetNode> lordEquipLv2 = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_lordEquipLv2));
		ref_ptr<crRadioWidgetNode> lordEquipLv3 = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_lordEquipLv3));
		ref_ptr<crRadioWidgetNode> lordEquipLv4 = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_lordEquipLv4));
		ref_ptr<crRadioWidgetNode> lordEquipLv5 = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_lordEquipLv5));
		ref_ptr<crRadioWidgetNode> lordEquipLv6 = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_lordEquipLv6));
		ref_ptr<crButtonWidgetNode> buybtn[3] = {NULL};
		for (int i = 0; i < 3;i++)
		{
			buybtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_buybtn[i]));
			if (buybtn[i].valid())
			{
				buybtn[i]->setVisiable(false);
			}
		}
		if(lordEquipLv1.valid())lordEquipLv1->setVisiable(false);
		if(lordEquipLv2.valid())lordEquipLv2->setVisiable(false);
		if(lordEquipLv3.valid())lordEquipLv3->setVisiable(false);
		if(lordEquipLv4.valid())lordEquipLv4->setVisiable(false);
		if(lordEquipLv5.valid())lordEquipLv5->setVisiable(false);
		if(lordEquipLv6.valid())lordEquipLv6->setVisiable(false);
		void *param;
		crData *canvasdata = m_this->getDataClass();
		crRole *mainrole = player->getMainRole();
		crData *roledata = mainrole->getDataClass();
		roledata->getParam(WCHDATA_Level,param);
		unsigned char roleLv = *(unsigned char *)param;
		if (roleLv >= 20)
		{
			if(lordEquipLv1.valid())lordEquipLv1->setVisiable(true);
		} 
		if (roleLv >= 30)
		{
			if(lordEquipLv2.valid())lordEquipLv2->setVisiable(true);
		}
		if (roleLv >= 40)
		{
			if(lordEquipLv3.valid())lordEquipLv3->setVisiable(true);
		}
		if (roleLv >= 50)
		{
			if(lordEquipLv4.valid())lordEquipLv4->setVisiable(true);
		}
		if (roleLv >= 60)
		{
			if(lordEquipLv5.valid())lordEquipLv5->setVisiable(true);
		}
		if (roleLv >= 70)
		{
			if(lordEquipLv6.valid())lordEquipLv6->setVisiable(true);
		}
		///////////////////////////////////////////////////////
		std::string str,warning;	
		if(info.valid())
		{		
			info->clearText();
		}
	    if(equippic.valid())
		{	
			equippic->setVisiable(false);
		}
		if(money.valid())money->setString(L"铜钱");
		if(material1.valid())material1->setString(L"材料");
		if(material2.valid())material2->setString(L"材料");
		if(material3.valid())material3->setString(L"材料");
		if(moneycount.valid())moneycount->setString(L"");
		if(matecount1.valid())matecount1->setString(L"");
		if(matecount2.valid())matecount2->setString(L"");
		if(matecount3.valid())matecount3->setString(L"");
		if(btn.valid())btn->setEnable(false);
		/////////////////////
		int equipid = 0;
		if (canvasdata)
		{
			canvasdata->getParam(WCHDATA_JXJCurSelForgeLordEquipID,param);
			equipid = *(int *)param;
		}
		// if (GLList)
		if(equipid <= 0)
		{
			warning = "缺少图纸";
		}
		if (equipid > 0)
		{
			int selectindex = GLList->getSelect();
			if(selectindex>=0)
			{
				bool btnenable = true;
				crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
				crData *data = myPlayer->getDataClass();
				//if(papercount){str = "1";papercount->setString(str);}
				ref_ptr<crTableIO>lairdEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
				int moneyid = lairdEquipTab->getTitleIndex("铜钱");
				int equipidindex = lairdEquipTab->getTitleIndex("equipid");
				//int mate4id = lairdEquipTab->getTitleIndex("材料4");
				int paperid = lairdEquipTab->getTitleIndex("图纸");
				int mate1id = lairdEquipTab->getTitleIndex("材料1");
				int mate2id = lairdEquipTab->getTitleIndex("材料2");
				int mate3id = lairdEquipTab->getTitleIndex("材料3");
				int infoindex = lairdEquipTab->getTitleIndex("条件");
				crTableIO::StrVec record,record1,record2,record3,record4,paperrecord;
				std::string file;
				if(lairdEquipTab->queryOneRecord(paperid,crArgumentParser::appItoa(equipid),record) >= 0 )
				{
					//if(info)
					//{
					//	file = record[infoindex];
					//	if(!file.empty())
					//	{
					//		file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
					//		info->setHypertext(file);
					//	}
					//	else
					//	{
					//		info->clearText();
					//	}
					//}
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					if(money.valid())
					{
						str = "铜钱";
						money->setString(str);
					}
					if(moneycount.valid())
					{
						moneycount->setColor(crVector4f(0,0,0,255));
						data->getParam(WCHDATA_JXJCoppercash,param);
						int mymoney = *(int *)param;
						if (mymoney<atoi(record[moneyid].c_str()))
						{
							moneycount->setColor(crVector4f(255,0,0,255));
							btnenable = false;
							warning = str + "不足";
						}
						moneycount->setString(crArgumentParser::appItoa(mymoney) + "/" + record[moneyid]);
					}
					std::string paperid2 = record[paperid];
					crVector2i mate1,mate2,mate3;
					crArgumentParser::appAtoVec(record[mate1id],mate1);
					crArgumentParser::appAtoVec(record[mate2id],mate2);
					crArgumentParser::appAtoVec(record[mate3id],mate3);
					ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					int matenameid = itemTab->getTitleIndex("name");
					int iconid = itemTab->getTitleIndex("icon");
					int miaoshuid = itemTab->getTitleIndex("物品描述");
					
					int query1 = itemTab->queryOneRecord(0,crArgumentParser::appItoa(mate1[0]),record1);
					int query2 = itemTab->queryOneRecord(0,crArgumentParser::appItoa(mate2[0]),record2);
					int query3 = itemTab->queryOneRecord(0,crArgumentParser::appItoa(mate3[0]),record3);
					int query4 = itemTab->queryOneRecord(0,record[equipidindex],record4);
					int querypaper = itemTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),paperrecord);
					if(material1.valid())material1->setString(query1 >= 0?record1[matenameid]:"");
					if(material2.valid())material2->setString(query2 >= 0?record2[matenameid]:"");
					if(material3.valid())material3->setString(query3 >= 0?record3[matenameid]:"");					
					if(info.valid())
					{		
						file = paperrecord[miaoshuid];
						std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						cfg_script.Add("CharacterSize",m_characterSize);
						v_i.clear();
						for (int vi = 0; vi < 4; vi++)
						{
							v_i.push_back(m_textColor[vi]);
						}
						cfg_script.Add("Color",v_i);

						cfg_script.Add("Content");
						cfg_script.Push("Content",1);
						cfg_script.Add("Text",file);
						cfg_script.Pop();

						cfg_script.Pop();
						info->setHypertext(cfg_script);
						//if(!file.empty())
						//{
						//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						//	info->setHypertext(file);
						//}
						//else
						//{
						//	info->clearText();
						//}
					}
					if(equippic.valid())
					{
						equippic->setVisiable(true);
						equippic->setImageName(query4 >= 0?record4[iconid]:"");
					}
					data->getParam(WCHDATA_JXJItemBagVec,param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					int count1 = 0,count2 = 0,count3 = 0;
					for (JXJItemBagVec::iterator itr = itembagvec->begin();
						itr!= itembagvec->end();
						++itr)
					{
						if((*itr)!=NULL)
						{
							if((*itr)->getItemID() == mate1[0])
							{
								count1+=(*itr)->getItemCount();
							}
							if((*itr)->getItemID() == mate2[0])
							{
								count2+=(*itr)->getItemCount();
							}
							if((*itr)->getItemID() == mate3[0])
							{
								count3+=(*itr)->getItemCount();
							}
						}
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					canvasdata->getParam(WCHDATA_JXJGongFangMaterialVec,param);
					GongFangMaterialVec *matevec = (GongFangMaterialVec *)param;
					matevec->clear();
					ref_ptr<crBagItemData> matedata;
					int needitemcount = 0;
					if(matecount1.valid() && query1 >= 0)
					{
						needitemcount = 0;
						matecount1->setColor(crVector4f(0,0,0,255));
						if (count1 < mate1[1])
						{
							needitemcount = mate1[1] - count1;
							matecount1->setColor(crVector4f(255,0,0,255));
							btnenable = false;
							warning = record1[matenameid] + "不足";
							if (buybtn[0].valid())
							{
								buybtn[0]->setVisiable(true);
							}
						}
						matecount1->setString(crArgumentParser::appItoa(count1) + "/" + crArgumentParser::appItoa(mate1[1]));
						matedata = new crBagItemData;
						matedata -> setItemID(mate1[0]);
						matedata ->setItemDeductCount(needitemcount);// setItemCount(needitemcount);
						matevec -> push_back(matedata);
					}
					if(matecount2.valid() && query2 >= 0)
					{
						needitemcount = 0;
						matecount2->setColor(crVector4f(0,0,0,255));
						if (count2 < mate2[1])
						{
							needitemcount = mate2[1] - count2;
							matecount2->setColor(crVector4f(255,0,0,255));
							btnenable = false;
							warning = record2[matenameid] + "不足";
							if (buybtn[1].valid())
							{
								buybtn[1]->setVisiable(true);
							}
						}
						matecount2->setString(crArgumentParser::appItoa(count2) + "/" + crArgumentParser::appItoa(mate2[1]));
						matedata = new crBagItemData;
						matedata -> setItemID(mate2[0]);
						matedata ->setItemDeductCount(needitemcount);// setItemCount(needitemcount);
						matevec->push_back(matedata);
					}
					if(matecount3.valid() && query3 >= 0)
					{	
						needitemcount = 0;
						matecount3->setColor(crVector4f(0,0,0,255));
						if (count3 < mate3[1])
						{
							needitemcount = mate3[1] - count3;
							matecount3->setColor(crVector4f(255,0,0,255));
							btnenable = false;
							warning = record3[matenameid] + "不足";
							if (buybtn[2].valid())
							{
								buybtn[2]->setVisiable(true);
							}
						}
						matecount3->setString(crArgumentParser::appItoa(count3) + "/" + crArgumentParser::appItoa(mate3[1]));
						matedata = new crBagItemData;
						matedata -> setItemID(mate3[0]);
						matedata ->setItemDeductCount(needitemcount);// setItemCount(needitemcount);
						matevec->push_back(matedata);
					}
					if(btn.valid())
					{
						btn->setEnable(btnenable);
					}
				}
			}
		}
		tipsText->setString(warning);
	}
}

/////////////////////////////////////////
//
//crJXJUIMakeLordEquipMethod
//
/////////////////////////////////////////
crJXJUIMakeLordEquipMethod::crJXJUIMakeLordEquipMethod():
	m_this(NULL)
{
}
crJXJUIMakeLordEquipMethod::crJXJUIMakeLordEquipMethod(const crJXJUIMakeLordEquipMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_equipList(handle.m_equipList)
{
}
void crJXJUIMakeLordEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIMakeLordEquipMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipList = str;
		break;
	}
}
void crJXJUIMakeLordEquipMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		crData *playerData = myPlayer->getDataClass();
		playerData->getParam(WCHDATA_JXJMakeEquipTechLv,param);
		unsigned char techlv = *(unsigned char *)param;
		if (techlv > 0)
		{
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			//ref_ptr<crListControlWidgetNode> equipList = dynamic_cast<crListControlWidgetNode *>(canvas->getWidget(m_equipList));
			//ref_ptr<crListControlNode> selectNode = equipList->getSelectNode();
			//if(selectNode)
			//{
			//	int selectid = selectNode->getData();
			//if(selectid>0)
			//{
			int equipid = 0;
			int needcount = 1;
			myPlayer->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needcount,NULL));
			if (needcount == 0)
			{
				crData *canvasdata = canvas->getDataClass();
				if (canvasdata)
				{
					canvasdata->getParam(WCHDATA_JXJCurSelForgeLordEquipID,param);
					equipid = *(int *)param;
				}
				if(equipid>0)
				{
					ref_ptr<crTableIO>lairdEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
					int paperid = lairdEquipTab->getTitleIndex("图纸");
					crTableIO::StrVec record;
					if(lairdEquipTab->queryOneRecord(paperid,crArgumentParser::appItoa(equipid),record) >= 0 )
					{
						unsigned char makecount = 1;
						if(makecount>0)
						{
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(5);
							stream->_writeInt(atoi(record[0].c_str()));
							stream->_writeUChar(makecount);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvMakeLordEquip,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
						}
					}
				}
			}
			else
			{
				myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));
			}
		}
		else
		{
			myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2095,NULL));//科技未研发
		}
	}
}

/////////////////////////////////////////
//
//crJXJRecvMakeLordEquipMethod
//
/////////////////////////////////////////
crJXJRecvMakeLordEquipMethod::crJXJRecvMakeLordEquipMethod():
	m_netType(GameClient_Game)
{
}

crJXJRecvMakeLordEquipMethod::crJXJRecvMakeLordEquipMethod(const crJXJRecvMakeLordEquipMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}
void crJXJRecvMakeLordEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvMakeLordEquipMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	}
}

void crJXJRecvMakeLordEquipMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			void *param;
			crData *data = m_this->getDataClass();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{//验证资源是否充足
				int equipid = m_stream->_readInt();
				unsigned char makecount = m_stream->_readUChar();
				char canmake = 0;
				int moneyneed = 0;
				int ironneed = 0;
				int i = 0;
				crVector4i itemneedid;
				crVector4i itemneed;
				do 
				{
					data ->getParam(WCHDATA_JXJMakeEquipTechLv,param);
					unsigned char makeequiptechlv = *(unsigned char *)param;
					if (makeequiptechlv <= 0)
					{
						canmake = -5;//科技未研发
						break;
					}
					ref_ptr<crTableIO>lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
					crTableIO::StrVec record;
					if(lordEquipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record) < 0 )
						break;

					int moneyid = lordEquipTab->getTitleIndex("铜钱");
					int ironid = lordEquipTab->getTitleIndex("材料4");
					int paperid = lordEquipTab->getTitleIndex("图纸");
					int mate1id = lordEquipTab->getTitleIndex("材料1");
					int mate2id = lordEquipTab->getTitleIndex("材料2");
					int mate3id = lordEquipTab->getTitleIndex("材料3");
					crVector2i mate1,mate2,mate3;
					moneyneed = atoi(record[moneyid].c_str());				//所需铜钱
					ironneed = atoi(record[ironid].c_str());				//所需铁矿
					int paperid2 = atoi(record[paperid].c_str());
					crArgumentParser::appAtoVec(record[mate1id],mate1);
					crArgumentParser::appAtoVec(record[mate2id],mate2);
					crArgumentParser::appAtoVec(record[mate3id],mate3);
				
					std::string name;
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					int *mymoney,*myiron;
					int count = 0;
					data->getParam(WCHDATA_JXJItemBagVec,param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					itemneedid = crVector4i(paperid2,mate1[0],mate2[0],mate3[0]);
					itemneed = crVector4i(1,mate1[1],mate2[1],mate3[1]);
					bool checkbagitem = true;
					bool ifempty = false;
					for (i = 0;i < 4;i++)
					{
						count = 0;
						JXJItemBagVec::iterator itr2 = itembagvec->begin();
						for(;itr2!=itembagvec->end();++itr2)
						{
							if((*itr2)!=NULL)
							{
								if ((*itr2)->getItemID() == itemneedid[i])
								{
									count += (*itr2)->getItemCount();
								}
							}
							else if(!ifempty)
							{		
								ifempty = true;
							}
						}
						if(count<itemneed[i])
						{
							checkbagitem = false;
							break;

						}
					}
					if(!ifempty)
					{
						canmake = -4;//背包不足
						data->excHandle(MAKECREPARAM(WCH_LockData,0));
						break;
					}
					if(!checkbagitem)
					{
						canmake = -1;//材料不足
						data->excHandle(MAKECREPARAM(WCH_LockData,0));
						break;
					}
					data->getParam(WCHDATA_JXJCoppercash,param);
					mymoney = (int *)param;
					data->getParam(WCHDATA_JXJIron,param);
					myiron = (int *)param;
					if (*myiron<ironneed)
					{
						canmake = -2;//铁矿不足
						data->excHandle(MAKECREPARAM(WCH_LockData,0));
						break;
					}
					if (*mymoney<moneyneed)
					{
						canmake = -3;//铜钱不足
						data->excHandle(MAKECREPARAM(WCH_LockData,0));
						break;
					}
					///////////////////////
					*mymoney -= moneyneed;
					*myiron -= ironneed;
					for (i = 0;i < 4;i++)
					{
						count = itemneed[i];
						JXJItemBagVec::iterator itr2 = itembagvec->begin();
						for (;itr2!=itembagvec->end();++itr2)
						{
							if((*itr2)!=NULL)
							{
								if ((*itr2)->getItemID()==itemneedid[i])
								{
									if((unsigned short)((*itr2)->getItemCount())>count)
									{
										(*itr2)->setItemCount((*itr2)->getItemCount() - count);
										break;
									}
									else
									{
										count -= (*itr2)->getItemCount();
										//(*itr2)->setItemCount(0);
										(*itr2) = NULL;
										continue;
									}
								}
							}
						}
					}
					/////////////////////////////////////////////////加入队列
					//JXJItemBagVec::iterator itr3 = itembagvec->begin();
					//for (;itr3!=itembagvec->end();++itr3)
					//{
					//	if ((*itr3)==NULL)
					//	{
					//		(*itr3) = itemdata;
					//		break;
					//	}
					//}
					////////////////////////////////////////////////////
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					canmake = 1;
				} while (0);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				if(canmake == 1)
				{
					stream->createBuf(46);
					stream->_writeChar(canmake);
					stream->_writeInt(equipid);//4
					stream->_writeUChar(makecount);//1
					stream->_writeInt(moneyneed);//4
					stream->_writeInt(ironneed);//4
					for(i = 0; i < 4; i++)//4*8=32
					{
						stream->_writeInt(itemneedid[i]);
						stream->_writeInt(itemneed[i]);
					}
				}
				else
				{
					stream->createBuf(1);
					stream->_writeChar(canmake);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvMakeLordEquip,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				if (canmake == 1)
				{
					ref_ptr<crBagItemData> itemdata = new crBagItemData;
					itemdata->setItemID(equipid);
					itemdata->setItemCount(makecount);
					///////装备打造完成后自动执行一次元宝精炼
					ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					ref_ptr<crTableIO>equipRefineQualityTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefineQualityTab);
					crTableIO::StrVec refrecord,itemrec;
					itemtab->queryOneRecord(0,crArgumentParser::appItoa(equipid),itemrec);
					int qualityid = atoi(itemrec[itemtab->getTitleIndex("品质")].c_str());
					crTableIO::DataVec refQualityData;
					equipRefineQualityTab->queryRecords(0,crArgumentParser::appItoa(qualityid),refQualityData);

					ref_ptr<crTableIO>refcreatetab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefineCreateTab);
					crTableIO::StrVec refcreaterecord;
					crVector3ub refid;
					//crVector3ub oldrefid;
					crVector2i vec2;
					int refqualityid = 0;
					int weight = 0;
					int magicproindex = equipRefineQualityTab->getTitleIndex("元宝");
					std::vector<int>WeightVec;
					weight = 0;
					refid[0] = 0;
					refid[1] = 0;
					refid[2] = 0;
					for( crTableIO::DataVec::iterator itr = refQualityData.begin();
						itr != refQualityData.end();
						++itr )
					{
						weight += atoi((*itr)[magicproindex].c_str());
						WeightVec.push_back(weight);
					} 
					rangei weightrnd(1,weight);
					int r,i;
					int weightcount = WeightVec.size();
					for( int ref = 0; ref<3; ++ref )
					{
						//if (iflock[ref] != 1)
						//{
							//随机精炼品质
							refqualityid = 0;
							r = weightrnd.get_random();
							for( i = 0; i<weightcount; i++ )
							{
								if(r<=WeightVec[i])
								{
									refqualityid = atoi(refQualityData[i][1].c_str());
									break;
								}
							}
							//随机ID
							vec2.set(0,256);
							if(refcreatetab->queryOneRecord(0,crArgumentParser::appItoa(refqualityid),refcreaterecord) >= 0)
							{
								crArgumentParser::appAtoVec(refcreaterecord[1],vec2);

							}
							if(refqualityid == 0)
							{
								vec2[0] = 0;
							}
							refid[ref] = getRefidID(ref,vec2,refid);//rangei(vec2[0],vec2[1]).get_random();
						//}
					}
					itemdata->setRefidID(refid[0], refid[1], refid[2]);
					RewardItemVec rewardItems;
					rewardItems.push_back(itemdata);
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				///游戏日志
				std::string logdata = "打造领主装备（canmake，equipid）" + crArgumentParser::appVectoa(crVector2i(canmake,equipid));
				GameLogData gamelog(Log_MakeLordEquip,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char success = m_stream->_readChar();
			if(success > 0)
			{
				void *param;
				crData *braindata = crBrain::getInstance()->getDataClass();
				braindata->getParam(WCHDATA_JXJNewguideMakeLordEquipCount, param);
				int *makeequipcount = (int *)param;
				(*makeequipcount) += 1;
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				int equipid = m_stream->_readInt();
				unsigned char makecount = m_stream->_readUChar();
				int moneyneed = m_stream->_readInt();
				int ironneed = m_stream->_readInt();
				int itemneedid[4];
				int itemneed[4];
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				int *mymoney,*myiron;
				data->getParam(WCHDATA_JXJCoppercash,param);
				mymoney = (int *)param;
				data->getParam(WCHDATA_JXJIron,param);
				myiron = (int *)param;
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				*mymoney-=moneyneed;
				*myiron-=ironneed;
				int count;
				JXJItemBagVec::iterator itr;
				JXJItemBagVec::iterator itr2;
				for( int i = 0; i<4; i++)
				{ 
					itr = itembagvec->begin();
					itemneedid[i] = m_stream->_readInt();
					itemneed[i] = m_stream->_readInt();

					count = itemneed[i];
					for (itr2 = itembagvec->begin();itr2!=itembagvec->end();++itr2)
					{
						if((*itr2)!=NULL)
						{
							if ((*itr2)->getItemID()==itemneedid[i])
							{
								if(((*itr2)->getItemCount())>count)
								{
									(*itr2)->setItemCount((*itr2)->getItemCount() - count);
									break;
								}
								else
								{
									count -= (*itr2)->getItemCount();
									//(*itr2)->setItemCount(0);
									(*itr2) = NULL;
									if (count == 0)
									{
										break;
									}
									else
									{
										continue;
									}
								}
							}
						}
					}
				}
				//ref_ptr<crBagItemData> itemdata = new crBagItemData;
				//itemdata->setItemID(equipid);
				//itemdata->setItemCount(makecount);
				//JXJItemBagVec::iterator itr3 = itembagvec->begin();
				//for (;itr3!=itembagvec->end();++itr3)
				//{
				//	if ((*itr3)==NULL)
				//	{
				//		(*itr3) = itemdata;
				//		break;
				//	}
				//}
				//
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				if(moneyneed !=0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Copper,-moneyneed));
				if(ironneed !=0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Iron,-ironneed));
			}
			else
			{
				int index = 0;
				switch (success)
				{
				case -1:
					index = 2045;//材料不足
					break;
				case -2:
					index = 2048;//铁矿不足
					break;
				case -3:
					index = 2032;//铜钱不足
					break;
				case -4:
					index = 2008;//背包不足
					break;
				case -5:
					index = 2095;//科技未研发
					break;
				default:
					break;
				}
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
			}
		}
	}
}

unsigned char crJXJRecvMakeLordEquipMethod::getRefidID(int refineindex,CRCore::crVector2i vec2,CRCore::crVector3ub refine3ub)
{
	crTableIO::StrVec record[3];
	ref_ptr<crTableIO>equipreftab[3];
	equipreftab[0] = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine0Tab);
	equipreftab[1] = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine1Tab);
	equipreftab[2] = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJEquipRefine2Tab);
	int shuxingid = 0;
	unsigned char refineid = 0;
	bool idvalid = true;
	std::vector<int> shuxingidvec;
	int i = 0, j = 0;
	std::set<unsigned char> IDSet;
	int trycount = 10;
	do 
	{
		trycount--;
		shuxingidvec.clear();
		for (i = 0; i < 3; ++i)
		{
			record[i].clear();
		}
		idvalid = true;
		refineid = rangei(vec2[0],vec2[1]).get_random();			
		if(IDSet.find(refineid)!=IDSet.end())
		{
			continue;
		}
		IDSet.insert(refineid);

		if (equipreftab[refineindex]->queryOneRecord(0,crArgumentParser::appItoa(refineid),record[refineindex]) >= 0)
		{
			int columncount = equipreftab[refineindex]->getColumnCount();
			for (i = 1;i < columncount; ++i)
			{
				if (!record[refineindex][i].empty())
				{
					shuxingidvec.push_back(i);
				}
			}
		}
		for (i = 0; i < 3; ++i)
		{
			if(refine3ub[i] > 0 && i != refineindex)
			{
				if (equipreftab[i]->queryOneRecord(0,crArgumentParser::appItoa(refine3ub[i]),record[i]) >= 0)
				{
					for (j = 0; j < shuxingidvec.size();++j)
					{
						if (!record[i][shuxingidvec[j]].empty())
						{
							idvalid = false;
						}
					}
				}
			}
		}
		if (idvalid)
		{
			break;
		}
		else
		{
			refineid = 0;
		}
	} while (trycount);
	return refineid;
}
/////////////////////////////////////////
//
//crJXJUIOnFriendMailingMethod
//
/////////////////////////////////////////
crJXJUIOnFriendMailingMethod::crJXJUIOnFriendMailingMethod():
	m_this(NULL)
{
}

crJXJUIOnFriendMailingMethod::crJXJUIOnFriendMailingMethod(const crJXJUIOnFriendMailingMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_friendcanvas(handle.m_friendcanvas),
	m_friendlist(handle.m_friendlist),
	m_mailcanvas(handle.m_mailcanvas),
	m_mailswitch(handle.m_mailswitch),
	m_mailnameinput(handle.m_mailnameinput),
	m_mailtitle1(handle.m_mailtitle1),
	m_mailtitle2(handle.m_mailtitle2)
{
}

void crJXJUIOnFriendMailingMethod::inputParam(int i, void *param)
{
}

void crJXJUIOnFriendMailingMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_friendcanvas = str;
		break;
	case 1:
		m_friendlist = str;
		break;
	case 2:
		m_mailcanvas = str;
		break;
	case 3:
		m_mailswitch = str;
		break;
	case 4:
		m_mailnameinput = str;
		break;
	case 5:
		m_mailtitle1 = str;
		break;
	case 6:
		m_mailtitle2 = str;
		break;
	default:
		break;
	}
}

void crJXJUIOnFriendMailingMethod::operator()(crHandle &handle)
{
	// get friend name
	crFriend *selecting_friend = NULL;
	ref_ptr<crCanvasNode>friend_canvas = crFilterRenderManager::getInstance()->findCanvas(m_friendcanvas);
	if (friend_canvas.valid())
	{
		ref_ptr<crTableWidgetNode> friend_list_table = dynamic_cast<crTableWidgetNode *>(friend_canvas->getWidget(m_friendlist));
		if(friend_list_table.valid())selecting_friend = (crFriend *)friend_list_table->getSelectData();
	}
	if(!selecting_friend)
	{
		// TODO:
		// alert selecting players
		return;
	}


	// open mail canvas 
	// insert mail info
	ref_ptr<crCanvasNode>mail_canvas = crFilterRenderManager::getInstance()->findCanvas(m_mailcanvas);
	if (mail_canvas.valid())
	{
		crMultiSwitch *mailswitch = dynamic_cast<crMultiSwitch *>(mail_canvas->getChildNode(m_mailswitch));
		crJXJUIMailData *mail_data = dynamic_cast<crJXJUIMailData *>(mail_canvas->getDataClass());
		mail_data->prepare_send_to(selecting_friend->getPlayerID(), selecting_friend->getName());

		// update mail showing
		ref_ptr<crStaticTextWidgetNode> title1 =  dynamic_cast<crStaticTextWidgetNode *>(mail_canvas->getWidget(m_mailtitle1));
		if (title1.valid())
		{
			title1->setString(std::string("收件人"));
		};
		ref_ptr<crStaticTextWidgetNode> title2 =  dynamic_cast<crStaticTextWidgetNode *>(mail_canvas->getWidget(m_mailtitle2));
		if (title2.valid())
		{
			title2->setString(std::string("主题"));
		}
		ref_ptr<crStaticTextWidgetNode> txt_to_name =  dynamic_cast<crStaticTextWidgetNode *>(mail_canvas->getWidget(m_mailnameinput));
		if (txt_to_name.valid())
		{
			txt_to_name->setString(selecting_friend->getName());
		}
		crFilterRenderManager::getInstance()->showCanvas(mail_canvas.get(), true);
		if (mailswitch)
		{
			mailswitch->setActiveSwitchSet(0);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIShowItemCanvasMethod
//
/////////////////////////////////////////
crJXJUIShowItemCanvasMethod::crJXJUIShowItemCanvasMethod():
	m_ea(NULL),
	m_this(NULL),
	m_itemId(0)
{
}
crJXJUIShowItemCanvasMethod::crJXJUIShowItemCanvasMethod(const crJXJUIShowItemCanvasMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_equipList(handle.m_equipList),
	m_canvas2(handle.m_canvas2),
	m_inputmoney(handle.m_inputmoney),
	m_input(handle.m_input),
	m_switchTips(handle.m_switchTips),
	m_tipsText(handle.m_tipsText),
	m_itemId(handle.m_itemId),
	m_ea(NULL),
	m_this(NULL)
{
}
void crJXJUIShowItemCanvasMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIShowItemCanvasMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_equipList = str;
		break;
	case 2:
		m_canvas2 = str;
		break;
	case 3:
		m_input = str;
		break;
	case 4:
		m_inputmoney = str;
		break;
	case 5:
		m_switchTips = str;
		break;
	case 6:
		m_tipsText = str;
		break;
	case 7:
		m_itemId = atoi(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJUIShowItemCanvasMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	ref_ptr<crCanvasNode>canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas2);
	ref_ptr<crCanvasNode>pcanvas = m_this->getParentCanvas();
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	//ref_ptr<crListControlWidgetNode> equipList = dynamic_cast<crListControlWidgetNode *>(pcanvas->getWidget(m_equipList));
	ref_ptr<crListControlNode> selectNode = m_this->getSelectNode();
	void *param;
	crData *data = myPlayer->getDataClass();
	data->getParam(WCHDATA_JXJOpenBagNum,param);
	unsigned char openbagnum = *(unsigned char *)param;
	if(canvas.valid() && selectNode.valid() &&myPlayer)
	{
		//int selectid = selectNode->getData();
		unsigned char selectid = selectNode->getData();//(unsigned char)m_this->MouseOnNodeIndex(m_ea->getXnormalized(),m_ea->getYnormalized());
		if (selectid>=0 && selectid < openbagnum)
		{
			const crBoundingBox &tips = canvas->getBoundBox();
			float posx = (tips.m_max[0]-tips.m_min[0])*0.5;
			float posy = (tips.m_max[1]-tips.m_min[1])*0.5;
			crVector2 mouse(m_ea->getXnormalized()+posx,m_ea->getYnormalized()-posy);
			/////////////////////////////////////////
			if ((mouse[0] + (posx * 2))>=1.5)
			{
				mouse[0]-=posx * 2;
			}
			if ((mouse[1] - (posy * 2))<=-1.5)
			{
				mouse[1]+=posy * 2;
			}
			/////////////////////////////////////////
			canvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
			//canvas->setCanFocus(true);
			canvas->setCanCaptureMouse(true);
			crFilterRenderManager::getInstance()->setMouseCapturer(canvas.get());
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->inputParam(WCHDATA_JXJSaleItemID,&selectid);
			crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
			//crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
		}
		else if((unsigned char)m_this->MouseOnNodeIndex(m_ea->getXnormalized(),m_ea->getYnormalized()) >= (int)openbagnum)
		{
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int oribagnum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOriBagNum,viplv).c_str()));
			int bagnummax = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBagNumMax,viplv).c_str()));
			int needbuynum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuyBagNumOnce,viplv).c_str()));
			if(needbuynum <= bagnummax - (int)openbagnum && needbuynum >0)
			{
				if (canvas2.valid())
				{
					ref_ptr<crStaticTextWidgetNode> input =  dynamic_cast<crStaticTextWidgetNode *>(canvas2->getWidget(m_input));
					ref_ptr<crStaticTextWidgetNode> inputmoney =  dynamic_cast<crStaticTextWidgetNode *>(canvas2->getWidget(m_inputmoney));
					crTableIO::StrVec record;
					ref_ptr<crTableIO>beibaotab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBeiBaoTab);

					//检测背包里现有的行囊令数量
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJItemBagVec, param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					int itemCount = 0;
					for (JXJItemBagVec::iterator itemitr = itembagvec->begin();
						itemitr != itembagvec->end();
						++itemitr)
					{
						if (itemitr->get())
						{
							if (m_itemId == itemitr->get()->getItemID())
							{
								itemCount = (int)itemitr->get()->getItemCount();
								break;
							}
						}
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));

					int itemIndex = beibaotab->getTitleIndex("行囊令");
					if (itemCount <= 0)
					{//购买背包格子时优先消耗道具，道具不足时消耗元宝
						itemIndex = beibaotab->getTitleIndex("元宝");
						ref_ptr<crStaticTextWidgetNode> costTipsText = dynamic_cast<crStaticTextWidgetNode *>(canvas2->getWidget(m_tipsText));
						ref_ptr<crMultiSwitch> switchTips = dynamic_cast<crMultiSwitch *>(canvas2->getChildNode(m_switchTips));
						if (switchTips.valid())
						{
							switchTips->setActiveSwitchSet(1);
							if (costTipsText.valid())
							{
								costTipsText->setString(L"礼金/元宝，是否确定？");
							}
						}
					}
					int j = ((int)openbagnum - oribagnum)/needbuynum;
					if (j < 0)
					{
						j = 0;
					}
					if ( beibaotab->queryOneRecord(0,crArgumentParser::appItoa(j),record) >= 0)
					{
						int totalmoney = atoi(record[itemIndex].c_str());
						if(input.valid())input->setString(crArgumentParser::appItoa(needbuynum));
						if(inputmoney.valid())inputmoney->setString(crArgumentParser::appItoa(totalmoney));
						crFilterRenderManager::getInstance()->showCanvas(canvas.get(),false);
						crFilterRenderManager::getInstance()->showCanvas(canvas2.get(),true);
					}
				}
			}
		}
	}
	//else if(!selectNode)
	//{
	//		//crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
	//	}
	//}
}
/////////////////////////////////////////
//
//crJXJUISetSaleCountMaxMethod
//
/////////////////////////////////////////
crJXJUISetSaleCountMaxMethod::crJXJUISetSaleCountMaxMethod():
	m_this(NULL)
{
}
crJXJUISetSaleCountMaxMethod::crJXJUISetSaleCountMaxMethod(const crJXJUISetSaleCountMaxMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_equipList(handle.m_equipList),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input),
	m_canvasbb(handle.m_canvasbb),
	m_sellok(handle.m_sellok)
{
}
void crJXJUISetSaleCountMaxMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISetSaleCountMaxMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipList = str;
		break;
	case 1:
		m_canvas = str;
		break;
	case 2:
		m_input = str;
		break;
	case 3:
		m_canvasbb = str;
		break;
	case 4:
		m_sellok = str;
		break;
	}
}
void crJXJUISetSaleCountMaxMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		ref_ptr<crCanvasNode>pcanvas = m_this->getParentCanvas();
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasbb);
		ref_ptr<crCanvasNode>canvascount = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvascount.valid())
		{
			ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvascount->getWidget(m_input));
			ref_ptr<crWidgetNode> sellok = dynamic_cast<crWidgetNode *>(canvascount->getWidget(m_sellok));
			if(canvas.valid() && input.valid() && pcanvas.valid() && sellok.valid())
			{
				/*int selectid = selectNode->getData();*/
				crData *braindata = crBrain::getInstance()->getDataClass();
				braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
				braindata->getParam(WCHDATA_JXJSaleItemID,param);//第几个格子
				unsigned char selectid = *(unsigned char*)param;
				braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
				if(selectid>=0)
				{
					crData *data = myPlayer->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJItemBagVec,param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					int count = 0;
					if (selectid < itembagvec->size() && (*itembagvec)[selectid]!=NULL)
					{
						count = (*itembagvec)[selectid]->getItemCount();
					}

					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					if(count>0)
					{ 
						std::string str = "1";//crArgumentParser::appItoa(count);
						crData *braindata = crBrain::getInstance()->getDataClass();
						braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
						braindata->inputParam(WCHDATA_JXJSaleItemMax,&count);
						braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
						if(input.valid())input->setString(str);
						crFilterRenderManager::getInstance()->showCanvas(canvascount.get(),true);
						crFilterRenderManager::getInstance()->showCanvas(pcanvas.get(),false);
						if(count == 1)
						{
							sellok->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
						}
					}
				}
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJUISetSaleCountMethod
//
/////////////////////////////////////////
crJXJUISetSaleCountMethod::crJXJUISetSaleCountMethod():
	m_this(NULL)
{
}
crJXJUISetSaleCountMethod::crJXJUISetSaleCountMethod(const crJXJUISetSaleCountMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_input(handle.m_input),
	m_step(handle.m_step)
{
}
void crJXJUISetSaleCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISetSaleCountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	case 1:
		m_step = str;
		break;
	}
}
void crJXJUISetSaleCountMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		int count = 0;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
		if(input.valid())
		{
			int nowcount = atoi((input->getUTF8String()).c_str());
			int step = atoi(m_step.c_str());
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
			braindata->getParam(WCHDATA_JXJSaleItemMax,param);
			int saleitemmax = *(int *)param;
			braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			count = nowcount+step;
			if(count<0||count>saleitemmax)count-=step;
			input->setString(crArgumentParser::appItoa(count));
		}
			
	}
}
/////////////////////////////////////////
//
//crJXJUISaleItemEquipMethod
//
/////////////////////////////////////////
crJXJUISaleItemEquipMethod::crJXJUISaleItemEquipMethod():
	m_this(NULL)
{
}
crJXJUISaleItemEquipMethod::crJXJUISaleItemEquipMethod(const crJXJUISaleItemEquipMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_input(handle.m_input)
{
}
void crJXJUISaleItemEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISaleItemEquipMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	}
}
void crJXJUISaleItemEquipMethod::operator()(crHandle &handle)
{
	//bool cancelTask = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		crData *data = myPlayer->getDataClass();
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
		unsigned char count;
		if(input.valid())count = atoi((input->getUTF8String()).c_str());
		if(canvas.valid() && count > 0)
		{
			void *param;
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->getParam(WCHDATA_JXJSaleItemID,param);
			unsigned char selectid = *(unsigned char*)param;
			if(selectid>=0 && count>0)
			{
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				if (itembagvec && selectid<itembagvec->size())
				{
					if ((*itembagvec)[selectid]!=NULL)
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(10);
						stream->_writeUChar(selectid);
						stream->_writeInt((*itembagvec)[selectid]->getItemID());
						stream->_writeInt((*itembagvec)[selectid]->getEquipMagic());
						stream->_writeUChar(count);
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvSaleItemEquip,stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
	}
	//handle.outputParam(0,&cancelTask);
}

/////////////////////////////////////////
//
//crJXJRecvSaleItemEquipMethod
//
/////////////////////////////////////////
crJXJRecvSaleItemEquipMethod::crJXJRecvSaleItemEquipMethod():
	m_netType(GameClient_Game){}
crJXJRecvSaleItemEquipMethod::crJXJRecvSaleItemEquipMethod(const crJXJRecvSaleItemEquipMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input)
{
}
void crJXJRecvSaleItemEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSaleItemEquipMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_fubenRushCanvas = str;
		break;
	case 3:
		m_fubenRushInput = str;
		break;
	case 4:
		m_cfg = str;
		break;
	}
}

void crJXJRecvSaleItemEquipMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			bool success = false;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{//验证物品是否可出售
				unsigned char selectid = m_stream->_readUChar();
				int selectitemid = m_stream->_readInt(); 
				_crInt32 equipmagic = m_stream->_readInt();
				unsigned char count = m_stream->_readUChar();
				
				void *param;
				int *mymoney;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJCoppercash,param);
				mymoney = (int *)param;
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				if (itembagvec && selectid<itembagvec->size())
				{
					if ((*itembagvec)[selectid]!=NULL)
					{
						if( (*itembagvec)[selectid]->getItemID() == selectitemid &&
							(*itembagvec)[selectid]->getEquipMagic() == equipmagic &&
							(*itembagvec)[selectid]->getItemCount() >= count)
						{
							(*itembagvec)[selectid]->setItemCount((*itembagvec)[selectid]->getItemCount() - count);
							ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
							int moneyid = itemTab->getTitleIndex("回收价格");
							crTableIO::StrVec record;
							if(itemTab->queryOneRecord(0,crArgumentParser::appItoa((*itembagvec)[selectid]->getItemID()),record) >= 0 )
							{
								int moneyget = atoi(record[moneyid].c_str()) * count;
								INTLIMITADD(*mymoney,moneyget,INT_MAX);
								//*mymoney += atoi(record[moneyid].c_str());
								success = true;
							}
							if ((*itembagvec)[selectid]->getItemCount()==0)
							{
								(*itembagvec)[selectid] = NULL;
							}
						}
					}
				}
					
				if(success)
				{
					data -> getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					unsigned short timemax = (unsigned short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSaleItemTimeMax,viplv).c_str()));
					data->getParam(WCHDATA_JXJSaleItemList,param);
					JXJSaleItemList *saleitemlist = (JXJSaleItemList*)param;
					if (saleitemlist)
					{
						ref_ptr<crSaleItemData> saleitemdata = new crSaleItemData;
						saleitemdata->setItemID(selectitemid);
						saleitemdata->setEquipMagic(equipmagic);
						saleitemdata->setItemCount(count);
						saleitemdata->setTime(timemax);
						saleitemlist->push_back(saleitemdata);
						if (saleitemlist->size() > 8)
						{
							saleitemlist->pop_front();
						}
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(15);
				stream->_writeBool(success);
				if (success)
				{
					stream->_writeInt(*mymoney);
					stream->_writeUChar(selectid);
					stream->_writeInt(selectitemid);
					stream->_writeInt(equipmagic);
					stream->_writeUChar(count);
				}
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvSaleItemEquip,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = "卖物品（success，itemid，count）：" + crArgumentParser::appVectoa(crVector3i(success,selectitemid,count));
				GameLogData gamelog(Log_SellItem,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool success = m_stream->_readBool();
			std::string str = "出售失败";
			void *param;
			int gotmoney = 0;
			ref_ptr<crCanvasNode>fubenRushCanvas = crFilterRenderManager::getInstance()->findCanvas(m_fubenRushCanvas);
			if(success)
			{
				int curmoney = m_stream->_readInt();
				unsigned char selectid = m_stream->_readUChar();
				int itemid = m_stream->_readInt();
				_crInt32 equipmagic = m_stream->_readInt();
				unsigned char count = m_stream->_readUChar();
				int *mymoney;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJCoppercash,param);
				mymoney = (int *)param;
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				if (itembagvec)
				{
					if ((*itembagvec)[selectid]!=NULL)
					{
						if( (*itembagvec)[selectid]->getItemID() == itemid &&
							(*itembagvec)[selectid]->getEquipMagic() == equipmagic &&
							(*itembagvec)[selectid]->getItemCount() >= count)
						{
							(*itembagvec)[selectid]->setItemCount((*itembagvec)[selectid]->getItemCount() - count);
							//ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
							//int moneyid = troopsEquipTab->getTitleIndex("回收价格");
							//crTableIO::StrVec record;
							//itemid = (*itembagvec)[selectid]->getItemID();
							//troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record);
							////*mymoney += atoi(record[moneyid].c_str());
							//int moneyget = atoi(record[moneyid].c_str());
							//INTLIMITADD(*mymoney,moneyget,INT_MAX);
							////
							gotmoney = curmoney - *mymoney;
							*mymoney = curmoney;
							if ((*itembagvec)[selectid]->getItemCount()==0)
							{
								(*itembagvec)[selectid] = NULL;
							}
						}
					}
				}
				data->getParam(WCHDATA_JXJSaleItemList,param);
				JXJSaleItemList *saleitemlist = (JXJSaleItemList*)param;
				if (saleitemlist)
				{
					ref_ptr<crSaleItemData> saleitemdata = new crSaleItemData;
					saleitemdata->setItemID(itemid);
					saleitemdata->setEquipMagic(equipmagic);
					saleitemdata->setItemCount(count);
					saleitemlist->push_back(saleitemdata);
					if (saleitemlist->size() > 8)
					{
						saleitemlist->pop_front();
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				//扫荡自动出售
				if(fubenRushCanvas.valid() && fubenRushCanvas->getVisiable())
				{
					ref_ptr<crHypertextWidgetNode> hperInput = dynamic_cast<crHypertextWidgetNode *>(fubenRushCanvas->getWidget(m_fubenRushInput));
					rcfg::ConfigScript cfg_script;
					std::vector<float>v_i;
					crVector4f colorGreen = crVector4f(255.0f,255.0f,0.0f,255.0f);
					if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,m_cfg,true,""))
					{
						CRCore::notify(CRCore::FATAL)<<"JXJ::crJXJChatReshowMethod(): file open error "<<m_cfg<<std::endl;
						//sprintf(gDebugInfo->buf(),"crJXJChatReshowMethod: file open error%s\n\0",m_cfg.c_str());
						//gDebugInfo->debugInfo(CRCore::FATAL);
						return;
					}
					cfg_script.Push("Hypertext");
					int index = 1;
					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					cfg_script.Add("Text",std::string("-----------------------/n"));
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					v_i.resize(0);
					for (int i = 0; i<4;i++)
					{
						v_i.push_back(colorGreen[i]);
					}
					cfg_script.Add("Color",v_i);
					cfg_script.Add("DrawMode","TEXT");
					cfg_script.Add("Text",std::string("您在扫荡中获得的装备已自动出售，获得铜钱：")+crArgumentParser::appItoa(gotmoney)+std::string(" \n"));
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					cfg_script.Add("Text",std::string("-----------------------/n"));
					cfg_script.Pop();

					cfg_script.Pop();
					if(hperInput.valid())
						hperInput->setHypertext(cfg_script,true);
				}
			}
			if(gotmoney !=0)
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Copper,gotmoney));
			//ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			//if (canvas && fubenRushCanvas && fubenRushCanvas->getVisiable()==false)
			//{
			//	ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
			//	if(input)input->setString(str);
			//	if(canvas)crFilterRenderManager::getInstance()->showCanvas(canvas,true);
			//}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICheckInputNumMethod
//
/////////////////////////////////////////
crJXJUICheckInputNumMethod::crJXJUICheckInputNumMethod():
	m_this(NULL)
{
}
crJXJUICheckInputNumMethod::crJXJUICheckInputNumMethod(const crJXJUICheckInputNumMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_input(handle.m_input)
{
}
void crJXJUICheckInputNumMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUICheckInputNumMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	}
}
void crJXJUICheckInputNumMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		int count = 0;
		ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_input));
		if(input.valid())
		{
			//int itemsalemax = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJItemSaleMax).c_str()));
			int count = atoi((input->getUTF8String()).c_str());
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
			braindata->getParam(WCHDATA_JXJSaleItemMax,param);
			int saleitemmax = *(int *)param;
			braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			if(count<1)count = 1;
			else if(count>saleitemmax)count = saleitemmax;
			input->setString(crArgumentParser::appItoa(count));
		}

	}
}
/////////////////////////////////////////
//
//crJXJUIKnapsackBuyOnShowMethod
//
/////////////////////////////////////////
crJXJUIKnapsackBuyOnShowMethod::crJXJUIKnapsackBuyOnShowMethod():
	m_this(NULL)
{
}
crJXJUIKnapsackBuyOnShowMethod::crJXJUIKnapsackBuyOnShowMethod(const crJXJUIKnapsackBuyOnShowMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_canvas(handle.m_canvas)
{
}
void crJXJUIKnapsackBuyOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIKnapsackBuyOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_image[0] = str;
		break;
	case 2:
		m_image[1] = str;
		break;
	case 3:
		m_image[2] = str;
		break;
	case 4:
		m_image[3] = str;
		break;
	case 5:
		m_image[4] = str;
		break;
	case 6:
		m_image[5] = str;
		break;
	case 7:
		m_image[6] = str;
		break;
	case 8:
		m_image[7] = str;
		break;
	case 9:
		m_time[0] = str;
		break;
	case 10:
		m_time[1] = str;
		break;
	case 11:
		m_time[2] = str;
		break;
	case 12:
		m_time[3] = str;
		break;
	case 13:
		m_time[4] = str;
		break;
	case 14:
		m_time[5] = str;
		break;
	case 15:
		m_time[6] = str;
		break;
	case 16:
		m_time[7] = str;
		break;
	}
}
void crJXJUIKnapsackBuyOnShowMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		int i = 0;
		bool ifimagebox = true;
		//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_input));
		crImageBoxWidgetNode *image[8];
		crStaticTextWidgetNode *time[8];
		for(i = 0; i < 8; i++)
		{
			image[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_image[i]));
			if (!image[i])ifimagebox = false;
			time[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_time[i]));
			time[i]->clearString();
		}
		ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		ref_ptr<crTableIO>troopsEquipTab2 = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		if(ifimagebox)
		{
			crData *data = myPlayer->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJSaleItemList,param);
			JXJSaleItemList *saleitemlist = (JXJSaleItemList*)param;
			crTableIO::StrVec record;
			int i = 0;
			int iconid = -1;
			for(JXJSaleItemList::iterator itr = saleitemlist->begin();itr!=saleitemlist->end();++itr,++i)
			{
				if (i < 8)
				{
					if(troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),record) >= 0 )
					{
						iconid = troopsEquipTab->getTitleIndex("icon");
					}
					else
					{
						if(troopsEquipTab2->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),record) >= 0 )
						{
							iconid = troopsEquipTab2->getTitleIndex("icon");
						}
					}
					if (iconid >= 0)
					{
						image[i]->clearImage();
						image[i]->setImageName(record[iconid]);
						image[i]->setVisiable(true);
						//image[i]->setName(record[nameid]+" "+crArgumentParser::appItoa(itr->second));
						time[i]->setString(crArgumentParser::appItoa((*itr)->getItemCount()));
					}
				}
			}
			for(i;i<8;i++)
			{
				image[i]->setVisiable(false);
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}

	}
}

/////////////////////////////////////////
//
//crJXJUIKnapsackBuyItemMethod
//
/////////////////////////////////////////
crJXJUIKnapsackBuyItemMethod::crJXJUIKnapsackBuyItemMethod():
	m_this(NULL)
{
}
crJXJUIKnapsackBuyItemMethod::crJXJUIKnapsackBuyItemMethod(const crJXJUIKnapsackBuyItemMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_input(handle.m_input)
{
}
void crJXJUIKnapsackBuyItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIKnapsackBuyItemMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	}
}
void crJXJUIKnapsackBuyItemMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		int count = 0;
		bool canbuy = false;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if(atoi(m_input.c_str()) >= 0)
		{
			crData *data = myPlayer->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJSaleItemList,param);
			JXJSaleItemList *saleitemlist = (JXJSaleItemList*)param;
			JXJSaleItemList::iterator itr;
			int i = 0;
			for(itr = saleitemlist->begin();itr!=saleitemlist->end();++itr,++i)
			{
				if (i == atoi(m_input.c_str()) && (*itr)->getItemCount()>0)
				{
					canbuy = true;
				}
			}

			if(canbuy)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(atoi(m_input.c_str()));
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvKnapsackBuyItem,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvKnapsackBuyItemMethod
//
/////////////////////////////////////////
crJXJRecvKnapsackBuyItemMethod::crJXJRecvKnapsackBuyItemMethod():
	m_netType(GameClient_Game){}
crJXJRecvKnapsackBuyItemMethod::crJXJRecvKnapsackBuyItemMethod(const crJXJRecvKnapsackBuyItemMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input)
{
}
void crJXJRecvKnapsackBuyItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvKnapsackBuyItemMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	}
}

void crJXJRecvKnapsackBuyItemMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{//验证物品是否可回购
				unsigned char selectid = m_stream->_readUChar();
				unsigned char count = 0;
				void *param;
				int *mymoney;
				int itemid = 0;
				_crInt32 equipmagic = 0;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJSaleItemList,param);
				JXJSaleItemList *saleitemdeq = (JXJSaleItemList*)param;
				int saleListSize = saleitemdeq->size();
				if(selectid>=saleListSize)
				{
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					return;
				}
				data->getParam(WCHDATA_JXJCoppercash,param);
				mymoney = (int *)param;
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				if (!saleitemdeq->empty())
				{
					data->getParam(WCHDATA_JXJOpenBagNum,param);
					unsigned char openbagnum = *(unsigned char*)param;
					JXJSaleItemList::iterator itr3;
					int i = 0;
					int bagitemcount = 0;
					unsigned char itemindex = 0;
					for(itr3 = saleitemdeq->begin();itr3!=saleitemdeq->end();++itr3,++i)
					{
						if (i == selectid)
						{
							itemid = (*itr3)->getItemID();
							equipmagic = (*itr3)->getEquipMagic();
							count = (*itr3)->getItemCount();
							break;
						}
					}
					JXJItemBagVec::iterator itr;
					ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					int moneyid = troopsEquipTab->getTitleIndex("回购价格");
					crTableIO::StrVec record,record2,record3;
					int totalprice = 0;
					if(itemid>0 && count>0)
					{
						if(troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record3) >= 0 )
						{
							totalprice = atoi(record3[moneyid].c_str()) * count;
							for (itr = itembagvec->begin();itr!=itembagvec->end();++itr,++itemindex)//验证背包格子数
							{
								if ((*itr)==NULL)
								{
									i = 0;
									for (itr3 = saleitemdeq->begin();itr3!=saleitemdeq->end();++itr3,++i)
									{
										if(selectid == i)
										{
											m_this->doEvent(WCH_JXJDeductCopperCash,MAKECREPARAM(&totalprice,NULL));
											if (totalprice == 0)
											{
												ref_ptr<crBagItemData> newbagitem = new crBagItemData;
												newbagitem->setItemID(itemid);
												newbagitem->setEquipMagic(equipmagic);
												newbagitem->setItemCount(count);
												(*itembagvec)[itemindex] = newbagitem;
												saleitemdeq->erase(itr3);
												success = 1;
											}
											else
											{
												success = 2;
											}
											break;
										}
									}
									break;
								}
							}
							if (itr == itembagvec->end())
							{
								success = 3;
							}
						}
					}


					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(12);
					stream->_writeUChar(success);
					if (success == 1)
					{
						stream->_writeInt(itemid);
						stream->_writeInt(equipmagic);
						stream->_writeUChar(count);
						stream->_writeUChar(selectid);
						stream->_writeUChar(itemindex);
					}
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvKnapsackBuyItem,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				///游戏日志
				std::string logdata = "背包回购（sucess，itemid）：" + crArgumentParser::appVectoa(crVector2i(success,itemid));
				GameLogData gamelog(Log_KnapsackBuyItem,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
				std::string str = "回购成功";
				if(success == 1)
				{
					int itemid = m_stream->_readInt();
					_crInt32 equipmagic = m_stream->_readInt();
					unsigned char count = m_stream->_readUChar();
					unsigned char selectid = m_stream->_readUChar();
					unsigned char itemindex = m_stream->_readUChar();
					void *param;
					crData *data = m_this->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					JXJItemBagVec::iterator itr;
					ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					int moneyid = troopsEquipTab->getTitleIndex("回购价格");
					crTableIO::StrVec record,record2,record3;
					data->getParam(WCHDATA_JXJItemBagVec,param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					if(count>0)
					{
						ref_ptr<crBagItemData> newbagitem = new crBagItemData;
						newbagitem->setItemID(itemid);
						newbagitem->setEquipMagic(equipmagic);
						newbagitem->setItemCount(count);
						(*itembagvec)[itemindex] = newbagitem;
					}
					data->getParam(WCHDATA_JXJSaleItemList,param);
					JXJSaleItemList *saleitemdeq = (JXJSaleItemList*)param;
					JXJSaleItemList::iterator itr3;
					int i = 0;
					for (itr3 = saleitemdeq->begin();itr3!=saleitemdeq->end();++itr3,++i)
					{
						if(selectid == i)
						{
							saleitemdeq->erase(itr3);
							break;
						}
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					input->setString(str);
				}
				else if(success == 2)
				{
					str = "铜钱不足";
					input->setString(str);
				}
				else if(success == 3)
				{
					str = "背包不足";
					input->setString(str);
				}
				else
				{
					str = "回购失败";
					input->setString(str);
				}
				crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJItemSaleTimerMethod
//
/////////////////////////////////////////
crJXJItemSaleTimerMethod::crJXJItemSaleTimerMethod():
	m_dt(0)
{
}
crJXJItemSaleTimerMethod::crJXJItemSaleTimerMethod(const crJXJItemSaleTimerMethod& handle):
	crMethod(handle),
	m_dt(handle.m_dt)
{
}
void crJXJItemSaleTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = *((int*)(LOCREPARAM(param64)));
		}
		else
		{
			m_dt = 0;
		}
		break;
	}
}
void crJXJItemSaleTimerMethod::addParam(int i, const std::string& str)
{
}
void crJXJItemSaleTimerMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKECREPARAM(WCH_LockData,1));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
			thisData->getParam(WCHDATA_JXJSaleItemList,param);
			JXJSaleItemList *itemlist = (JXJSaleItemList *)param;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			crPlayerDataEventPacket packet;
			JXJSaleItemList::iterator itr,itr2;
			unsigned char result = 0;
			for(itr = itemlist->begin();itr!=itemlist->end();++itr)
			{
				(*itr)->setTime(((*itr)->getTime())-m_dt);
			}
			for(itr2 = itemlist->begin();itr2!=itemlist->end();++itr2)
			{
				if(((*itr2)->getTime())<=0)//物品回购期限到
				{
					result = 1;
					if(itemlist->size())itemlist->pop_front();
					stream->createBuf(1);
					stream->_writeUChar(result);
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRefreshSaleItemTime,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					break;
				}
			}
			thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRefreshSaleItemTimeMethod
//
/////////////////////////////////////////
crJXJRefreshSaleItemTimeMethod::crJXJRefreshSaleItemTimeMethod():
	m_netType(GameClient_Game){}
crJXJRefreshSaleItemTimeMethod::crJXJRefreshSaleItemTimeMethod(const crJXJRefreshSaleItemTimeMethod& handle):
	crMethod(handle)
{
}
void crJXJRefreshSaleItemTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRefreshSaleItemTimeMethod::addParam(int i, const std::string& str)
{
}

void crJXJRefreshSaleItemTimeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			unsigned char result = m_stream->_readUChar();
			if(result)
			{
				thisData->excHandle(MAKECREPARAM(WCH_LockData,1));
				thisData->getParam(WCHDATA_JXJSaleItemList,param);
				JXJSaleItemList *itemlist = (JXJSaleItemList *)param;
				itemlist->pop_front();
				thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBuyKnapsackBagMethod
//
/////////////////////////////////////////
crJXJUIBuyKnapsackBagMethod::crJXJUIBuyKnapsackBagMethod():
	m_this(NULL),
	m_itemId(0)
{
}
crJXJUIBuyKnapsackBagMethod::crJXJUIBuyKnapsackBagMethod(const crJXJUIBuyKnapsackBagMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_inputcount(handle.m_inputcount),
	m_inputmoney(handle.m_inputmoney),
	m_moneycanvas(handle.m_moneycanvas),
	m_itemId(handle.m_itemId)
{
}
void crJXJUIBuyKnapsackBagMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIBuyKnapsackBagMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_inputcount = str;
		break;
	case 1:
		m_inputmoney = str;
		break;
	case 2:
		m_moneycanvas = str;
		break;
	case 3:
		m_itemId = atoi(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJUIBuyKnapsackBagMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crStaticTextWidgetNode> inputcount = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_inputcount));
		ref_ptr<crStaticTextWidgetNode> inputmoney = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_inputmoney));
		ref_ptr<crCanvasNode>moneycanvas = crFilterRenderManager::getInstance()->findCanvas(m_moneycanvas);
		if(inputcount.valid() && inputmoney.valid())
		{
			crData *data = myPlayer->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));

			//检测背包里现有行囊令（用于开启背包）的数量
			unsigned char itemCount = 0;
			data->getParam(WCHDATA_JXJItemBagVec, param);
			JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
			for (JXJItemBagVec::iterator itemitr = itembagvec->begin();
				itemitr != itembagvec->end();
				++itemitr)
			{
				if (itemitr->get())
				{
					if (m_itemId == itemitr->get()->getItemID())
					{
						itemCount = (int)itemitr->get()->getItemCount();
						break;
					}
				}
			}
			unsigned short needCost;
			unsigned char count;
			needCost = atoi((inputmoney->getUTF8String()).c_str());
			count = atoi((inputcount->getUTF8String()).c_str());
			if(itemCount >= needCost)
			{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(5);
				stream->_writeUShort(needCost);
				stream->_writeUChar(count);
				stream->_writeUShort(m_itemId);//开启背包所需消耗的道具ID
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuyKnapsackBag,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
			else
			{//道具不足时，检查元宝购买条件
				data->getParam(WCHDATA_JXJGoldingot,param);
				int mycash = *(int*)param;
				data->getParam(WCHDATA_JXJGiftGold,param);
				int giftgold = *(int*)param;
				mycash += giftgold;
				if (mycash >= needCost)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(5);
					stream->_writeUShort(needCost);
					stream->_writeUChar(count);
					stream->_writeUShort(0);//使用元宝开启背包，不消耗道具；
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuyKnapsackBag,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				else
				{
					short tipsindex = 7032;
					myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(tipsindex,NULL)); //行囊令和元宝都不足，购买失败
					//				if(moneycanvas.valid())crFilterRenderManager::getInstance()->showCanvas(moneycanvas.get(),true);
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvBuyKnapsackBagMethod
//
/////////////////////////////////////////
crJXJRecvBuyKnapsackBagMethod::crJXJRecvBuyKnapsackBagMethod():
	m_netType(GameClient_Game){}
crJXJRecvBuyKnapsackBagMethod::crJXJRecvBuyKnapsackBagMethod(const crJXJRecvBuyKnapsackBagMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_input(handle.m_input),
	m_canvas(handle.m_canvas)
{
}
void crJXJRecvBuyKnapsackBagMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBuyKnapsackBagMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_canvas = str;
		break;
	}
}

void crJXJRecvBuyKnapsackBagMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{//验证背包是否可扩充
				unsigned short needCost = m_stream->_readUShort();
				unsigned char count = m_stream->_readUChar();
				unsigned short itemId = m_stream->_readUShort();
				void *param;
				//int *mycash;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				//data->getParam(WCHDATA_JXJGoldingot,param);
				//mycash = (int *)param;

				bool canBuy = false;
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				if (itemId != 0)
				{
					//检测背包里现有行囊令（用于开启背包）的数量
					int itemCount = 0;
					for (JXJItemBagVec::iterator itemitr = itembagvec->begin();
						itemitr != itembagvec->end();
						++itemitr)
					{
						if (itemitr->get())
						{
							if (itemId == itemitr->get()->getItemID())
							{
								itemCount = (int)itemitr->get()->getItemCount();
								if (itemCount >= 1)
								{
									canBuy = true;
									//itemitr->get()->setItemCount(--itemCount);
									break;
								}
							}
						}
					}
				}
				else
				{
					data->getParam(WCHDATA_JXJGoldingot,param);
					int mycash = *(int*)param;
					data->getParam(WCHDATA_JXJGiftGold,param);
					int giftgold = *(int*)param;
					mycash += giftgold;
					if (mycash >= needCost)
					{
						canBuy = true;
					}
				}
				if (canBuy)
				{
					data->getParam(WCHDATA_JXJOpenBagNum,param);
					unsigned char *openbagnum = (unsigned char *)param;
					int sum = 0;
					bool needdeductgold = false;
					data -> getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					int oribagnum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOriBagNum,viplv).c_str()));
					int bagnummax = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBagNumMax,viplv).c_str()));
					int needbuynum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuyBagNumOnce,viplv).c_str()));
					crTableIO::StrVec record;
					ref_ptr<crTableIO>beibaotab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJBeiBaoTab);
					int itemIndex = beibaotab->getTitleIndex("行囊令");
					if (itemId == 0)
					{
						itemIndex = beibaotab->getTitleIndex("元宝");
					}
					int j = ((int)*openbagnum - oribagnum)/needbuynum;
				
					if (bagnummax >= needbuynum+(int)*openbagnum
						&& beibaotab->queryOneRecord(0,crArgumentParser::appItoa(j),record) >= 0)
					{
						int totalmoney = atoi(record[itemIndex].c_str());
						if(totalmoney == needCost)
						{
							if (itemId == 0)
							{//元宝开启
								MoneyChangeData moneydata(totalmoney,"扩充背包");
								m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold)); //道具不足，使用元宝开启
	 							if(moneydata.first == 0)
	 							{
									//*mycash -= totalmoney;
									*openbagnum += count;
									itembagvec->resize((int)*openbagnum);
									//data->inputParam(WCHDATA_JXJOpenBagNum,&openbagnum);
									success = 1;
								}
	 							else
	 							{
	 								success = 4;//元宝不足
								}
							}
							else
							{//道具开启
								*openbagnum += count;
								itembagvec->resize((int)*openbagnum);
								success = 1;

								DeductItemMap deductitemmap;
								ref_ptr<crBagItemData> deductitem;
								deductitem =new crBagItemData;
								deductitem->setItemID(itemId);
								deductitem->setItemDeductCount(1);
								deductitem->setEquipMagic(0);
								deductitemmap.insert(std::make_pair(itemId,deductitem));
								//扣除物品
								m_this->doEvent(WCH_JXJRecvDeductItems,MAKECREPARAM(&deductitemmap,0));

								///游戏日志
								if (itemId != 0)
								{//使用道具鼓舞
									std::string logdata = "使用物品（success，itemid）：" + crArgumentParser::appVectoa(crVector2i(success,itemId));
									GameLogData gamelog(Log_UseBagItem,logdata);
									crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
								}
							}
						}
						else
						{
							success = 3;//服务器数据与客户端不同步
						}
					}
					else
					{
						success = 2;//购买的背包超限
					}
// 					if (needdeductgold)
// 					{
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					callback->savePlayerData(playerData.get());
//					}
				}
				else
				{
					success = 4;//道具不足
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(6);
				stream->_writeUChar(success);
				stream->_writeUShort(needCost);
				stream->_writeUChar(count);
				stream->_writeUShort(itemId);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBuyKnapsackBag,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = "背包扩充（success，count）:" + crArgumentParser::appVectoa(crVector2i(success,count));
				GameLogData gamelog(Log_BuyKnapsackBag,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
			if (tips.valid())
			{
				ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if(success == 1)
				{
					unsigned short needCost = m_stream->_readUShort();
					int count = m_stream->_readUChar();
					unsigned short itemId = m_stream->_readUShort();
					//int *mycash;
					void *param;
					unsigned char *openbagnum;
					std::string str = "购买成功！";
					crData *data = m_this->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					//data->getParam(WCHDATA_JXJGoldingot,param);
					//mycash = (int *)param;
					data->getParam(WCHDATA_JXJOpenBagNum,param);
					openbagnum = (unsigned char *)param;
					//*mycash -= needmoney;
					*openbagnum += count;

					data->getParam(WCHDATA_JXJItemBagVec,param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					itembagvec->resize((int)*openbagnum);

					//if (itemId != 0)
					//{//itemId为0时，表示元宝开启
					//	//检测背包里现有行囊令（用于开启背包）的数量
					//	int itemCount = 0;
					//	bool itemEnough = false;
					//	for (JXJItemBagVec::iterator itemitr = itembagvec->begin();
					//		itemitr != itembagvec->end();
					//		++itemitr)
					//	{
					//		if (itemitr->get())
					//		{
					//			if (itemId == itemitr->get()->getItemID())
					//			{
					//				itemCount = (int)itemitr->get()->getItemCount();
					//				if (itemCount >= needCost)
					//				{
					//					itemitr->get()->setItemCount(itemCount - needCost);
					//				}
					//				else
					//					itemitr->get()->setItemCount(0);
					//				break;
					//			}
					//		}
					//	}
					//}

					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					if(input.valid())input->setString(str);
					if(tips.valid())crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);

					//JXJItemBagVec deductitembagvec;
					//JXJItemBagVec deductcardbagvec;
					//deductitembagvec.push_back(NULL);
					//deductcardbagvec.push_back(NULL);
					//CRCore::ref_ptr<crBagItemData> newitem = new crBagItemData;
					//newitem->setItemID((int)itemId);
					//newitem->setEquipMagic(0);
					//newitem->setItemDeductCount(1);
					//deductitembagvec.push_back(newitem);
					////crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM((int)itemId,-1));
					//crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeItems,MAKECREPARAM(&deductitembagvec,&deductcardbagvec));
				}
				if(success == 2||success ==3)
				{
					std::string str = "购买失败！";
					if(input.valid())input->setString(str);
					if(tips.valid())crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);
				}
				if(success == 4)
					if(canvas.valid())crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIChangeItemPosMethod
//
/////////////////////////////////////////
crJXJUIChangeItemPosMethod::crJXJUIChangeItemPosMethod():
	m_ea(NULL),
	m_this(NULL)
{}
crJXJUIChangeItemPosMethod::crJXJUIChangeItemPosMethod(const crJXJUIChangeItemPosMethod& handle):
	crMethod(handle),
	m_myBagList(handle.m_myBagList),
	m_pagenum(handle.m_pagenum),
	m_itemtype(handle.m_itemtype),
	m_curpagenum(handle.m_curpagenum),
	m_type(handle.m_type),
	m_ea(NULL),
	m_this(NULL),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
	for (int i = 0;i<5;i++)
	{
		m_image[i] = handle.m_image[i];
	}
}
void crJXJUIChangeItemPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIChangeItemPosMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_itemtype = str;
		break;
	case 1:
		m_curpagenum = str;
		break;
	case 2:
		m_type = atoi(str.c_str());
		break;
	case 3:
		m_image[0] = str;
		break;
	case 4:
		m_image[1] = str;
		break;
	case 5:
		m_image[2] = str;
		break;
	case 6:
		m_image[3] = str;
		break;
	case 7:
		m_image[4] = str;
		break;
	case 8:
		m_tipcanvas = str;
		break;
	case 9:
		m_tiptitle = str;
		break;
	case 10:
		m_tipcontent = str;
		break;
	}
}
void crJXJUIChangeItemPosMethod::operator()(crHandle &handle)
{
	bool success = true;
	bool ifequip = false;
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	ref_ptr<crListControlNode> selectNode = m_this->getSelectNode();
	if(myPlayer && netConductor && selectNode.valid()/* && selectNode->getVisiable()*/)
	{
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		void *param;
		unsigned char openbagnum;
		JXJItemBagVec *itembagvec;
		bool canputon = true;
		int typeitem,curpage;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crRadioGroupWidgetNode> itemtype = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_itemtype));
		ref_ptr<crRadioGroupWidgetNode> curpagenum = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_curpagenum));
		if(itemtype.valid())
		{
			typeitem = itemtype->getSelect();
		}
		if(curpagenum.valid())
		{
			curpage = curpagenum->getSelect();
		}
		data->getParam(WCHDATA_JXJItemBagVec,param);
		itembagvec = (JXJItemBagVec *)param;
		if(selectNode->getData() < itembagvec->size() && m_ea && (typeitem == IT_Equip || typeitem == IT_ALL) )
		{
			crTableIO::StrVec lordequiprecord;
			int needcharacterlevelindex = itemtab->getTitleIndex("人物等级"); 
			int typeindex = itemtab->getTitleIndex("类型"); 

			if ((*itembagvec)[selectNode->getData()]!=NULL)
			{
				do 
				{
					if(!m_this)
						break;
					crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
					crWidgetNode* pickUI = NULL;
					crWidgetNode *capturer = crFilterRenderManager::getInstance()->getMouseCapturer();
					crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
					crFilterRenderManager::getInstance()->mousePick(mouse,pickUI);
					crFilterRenderManager::getInstance()->setMouseCapturer(capturer);
					if(!pickUI)
					{//Drop Item
						break;
					}
					else if(pickUI != selectNode.get())
					{
						int itemid = (*itembagvec)[selectNode->getData()]->getItemID();
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itembagvec)[selectNode->getData()]->getItemID()),lordequiprecord) >= 0 )
						{
							if(atoi(lordequiprecord[typeindex].c_str()) == IT_Equip)
							{
								crRole *mainRole = myPlayer->getMainRole();
								crData *roleData = mainRole->getDataClass();
								roleData->getParam(WCHDATA_Level,param);
								unsigned char rolelv = *(unsigned char *)param;
								unsigned char needlv = atoi(lordequiprecord[needcharacterlevelindex].c_str());
								if (rolelv<needlv)
								{
									//提示等级不足
									canputon = false;
								}
								for(int i = 0; i<5; i++)
								{
									if(dynamic_cast<crImageBoxWidgetNode *>(pickUI) && pickUI->getName().compare(m_image[i]) == 0)
									{
										if(!canputon)
										{
											myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2024,NULL));//等级不足
										}
										else
										{
											//dynamic_cast<crImageBoxWidgetNode *>(pickUI)->select(true);
											ifequip = true;
											ref_ptr<crStreamBuf> stream = new crStreamBuf;
											stream->createBuf(5);
											stream->_writeUChar((unsigned char)selectNode->getData());
											stream->_writeInt(itemid);
											crPlayerDataEventPacket packet;
											crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPutOnEquip,stream.get());
											netConductor->getNetManager()->sendPacket("all",packet);
										}
									}
								}
							}
						}
					}
					//crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
				} while (0);
			}
		}
		if(!ifequip && m_ea)
		{
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int onepagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBagOnePage,viplv).c_str()));
			if(m_this)
			{
				switch (m_type)
				{
				case 0:
					data->getParam(WCHDATA_JXJItemBagVec,param);
					itembagvec = (JXJItemBagVec *)param;
					data->getParam(WCHDATA_JXJOpenBagNum,param);
					openbagnum = *(unsigned char *)param;
					break;
				case 1:
					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
					itembagvec = (JXJItemBagVec *)param;
					openbagnum = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
					break;
				}
				int exchange = m_this->MouseOnNodeIndex(m_ea->getXnormalized(),m_ea->getYnormalized());
				if(exchange>=openbagnum)success = false;
				if (exchange>=0 && exchange<openbagnum && /*!typeitem && */selectNode.valid())
				{
					int selectid = selectNode->getData();
					if (typeitem > 0)
					{
						success = false;
					}
					else
					{
						if (exchange==selectid && (*itembagvec)[exchange]!=NULL)
						{
							success = false;
						}
						if(selectid>=0 && selectid <openbagnum && exchange!=selectid)
						{
							ref_ptr<crBagItemData> tmp;
							if((*itembagvec)[exchange]!=NULL && (*itembagvec)[selectid]!=NULL)
							{
								if ((*itembagvec)[exchange]->getItemID()!=(*itembagvec)[selectid]->getItemID()||
									(*itembagvec)[exchange]->getEquipMagic()!=(*itembagvec)[selectid]->getEquipMagic())
								{
									//int exitemid = (*itembagvec)[exchange]->getItemID();
									//unsigned char exitemcount = (*itembagvec)[exchange]->getItemCount();

									//(*itembagvec)[exchange]->setItemID((*itembagvec)[selectid]->getItemID());
									//(*itembagvec)[exchange]->setItemCount((*itembagvec)[selectid]->getItemCount());

									//(*itembagvec)[selectid]->setItemID(exitemid);
									//(*itembagvec)[selectid]->setItemCount(exitemcount);
									tmp = (*itembagvec)[exchange];
									(*itembagvec)[exchange] = (*itembagvec)[selectid];
									(*itembagvec)[selectid] = tmp;
								}
								else
								{
									int maxnum = itemtab->getTitleIndex("叠加数量");
									crTableIO::StrVec itemrecord;
									if (itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itembagvec)[selectid]->getItemID()),itemrecord) >= 0)
									{
										int counttotal= (*itembagvec)[exchange]->getItemCount() + (*itembagvec)[selectid]->getItemCount();
										if(counttotal<= atoi(itemrecord[maxnum].c_str()))
										{
											(*itembagvec)[exchange]->setItemCount(counttotal);
											(*itembagvec)[selectid] = NULL;
										}
										else
										{
											(*itembagvec)[exchange]->setItemCount(atoi(itemrecord[maxnum].c_str()));
											(*itembagvec)[selectid]->setItemCount(counttotal-atoi(itemrecord[maxnum].c_str()));
										}
									}
								}
							}
							else
							{
								tmp = (*itembagvec)[exchange];
								(*itembagvec)[exchange] = (*itembagvec)[selectid];
								(*itembagvec)[selectid] = tmp;
							}
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(3);
							stream->_writeUChar(selectid);
							stream->_writeUChar(exchange);
							stream->_writeUChar(m_type);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvChangeItemPos,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
						}
					}
				}
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
	handle.outputParam(0,&success);

}
/////////////////////////////////////////
//
//crJXJRecvChangeItemPosMethod
//
/////////////////////////////////////////
crJXJRecvChangeItemPosMethod::crJXJRecvChangeItemPosMethod():
	m_netType(GameClient_Game){}
crJXJRecvChangeItemPosMethod::crJXJRecvChangeItemPosMethod(const crJXJRecvChangeItemPosMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_input(handle.m_input)
{
}
void crJXJRecvChangeItemPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvChangeItemPosMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_input = str;
		break;
	}
}

void crJXJRecvChangeItemPosMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{//验证背包是否可移动
				unsigned char selectid = m_stream->_readUChar();
				unsigned char exchange = m_stream->_readUChar();
				unsigned char m_type = m_stream->_readUChar();
				void *param;
				unsigned char openbagnum;
				JXJItemBagVec *itembagvec;
				crData *data = m_this->getDataClass();
				data -> getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				switch (m_type)
				{
				case 0:
					data->getParam(WCHDATA_JXJItemBagVec,param);
					itembagvec = (JXJItemBagVec *)param;
					data->getParam(WCHDATA_JXJOpenBagNum,param);
					openbagnum = *(unsigned char *)param;
					break;
				case 1:
					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
					itembagvec = (JXJItemBagVec *)param;
					openbagnum = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
					break;
				}
				if(selectid <openbagnum && exchange!=selectid && exchange < openbagnum)
				{
					ref_ptr<crBagItemData> tmp;
					if((*itembagvec)[exchange]!=NULL && (*itembagvec)[selectid]!=NULL)
					{
						if ((*itembagvec)[exchange]->getItemID()!=(*itembagvec)[selectid]->getItemID()||
							(*itembagvec)[exchange]->getEquipMagic()!=(*itembagvec)[selectid]->getEquipMagic())
						{
							//int exitemid = (*itembagvec)[exchange]->getItemID();
							//unsigned char exitemcount = (*itembagvec)[exchange]->getItemCount();

							//(*itembagvec)[exchange]->setItemID((*itembagvec)[selectid]->getItemID());
							//(*itembagvec)[exchange]->setItemCount((*itembagvec)[selectid]->getItemCount());

							//(*itembagvec)[selectid]->setItemID(exitemid);
							//(*itembagvec)[selectid]->setItemCount(exitemcount);
							////crBagItemData *bagitem = (*itembagvec)[exchange].get();
							////(*itembagvec)[exchange] = (*itembagvec)[selectid];//selectid修改
							////(*itembagvec)[selectid] = bagitem;
							tmp = (*itembagvec)[exchange];
							(*itembagvec)[exchange] = (*itembagvec)[selectid];
							(*itembagvec)[selectid] = tmp;
						}
						else
						{
							ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
							int maxnum = itemtab->getTitleIndex("叠加数量");
							crTableIO::StrVec itemrecord;
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itembagvec)[selectid]->getItemID()),itemrecord) >= 0 )
							{
								int counttotal= (*itembagvec)[exchange]->getItemCount() + (*itembagvec)[selectid]->getItemCount();
								if(counttotal<= atoi(itemrecord[maxnum].c_str()))
								{
									(*itembagvec)[exchange]->setItemCount(counttotal);
									(*itembagvec)[selectid] = NULL;
								}
								else
								{
									(*itembagvec)[exchange]->setItemCount(atoi(itemrecord[maxnum].c_str()));
									(*itembagvec)[selectid]->setItemCount(counttotal-atoi(itemrecord[maxnum].c_str()));
								}
							}
						}
						success = 1;
					}
					else
					{
						tmp = (*itembagvec)[exchange];
						(*itembagvec)[exchange] = (*itembagvec)[selectid];
						(*itembagvec)[selectid] = tmp;
						success = 1;
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					if(!success)
					{
						stream->createBuf(21);
						stream->_writeUChar(success);
						stream->_writeUChar(selectid);
						stream->_writeUChar(exchange);
						if((*itembagvec)[selectid]!=NULL)
						{
							stream->_writeInt((*itembagvec)[selectid]->getItemID());//16+3
							stream->_writeInt((*itembagvec)[selectid]->getEquipMagic());
							stream->_writeUChar((*itembagvec)[selectid]->getItemCount());
						}
						else
						{
							stream->_writeInt(0);
						}
						if((*itembagvec)[exchange]!=NULL)
						{
							stream->_writeInt((*itembagvec)[exchange]->getItemID());
							stream->_writeInt((*itembagvec)[exchange]->getEquipMagic());
							stream->_writeUChar((*itembagvec)[exchange]->getItemCount());
						}
						else
						{
							stream->_writeInt(0);
						}
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvChangeItemPos,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
					///游戏日志
					std::string logdata = "背包交换物品位置（selectid,exchange）：" + crArgumentParser::appVectoa(crVector2i(selectid,exchange));
					GameLogData gamelog(Log_ChangeItemPos,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
			if (tips.valid())
			{
				ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
				if(success == 0)
				{
					void *param;
					int selectid = m_stream->_readUChar();
					int exchage = m_stream->_readUChar();
					int itemid1 = m_stream->_readInt();
					_crInt32 euqipmagicid1 = 0;
					unsigned char count1 = 0;
					if(itemid1>0)
					{
						euqipmagicid1 = m_stream->_readInt();
						count1 = m_stream->_readUChar();
					}
					int itemid2 = m_stream->_readUChar();
					_crInt32 euqipmagicid2 = 0;
					unsigned char count2 = 0;
					if(itemid2>0)
					{
						euqipmagicid2 = m_stream->_readInt();
						count2 = m_stream->_readUChar();
					}
					crData *data = m_this->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJItemBagVec,param);
					JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
					if(itemid1>0)
					{
						(*itembagvec)[selectid]->setItemID(itemid1);
						(*itembagvec)[selectid]->setEquipMagic(euqipmagicid1);
						(*itembagvec)[selectid]->setItemCount(count1);
					}
					else
					{
						(*itembagvec)[selectid] = NULL;
					}
					if(itemid2>0)
					{
						(*itembagvec)[exchage]->setItemID(itemid2);
						(*itembagvec)[exchage]->setEquipMagic(euqipmagicid2);
						(*itembagvec)[exchage]->setItemCount(count2);
					}
					else
					{
						(*itembagvec)[exchage] = NULL;
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					std::string str = "背包已更新";
					if(input.valid())input->setString(str);
					if(tips.valid())crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPutOnEquipMethod
//
/////////////////////////////////////////
crJXJPutOnEquipMethod::crJXJPutOnEquipMethod():
	m_this(NULL),
	m_isconfirm(false)
{
}
crJXJPutOnEquipMethod::crJXJPutOnEquipMethod(const crJXJPutOnEquipMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_bagcanvas(handle.m_bagcanvas),
	m_allusecheck(handle.m_allusecheck),
	m_loadingcanvas(handle.m_loadingcanvas),
	m_isconfirm(handle.m_isconfirm)
{
}
void crJXJPutOnEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJPutOnEquipMethod::addParam(int i, const std::string& str)
{
	switch(i)
	{
	case 0:
		m_bagcanvas = str;
		break;
	case 1:
		m_allusecheck = str;
		break;
	case 2:
		m_loadingcanvas = str;
		break;
	case 3:
		m_isconfirm = (bool)(atoi(str.c_str()));
		break;
	}
}
void crJXJPutOnEquipMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		void *param;
		if(m_this)
		{
			int itemid = 0;
			int itemcount = 0;
			unsigned char useall = 0;
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
			braindata->getParam(WCHDATA_JXJSaleItemID,param);
			unsigned char selectid = *(unsigned char*)param;
			braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			crData *data = myPlayer->getDataClass();
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJItemBagVec,param);
			JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
			if(selectid >= 0)
			{
				if ((*itembagvec)[selectid]!=NULL)
				{
					itemid = (*itembagvec)[selectid]->getItemID();
					itemcount = (*itembagvec)[selectid]->getItemCount();
					if (itemid > 0)
					{
						ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
						int typeindex = itemtab->getTitleIndex("类型");
						int scriptindex = itemtab->getTitleIndex("脚本");
						crTableIO::StrVec itemrecord;
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),itemrecord) >= 0 )
						{
							if (atoi(itemrecord[typeindex].c_str()) == IT_Equip)
							{
								////
								crRole *mainRole = myPlayer->getMainRole();
								crData *roleData = mainRole->getDataClass();
								roleData->getParam(WCHDATA_Level,param);
								unsigned char rolelv = *(unsigned char *)param;
								int needcharacterlevelindex = itemtab->getTitleIndex("人物等级"); 
								unsigned char needlv = atoi(itemrecord[needcharacterlevelindex].c_str());
								if (rolelv >= needlv)
								{
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(5);
									stream->_writeUChar(selectid);
									stream->_writeInt(itemid);
									crPlayerDataEventPacket packet;
									crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPutOnEquip,stream.get());
									netConductor->getNetManager()->sendPacket("all",packet);
								}
								else
								{
									//提示等级不足
									myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2024,NULL));//等级不足
								}
								crFilterRenderManager::getInstance()->showCanvas(canvas.get(),false);
							}
							else if(!itemrecord[scriptindex].empty())
							{
								ref_ptr<crCanvasNode>bagcanvas = crFilterRenderManager::getInstance()->findCanvas(m_bagcanvas);
								ref_ptr<crCanvasNode>loadingcanvas = crFilterRenderManager::getInstance()->findCanvas(m_loadingcanvas);
								if (bagcanvas.valid())
								{
									ref_ptr<crCheckBoxWidgetNode> allusecheck = dynamic_cast<crCheckBoxWidgetNode *>(bagcanvas->getWidget(m_allusecheck));
									if (allusecheck.valid())
									{
										useall = allusecheck->getSelect();
									}
								}
								crData *braindata = crBrain::getInstance()->getDataClass();
								if (useall > 0 && braindata)
								{
									braindata->inputParam(WCHDATA_JXJUseItemRemainCount,&itemcount);
									if (loadingcanvas.valid())
									{
										crFilterRenderManager::getInstance()->doModal(loadingcanvas.get());
									}
								}
								else
								{
									braindata->inputParam(WCHDATA_JXJUseItemRemainCount,0);
								}
								if (m_isconfirm)
								{
									myPlayer->doEvent(MAKEINT64(WCH_JXJUseBagItemConfirm,NULL), MAKECREPARAM(itemid,selectid));
								}
								else
								{
									myPlayer->doEvent(MAKEINT64(WCH_JXJUseBagItem,NULL), MAKECREPARAM(itemid,selectid));
								}
							}
						}
					}
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvPutOnEquipMethod
//
/////////////////////////////////////////
crJXJRecvPutOnEquipMethod::crJXJRecvPutOnEquipMethod():
	m_netType(GameClient_Game){}
crJXJRecvPutOnEquipMethod::crJXJRecvPutOnEquipMethod(const crJXJRecvPutOnEquipMethod& handle):
	crMethod(handle)
	//m_tips(handle.m_tips),
	//m_input(handle.m_input)
{
}
void crJXJRecvPutOnEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPutOnEquipMethod::addParam(int i, const std::string& str)
{
	//switch (i)
	//{
	//case 0:
	//	m_tips = str;
	//	break;
	//case 1:
	//	m_input = str;
	//	break;
	//}
}

void crJXJRecvPutOnEquipMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			char success = 0;//-1,等级不足，-2需要整理背包，-3非法道具
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{//验证背包是否可移动
				unsigned char selectid = m_stream->_readUChar();
				int recvitemid = m_stream->_readInt();
				void *param;
				unsigned char openbagnum;
				int itemid = 0,itemid2 = 0;
				_crInt32 equipmagic = 0,equipmagic2 = 0;
				JXJItemBagVec *itembagvec;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				itembagvec = (JXJItemBagVec *)param;
				data->getParam(WCHDATA_JXJOpenBagNum,param);
				openbagnum = *(unsigned char *)param;
				crData *mainroledata = m_this->getMainRole()->getDataClass();
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,1));
				//mainroledata->getParam(WCHDATA_JXJLordSuitMap,param);
				//JXJLordSuitMap *lordequipsuitmap = (JXJLordSuitMap *)param;;
				if(selectid>=0 && selectid <openbagnum)
				{
					if((*itembagvec)[selectid]!=NULL)
					{
						itemid = (*itembagvec)[selectid]->getItemID();
						//if (recvitemid == itemid)
						{
							equipmagic = (*itembagvec)[selectid]->getEquipMagic();
							ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
							ref_ptr<crTableIO>equiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
							int equippos = equiptab->getTitleIndex("partid");
							crTableIO::StrVec itemrecord,equiprecord;
							if(equiptab->queryOneRecord(0,crArgumentParser::appItoa(itemid),equiprecord)  >= 0 && itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),itemrecord) >= 0 )
							{
								mainroledata->getParam(WCHDATA_JXJLordEquipVec,param);
								JXJLordEquipVec *lordequipvec = (JXJLordEquipVec *)param;;
								////
								int needcharacterlevelindex = itemtab->getTitleIndex("人物等级"); 

								//crRole *mainRole = m_this->getMainRole();
								//crData *roleData = mainRole->getDataClass();
								mainroledata->getParam(WCHDATA_Level,param);
								unsigned char rolelv = *(unsigned char *)param;
								//////
								unsigned char needlv = atoi(itemrecord[needcharacterlevelindex].c_str());
								int partid = atoi(equiprecord[equippos].c_str());
								if (rolelv >= needlv)
								{
									if ((*lordequipvec)[partid].first>0)
									{
										itemid2 = (*lordequipvec)[partid].first;
										equipmagic2 = (*lordequipvec)[partid].second;
									}
									(*lordequipvec)[partid].first = itemid;
									(*lordequipvec)[partid].second = equipmagic;
									if (itemid2 > 0)
									{
										(*itembagvec)[selectid]->setItemID(itemid2);
										(*itembagvec)[selectid]->setEquipMagic(equipmagic2);
									}
									else
									{
										(*itembagvec)[selectid] = NULL;
									}
									//m_this->getMainRole()->doEvent(WCH_JXJCheckLordEquipSuit);
									success = 1;//成功
								}
								else
								{
									success = -1;//等级不足
								}
							}
							else
							{
								success = -3;//非法道具
							}
						}
						//else
						//{
						//	success = -2;//需要整理背包
						//}
					}
					else
					{
						success = -2;//需要整理背包
					}
				}
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,0));
				data->excHandle(MAKECREPARAM(WCH_LockData,0));

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				if(success!=0)
				{
					stream->createBuf(18);
					stream->_writeChar(success);
					stream->_writeUChar(selectid);
					stream->_writeInt(itemid);
					stream->_writeInt(equipmagic);
					stream->_writeInt(itemid2);
					stream->_writeInt(equipmagic2);
					//stream->_writeUChar((unsigned char)lordequipsuitmap->size());
					//if (lordequipsuitmap->size() > 0)
					//{
					//	for (JXJLordSuitMap::iterator itr = lordequipsuitmap->begin();
					//		itr!=lordequipsuitmap->end();
					//		++itr)
					//	{
					//		if (itr->first > 0)
					//		{
					//			stream->_writeUChar(itr->first);
					//			stream->_writeUChar(itr->second);
					//		}
					//	}
					//}
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPutOnEquip,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				///游戏日志
				std::string logdata = "穿装备(success,itemid)，" + crArgumentParser::appVectoa(crVector2i(success,itemid));
				GameLogData gamelog(Log_PutOnEquip,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			char success = m_stream->_readChar();
			//ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
			//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
			if(success == 1)
			{
				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				crData *mainroledata = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole()->getDataClass();
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,1));
				//mainroledata->getParam(WCHDATA_JXJLordSuitMap,param);
				//JXJLordSuitMap *lordequipsuitmap = (JXJLordSuitMap *)param;
				//lordequipsuitmap->clear();
				int selectid = m_stream->_readUChar();
				int itemid1 = m_stream->_readInt();
				_crInt32 equipmagic = m_stream->_readInt();
				int itemid2 = m_stream->_readInt();
				_crInt32 equipmagic2 = m_stream->_readInt();
				//unsigned char suitsize = m_stream->_readUChar();
				//unsigned char suitid = 0;
				//unsigned char suitnum = 0;
				//for (int i = 0; i < suitsize;i++)
				//{
				//	suitid = m_stream->_readUChar();
				//	suitnum = m_stream->_readUChar();
				//	lordequipsuitmap->insert(std::make_pair(suitid,suitnum));
				//}
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				mainroledata->getParam(WCHDATA_JXJLordEquipVec,param);
				JXJLordEquipVec *lordequipvec = (JXJLordEquipVec *)param;
				if(itemid1>0)
				{
					ref_ptr<crTableIO>equiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
					int equippos = equiptab->getTitleIndex("partid");
					crTableIO::StrVec record;
					if(equiptab->queryOneRecord(0,crArgumentParser::appItoa(itemid1),record) >= 0 )
					{
						int partid = atoi(record[equippos].c_str());
						(*lordequipvec)[partid].first = itemid1;
						(*lordequipvec)[partid].second = equipmagic;
					}
				}
				if(itemid2>0)
				{
					(*itembagvec)[selectid]->setItemID(itemid2);
					(*itembagvec)[selectid]->setEquipMagic(equipmagic2);
				}
				else
				{
					(*itembagvec)[selectid] = NULL;
				}
				//m_this->getMainRole()->doEvent(WCH_JXJCheckLordEquipSuit);
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,0));
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				//std::string str = "背包已更新";
				//if(input)input->setString(str);
				//if(tips)crFilterRenderManager::getInstance()->showCanvas(tips,true);
			}
			else
			{//错误提示
				int index = 0;
				switch (success)
				{
				case -1://等级不足
					index = 2024;
					break;
				case -2://需要整理背包
					index = 2046;
					break;
				case -3://非法道具
					index = 2047;
					break;
				}
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISplitItemEquipMethod
//
/////////////////////////////////////////
crJXJUISplitItemEquipMethod::crJXJUISplitItemEquipMethod():
	m_this(NULL)
{
}
crJXJUISplitItemEquipMethod::crJXJUISplitItemEquipMethod(const crJXJUISplitItemEquipMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_input(handle.m_input),
	m_tips(handle.m_tips),
	m_inputtips(handle.m_inputtips)
{
}
void crJXJUISplitItemEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISplitItemEquipMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	case 1:
		m_tips = str;
		break;
	case 2:
		m_inputtips = str;
		break;
	}
}
void crJXJUISplitItemEquipMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
		ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
		if(!tips)
			return;
		ref_ptr<crStaticTextWidgetNode> inputtip = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_inputtips));
		unsigned char count;
		if(input.valid())count = atoi((input->getUTF8String()).c_str());
		if(canvas.valid() && count > 0)
		{
			void *param;
			crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->getParam(WCHDATA_JXJSaleItemID,param);
			unsigned char selectid = *(unsigned char*)param;
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJItemBagVec,param);
			JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
			data->getParam(WCHDATA_JXJOpenBagNum,param);
			unsigned char openbagnum = *(unsigned char *)param;
			JXJItemBagVec::iterator itr;
			if(selectid<openbagnum && count>0)
			{
				unsigned char splitid = 0;
				for (itr = itembagvec->begin();itr!=itembagvec->end();++itr,++splitid)
				{
					if ((*itr) == NULL)
					{
						if ((*itembagvec)[selectid]!=NULL)
						{
							unsigned char newcount = (*itembagvec)[selectid]->getItemCount() - count;
							int itemid = (*itembagvec)[selectid]->getItemID();
							_crInt32 equipmagic = (*itembagvec)[selectid]->getEquipMagic();
							ref_ptr<crBagItemData> bagitem = new crBagItemData;
							bagitem->setItemID(itemid);
							bagitem->setEquipMagic(equipmagic);
							bagitem->setItemCount(count);
							(*itembagvec)[splitid] = bagitem;
							if(newcount > 0)
							{
								(*itembagvec)[selectid]->setItemCount(newcount);
							}
							else
							{
								(*itembagvec)[selectid] = NULL;
							}
							//(*itr)->setItemCount(count);
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(11);
							stream->_writeInt(itemid);
							stream->_writeInt(equipmagic);
							stream->_writeUChar(selectid);
							stream->_writeUChar(splitid);
							stream->_writeUChar(count);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvSplitItemEquip,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
							break;
						}
					}
				}
				if (itr == itembagvec->end())
				{
					std::string str = "格子不足";
					if(inputtip.valid())inputtip->setString(str);
					if(tips.valid())crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSplitItemEquipMethod
//
/////////////////////////////////////////
crJXJRecvSplitItemEquipMethod::crJXJRecvSplitItemEquipMethod():
	m_netType(GameClient_Game){}
crJXJRecvSplitItemEquipMethod::crJXJRecvSplitItemEquipMethod(const crJXJRecvSplitItemEquipMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSplitItemEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSplitItemEquipMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_input = str;
		break;
	}
}

void crJXJRecvSplitItemEquipMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{//验证是否可拆分
				int itemid = m_stream ->_readInt();
				_crInt32 equipmagic = m_stream->_readInt();
				unsigned char selectid = m_stream->_readUChar();
				unsigned char splitid = m_stream->_readUChar();
				unsigned char count = m_stream->_readUChar();
				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				data->getParam(WCHDATA_JXJOpenBagNum,param);
				unsigned char openbagnum = *(unsigned char *)param;
				//JXJItemBagVec::iterator itr;
				if(selectid<openbagnum && count>0)
				{
					if (/*(*itr) == NULL && */(*itembagvec)[selectid] !=NULL && (*itembagvec)[splitid] == NULL && 
						(*itembagvec)[selectid]->getItemID() == itemid &&
						(*itembagvec)[selectid]->getEquipMagic() == equipmagic/*splitid == splitid2*/)
					{
						short newcount = (short)(*itembagvec)[selectid]->getItemCount() - (short)count;
						if(newcount >= 0)
						{
							ref_ptr<crBagItemData> bagitem = new crBagItemData;
							bagitem->setItemID(itemid);
							bagitem->setEquipMagic(equipmagic);
							bagitem->setItemCount(count);
							(*itembagvec)[splitid] = bagitem;
							if (newcount > 0)
							{
								(*itembagvec)[selectid]->setItemCount(newcount);
							}
							else
							{
								(*itembagvec)[selectid] = NULL;
							}
							success = 1;
						}
					}
				}

				//if(success != 1)
				//{
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(21);
				stream->_writeUChar(success);
				stream->_writeUChar(selectid);
				stream->_writeUChar(splitid);
				if(selectid<openbagnum && (*itembagvec).at(selectid)!=NULL)
				{
					stream->_writeInt((*itembagvec).at(selectid)->getItemID());//16+3
					stream->_writeInt((*itembagvec).at(selectid)->getEquipMagic());//16+3
					stream->_writeUChar((*itembagvec).at(selectid)->getItemCount());
				}
				else
				{
					stream->_writeInt(0);
					//stream->_writeUChar(0);
				}
				if(selectid<openbagnum && (*itembagvec).at(splitid)!=NULL)
				{
					stream->_writeInt((*itembagvec).at(splitid)->getItemID());//16+3
					stream->_writeInt((*itembagvec).at(splitid)->getEquipMagic());//16+3
					stream->_writeUChar((*itembagvec).at(splitid)->getItemCount());
				}
				else
				{
					stream->_writeInt(0);
					//stream->_writeUChar(0);
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvChangeItemPos,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				//}
				//WCH_JXJRecvChangeItemPos
				//WCH_JXJRecvSplitItemEquip
				///游戏日志
				std::string logdata = "背包拆分物品（success,splitid）：" + crArgumentParser::appVectoa(crVector2i(success,splitid));
				GameLogData gamelog(Log_SplitBagItem,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		//else if(m_netType == GameClient_Game)
		//{
		//	unsigned char success = m_stream->_readUChar();
		//	ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
		//	ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
		//	if(success == 1)
		//	{
		//		int selectid = m_stream->_readInt();
		//		unsigned char splitid = m_stream->_readUChar();
		//		unsigned char count = m_stream->_readUChar();
		//		void *param;
		//		crData *data = m_this->getDataClass();
		//		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		//		data->getParam(WCHDATA_JXJItemBagVec,param);
		//		JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;

		//		(*itembagvec)[selectid]->setItemCount((*itembagvec)[selectid]->getItemCount() - count);
		//		ref_ptr<crBagItemData> bagitem = new crBagItemData;
		//		bagitem->setItemID((*itembagvec)[selectid]->getItemID());
		//		bagitem->setItemCount(count);
		//		(*itembagvec)[splitid] = bagitem;
		//		data->excHandle(MAKECREPARAM(WCH_LockData,0));
		//	}
		//	if(success == 0)
		//	{
		//		std::string str = "拆分失败";
		//		if(input)input->setString(str);
		//		if(tips)crFilterRenderManager::getInstance()->showCanvas(tips,true);
		//	}
		//	if(success == 2)
		//	{
		//		std::string str = "格子不足";
		//		if(input)input->setString(str);
		//		if(tips)crFilterRenderManager::getInstance()->showCanvas(tips,true);
		//	}
		//}
	}
}


/////////////////////////////////////////
//
//crJXJUIChangeBagPageMethod
//
/////////////////////////////////////////
crJXJUIChangeBagPageMethod::crJXJUIChangeBagPageMethod()
{
}
crJXJUIChangeBagPageMethod::crJXJUIChangeBagPageMethod(const crJXJUIChangeBagPageMethod& handle):
	crMethod(handle),
	m_radio(handle.m_radio),
	m_myBagList(handle.m_myBagList)
{
}
void crJXJUIChangeBagPageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIChangeBagPageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_radio = str;
		break;
	case 1:
		m_myBagList = str;
		break;
	}
}
void crJXJUIChangeBagPageMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	//ref_ptr<crListControlWidgetNode> backPackList = dynamic_cast<crListControlWidgetNode *>(m_this->getWidget(m_myBagList));
	ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio));
	if(m_ea && radio.valid())
	{
		do 
		{
			if(!m_this)
				break;
			ref_ptr<crListControlNode> listNode = m_this->getSelectNode();
			if(!listNode || !listNode->getVisiable())
			{
				break;
			}
			crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
			crWidgetNode* pickUI = NULL;
			crWidgetNode *capturer = crFilterRenderManager::getInstance()->getMouseCapturer();
			crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
			crFilterRenderManager::getInstance()->mousePick(mouse,pickUI);
			crFilterRenderManager::getInstance()->setMouseCapturer(capturer);
			if(!pickUI)
			{//Drop Item
				break;
			}
			else if(pickUI != listNode.get())
			{
				if(dynamic_cast<crRadioWidgetNode *>(pickUI) && pickUI->getParentWidget()->getName().compare(m_radio) == 0)
				{
					dynamic_cast<crRadioWidgetNode *>(pickUI)->select(true);
				}
			}
		} while (0);
	}
}

/////////////////////////////////////////
//
//crJXJUISetAcceptDragMethod
//
/////////////////////////////////////////
crJXJUISetAcceptDragMethod::crJXJUISetAcceptDragMethod():
	m_this(NULL)
{
}
crJXJUISetAcceptDragMethod::crJXJUISetAcceptDragMethod(const crJXJUISetAcceptDragMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJUISetAcceptDragMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRadioGroupWidgetNode*)param;
		break;
	}
}
void crJXJUISetAcceptDragMethod::addParam(int i, const std::string& str)
{
}
void crJXJUISetAcceptDragMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		for (int i = 0; i<5 ;i++)
		{
			m_this->getRadio(i)->setAcceptDrag(true);
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIJiangkaListUpdateMethod
//
/////////////////////////////////////////
crJXJUIJiangkaListUpdateMethod::crJXJUIJiangkaListUpdateMethod(){}
crJXJUIJiangkaListUpdateMethod::crJXJUIJiangkaListUpdateMethod(const crJXJUIJiangkaListUpdateMethod& handle):
	crMethod(handle),
	m_myBagList(handle.m_myBagList),
	m_pagenum(handle.m_pagenum),
	m_itemtype(handle.m_itemtype),
	m_itemtype2(handle.m_itemtype2),
	m_itemtype3(handle.m_itemtype3),
	//m_sellcanvas(handle.m_sellcanvas),
	//m_upgradecanvas(handle.m_upgradecanvas),
	m_leftbtn(handle.m_leftbtn),
	m_rightbtn(handle.m_rightbtn),
	m_defaulticon(handle.m_defaulticon)/*,
	m_orangeupgradecanvas(handle.m_orangeupgradecanvas)*/
{
	for( int i=0; i<10; i++)
	{
		m_frame[i] = handle.m_frame[i];
	}
}
void crJXJUIJiangkaListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIJiangkaListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_myBagList = str;
		break;
	case 1:
		m_pagenum = str;
		break;
	case 2:
		m_itemtype = str;
		break;
	case 3:
		m_itemtype2 = str;
		break;
	case 4:
		m_itemtype3 = str;
		break;
	case 5:
		//m_sellcanvas = str;
		break;
	case 6:
		//m_upgradecanvas = str;
		break;
	case 7:
		m_leftbtn = str;
		break;
	case 8:
		m_rightbtn = str;
		break;
	case 9:
		m_defaulticon = str;
		break;
	//case 10:
	//	m_whiteframe = str;
	//	break;
	//case 11:
	//	m_greenframe = str;
	//	break;
	//case 12:
	//	m_blueframe = str;
	//	break;
	//case 13:
	//	m_purpleframe = str;
	//	break;
	//case 14:
	//	m_orangeframe = str;
	//	break;
	case 10:
		//m_orangeupgradecanvas = str;
		break;
	case 11:
	case 12:
	case 13:
	case 14:
	case 15:
	case 16:
	case 17:
	case 18:
	case 19:
	case 20:
		m_frame[i-11] = str;
		break;
	}
}
void crJXJUIJiangkaListUpdateMethod::operator()(crHandle &handle)
{
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	if(m_this)
	{
		int typeitem = 0,typeitem2 = 0,curpage = 0;
		ref_ptr<crListControlWidgetNode> backPackList = dynamic_cast<crListControlWidgetNode *>(m_this->getWidget(m_myBagList));
		ref_ptr<crStaticTextWidgetNode> pagenum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
		ref_ptr<crRadioGroupWidgetNode> itemtype = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_itemtype));
		ref_ptr<crRadioGroupWidgetNode> itemtype2 = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_itemtype2));
		ref_ptr<crRadioGroupWidgetNode> itemtype3 = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_itemtype3));
		ref_ptr<crButtonWidgetNode> leftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_leftbtn));
		ref_ptr<crButtonWidgetNode> rightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_rightbtn));
		//ref_ptr<crCanvasNode>sellcanvas = crFilterRenderManager::getInstance()->findCanvas(m_sellcanvas);
		//ref_ptr<crCanvasNode>upgradecanvas = crFilterRenderManager::getInstance()->findCanvas(m_upgradecanvas);
		//ref_ptr<crCanvasNode>orangeupgradecanvas = crFilterRenderManager::getInstance()->findCanvas(m_orangeupgradecanvas);
		crData *canvas_data = m_this->getDataClass();

		if(backPackList.valid())
		{
			//if (itemtype3.valid() && sellcanvas.valid() && upgradecanvas.valid() && orangeupgradecanvas.valid())
			//{
			//	switch (itemtype3->getSelect())
			//	{
			//	case JKBT_Jiangka:
			//		if (sellcanvas->getVisiable())
			//		{
			//			sellcanvas->setVisiable(false);
			//		}
			//		if (upgradecanvas->getVisiable())
			//		{
			//			upgradecanvas->setVisiable(false);
			//		}
			//		if (orangeupgradecanvas->getVisiable())
			//		{
			//			orangeupgradecanvas->setVisiable(false);
			//		}
			//		break;
			//	case JKBT_Upgrade:
			//		//crFilterRenderManager::getInstance()->showCanvas(upgradecanvas,true);
			//		if (sellcanvas->getVisiable())
			//		{
			//			sellcanvas->setVisiable(false);
			//		}
			//		break;
			//	case JKBT_Sell:
			//		//crFilterRenderManager::getInstance()->showCanvas(sellcanvas,true);
			//		if (upgradecanvas->getVisiable())
			//		{
			//			upgradecanvas->setVisiable(false);
			//		}
			//		if (orangeupgradecanvas->getVisiable())
			//		{
			//			orangeupgradecanvas->setVisiable(false);
			//		}
			//		break;
			//	}
			//}
			void *param;
			crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int totalcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
			int onepagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagOnePageNum,viplv).c_str()));
			if(itemtype.valid())
			{
				typeitem = itemtype->getSelect();
			}
			if (itemtype2.valid())
			{
				typeitem2 = itemtype2->getSelect();
			}
			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			ref_ptr<crTableIO>itemtab2 = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
			//braindata
			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->getParam(WCHDATA_JXJCurJiangkaBagPageNum,param);
			curpage = *(int *)param;
			//playerdata
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvas_data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJJiangkaBagVec,param);
			JXJItemBagVec *itembagvec2 = (JXJItemBagVec *)param;
			canvas_data->getParam(WCHDATA_JXJForJKVec, param);
			JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
			crTableIO::StrVec itemrecord,itemrecord2;
			std::string iconfile;
			//std::string title,title2;
			//backPackList->clearList();
			backPackList->setListNodeCount(totalcount);
			backPackList->setStartYPos(curpage - 1);
			crListControlWidgetNode::ListNodeVec& listNodeVec = backPackList->getListNodeVec();
			//int index = 0;
			int count = 0;
			int nameid = itemtab->getTitleIndex("name");
			int iconid = itemtab->getTitleIndex("miniicon");
			int color = itemtab->getTitleIndex("品质");
			int attrid = itemtab->getTitleIndex("将卡类型");
			//itembagvec->resize(openbagnum);
			/////////////////////////////////////////////

			//JXJItemBagVec newitembagvec,newitembagvec2;
			//BagItemMultiMap2 bagitemmap,bagitemmap2;
			//for (JXJItemBagVec::iterator itr = itembagvec->begin();
			//	itr != itembagvec->end();
			//	++itr)
			//{
			//	if((*itr)!= NULL)
			//	{
			//		if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
			//			bagitemmap.insert(std::make_pair(atoi(itemrecord[color].c_str()),(*itr).get()));
			//	}
			//}

			//for (BagItemMultiMap2::iterator itr2 = bagitemmap.begin();
			//	itr2 != bagitemmap.end();
			//	++itr2 )
			//{
			//	if(newitembagvec.empty())
			//		newitembagvec.push_back(itr2->second);
			//	else
			//	{
			//		crBagItemData *backitem;
			//		backitem = (newitembagvec.back()).get();
			//		{
			//			newitembagvec.push_back(itr2->second);
			//		}

			//	}
			//}
			//newitembagvec.resize(itembagvec->size());
			//itembagvec->swap(newitembagvec);
			////////////////////////////////////////////
			//for (JXJItemBagVec::iterator itr = itembagvec2->begin();
			//	itr != itembagvec2->end();
			//	++itr)
			//{
			//	if((*itr)!= NULL)
			//	{
			//		if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
			//			bagitemmap2.insert(std::make_pair(atoi(itemrecord[color].c_str()),(*itr).get()));
			//	}
			//}

			//for (BagItemMultiMap2::iterator itr2 = bagitemmap2.begin();
			//	itr2 != bagitemmap2.end();
			//	++itr2 )
			//{
			//	if(newitembagvec2.empty())
			//		newitembagvec2.push_back(itr2->second);
			//	else
			//	{
			//		crBagItemData *backitem;
			//		backitem = (newitembagvec2.back()).get();
			//		{
			//			newitembagvec2.push_back(itr2->second);
			//		}

			//	}
			//}
			//newitembagvec2.resize(itembagvec2->size());
			//itembagvec2->swap(newitembagvec2);

			//////////////////////////////////////////////
			int dataid = 0;
			for(int index=0;index<totalcount;index++)
			{
				listNodeVec[index]->setData(-1);
				listNodeVec[index]->setImageName(m_defaulticon);
				listNodeVec[index]->setImageName("",1);
				listNodeVec[index]->setVisiable(true);
				listNodeVec[index]->setEnable(false);
			}
			//index = 0;
			if(!typeitem)
			{
				for( JXJItemBagVec::iterator itr = itembagvec->begin();
					itr != itembagvec->end();
					++itr,/*++index,*/++dataid )
				{
					if(count<totalcount)
					{
						if((*itr)!=NULL && (*itr)->getItemID()!=0)
						{
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
							{
								int nowcount = (*itr)->getItemCount();
								if (nowcount == 0)
								{
									//index--;
									continue;
								}
								if (typeitem2>0)
								{
									if (atoi(itemrecord[attrid].c_str()) != typeitem2 - 1)
									{
										//index--;
										continue;
									}
								}
								int quality = atoi(itemrecord[color].c_str());
								//switch (atoi(itemrecord[color].c_str()))
								//{
								//case 0:
								//	framefile = m_whiteframe;
								//	break;
								//case 1:
								//	framefile = m_greenframe;
								//	break;
								//case 2:
								//	framefile = m_blueframe;
								//	break;
								//case 3:
								//	framefile = m_purpleframe;
								//	break;
								//case 4:
								//case 5:
								//case 6:
								//case 7:
								//case 8:
								//case 9:
								//	framefile = m_orangeframe;
								//	break;
								//default:
								//	framefile = "";
								//	break;
								//}
								//title = itemrecord[nameid];
								//title2 = crArgumentParser::appItoa(nowcount);
								iconfile = itemrecord[iconid];
								//listNodeVec[index]->setTitle(title);
								//listNodeVec[index]->setTitle2(title2);
								listNodeVec[count]->setData(/*curpage*onepagecount+*/dataid);
								listNodeVec[count]->setImageName(iconfile);
								listNodeVec[count]->setImageName(m_frame[quality],1);
								listNodeVec[count]->setVisiable(true);
								listNodeVec[count]->setEnable(true);
								count++;
							}
						}
					}
				}
			}
			else
			{
				for( JXJItemBagVec::iterator itr = itembagvec->begin();
					itr != itembagvec->end();
					++itr,/*++index,*/++dataid )
				{
					if(count<totalcount)
					{
						if((*itr)!=NULL && (*itr)->getItemID()!=0)
						{
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
							{
								int nowcount = (*itr)->getItemCount();
								if (typeitem - 1 != CardColor_Orange)
								{
									if (atoi(itemrecord[color].c_str()) != typeitem - 1 || nowcount == 0)
									{
										//index--;
										continue;
									}
								}
								else
								{
									if (atoi(itemrecord[color].c_str()) < typeitem - 1 || nowcount == 0)
									{
										//index--;
										continue;
									}
								}
								if (typeitem2 > 0)
								{
									if(atoi(itemrecord[attrid].c_str()) != typeitem2 - 1)  
									{
										//index--;
										continue;
									}
								}
								//switch (atoi(itemrecord[color].c_str()))
								//{
								//case 0:
								//	framefile = m_whiteframe;
								//	break;
								//case 1:
								//	framefile = m_greenframe;
								//	break;
								//case 2:
								//	framefile = m_blueframe;
								//	break;
								//case 3:
								//	framefile = m_purpleframe;
								//	break;
								//case 4:
								//case 5:
								//case 6:
								//case 7:
								//case 8:
								//case 9:
								//	framefile = m_orangeframe;
								//	break;
								//default:
								//	framefile = "";
								//	break;
								//}
								int quality = atoi(itemrecord[color].c_str());
								//title = itemrecord[nameid];
								//title2 = crArgumentParser::appItoa(nowcount);
								iconfile = itemrecord[iconid];
								//listNodeVec[index]->setTitle(title);
								//listNodeVec[index]->setTitle2(title2);
								listNodeVec[count]->setData(/*curpage*onepagecount+*/dataid);
								listNodeVec[count]->setImageName(iconfile);
								listNodeVec[count]->setImageName(m_frame[quality],1);
								listNodeVec[count]->setVisiable(true);
								listNodeVec[count]->setEnable(true);
								count++;
							}
						}
						//else
						//{
						//	index--;
						//}
					}
				}
			}
			canvas_data->excHandle(MAKECREPARAM(WCH_LockData,0));
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
			//if(index<0)index=0;
			int totalpage = ceil((float)count/(float)onepagecount);
			if (totalpage<1)
			{
				totalpage = 1;
			}
			brainData->inputParam(WCHDATA_JXJTotalJiangkaBagPageNum,&totalpage);

			if (leftbtn.valid())
			{
				leftbtn->setEnable(true);
			}
			if (rightbtn.valid())
			{
				rightbtn->setEnable(true);
			}
			if (curpage <= 1)
			{
				if (leftbtn.valid())
				{
					leftbtn->setEnable(false);
				}
			}
			if(curpage >= totalpage)
			{
				if (rightbtn.valid())
				{
					rightbtn->setEnable(false);
				}
			}
			if(pagenum.valid())pagenum->setString(crArgumentParser::appItoa(curpage)+"/"+crArgumentParser::appItoa(totalpage));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIjiangkaTipInfoMethod
//
/////////////////////////////////////////
crJXJUIjiangkaTipInfoMethod::crJXJUIjiangkaTipInfoMethod():
	m_ea(NULL),
	m_this(NULL),
	m_cardlvsw("XingJi")
{
}
crJXJUIjiangkaTipInfoMethod::crJXJUIjiangkaTipInfoMethod(const crJXJUIjiangkaTipInfoMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_backboard(handle.m_backboard),
	m_ea(NULL),
	m_this(NULL),
	m_card(handle.m_card),
	m_guojia(handle.m_guojia),
	m_shuxing(handle.m_shuxing),
	m_bingzhong(handle.m_bingzhong),
	m_leixing(handle.m_leixing),
	m_jinengmiaoshu(handle.m_jinengmiaoshu),
	m_nameimage(handle.m_nameimage),
	m_jineng(handle.m_jineng),
	m_cardlvsw(handle.m_cardlvsw)
{
}
void crJXJUIjiangkaTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIjiangkaTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_card = str;
		break;
	case 2:
		m_backboard = str;
		break;
	case 3:
		m_guojia = str;
		break;
	case 4:
		m_shuxing = str;
		break;
	case 5:
		m_bingzhong = str;
		break;
	case 6:
		m_leixing = str;
		break;
	case 7:
		m_jinengmiaoshu = str;
		break;
	case 8:
		m_nameimage = str;
		break;
	case 9:
		m_jineng = str;
		break;
	}
}
void crJXJUIjiangkaTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(tipsCanvas.valid() && playerData)
	{
		void *param;
		tipsCanvas->setCanFocus(false);
		//ref_ptr<crHypertextWidgetNode> info2 = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_info2));
		ref_ptr<crHypertextWidgetNode> jinengmiaoshu = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_jinengmiaoshu));
		ref_ptr<crImageBoxWidgetNode> card = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_card));
		ref_ptr<crImageBoxWidgetNode> nameimage = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_nameimage));
		crMultiSwitch *backboard = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_backboard));
		crMultiSwitch *cardlvsw = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_cardlvsw));
		ref_ptr<crListControlNode> selectNode = m_this->getSelectNode();
		crData *data = playerData->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		unsigned char openbagnum = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
		int itemid;
		if(selectNode.valid())
		{
			int selectid = selectNode->getData();
			if (selectid>=0 && selectid<openbagnum)
			{
				JXJItemBagVec *itembagvec = NULL;
				crData *cdata = m_this->getParentCanvas()->getDataClass();
				if (cdata)
				{
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					cdata->excHandle(MAKECREPARAM(WCH_LockData,1));
					cdata->getParam(WCHDATA_JXJForJKVec,param);
					itembagvec = (JXJItemBagVec *)param;
					if (!itembagvec)
					{
						data->getParam(WCHDATA_JXJJiangkaBagVec,param);
						itembagvec = (JXJItemBagVec *)param;
					}
					if (itembagvec && (*itembagvec)[selectid]!=NULL)
					{
						itemid = (*itembagvec)[selectid]->getItemID();
						if(itemid>0)
						{
							ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);

							//int jinengmiaoshuid = troopsEquipTab->getTitleIndex("技能描述");
							int cardid = troopsEquipTab->getTitleIndex("picture");
							int nameimageid = troopsEquipTab->getTitleIndex("姓名");
							int backboardid = troopsEquipTab->getTitleIndex("品质");
							int guojiaid = troopsEquipTab->getTitleIndex("国家");
							crTableIO::StrVec record;
							if (troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
							{
								//std::string file;
								if(jinengmiaoshu.valid())
								{
									//file = record[jinengmiaoshuid];
									//if(!file.empty())
									//{
									//	jinengmiaoshu->clearText();
									//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
									//	jinengmiaoshu->setHypertext(file);
									//}
									//else
									//{
									//	jinengmiaoshu->clearText();
									//}
									ItemMap itemMap;
									rcfg::ConfigScript outscript(&itemMap);
									crVector2i item(itemid,0);
									playerData->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
									jinengmiaoshu->setHypertext(outscript);
								}
								if(card.valid())
								{
									card->setImageName(record[cardid].c_str());
								}
								if(nameimage.valid())
								{
									nameimage->setImageName(record[nameimageid].c_str());
								}
								if(backboard)
								{
									int cardcolor = atoi(record[backboardid].c_str());
									backboard->setActiveSwitchSet(cardcolor);
									//if (cardcolor < CardColor_Orange)
									//{
									//	backboard->setActiveSwitchSet(cardcolor);
									//	if (cardlvsw)
									//	{
									//		cardlvsw->setActiveSwitchSet(0);
									//	}
									//}
									//else
									//{
									//	backboard->setActiveSwitchSet(cardcolor);//CardColor_Orange
									//	if (cardlvsw)
									//	{
									//		cardlvsw->setActiveSwitchSet(cardcolor - CardColor_Orange + 1);
									//	}
									//}
								}

								crVector4f rect = selectNode->getRect();
								crVector4f rectoffset = m_this->getRectOffset();
								const crBoundingBox &tips = tipsCanvas->getBoundBox();
								float posx = (tips.m_max[0]-tips.m_min[0])*0.5;
								float posy = (tips.m_max[1]-tips.m_min[1])*0.5;
								//const crMatrix &mat = crListControlWidgetNode::getMvpwNode()->getMatrix();
								CRCore::crMatrixTransform *m_mvpwNode = m_this->getMvpwNode();
								const crMatrix &mat = m_mvpwNode->getMatrix() * m_this->getParentCanvas()->getMatrix();
								//crMatrix invmat = crMatrix::inverse(mat);
								crVector3 pos(rect[2] + rect[0] + rectoffset[0],rect[1] - rect[3] - rectoffset[1],0.0f);
								crVector3 ipos = pos * mat;
								/////////////////////////////////////////
								crVector3 pos2(rect[0] ,rect[1],0.0f);
								crVector3 ipos2 = pos2 * mat;
								float posx2,posy2;
								/////////////////////////////////////////
								if (ipos2[0] >= 0)
								{
									posx2 = ipos2[0] - posx;
								}
								else
								{
									posx2 = ipos[0] + posx;
								}
								if (ipos2[1] >= 0)
								{
									posy2 = ipos[1] - posy;
								}
								else
								{
									posy2 = ipos2[1] + posy;
								}
								if((abs(posy2)+posy)>1.0f)
								{
									if (posy2 >= 0)
									{
										posy2 -= posy;
									}
									else
									{
										posy2 += posy;
									}
								}
								crVector2 mouse(crVector2(posx2,posy2));
								/////////////////////////////////////////
								tipsCanvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
								tipsCanvas->setCanFocus(false);
								crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
							}
						}
					}
					cdata->excHandle(MAKECREPARAM(WCH_LockData,0));
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				else
				{
					crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
				}
			}
			else
			{
				crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
			}
		}
		else
		{
			crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIJiangkaBagPageMethod
//
/////////////////////////////////////////
crJXJUIJiangkaBagPageMethod::crJXJUIJiangkaBagPageMethod():
	m_this(NULL)
{
}
crJXJUIJiangkaBagPageMethod::crJXJUIJiangkaBagPageMethod(const crJXJUIJiangkaBagPageMethod& handle):
	crMethod(handle),
	m_step(handle.m_step)
{
}
void crJXJUIJiangkaBagPageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIJiangkaBagPageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = str;
		break;
	}
}
void crJXJUIJiangkaBagPageMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();

	if(m_this &&playerGameData)
	{
		void *param;
		int curpagenum,totalpage;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->getParam(WCHDATA_JXJCurJiangkaBagPageNum,param);
		curpagenum = *(int *)param;
		brainData->getParam(WCHDATA_JXJTotalJiangkaBagPageNum,param);
		totalpage = *(int *)param;
		if (m_step == "L")
		{
			curpagenum = 1;
		}
		else if (m_step == "R")
		{
			curpagenum = totalpage;
		}
		else
		{
			curpagenum += atoi(m_step.c_str());
			if (curpagenum <= 0 || curpagenum>totalpage)
			{
				curpagenum -=atoi(m_step.c_str());
			}
		}
		brainData->inputParam(WCHDATA_JXJCurJiangkaBagPageNum,&curpagenum);
	}
}


/////////////////////////////////////////
//
//crJXJAddOneJiangkaMethod
//
/////////////////////////////////////////
crJXJAddOneJiangkaMethod::crJXJAddOneJiangkaMethod():
	m_this(NULL)
{
}
crJXJAddOneJiangkaMethod::crJXJAddOneJiangkaMethod(const crJXJAddOneJiangkaMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_radio1(handle.m_radio1),
	m_radio2(handle.m_radio2),
	//m_radio3(handle.m_radio3),
	m_index(handle.m_index),
	m_this(NULL)
{
}
void crJXJAddOneJiangkaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJAddOneJiangkaMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_radio1 = str;
		break;
	case 2:
		m_radio2 = str;
		break;
	//case 3:
		//m_radio3 = str;
		//break;
	case 3:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJAddOneJiangkaMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crCanvasNode>canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if(canvas.valid() && canvas2.valid())
		{
			crData *canvasdata = canvas -> getDataClass();
			int row = m_index/3;
			int col = m_index%3;
			if (col == JiangkaType_ji)
			{
				canvasdata->inputParam(WCHDATA_JXJCurFormation1stCardIndex,&row);
			}
			else if(col == JiangkaType_mou)
			{
				canvasdata->inputParam(WCHDATA_JXJCurFormation2ndCardIndex,&row);
			}
			ref_ptr<crRadioGroupWidgetNode> radio1 = dynamic_cast<crRadioGroupWidgetNode *>(canvas2->getWidget(m_radio1));
			ref_ptr<crRadioGroupWidgetNode> radio2 = dynamic_cast<crRadioGroupWidgetNode *>(canvas2->getWidget(m_radio2));
			//ref_ptr<crRadioGroupWidgetNode> radio3 = dynamic_cast<crRadioGroupWidgetNode *>(canvas2->getWidget(m_radio3));
			row = (char)m_index/3;//将卡装备在第几行，将卡装备行数
			//const crBoundingBox &bbox = backPackList->getBoundBox();
			//float posy = (bbox.m_max[1]-bbox.m_min[1])*curpage;

			//////////////
			canvas->setMatrix(crMatrix::translate(-0.3,0,0.0f));
			//canvas->setCanFocus(false);
			//crFilterRenderManager::getInstance()->showCanvas(canvas,true);
			const crBoundingBox &bbox = canvas->getBoundBox();

			/////////////////
			const crBoundingBox &bbox2 = canvas2->getBoundBox();
			canvas2->setMatrix(crMatrix::translate(bbox.m_max[0] + bbox2.xLength()+0.015832,0,0.0f));
			//canvas2->setCanFocus(false);
			crFilterRenderManager::getInstance()->showCanvas(canvas2.get(),true);
			//if(radio1)
			//{
			//	radio1->select(0);
			//}
			//if(radio3.valid())
			//{
			//	radio3->select(JKBT_Jiangka);
			//	radio3->doEvent(WCH_UI_SelectChange);
			//}
			if(radio2.valid())
			{
				radio2->select(col + 1);
				radio2->doEvent(WCH_UI_SelectChange);
			}
			//crData *data = myPlayer->getDataClass();

			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->inputParam(WCHDATA_JXJJiangkaFormationRow,&row);
		}
	}
}


/////////////////////////////////////////
//
//crJXJUIAddJiangKaMethod
//
/////////////////////////////////////////
crJXJUIAddJiangKaMethod::crJXJUIAddJiangKaMethod():
	m_this(NULL)
{
}
crJXJUIAddJiangKaMethod::crJXJUIAddJiangKaMethod(const crJXJUIAddJiangKaMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_canvas(handle.m_canvas)
{
	for (int i = 0; i < 6;i++)
	{
		m_formationbtn[i] = handle.m_formationbtn[i];
		m_formationsw[i] = handle.m_formationsw[i];
	}
}
void crJXJUIAddJiangKaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	}
}
void crJXJUIAddJiangKaMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str; //编队窗口
		break;
	case 1:
		m_formationbtn[0] = str;
		break;
	case 2:
		m_formationbtn[1] = str;
		break;
	case 3:
		m_formationbtn[2] = str;
		break;
	case 4:
		m_formationbtn[3] = str;
		break;
	case 5:
		m_formationbtn[4] = str;
		break;
	case 6:
		m_formationbtn[5] = str;
		break;
	case 7:
		m_formationsw[0] = str;
		break;
	case 8:
		m_formationsw[1] = str;
		break;
	case 9:
		m_formationsw[2] = str;
		break;
	case 10:
		m_formationsw[3] = str;
		break;
	case 11:
		m_formationsw[4] = str;
		break;
	case 12:
		m_formationsw[5] = str;
		break;
	}
}
void crJXJUIAddJiangKaMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	//crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(m_this && playerData/* && netConductor*/)
	{
		ref_ptr<crCanvasNode>cardcanvas = m_this->getParentCanvas();
		ref_ptr<crCanvasNode>formationcanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (cardcanvas.valid() && formationcanvas.valid() && formationcanvas->getVisiable())
		{
			void *param;
			ref_ptr<crListControlNode> selectNode = m_this->getSelectNode();
			crData *data = playerData->getDataClass();
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			unsigned char openbagnum = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
			bool success = false;
			if(selectNode.valid())
			{
				int selectid = selectNode->getData();
				if (selectid>=0 && selectid<openbagnum)
				{
					int col = 0;
					int row = 0;
					int color = 0;
					int index = 0;
					ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					crTableIO::StrVec itemrecord;
					int attrindex = itemtab->getTitleIndex("将卡类型");
					int colorindex = itemtab->getTitleIndex("品质");
					int iconindex = itemtab->getTitleIndex("icon");
					int nameindex = itemtab->getTitleIndex("name");
					//cardbagdata
					crData *cardbagdata = cardcanvas ->getDataClass();
					cardbagdata->excHandle(MAKECREPARAM(WCH_LockData,1));
					cardbagdata->getParam(WCHDATA_JXJForJKVec, param);
					JXJItemBagVec *tempcardvec = (JXJItemBagVec *)param;
					//formationdata
					crData *formationdata = formationcanvas -> getDataClass();
					formationdata->getParam(WCHDATA_JXJTempFormationVec, param);
					FormationInfoVec *formations = (FormationInfoVec *)param;
					formationdata->getParam(WCHDATA_JXJCurFormation1stCardIndex, param);
					int firstcardindex = *(int *)param;
					formationdata->getParam(WCHDATA_JXJCurFormation2ndCardIndex, param);
					int secondcardindex = *(int *)param;
					///////////////////////////////////////////////////
					std::string cardname;
					int itemid = 0;
					if (selectid < tempcardvec->size() && (*tempcardvec)[selectid]!=NULL)
					{
						itemid = (*tempcardvec)[selectid]->getItemID();
						if (itemid > 0 && attrindex > 0 && colorindex > 0 && iconindex > 0)
						{
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),itemrecord) >= 0 )
							{
								cardname = itemrecord[nameindex];
								col = atoi(itemrecord[attrindex].c_str());
								color = atoi(itemrecord[colorindex].c_str());
								//if (color > CardColor_Orange)
								//{
								//	color = CardColor_Orange;
								//}
								color = color + 1;
								if (col == JiangkaType_ji)
								{
									row = firstcardindex;
								}
								else if (col == JiangkaType_mou)
								{
									row = secondcardindex;
								}
								if (row >= formations->size())
								{
									row = formations->size() - 1;
								}
								if (row < 0)
								{
									row = 0;
								}
								index = row * 2 + col;
								if((*formations)[row]!=NULL && col<=JiangkaType_mou && col >=JiangkaType_ji)success =true;
							}
						}
					}
					if (success)
					{
						//同名将卡只能编一张
						bool ifnamesame = false;
						crVector2i equips[3]; 
						int equipindex = 0;
						std::string tempcardname;
						crTableIO::StrVec itemrecord2;
						for (FormationInfoVec::iterator fitr = formations->begin();
							fitr != formations->end() && equipindex < 3;
							++fitr, ++equipindex)
						{
							if (fitr->get())
							{
								equips[equipindex] = fitr->get()->getEquips(); 
								for (int i = 0; i < 2; ++i)
								{
									if (equipindex == row && i == col)
									{
										continue;
									}
									if (itemtab->queryOneRecord(0, crArgumentParser::appItoa(equips[equipindex][i]), itemrecord2) >= 0)
									{
										tempcardname = itemrecord2[nameindex];
										if (tempcardname.compare(cardname) == 0)
										{
											ifnamesame = true;
											break;
										}
									}
								}
							}
							if (ifnamesame)
							{
								break;
							}
						}
						//= (*formations)[row]->getEquips();
						if (row < 3 && !ifnamesame)
						{
							if (equips[row][col] > 0)
							{
								(*tempcardvec)[selectid]->setItemID(equips[row][col]);
							}
							else
							{
								(*tempcardvec)[selectid] = NULL;
							}
							equips[row][col] = itemid;
							(*formations)[row]->setEquips(equips[row]);

							ref_ptr<crWidgetNode> formationbtn = formationcanvas->getWidget(m_formationbtn[index]);
							crMultiSwitch *formationsw = dynamic_cast<crMultiSwitch *>(formationcanvas->getChildNode(m_formationsw[index]));
							if (formationbtn.valid())
							{
								crStateSet *stateset = dynamic_cast<crObject *>((dynamic_cast<crGroup *>(formationbtn->getChild(0)))->getChild(0))->getDrawable(0)->getStateSet();
								if (stateset)
								{
									CRCore::crTexture2D *texture_2d =
										dynamic_cast<CRCore::crTexture2D *>(stateset->getTextureAttribute(0, CRCore::crStateAttribute::TEXTURE));
									texture_2d->setImage(0, texture_2d->getImageDataRequestHandler()->requestImageFile(itemrecord[iconindex], texture_2d));
								}
							}
							if (formationsw)
							{
								formationsw->setVisiable(true);
								formationsw->setActiveSwitchSet(color);
							}
						}
						if (ifnamesame)
						{
							playerData->doEvent(WCH_JXJUIShowTipsCanvas, MAKECREPARAM(2109, NULL));//
						}
					}
					cardbagdata->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}
		}
	}
}


///////////////////////////////////////////
////
////crJXJRecvAddJiangKaMethod
////
///////////////////////////////////////////
//crJXJRecvAddJiangKaMethod::crJXJRecvAddJiangKaMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvAddJiangKaMethod::crJXJRecvAddJiangKaMethod(const crJXJRecvAddJiangKaMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvAddJiangKaMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJRecvAddJiangKaMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_tips = str;
//		break;
//	case 1:
//		m_input = str;
//		break;
//	}
//}
//void crJXJRecvAddJiangKaMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			unsigned char success = 0;
//			int playerid = m_this->getPlayerID();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				unsigned char selectid = m_stream->_readUChar();
//				char row = m_stream->_readChar();
//				void *param;
//				int itemid = 0;
//				unsigned char result = 0;
//				unsigned char col = 0;
//				crData *data = m_this->getDataClass();
//				//playerdata
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				data->getParam(WCHDATA_JXJFormationInfoVec, param);
//				ref_ptr<crFormationInfo>fi;
//				FormationInfoVec *formations = (FormationInfoVec *)param;
//				data->getParam(WCHDATA_JXJJiangkaBagVec, param);
//				JXJItemBagVec *jiangkabag = (JXJItemBagVec *)param;
//
//
//				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//				crTableIO::StrVec itemrecord;
//				JXJItemBagVec newitembagvec;
//				BagItemMultiMap2 bagitemmap;
//				for (JXJItemBagVec::iterator itr = jiangkabag->begin();
//					itr != jiangkabag->end();
//					++itr)
//				{
//					if((*itr)!= NULL)
//					{
//						int quality = itemtab->getTitleIndex("品质");
//						itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord);
//						bagitemmap.insert(std::make_pair(atoi(itemrecord[quality].c_str()),(*itr).get()));
//					}
//				}
//
//				for (BagItemMultiMap2::iterator itr2 = bagitemmap.begin();
//					itr2 != bagitemmap.end();
//					++itr2 )
//				{
//					if(newitembagvec.empty())
//						newitembagvec.push_back(itr2->second);
//					else
//					{
//						crBagItemData *backitem;
//						backitem = (newitembagvec.back()).get();
//						{
//							newitembagvec.push_back(itr2->second);
//						}
//
//					}
//				}
//				newitembagvec.resize(jiangkabag->size());
//				jiangkabag->swap(newitembagvec);
//
//				if((*formations)[row]!=NULL)
//				{
//					if ((*jiangkabag)[selectid]!=NULL)
//					{
//						itemid = (*jiangkabag)[selectid]->getItemID();
//						if((*jiangkabag)[selectid]->getItemCount() > 0)
//						{
//							result = 1;
//						}
//					}
//					//int usedjiangka = 0;
//					//int havejiangka = 0;
//					//检测将卡数量
//					//for (FormationInfoVec::iterator itr = formations->begin();
//					//	itr != formations->end();
//					//	++itr)
//					//{
//					//	fi = itr->get();
//					//	crVector3i equip = fi->getEquips();
//					//	for(int i = 0; i < 3; i++)
//					//	{
//					//		if (equip[i] == itemid)
//					//		{
//					//			usedjiangka++;
//					//		}
//					//	}
//					//}
//
//					//for (JXJItemBagVec::iterator itr2 = jiangkabag->begin();
//					//	itr2 != jiangkabag->end();
//					//	++itr2)
//					//{
//					//	if((*itr2)!=NULL && (*itr2)->getItemCount()>0)
//					//	{
//					//		if ((*itr2)->getItemID() == itemid)
//					//		{
//					//			havejiangka++;
//					//		}
//					//	}
//					//}
//					//if (havejiangka > usedjiangka)
//					//{
//					//	result = 1;
//					//}
//					if(result == 1)
//					{
//						int attri = itemtab->getTitleIndex("将卡类型");
//						itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),itemrecord);
//						if (itemrecord.size())
//						{
//							col = atoi(itemrecord[attri].c_str());
//							if (col >=0 && col <3)
//							{
//								crVector2i equip = (*formations)[row]->getEquips();
//								int equipitemid = equip[col];
//								equip[col] = itemid;
//								(*formations)[row]->setEquips(equip);
//								if (equipitemid>0)
//								{
//									(*jiangkabag)[selectid]->setItemID(equipitemid);
//								}
//								else
//								{
//									(*jiangkabag)[selectid] = NULL;
//								}
//							}
//						}
//					}
//				}
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(8);
//				stream->_writeUChar(result);
//				stream->_writeInt(itemid);
//				stream->_writeChar(row);
//				stream->_writeUChar(col);
//				stream->_writeUChar(selectid);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvAddJiangKa,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//		}
//		if(m_netType == GameClient_Game)
//		{
//			unsigned char result =m_stream->_readUChar();
//			int itemid =m_stream->_readInt();
//			char row =m_stream->_readChar();
//			unsigned char col =m_stream->_readUChar();
//			unsigned char selectid =m_stream->_readUChar();
//			if(result == 1)
//			{
//				void *param;
//				crData *data = m_this -> getDataClass();
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				data->getParam(WCHDATA_JXJFormationInfoVec, param);
//				ref_ptr<crFormationInfo>fi;
//				FormationInfoVec *formations = (FormationInfoVec *)param;
//				crVector2i equip = (*formations)[row]->getEquips();
//				int equipitemid = equip[col];
//				equip[col] = itemid;
//				(*formations)[row]->setEquips(equip);
//				data->getParam(WCHDATA_JXJJiangkaBagVec, param);
//				JXJItemBagVec *jiangkabag = (JXJItemBagVec *)param;
//				if (equipitemid>0)
//				{
//					(*jiangkabag)[selectid]->setItemID(equipitemid);
//				}
//				else
//				{
//					(*jiangkabag)[selectid] = NULL;
//				}
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//			}
//		}
//	}
//}


/////////////////////////////////////////
//
//crJXJUIAddJiangKaDragMethod
//
/////////////////////////////////////////
crJXJUIAddJiangKaDragMethod::crJXJUIAddJiangKaDragMethod()
{
}
crJXJUIAddJiangKaDragMethod::crJXJUIAddJiangKaDragMethod(const crJXJUIAddJiangKaDragMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_cardUpgradeSw(handle.m_cardUpgradeSw),
	m_updatecardiconname(handle.m_updatecardiconname),
	m_needcardiconname1(handle.m_needcardiconname1),
	m_needcardiconname2(handle.m_needcardiconname2),
	m_needcardiconname3(handle.m_needcardiconname3),
	m_Jk_Yanshi(handle.m_Jk_Yanshi)
	//m_orangecardupgradecanvas(handle.m_orangecardupgradecanvas)
{
	for( int i = 0; i<9; i++)
	{
		m_btn[i] = handle.m_btn[i];
		if(i<6)
		{
			m_colorbox[i] = handle.m_colorbox[i];
		}
	}
}
void crJXJUIAddJiangKaDragMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIAddJiangKaDragMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_btn[0] = str;
		break;
	case 2:
		m_btn[1] = str;
		break;
	case 3:
		m_btn[2] = str;
		break;
	case 4:
		m_btn[3] = str;
		break;
	case 5:
		m_btn[4] = str;
		break;
	case 6:
		m_btn[5] = str;
		break;
	case 7:
		m_btn[6] = str;
		break;
	case 8:
		m_btn[7] = str;
		break;
	case 9:
		m_btn[8] = str;
		break;
	case 10:
		m_colorbox[0] = str;
		break;
	case 11:
		m_colorbox[1] = str;
		break;
	case 12:
		m_colorbox[2] = str;
		break;
	case 13:
		m_colorbox[3] = str;
		break;
	case 14:
		m_colorbox[4] = str;
		break;
	case 15:
		m_colorbox[5] = str;
		break;
	case 16:
		m_cardUpgradeSw = str;
		break;
	case 17:
		m_updatecardiconname = str;
		break;
	case 18:
		m_needcardiconname1 = str;
		break;
	case 19:
		m_needcardiconname2 = str;
		break;
	case 20:
		m_needcardiconname3 = str;
		break;
	case 21:
		//m_orangecardupgradecanvas = str;
		break;
	case 22:
		m_strPersuadeCanvas = str;
		break;
	case 23:
		m_strImageBox = str;
		break;
	case 24:
		m_strPersuadeSw = str;
		break;
	case 25:
		m_strPersuadeSw_Time = str;
		break;
	case 26:
		m_strTimeText = str;
		break;
	case 27:
		m_strPersuadeSw_Level = str;
		break;
	case 28:
		m_strLunHuiCanvas = str;
		break;
	//case 29:
	//case 30:
	//case 31:
	//case 32:
	//case 33:
	//case 34:
	//	m_strImgCard[i-29] = str;
	//	break;
	//case 35:
	//case 36:
	//case 37:
	//case 38:
	//case 39:
	//	m_strSwIsOpen[i-35] = str;
	//	break;
	//case 40:
	//case 41:
	//case 42:
	//case 43:
	//case 44:
	//case 45:
	//	m_strSwCardLv[i-40] = str;
	//	break;
	case 46:
	case 47:
	case 48:
	case 49:
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
	case 55:
	case 56:
	case 57:
	case 58:
	case 59:
	case 60:
		{
			std::vector<std::string>strvec;
			crArgumentParser::appAtoVec(str, strvec);
			m_strImgCard[i - 46][0] = strvec[0];
			m_strImgCard[i - 46][1] = strvec[1];
		}
		break;
	case 61:
	case 62:
	case 63:
	case 64:
	case 65:
	case 66:
	case 67:
	case 68:
	case 69:
	case 70:
	case 71:
	case 72:
	case 73:
	case 74:
	case 75:
		m_strSwCardLv[i-61] = str;
		break;
	case 76:
		m_Jk_Yanshi = str;
		break;
	}
}
void crJXJUIAddJiangKaDragMethod::operator()(crHandle &handle)
{
	void *param;
	bool canceltask = false;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!m_this || !myPlayer) return;
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	ref_ptr<crCanvasNode>canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas);//编队界面
	//ref_ptr<crCanvasNode>canvas3 = canvas;//crFilterRenderManager::getInstance()->findCanvas(m_canvas3);//将卡升级界面
	//ref_ptr<crCanvasNode>orangecardupgradecanvas = canvas;//crFilterRenderManager::getInstance()->findCanvas(m_orangecardupgradecanvas);//橙卡升猩界面
	ref_ptr<crMultiSwitch> cardUpgradeSw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_cardUpgradeSw));
	//ref_ptr<crCanvasNode>persuadeCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strPersuadeCanvas);//说服界面
	ref_ptr<crCanvasNode>lunhuiCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strLunHuiCanvas);//轮回界面
	if(!canvas2 || !cardUpgradeSw /*|| !persuadeCanvas*/ || !lunhuiCanvas) return;
	ref_ptr<crMultiSwitch> Jk_Yanshi = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_Jk_Yanshi));

	int cardUpdateSw = cardUpgradeSw->getActiveSwitchSet();
	crData *formation_data = canvas2->getDataClass();
	crData *form_card_data = canvas->getDataClass();
	crData *data = myPlayer->getDataClass();
	data -> getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	do 
	{
		ref_ptr<crListControlNode> drag_node = m_this->getSelectNode();
		if(!drag_node || !drag_node->getVisiable()) break;

		// pick
		ref_ptr<crTableIO>equip_table = CRNetApp::crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crTableIO::StrVec	record, record2;
		crWidgetNode* pick_item = NULL;
		if (m_ea)
		{
			crVector2 mouse(m_ea->getXnormalized(), m_ea->getYnormalized());
			crWidgetNode *capturer = crFilterRenderManager::getInstance()->getMouseCapturer();
			crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
			crFilterRenderManager::getInstance()->mousePick(mouse, pick_item);
			crFilterRenderManager::getInstance()->setMouseCapturer(capturer);
		}
		//if(!pick_item) break;
		if(pick_item && pick_item->getParentCanvas() == canvas2.get())
		{
			for (int i = 0; i < 9; i++)
			{
				// find button
				if(pick_item && pick_item->getName().compare(m_btn[i]) == 0)
				{
					int row = i/3;
					int col = 0;
					// insert card
					//formation_data->excHandle(MAKECREPARAM(WCH_LockData,1));
					form_card_data->excHandle(MAKECREPARAM(WCH_LockData,1));
	// equips look-up table
					//formation_data->getParam(WCHDATA_JXJForedHeadCells, param);
					//int *heads = (int *)param;					
					formation_data->getParam(WCHDATA_JXJTempFormationVec, param);
					FormationInfoVec *tempformationvec = (FormationInfoVec *)param;
					form_card_data->getParam(WCHDATA_JXJForJKVec, param);
					JXJItemBagVec *data_card = (JXJItemBagVec *)param;

					std::string cardname;
					// get drag card info
					int drag_id = drag_node->getData();
					unsigned char bag_num = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
					//if (drag_id < 0 || drag_id >= bag_num) continue;
					int item_id = (*data_card)[drag_id]->getItemID();
					int card_type_index = equip_table->getTitleIndex("将卡类型");
					int colorindex = equip_table->getTitleIndex("品质");
					int nameindex = equip_table->getTitleIndex("name");
					
					if (equip_table->queryOneRecord(0, crArgumentParser::appItoa(item_id), record) >= 0)
					{
						col = atoi(record[card_type_index].c_str());
						cardname = record[nameindex];
					}

					if(col >= 2)
					{
						form_card_data->excHandle(MAKECREPARAM(WCH_LockData,0));
						//formation_data->excHandle(MAKECREPARAM(WCH_LockData,0));
						break;
					}
					//检测同名将卡
					bool ifnamesame = false;
					crVector2i equips[3];
					int equipindex = 0;
					std::string tempcardname;
					for (FormationInfoVec::iterator fitr = tempformationvec->begin();
						fitr != tempformationvec->end() && equipindex < 3;
						++fitr, ++equipindex)
					{
						if (fitr->get())
						{
							equips[equipindex] = fitr->get()->getEquips();
							for (int i = 0; i < 2; ++i)
							{
								if (equipindex == row && i == col)
								{
									continue;
								}
								if (equip_table->queryOneRecord(0, crArgumentParser::appItoa(equips[equipindex][i]), record) >= 0)
								{
									tempcardname = record[nameindex];
									if (tempcardname.compare(cardname) == 0)
									{
										ifnamesame = true;
										break;
									}
								}
							}
						}
						if (ifnamesame)
						{
							break;
						}
					}
					if (ifnamesame)
					{
						myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKECREPARAM(2109, NULL));//
					}
					//= formationinfo->getEquips();
					// return card to bag
					if (row < 3 && !ifnamesame)
					{
						ref_ptr<crFormationInfo> formationinfo = (*tempformationvec)[row];
						if (equips[row][col] >= 0)
						{
							if (col == 0)
							{
								formation_data->inputParam(WCHDATA_JXJCurFormation1stCardIndex, &row);
							}
							else
							{
								formation_data->inputParam(WCHDATA_JXJCurFormation2ndCardIndex, &row);
							}
							//bool find_flag = false;
							//for(int i = 0; i < data_card->size(); i++)
							//{
							//	if(!(*data_card)[i].get()) continue;
							//	if((*data_card)[i].get()->getItemID() == heads[row * 3 + col])
							//	{
							//		find_flag = true;
							//		(*data_card)[i].get()->setItemCount((*data_card)[i].get()->getItemCount() + 1);
							//		break;
							//	}
							//}

							//if(!find_flag)
							//{
							for (int i = 0; i < data_card->size(); i++)
							{
								if (!((*data_card)[i].get()))
								{
									(*data_card)[i] = new crBagItemData;
									(*data_card)[i].get()->setItemID(equips[row][col]);
									(*data_card)[i].get()->setItemCount(1);
									break;
								}
							}
							//}
						}

						// replace card
						(*data_card)[drag_id]->setItemCount((*data_card)[drag_id]->getItemCount() - 1);
						if ((*data_card)[drag_id]->getItemCount() <= 0)
						{
							(*data_card)[drag_id] = NULL;
						}
						equips[row][col] = item_id;
						formationinfo->setEquips(equips[row]);

						if (equip_table->queryOneRecord(0, crArgumentParser::appItoa(item_id), record) >= 0)
						{
							int icon_id = equip_table->getTitleIndex("icon");
							ref_ptr<crWidgetNode> equip_btn = canvas2->getWidget(m_btn[row * 3 + col]);
							if(equip_btn.valid())
							{
								CRCore::crStateSet *state_set =
									dynamic_cast<CRCore::crObject *>((dynamic_cast<CRCore::crGroup *>(equip_btn->getChild(0)))->getChild(0))->getDrawable(0)->getStateSet();
								CRCore::crTexture2D *texture_2d =
									dynamic_cast<CRCore::crTexture2D *>(state_set->getTextureAttribute(0, CRCore::crStateAttribute::TEXTURE));
								texture_2d->setImage(0, texture_2d->getImageDataRequestHandler()->requestImageFile(record[icon_id], texture_2d));
							}
							if (col<2)
							{
								crMultiSwitch *multiswitch = dynamic_cast<crMultiSwitch *>(canvas2->getChildNode(m_colorbox[row * 2 + col]));
								if (multiswitch)
								{
									int cardcolot = atoi(record[colorindex].c_str());
									//if (cardcolot > CardColor_Orange)
									//{
									//	cardcolot = CardColor_Orange;
									//}
									multiswitch->setVisiable(true);
									multiswitch->setActiveSwitchSet(1 + cardcolot);
								}
							}
						}
					}

					form_card_data->excHandle(MAKECREPARAM(WCH_LockData,0));
					//formation_data->excHandle(MAKECREPARAM(WCH_LockData,0));
					break;
				}
			}
		}
//		else if(pick_item && pick_item->getParentCanvas() == persuadeCanvas.get())
//		{
//// 			for (int i = 0; i < 9; i++)
//// 			{
//// 				// find button
//// 				if(dynamic_cast<ref_ptr<crButtonWidgetNode> >(pick_item) && pick_item->getName().compare(m_btn[i]) == 0)
//				{
//					//int row = i/3;
//					//int col = 0;
//					form_card_data->excHandle(MAKECREPARAM(WCH_LockData,1));				
//					formation_data->getParam(WCHDATA_JXJTempFormationVec, param);
//					FormationInfoVec tempformationvec = *(FormationInfoVec *)param;
//					form_card_data->getParam(WCHDATA_JXJForJKVec, param);
//					JXJItemBagVec *data_card = (JXJItemBagVec *)param;
//
//					// get drag card info
//					int drag_id = drag_node->getData();
//					unsigned char bag_num = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
//					int item_id = (*data_card)[drag_id]->getItemID();
//					//int card_type_index = equip_table->getTitleIndex("将卡类型");
//					int colorindex = equip_table->getTitleIndex("品质");
//					//equip_table->queryOneRecord(0, crArgumentParser::appItoa(item_id), record);
//					//col = atoi(record[card_type_index].c_str());
//
//// 					if(col >= 2)
//// 					{
//// 						form_card_data->excHandle(MAKECREPARAM(WCH_LockData,0));
//// 						break;
//// 					}
//
//					// return card to bag
//// 					ref_ptr<crFormationInfo> formationinfo = tempformationvec[row];
//// 					crVector2i equips = formationinfo->getEquips();
//// 					if(equips[col] >= 0)
//// 					{
//// 						if (col == 0)
//// 						{
//// 							formation_data->inputParam(WCHDATA_JXJCurFormation1stCardIndex, &row);
//// 						}
//// 						else
//// 						{
//// 							formation_data->inputParam(WCHDATA_JXJCurFormation2ndCardIndex, &row);
//// 						}
//// 						for(int i = 0; i < data_card->size(); i++)
//// 						{
//// 							if(!((*data_card)[i].get()))
//// 							{
//// 								(*data_card)[i] = new crBagItemData;
//// 								(*data_card)[i].get()->setItemID(equips[col]);
//// 								(*data_card)[i].get()->setItemCount(1);
//// 								break;
//// 							}
//// 						}
//// 					}
//
//					// replace card
//// 					(*data_card)[drag_id]->setItemCount((*data_card)[drag_id]->getItemCount() - 1);
//// 					if((*data_card)[drag_id]->getItemCount() <= 0)
//// 					{
//// 						(*data_card)[drag_id] = NULL;
//// 					}
//// 					equips[col] = item_id;
//// 					formationinfo->setEquips(equips);
//
//					if (equip_table->queryOneRecord(0, crArgumentParser::appItoa(item_id), record) >= 0)
//					{
//						int icon_id = equip_table->getTitleIndex("icon");
//						ref_ptr<crButtonWidgetNode> btImageBox = dynamic_cast<crButtonWidgetNode *>(persuadeCanvas->getWidget(m_strImageBox));
//						// 					if(imageBox)
//						// 					{
//						// 						imageBox->setEnable(true);
//						// 						imageBox->setImageName(record[icon_id]);
//						// 					}
//						CRCore::crStateSet *state_set = dynamic_cast<CRCore::crObject *>(( dynamic_cast<CRCore::crGroup *>(btImageBox->getChild(0)))->getChild(0))->getDrawable(0)->getStateSet();
//						CRCore::crTexture2D *texture_2d = 	dynamic_cast<CRCore::crTexture2D *>(state_set->getTextureAttribute(0,CRCore::crStateAttribute::TEXTURE));
//						texture_2d->setImage(0,texture_2d->getImageDataRequestHandler()->requestImageFile(record[icon_id],texture_2d));
//
//						crMultiSwitch *multiswitch =dynamic_cast<crMultiSwitch *>(persuadeCanvas->getChildNode(m_strPersuadeSw));
//						if (multiswitch)
//						{
//							int cardcolot = atoi(record[colorindex].c_str());
//							//if (cardcolot > CardColor_Orange)
//							//{
//							//	cardcolot = CardColor_Orange;
//							//}
//							multiswitch->setVisiable(true);
//							multiswitch->setActiveSwitchSet(cardcolot);
//						}
//
//						//处理说服界面
//						crMultiSwitch *multiswitch_time =dynamic_cast<crMultiSwitch *>(persuadeCanvas->getChildNode(m_strPersuadeSw_Time));
//						crMultiSwitch *multiswitch_level =dynamic_cast<crMultiSwitch *>(persuadeCanvas->getChildNode(m_strPersuadeSw_Level));
//						ref_ptr<crStaticTextWidgetNode> textNode = dynamic_cast<crStaticTextWidgetNode *>(persuadeCanvas->getWidget(m_strTimeText));
//						crData *canvasData = persuadeCanvas->getDataClass();
//						crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
//						crTableIO::DataVec infoVec;
//						ref_ptr<crTableIO>fubenCardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPersuadeFubenCardTab);
//						if(canvasData && playerData)
//						{
//							canvasData->getParam(WCHDATA_JXJPersuadeFubenID,param);
//							unsigned short fubenid = *(unsigned short *)param;
//							playerData->getParam(WCHDATA_JXJVipLv,param);
//							unsigned char vipLevel = *(unsigned char *)param;
//
//							int needTime = 0;
//							switch (atoi(record[colorindex].c_str()))
//							{
//							case 1:
//								needTime = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPersuadeTime_G,vipLevel).c_str());
//								multiswitch_level->setActiveSwitchSet(1);
//								break;
//							case 2:
//								needTime = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPersuadeTime_B,vipLevel).c_str());
//								multiswitch_level->setActiveSwitchSet(2);
//								break;
//							case 3:
//								needTime = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPersuadeTime_P,vipLevel).c_str());
//								multiswitch_level->setActiveSwitchSet(3);
//								break;
//							case 4:
//							case 5:
//							case 6:
//							case 7:
//							case 8:
//								needTime = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPersuadeTime_O,vipLevel).c_str());
//								multiswitch_level->setActiveSwitchSet(4);
//								break;
//							default:
//								needTime = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPersuadeTime_W,vipLevel).c_str());
//								multiswitch_level->setActiveSwitchSet(0);
//								break;
//							}
//							if(fubenCardTab.valid())
//							{
//								int itemIndex = fubenCardTab->getTitleIndex("itemid");
//								int timeIndex = fubenCardTab->getTitleIndex("time");
//								fubenCardTab->queryRecords(0,crArgumentParser::appItoa(fubenid),infoVec);
//								for(int i = 0;i<infoVec.size();i++)
//								{
//									if(infoVec[itemIndex][i].compare(crArgumentParser::appItoa(item_id)) == 0)
//									{
//										needTime = atoi(infoVec[timeIndex][i].c_str());
//										multiswitch_level->setActiveSwitchSet(5);
//										break;
//									}
//								}
//							}
//
//							if(needTime>0 && multiswitch_time && textNode.valid())
//							{
//								multiswitch_time->setActiveSwitchSet(1);
//								int hour = needTime/3600;
//								int minute = (needTime%3600)/60;
//								int second = (needTime%3600)%60;
//
//								char timetext[128];
//								sprintf(timetext,"%02d:%02d:%02d\0",hour,minute,second);
//
//								textNode->setString(std::string(timetext));
//
//								canvasData->inputParam(WCHDATA_JXJPersuadeJKID,&item_id);
//							}
//						}
//					}
//					form_card_data->excHandle(MAKECREPARAM(WCH_LockData,0));
//					break;
//				}
//			//}
//		}
		else if (pick_item && pick_item->getParentCanvas() == lunhuiCanvas.get() && Jk_Yanshi->getActiveSwitchSet()==0)
		{
			//获取playerstore中已有如果serverid相等则可以操作，否则不能操作

			bool isCanbe = true;
			for (int i = 0; i<CycleCardOnePageCount; i++)
			{
				if(pick_item->getName() == m_strImgCard[i][0])
				{
					/*if(i>0)
					{
					crMultiSwitch *multiSwitch = dynamic_cast<crMultiSwitch *>(lunhuiCanvas->getChildNode(m_strSwIsOpen[i-1]));
					if(multiSwitch && multiSwitch->getActiveSwitchSet()==0)
					{
					isCanbe = true;
					}
					}
					else
					{
					isCanbe = true;
					}*/
					if(isCanbe)
					{
						crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
						if(playerData)
						{
							playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
							playerData->getParam(WCHDATA_JXJPlayerStore,param);
							crJXJPlayerStore * playerStore = (crJXJPlayerStore *)param;
							if(playerStore)
							{
								crData *playerStoreData = playerStore->getDataClass();
								if(playerStoreData)
								{
									playerStoreData->excHandle(MAKECREPARAM(WCH_LockData,1));
									playerStoreData->getParam(WCHDATA_JXJJiangkaBagVec,param);
									JXJStoreItemBagVec *cardVec = (JXJStoreItemBagVec *)param;

									//if(i >= cardVec->size() || \
									//	(i<cardVec->size() && (*cardVec)[i].valid() && (*cardVec)[i]->getItemServerID() == 1))
									{
										//
										crMultiSwitch *multiswitch_level =dynamic_cast<crMultiSwitch *>(lunhuiCanvas->getChildNode(m_strSwCardLv[i]));
										crImageBoxWidgetNode *imageBox = dynamic_cast<crImageBoxWidgetNode *>(lunhuiCanvas->getChildNode(m_strImgCard[i][1]));
										ref_ptr<crRadioGroupWidgetNode> cardPage = dynamic_cast<crRadioGroupWidgetNode *>(lunhuiCanvas->getWidget("XLunhui_jiangka_qieye"));
										int page = cardPage->getSelect();
										int offset = page*CycleCardOnePageCount;

										if(multiswitch_level && imageBox)
										{
											int colorindex = equip_table->getTitleIndex("品质");
											int icon_id = equip_table->getTitleIndex("icon");
											int drag_id = drag_node->getData();
											form_card_data->excHandle(MAKECREPARAM(WCH_LockData,1));
											form_card_data->getParam(WCHDATA_JXJForJKVec, param);
											JXJItemBagVec *data_card = (JXJItemBagVec *)param;
											int item_id = (*data_card)[drag_id]->getItemID();
											if(equip_table->queryOneRecord(0, crArgumentParser::appItoa(item_id), record) >= 0 )
											{
												imageBox->setVisiable(true);
												imageBox->setImageName(record[icon_id]);

												int cardcolot = atoi(record[colorindex].c_str());
												//if (cardcolot > CardColor_Orange)
												//{
												//	cardcolot = CardColor_Orange;
												//}
												multiswitch_level->setVisiable(true);
												multiswitch_level->setActiveSwitchSet(cardcolot+1);

												//存入canvasData
												crData *canvasData = lunhuiCanvas->getDataClass();
												if(canvasData)
												{
													canvasData->excHandle(MAKECREPARAM(WCH_LockData,1));
													canvasData->getParam(WCHDATA_JXJLunHuiCardMap,param);
													ItemOrCardMap *cardmap = (ItemOrCardMap *)param;
													canvasData->getParam(WCHDATA_JXJTempCardSwitchMap,param);
													ItemSwitchMap *switchmap = (ItemSwitchMap *)param;
													
													if(cardmap)
													{
														int offseti = i + offset;
														//处理将卡与背包显示
														ItemOrCardMap::iterator itr_card = cardmap->find(offseti);
														if(itr_card!=cardmap->end())
														{
															ref_ptr<crBagItemData> temp = new crBagItemData;
															temp->setItemID(itr_card->second->getItemID());
															temp->setItemCount(1);
// 															playerData->getParam(WCHDATA_JXJJiangkaBagVec,param);
// 															JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
// 															for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
// 																itr!=jiangkabagvec->end();
// 																++itr)
// 															{
// 																if(!itr->valid()) continue;
// 																if ((*itr) == NULL)
// 																{
// 																	*itr = temp;
// 																	break;
// 																}
// 															}
															(*data_card)[drag_id] = NULL;//temp;20150522

															temp = new crBagItemData;
															temp->setItemID(item_id);
															temp->setItemCount(1);
															(*cardmap)[offseti] = temp;
														}
														else
														{
															if (offseti<cardVec->size() && (*cardVec)[offseti].valid())
															{
																ref_ptr<crBagItemData> temp = new crBagItemData;
																temp->setItemID((*cardVec)[offseti]->getItemID());
																temp->setItemCount(1);

																//放入临时转换背包
																switchmap->insert(std::make_pair(offseti,(*cardVec)[offseti]));

																playerData->getParam(WCHDATA_JXJJiangkaBagVec,param);
																JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
																for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
																	itr!=jiangkabagvec->end();
																	++itr)
																{
																	if(!itr->valid()) continue;
																	if ((*itr)->getItemID() == item_id)
																	{
																		*itr = NULL;//temp;直接覆盖，不替换出轮回仓库里的装备20150522
																		break;
																	}
																}
																(*data_card)[drag_id] = NULL;//temp;20150522
															}
															else
															{
																playerData->getParam(WCHDATA_JXJJiangkaBagVec,param);
																JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
																for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
																	itr!=jiangkabagvec->end();
																	++itr)
																{
																	if(!itr->valid()) continue;
																	if ((*itr)->getItemID() == item_id)
																	{
																		*itr = NULL;
																		break;
																	}
																}
																(*data_card)[drag_id] = NULL;
															}
															
															ref_ptr<crBagItemData> temp = new crBagItemData;
															temp->setItemID(item_id);
															temp->setItemCount(1);
															cardmap->insert(std::make_pair(offseti,temp));
														}														
													}
													canvasData->excHandle(MAKECREPARAM(WCH_LockData,0));
												}
											}
											form_card_data->excHandle(MAKECREPARAM(WCH_LockData,0));
										}
									}

									playerStoreData->excHandle(MAKECREPARAM(WCH_LockData,0));
								}
							}
							playerData->excHandle(MAKECREPARAM(WCH_LockData,0));
						}
					}

				}
			}
		}
		else if(cardUpdateSw == 0||cardUpdateSw==2)
		{//将卡升级或者橙卡升级
			int flag = 0;
			crData *orangedata = canvas->getDataClass();
			if (orangedata)
			{
				orangedata->getParam(WCHDATA_JXJRecvChengKaUpgradeFlag,param);
				flag = *(int *)param;
			}
			if (flag == 0)
			{
				bool ifcanupdate = true;
				crData *braindata = crBrain::getInstance()->getDataClass();
				//braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
				braindata->getParam(WCHDATA_JXJUpgradeJiangkaIndex,param);
				short salejiangkaindex = *(short *)param;
				form_card_data->excHandle(MAKECREPARAM(WCH_LockData,1));
				form_card_data->getParam(WCHDATA_JXJForJKVec, param);
				JXJItemBagVec *data_card = (JXJItemBagVec *)param;
				//data->getParam(WCHDATA_JXJOrangeCardUpgradeTechLv,param);
				//unsigned char OrangeCardUpgradeTechLv = *(unsigned char *)param;

				if(drag_node.valid())
				{
					// get drag card info
					int curindex = drag_node->getData();
					if (curindex >= 0)
					{
						int cardcolor = 0;
						bool iftop = false;
						bool iftechopen = true;
						unsigned char bag_num = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
						//if (drag_id < 0 || drag_id >= bag_num) continue;
						int item_id = (*data_card)[curindex]->getItemID();
						int cardcolorindex = equip_table->getTitleIndex("品质");
						int newcardindex = equip_table->getTitleIndex("升级所得物品");
						if(equip_table->queryOneRecord(0, crArgumentParser::appItoa(item_id), record2) >= 0 )
						{
							cardcolor = atoi(record2[cardcolorindex].c_str());
							if(cardcolor >= CardColor_Orange)
							{
								ifcanupdate = false;
							}
							if (cardcolor >= CardColor_Ten)
							{
								iftop = true;
							}
						}
						if (!iftop)
						{
							if(ifcanupdate/* && !canvas3->getVisiable()*/)
							{
								//crFilterRenderManager::getInstance()->showCanvas(canvas3.get(),true);
								cardUpgradeSw->setActiveSwitchSet(0);
							}
							if (!ifcanupdate/* && !orangecardupgradecanvas->getVisiable()*/)
							{
								//将卡升星不再受科技限制
								//if (OrangeCardUpgradeTechLv > 0)
								//{ 
								//crFilterRenderManager::getInstance()->showCanvas(canvas3.get(),false);
								//crFilterRenderManager::getInstance()->showCanvas(orangecardupgradecanvas.get(),true);
								cardUpgradeSw->setActiveSwitchSet(2);
								//}
								//else
								//{
								//	iftechopen = false;
								//	myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,2083);
								//}
							}
							if (atoi(record2[newcardindex].c_str()) > 0)
							{
								ifcanupdate = true;
							}
							else
							{
								ifcanupdate = false;
							}
							if(ifcanupdate && iftechopen)
							{
								salejiangkaindex = (short)curindex;
								if (form_card_data)
								{
									//form_card_data->excHandle(MAKECREPARAM(WCH_LockData,1));
									//form_card_data->getParam(WCHDATA_JXJForJKVec,param);
									//JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
									crData *playerdata =  crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
									playerdata->getParam(WCHDATA_JXJJiangkaBagVec,param);
									JXJItemBagVec *playercard = (JXJItemBagVec *)param;
									data_card->clear();
									ref_ptr<crBagItemData> temp = NULL;
									for(int i = 0; i < playercard->size(); i++)
									{
										temp = NULL;
										if((*playercard)[i].get())
										{
											temp = new crBagItemData;
											temp->setItemID((*playercard)[i]->getItemID());
											temp->setItemCount((*playercard)[i]->getItemCount());
										}
										data_card->push_back(temp);
									}
									//playerData->doEvent(WCH_JXJUpdateCardCanvas);
									if((*data_card)[drag_node->getData()].valid())
										(*data_card)[drag_node->getData()]->setItemCount(0);
									//form_card_data->excHandle(MAKECREPARAM(WCH_LockData,0));
								}
							}
						}
						else
						{
							myPlayer->doEvent(WCH_JXJUIShowTipsCanvas, MAKECREPARAM(2072,NULL));
						}
					}
				}
				form_card_data->excHandle(MAKECREPARAM(WCH_LockData,0));
				braindata->inputParam(WCHDATA_JXJUpgradeJiangkaIndex,&salejiangkaindex);
				//braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			else
			{
				canceltask = true;
			}
		}
		//crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
	} while (0);
	handle.outputParam(0,&canceltask);
}
//{
//	bool canceltask = true;
//	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
//	ref_ptr<crCanvasNode>canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
//	//ref_ptr<crListControlWidgetNode> backPackList = dynamic_cast<crListControlWidgetNode *>(m_this->getWidget(m_myBagList));
//	//ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio));
//	if(m_ea && canvas2)
//	{
//		do 
//		{
//			if(!m_this)
//				break;
//			ref_ptr<crListControlNode> listNode = m_this->getSelectNode();
//			if(!listNode || !listNode->getVisiable())
//			{
//				break;
//			}
//			crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
//			ref_ptr<crWidgetNode> pickUI = NULL;
//			crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
//			crFilterRenderManager::getInstance()->mousePick(mouse,pickUI);
//			crFilterRenderManager::getInstance()->setMouseCapturer(m_this);
//			if(!pickUI)
//			{//Drop Item
//				break;
//			}
//			else if(pickUI->getParentCanvas() == canvas2)
//			{
//				for (int i = 0; i < 9; i++)
//				{
//					if(dynamic_cast<ref_ptr<crButtonWidgetNode> >(pickUI) && pickUI->getName().compare(m_btn[i]) == 0)
//					{
//						char row = (char)i/3;
//						crData *brainData = crBrain::getInstance()->getDataClass();
//						brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
//						brainData->inputParam(WCHDATA_JXJJiangkaFormationRow,&row);
//						brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
//						canceltask = false;
//						break;
//					}
//				}
//			}
//		} while (0);
//	}
//
//	handle.outputParam(0,&canceltask);
//}


/////////////////////////////////////////
//
//crJXJShowKnapsackCanvasMethod
//
/////////////////////////////////////////
crJXJShowKnapsackCanvasMethod::crJXJShowKnapsackCanvasMethod()
{
}

crJXJShowKnapsackCanvasMethod::crJXJShowKnapsackCanvasMethod(const crJXJShowKnapsackCanvasMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_radio(handle.m_radio)
{
}

void crJXJShowKnapsackCanvasMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJShowKnapsackCanvasMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_radio = str;
		break;
	}
}

void crJXJShowKnapsackCanvasMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	ref_ptr<crCanvasNode>canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(canvas.valid() && canvas2.valid())
	{
		//canvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
		//canvas->setCanFocus(false);
		canvas->setMatrix(crMatrix::translate(-0.3,0,0.0f));
		//canvas->setCanFocus(false);
		crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
		const crBoundingBox &bbox = canvas->getBoundBox();

		/////////////////
		const crBoundingBox &bbox2 = canvas2->getBoundBox();
		canvas2->setMatrix(crMatrix::translate(bbox.m_max[0] + 0.5*(bbox2.m_max[0] - bbox2.m_min[0]),0,0.0f));
		//canvas2->setCanFocus(false);
		crFilterRenderManager::getInstance()->showCanvas(canvas2.get(),true);
		ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas2->getWidget(m_radio));
		radio->select(IT_Equip);
	}
}
/////////////////////////////////////////
//
//crJXJUIFeudalLordUpdateMethod
//
/////////////////////////////////////////
crJXJUIFeudalLordUpdateMethod::crJXJUIFeudalLordUpdateMethod()
{
}

crJXJUIFeudalLordUpdateMethod::crJXJUIFeudalLordUpdateMethod(const crJXJUIFeudalLordUpdateMethod& handle):
	crMethod(handle)
{	
	m_name = handle.m_name;
	m_guoJia = handle.m_guoJia;
	m_level = handle.m_level;
	m_guanzhi = handle.m_guanzhi;
	m_gongxun = handle.m_gongxun;
	m_bingfa = handle.m_bingfa;
	m_zhenfa = handle.m_zhenfa;
	m_tongshuai = handle.m_tongshuai;
	m_dongcha = handle.m_dongcha;
	m_touxiang = handle.m_touxiang;
	m_exp = handle.m_exp;
	m_zhan = handle.m_zhan;
	for (int i = 0; i < 5; ++i)
	{
		m_equip[i] = handle.m_equip[i];
		m_defaultname[i] = handle.m_defaultname[i];
	}
	for (int i = 0; i < 4; ++i)
	{
		m_btnAdd[i] = handle.m_btnAdd[i];
		m_radioBtn[i] = handle.m_radioBtn[i] ;
	}
	m_radioGroup = handle.m_radioGroup;
}

void crJXJUIFeudalLordUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIFeudalLordUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_name = str;
		break;
	case 1:
		m_guoJia = str;
		break;
	case 2:
		m_level = str;
		break;
	case 3:
		m_guanzhi = str;
		break;
	case 4:
		m_gongxun = str;
		break;
	case 5:
		m_bingfa = str;
		break;
	case 6:
		m_zhenfa = str;
		break;
	case 7:
		m_tongshuai = str;
		break;
	case 8:
		m_dongcha = str;
		break;
	case 9:
		m_equip[0] = str;
		break;
	case 10:
		m_equip[1] = str;
		break;
	case 11:
		m_equip[2] = str;
		break;
	case 12:
		m_equip[3] = str;
		break;
	case 13:
		m_equip[4] = str;
		break;
	case 14:
		m_touxiang = str;
		break;
	case 15:
		m_exp = str;
		break;
	case 16:
		m_defaultname[0] = str;
		break;
	case 17:
		m_defaultname[1] = str;
		break;
	case 18:
		m_defaultname[2] = str;
		break;
	case 19:
		m_defaultname[3] = str;
		break;
	case 20:
		m_defaultname[4] = str;
		break;
	case 21:
	case 22:
	case 23:
	case 24:
		m_btnAdd[i-21] = str;
		break;
	case 25:
	case 26:
	case 27:
	case 28:
		m_radioBtn[i-25] = str;
		break;
	case 29:
		m_radioGroup = str;
		break;
	case 30:
		m_zhan = str;
		break;
	}
}

void crJXJUIFeudalLordUpdateMethod::operator()(crHandle &handle)
{
	//ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(m_this)
	{
		ref_ptr<crButtonWidgetNode> zhanbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_zhan));
		if(zhanbtn.valid())
			zhanbtn->setVisiable(true);

		void *param;
		unsigned char viplv = 0;
		crImageBoxWidgetNode *equip[5];
		crTableIO::StrVec record,recordd,record2,itemrecord,govrecord;
		crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
		crData *playerdata = playerData->getDataClass();
		crRole *mainrole = playerData->getMainRole();
		if(mainrole && mainrole->getDataClass())
		{
			bool isMyself = false;
			std::string myName = crMyPlayerData::getInstance()->getPlayerGameData()->getCharacterName();
			ref_ptr<crStaticTextWidgetNode> playerName = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_name));
			playerdata->getParam(WCHDATA_JXJCheckIsMyself, param);
			isMyself = *(bool *)param;
			if (playerName.valid() && !myName.empty())
			{
				std::wstring text = playerName->getString();
				std::string name = CRIOManager::convertUTF16toUTF8(text.c_str());
				if (name != myName && !name.empty())
				{
					//如果当前显示的该领主窗口不是自己的，则该窗口不会实时更新。
					if (!isMyself)
					{
						return;
					}
				}
			}
			crData *mainroledata = mainrole->getDataClass();

			for (int i = 0; i < 5; i++)
			{
				equip[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_equip[i]));
			}

			if (playerdata)
			{
				playerdata -> getParam(WCHDATA_JXJVipLv,param);
				viplv = *(unsigned char *)param;
				playerdata->excHandle(MAKECREPARAM(WCH_LockData,1));

				playerdata->getParam(WCHDATA_PlayerIconID,param);
				unsigned char iconid = *(unsigned char *)param;
				playerdata->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;

				ref_ptr<crTableIO>playerIconTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJPlayerIconTab);
				if(playerIconTable.valid() && playerIconTable->queryOneRecord(0,crArgumentParser::appItoa(iconid),record) >= 0 )
				{
					//头像
					int iconindex = playerIconTable->getTitleIndex("icon2");
					ref_ptr<crImageBoxWidgetNode> image = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_touxiang));
					if(image.valid() && iconindex>=0 )image->setImageName(record[iconindex]);
				}

				///国家
				ref_ptr<crTableIO>playershilitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShiliTab);
				if(playershilitab.valid() && playershilitab->queryOneRecord(0,crArgumentParser::appItoa(shiliid),record2) >= 0 )
				{
					int shilinameindex = playershilitab->getTitleIndex("name");
					ref_ptr<crStaticTextWidgetNode> guojia = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_guoJia));
					if(guojia.valid() && shilinameindex>=0 ) 
						guojia->setString(record2[shilinameindex]);
				}

				///名字
				ref_ptr<crStaticTextWidgetNode> name = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_name));
				if(name.valid())
					name->setString(crMyPlayerData::getInstance()->getPlayerGameData()->getCharacterName());
				playerdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			}

			//经验
			ref_ptr<crProgressWidgetNode> expProgress = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_exp));
			ref_ptr<crTableIO>LordlvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordlvTab);
			mainroledata->getParam(WCHDATA_Experience,param);
			int  curexperience = *(int *)param;
			int lvid = LordlvTab->getTitleIndex("lv");
			int experience = LordlvTab->getTitleIndex("经验");
			mainroledata->getParam(WCHDATA_Level,param);
			unsigned char nowlv = *(unsigned char *)param;
			unsigned char nextlv = nowlv+1;
			LordlvTab->queryOneRecord(lvid,crArgumentParser::appItoa((int)(nowlv)),recordd);
			LordlvTab->queryOneRecord(lvid,crArgumentParser::appItoa((int)nextlv),record);

			// 		if(record.size())
			// 		{
			// 			if (int(nowlv) == 1)
			// 			{
			// 				if(expInput)expInput->setString(crArgumentParser::appItoa(curexperience)+"/"+crArgumentParser::appItoa(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str())));
			// 			}
			// 			else if(expInput)expInput->setString(crArgumentParser::appItoa(curexperience - atoi(recordd[experience].c_str()))+"/"+crArgumentParser::appItoa(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str())));
			// 		}
			int maxlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxLevel,viplv).c_str());
			if(expProgress.valid())
			{
				if (int(nowlv) >= maxlv)
				{
					float nowprogess = 1;
					expProgress->setProgress(nowprogess);
				}
				else
				{
					if (int(nowlv) == 1)
					{
						float nowprogess = float(curexperience)/float(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str()));
						expProgress->setProgress(nowprogess);
					} 
					else
					{
						float nowprogess = float(curexperience - atoi(recordd[experience].c_str()))/float(atoi(record[experience].c_str()) - atoi(recordd[experience].c_str()));
						expProgress->setProgress(nowprogess);
					}
				}
			}

			// 
			mainroledata->getParam(WCHDATA_JXJLordEquipVec,param);
			JXJLordEquipVec *equipvec = (JXJLordEquipVec *)param;
			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			int imageid = itemtab->getTitleIndex("icon");
			for (int i = 0; i<equipvec->size();i++)
			{
				if(equip[i])
				{
					equip[i]->setVisiable(true);
					equip[i]->setImageName(m_defaultname[i]);
				}
				if((*equipvec)[i].first>0)
				{
					if (itemtab->queryOneRecord(0,crArgumentParser::appItoa((*equipvec)[i].first),itemrecord) >= 0)
					{
						if(equip[i] && itemrecord.size()>0)equip[i]->setImageName(itemrecord[imageid]);
					}
				}
			}
			ref_ptr<crButtonWidgetNode> btnAdd[4]={NULL};
			ref_ptr<crRadioWidgetNode> radio_equips[4] = {NULL};
			mainroledata->getParam(WCHDATA_JXJCurrentEquipVecIndex,param);
			unsigned char index = *(unsigned char *)param;
			mainroledata->getParam(WCHDATA_JXJSavedEquipVecs,param);
			unsigned char openedEquips =  *(unsigned char*)param;
			ref_ptr<crRadioGroupWidgetNode> radioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radioGroup));
			if(radioGroup.valid())
				radioGroup->select(index);
			for (int i = 0 ; i < 4; ++i)
			{
				btnAdd[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_btnAdd[i]));
				radio_equips[i] = dynamic_cast<crRadioWidgetNode*>(m_this->getWidget(m_radioBtn[i]));
				if(btnAdd[i].valid() && radio_equips[i].valid() )
				{
					if (i <= openedEquips-1)
					{
						radio_equips[i]->setVisiable(true);
						radio_equips[i]->setEnable(true);
					} 
					else
					{
						radio_equips[i]->setVisiable(false);
					}

					if(i == openedEquips)
					{
						btnAdd[i]->setVisiable(true);
						btnAdd[i]->setEnable(true);
					}else
					{
						btnAdd[i]->setVisiable(false);
					}
				}
			}

			float totlebingfa = 0;
			float totlezhenfa = 0;
			float totledongcha = 0;
			float totletongshuai = 0;
			//int m_characterSize = 14;
			//ref_ptr<crHypertextWidgetNode> input[4] = {NULL};
			//std::string str1[4];
			//std::string str2[4];
			//兵法
			mainroledata->getParam(WCHDATA_JXJBingFa,param);
			short bingfa = *(short *)param;
			mainrole->doEvent(WCH_JXJGetBingFa,MAKECREPARAM(&totlebingfa,NULL));
			ref_ptr<crStaticTextWidgetNode> inputBingfa = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_bingfa));
			if(inputBingfa.valid())
			{
				std::string totalStr =  crArgumentParser::appItoa(totlebingfa);
				if((short)totlebingfa-bingfa > 0 )
				{
					inputBingfa->setColor(FCOLOR_ORANGE);
					totalStr +="(+"+crArgumentParser::appItoa((short)totlebingfa-bingfa)+")";
				}
				else
				{
					inputBingfa->setColor(FCOLOR_WHITE);
				}
				inputBingfa->setString(totalStr);
			}
			//str1[0] = crArgumentParser::appItoa(totlebingfa);
			//str2[0] = "(+"+crArgumentParser::appItoa((short)totlebingfa-bingfa)+")";
			//阵法
			mainroledata->getParam(WCHDATA_JXJZhenFa,param);
			short zhenfa = *(short *)param;
			mainrole->doEvent(WCH_JXJGetZhenFa,MAKECREPARAM(&totlezhenfa,NULL));
			ref_ptr<crStaticTextWidgetNode> inputZhenfa = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_zhenfa));
			if(inputZhenfa.valid())
			{
				std::string totalStr = crArgumentParser::appItoa(totlezhenfa);
				if((short)totlezhenfa-zhenfa > 0)
				{
					inputZhenfa->setColor(FCOLOR_ORANGE);
					totalStr += "(+"+crArgumentParser::appItoa((short)totlezhenfa-zhenfa)+")";
				}
				else
				{
					inputZhenfa->setColor(FCOLOR_WHITE);
				}
				inputZhenfa->setString(totalStr);
			}
			//str1[1] = crArgumentParser::appItoa(totlezhenfa);
			//str2[1] = "(+"+crArgumentParser::appItoa((short)totlezhenfa-zhenfa)+")";
			//洞察
			mainroledata->getParam(WCHDATA_JXJDongCha,param);
			short dongcha = *(short *)param;
			mainrole->doEvent(WCH_JXJGetDongCha,MAKECREPARAM(&totledongcha,NULL));
			ref_ptr<crStaticTextWidgetNode> inputDongCha = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_dongcha));
			if(inputDongCha.valid())
			{
				std::string totalStr = crArgumentParser::appItoa(totledongcha);
				if((short)totledongcha-dongcha > 0)
				{
					inputDongCha->setColor(FCOLOR_ORANGE);
					totalStr += "(+"+crArgumentParser::appItoa((short)totledongcha-dongcha)+")";
				}
				else
				{
					inputDongCha->setColor(FCOLOR_WHITE);
				}
				inputDongCha->setString(totalStr);
			}
			//str1[2] = crArgumentParser::appItoa(totledongcha);
			//str2[2] = "(+"+crArgumentParser::appItoa((short)totledongcha-dongcha)+")";
			//统率
			crVector3f factor;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJTongShuaiFactor,viplv),factor);
			mainroledata->getParam(WCHDATA_JXJTongShuai,param);
			short tongshuai = *(short *)param;
			mainrole->doEvent(WCH_JXJGetTongShuai,MAKECREPARAM(&totletongshuai,NULL));
			ref_ptr<crStaticTextWidgetNode> inputTongshuai = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_tongshuai));
			int leaderPower = tongshuai * factor[0] +factor[1];
			int extraLeader = (totletongshuai-tongshuai);
			if(inputTongshuai.valid())
			{
				std::string totalStr = crArgumentParser::appItoa(totletongshuai);
				if(extraLeader > 0)
				{
					inputTongshuai->setColor(FCOLOR_ORANGE);
					totalStr +="(+"+crArgumentParser::appItoa(extraLeader)+")";
				}
				else
				{
					inputTongshuai->setColor(FCOLOR_WHITE);
				}
				inputTongshuai->setString(totalStr);
			}
			//str1[3] = crArgumentParser::appItoa(totletongshuai);
			//str2[3] = "(+"+crArgumentParser::appItoa(extraLeader)+")";
			//crVector4f m_textColor1(255.0,255.0,255.0,255.0);
			//crVector4f m_textColor2(0.0,255.0,0.0,255.0);
			////////////////////////////////////////
			//for (int i = 0;i < 4;i ++)
			//{
			//	if(input[i])
			//	{
			//		input[i]->clearText();
			//		std::vector<float>v_i;
			//		ItemMap itemMap;
			//		rcfg::ConfigScript cfg_script(&itemMap);
			//		cfg_script.Add("Hypertext");
			//		cfg_script.Push("Hypertext");
			//		cfg_script.Add("CharacterSize",m_characterSize);

			//		cfg_script.Add("Content");
			//		cfg_script.Push("Content",1);
			//		v_i.clear();
			//		for (int vi = 0; vi < 4; vi++)
			//		{
			//			v_i.push_back(m_textColor1[vi]);
			//		}
			//		cfg_script.Add("Color",v_i);
			//		cfg_script.Add("Text",str1[i]);
			//		cfg_script.Pop();
			//		//

			//		cfg_script.Add("Content");
			//		v_i.clear();
			//		for (int vi = 0; vi < 4; vi++)
			//		{
			//			v_i.push_back(m_textColor2[vi]);
			//		}
			//		cfg_script.Add("Color",v_i);
			//		cfg_script.Push("Content",2);
			//		cfg_script.Add("Text",str2[i]);
			//		cfg_script.Pop();

			//		cfg_script.Pop();
			//		input[i]->setHypertext(cfg_script);
			//		
			//	}
			//}
			///////////////////////////////////////////////

			//官职
			ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
			int postnameid = postTab->getTitleIndex("govpost");
			mainroledata->getParam(WCHDATA_JXJGovPost,param);
			unsigned char govpost = *(unsigned char *)param;
			if (postTab->queryOneRecord(0,crArgumentParser::appItoa(govpost),govrecord) >= 0)
			{
				ref_ptr<crStaticTextWidgetNode> inputGuanzhi = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_guanzhi));
				if(inputGuanzhi.valid())
					inputGuanzhi->setString(govrecord[postnameid]);
			}
			//等级
			mainroledata->getParam(WCHDATA_Level,param);
			unsigned char lv = *(unsigned char *)param;
			ref_ptr<crStaticTextWidgetNode> inputLevel = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_level));
			if(inputLevel.valid())inputLevel->setString(crArgumentParser::appItoa(lv)+std::string("级"));
			//领导力
			int totallead = 0;
			playerData->doEvent(WCH_JXJFormationGetLeaderPower, MAKECREPARAM(&totallead, NULL));
			//mainroledata->getParam(WCHDATA_JXJExploit,param);
			//int exploit = *(int *)param;
			ref_ptr<crStaticTextWidgetNode> inputGongxun = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gongxun));
			if (inputGongxun.valid())inputGongxun->setString(crArgumentParser::appItoa(totallead));
		}
	}
}
///////////////////////////////////////////
////
////crJXJGetOneJiangkaPromptMethod
////
///////////////////////////////////////////
//crJXJGetOneJiangkaPromptMethod::crJXJGetOneJiangkaPromptMethod():
//	m_font("simhei.ttf"),
//	m_characterSize(16),
//	m_textColor(255,255,0,255),
//	m_goldColor(255,0,0,255)
//{
//}
//
//crJXJGetOneJiangkaPromptMethod::crJXJGetOneJiangkaPromptMethod(const crJXJGetOneJiangkaPromptMethod& handle):
//	crMethod(handle),
//	m_radio(handle.m_radio),
//	m_btnindex(handle.m_btnindex),
//	m_promptCanvas(handle.m_promptCanvas),
//	m_information(handle.m_information),
//	m_OKbtn(handle.m_OKbtn),
//	m_font(handle.m_font),
//	m_characterSize(handle.m_characterSize),
//	m_textColor(handle.m_textColor),
//	m_goldColor(handle.m_goldColor),
//	m_promptTitle(handle.m_promptTitle)
//{
//}
//
//void crJXJGetOneJiangkaPromptMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//
//void crJXJGetOneJiangkaPromptMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_radio = str;
//		break;
//	case 1:
//		m_btnindex = atoi(str.c_str());
//		break;
//	case 2:
//		m_promptTitle = str;
//		break;
//	case 3:
//		m_promptCanvas = str;
//		break;
//	case 4:
//		m_information = str;
//		break;
//	case 5:
//		m_OKbtn = str;
//		break;
//	case 6:
//		m_font = str;
//		break;
//	case 7:
//		m_characterSize = atoi(str.c_str());
//		break;
//	case 8:
//		crArgumentParser::appAtoVec(str,m_textColor);
//		break;
//	case 9:
//		crArgumentParser::appAtoVec(str,m_goldColor);
//		break;
//	}
//}
//
//void crJXJGetOneJiangkaPromptMethod::operator()(crHandle &handle)
//{
//	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
//	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(canvas && playerData)
//	{
//		int nameid = 0;
//		int moneyid = 0;
//		ref_ptr<crCanvasNode>pcanvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
//		ref_ptr<crHypertextWidgetNode> information = dynamic_cast<crHypertextWidgetNode *>(pcanvas->getWidget(m_information));
//		ref_ptr<crButtonWidgetNode> OKbtn = dynamic_cast<crButtonWidgetNode *>(pcanvas->getWidget(m_OKbtn));
//		ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(pcanvas->getWidget(m_promptTitle));
//		void *param;
//		int cardid;
//		bool success = false;
//		unsigned char cardtype = 0;
//		crData *data = playerData->getDataClass();
//		data->excHandle(MAKECREPARAM(WCH_LockData,1));
//		ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio));
//		int select = radio->getSelect();
//		if(select == 0)
//		{
//			data->getParam(WCHDATA_JXJHallCard,param);
//			int *hallCard = (int *)param;
//			cardid = *(hallCard + m_btnindex);
//			if(cardid != 0)
//			{
//				success = true;
//				cardtype = 0;
//			}
//		}
//		else
//		{
//			data->getParam(WCHDATA_JXJPrivateCard,param);
//			int *privateCard = (int *)param;
//			cardid = *(privateCard + m_btnindex - 1);
//			if(cardid != 0)
//			{
//				success = true;
//				cardtype = 1;
//			}
//		}
//		if (cardid != 0)
//		{
//			data->getParam(WCHDATA_JXJCoppercash,param);
//			int mymoney = *(int *)param;
//			if(OKbtn) OKbtn->setEnable(false);
//
//			ref_ptr<crTableIO>ItemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//			crTableIO::StrVec record;
//			ItemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),record);
//			nameid = ItemTable->getTitleIndex("name");
//			moneyid = ItemTable->getTitleIndex("回收价格");
//			std::string text = "购买【"+record[nameid]+"】吗？";
//
//			//title->setString(L"获取将卡提示");
//			std::vector<float>v_i;
//			ItemMap itemMap;
//			rcfg::ConfigScript cfg_script(&itemMap);
//			cfg_script.Add("Hypertext");
//			cfg_script.Push("Hypertext");
//			cfg_script.Add("Font",m_font);
//			cfg_script.Add("CharacterSize",m_characterSize);
//			v_i.clear();
//			v_i.push_back(m_textColor[0]);
//			v_i.push_back(m_textColor[1]);
//			v_i.push_back(m_textColor[2]);
//			v_i.push_back(m_textColor[3]);
//			cfg_script.Add("Color",v_i);
//
//			cfg_script.Add("Content");
//			cfg_script.Push("Content",1);
//			cfg_script.Add("Text","您确认要花费");
//			cfg_script.Pop();
//
//			cfg_script.Add("Content");
//			cfg_script.Push("Content",2);
//			v_i.clear();
//			v_i.push_back(m_goldColor[0]);
//			v_i.push_back(m_goldColor[1]);
//			v_i.push_back(m_goldColor[2]);
//			v_i.push_back(m_goldColor[3]);
//			cfg_script.Add("Color",v_i);
//			char tmpText[32];
//			sprintf(tmpText,"%d铜钱\0",atoi(record[moneyid].c_str()));
//			cfg_script.Add("Text",tmpText);
//			cfg_script.Pop();
//
//			cfg_script.Add("Content");
//			cfg_script.Push("Content",3);
//			cfg_script.Add("Text",text);
//			cfg_script.Pop();
//
//			cfg_script.Pop();
//			if(information)information->setHypertext(cfg_script);
//			if(OKbtn)OKbtn->setEnable(true);
//			if (atoi(record[moneyid].c_str()) > mymoney)
//			{
//				if(OKbtn)OKbtn->setEnable(false);
//			}
//			crData *dlgData = pcanvas->getDataClass();
//			dlgData->inputParam(WCHDATA_CommandDlgWidget,m_this);
//			crFilterRenderManager::getInstance()->doModal(pcanvas);
//		}
//		data->excHandle(MAKECREPARAM(WCH_LockData,0));
//	}
//}
///////////////////////////////////////////
////
////crJXJGetOneJiangkaMethod
////
///////////////////////////////////////////
//crJXJGetOneJiangkaMethod::crJXJGetOneJiangkaMethod()
//{
//}
//
//crJXJGetOneJiangkaMethod::crJXJGetOneJiangkaMethod(const crJXJGetOneJiangkaMethod& handle):
//	crMethod(handle),
//	m_radio(handle.m_radio),
//	m_btnindex(handle.m_btnindex)
//{
//}
//
//void crJXJGetOneJiangkaMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//
//void crJXJGetOneJiangkaMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_radio = str;
//		break;
//	case 1:
//		m_btnindex = atoi(str.c_str());
//		break;
//	}
//}
//
//void crJXJGetOneJiangkaMethod::operator()(crHandle &handle)
//{
//	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
//	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
//	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//	if(canvas && playerData && netConductor)
//	{
//		void *param;
//		int cardid;
//		bool success = false;
//		unsigned char cardtype = 0;
//		crData *data = playerData->getDataClass();
//		data->excHandle(MAKECREPARAM(WCH_LockData,1));
//		ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio));
//		int select = radio->getSelect();
//		if(select == 0)
//		{
//			data->getParam(WCHDATA_JXJHallCard,param);
//			int *hallCard = (int *)param;
//			cardid = *(hallCard + m_btnindex);
//			if(cardid != 0)
//			{
//				success = true;
//				cardtype = 0;
//			}
//		}
//		else
//		{
//			data->getParam(WCHDATA_JXJPrivateCard,param);
//			int *privateCard = (int *)param;
//			cardid = *(privateCard + m_btnindex - 1);
//			if(cardid != 0)
//			{
//				success = true;
//				cardtype = 1;
//			}
//		}
//		if(success)
//		{
//			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//			crTableIO::StrVec itemrecord;
//			itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),itemrecord);
//			int moneyid = itemtab->getTitleIndex("回收价格");
//			data->getParam(WCHDATA_JXJCoppercash,param);
//			int mymoney = *(int *)param;
//			if (atoi(itemrecord[moneyid].c_str()) > mymoney)
//			{
//				success = false;
//			}
//		}
//		data->excHandle(MAKECREPARAM(WCH_LockData,0));
//		if(success)
//		{
//			ref_ptr<crStreamBuf> stream = new crStreamBuf;
//			stream->createBuf(6);
//			stream->_writeInt(cardid);
//			stream->_writeUChar(cardtype);
//			stream->_writeUChar(m_btnindex);
//			crPlayerDataEventPacket packet;
//			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGetJiangKa,stream.get());
//			netConductor->getNetManager()->sendPacket("all",packet);
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvGetJiangKaMethod
////
///////////////////////////////////////////
//crJXJRecvGetJiangKaMethod::crJXJRecvGetJiangKaMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvGetJiangKaMethod::crJXJRecvGetJiangKaMethod(const crJXJRecvGetJiangKaMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvGetJiangKaMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//void crJXJRecvGetJiangKaMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_tips = str;
//		break;
//	case 1:
//		m_input = str;
//		break;
//	}
//}
//void crJXJRecvGetJiangKaMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			void *param;
//			unsigned char success = 0;
//			int playerid = m_this->getPlayerID();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				crData *data = playerData->getPlayerGameData()->getDataClass();
//				int cardid = m_stream->_readInt();
//				unsigned char cardtype = m_stream->_readUChar();
//				unsigned char btnindex = m_stream->_readUChar();
//
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
//				JXJItemBagVec *jiangkavec = (JXJItemBagVec *)param;
//				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//				crTableIO::StrVec itemrecord;
//				itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),itemrecord);
//				int moneyid = itemtab->getTitleIndex("回收价格");
//				data->getParam(WCHDATA_JXJCoppercash,param);
//				int *mymoney = (int *)param;
//				if (atoi(itemrecord[moneyid].c_str()) < *mymoney)
//				{
//					for(JXJItemBagVec::iterator itr = jiangkavec->begin(); itr!= jiangkavec->end();++itr)
//					{
//						if ((*itr) == NULL)
//						{
//							ref_ptr<crBagItemData> itemdata = new crBagItemData;
//							itemdata->setItemID(cardid);
//							itemdata->setItemCount(1);
//							(*itr) = itemdata;
//							*mymoney -= atoi(itemrecord[moneyid].c_str());
//							success = 1;
//							break;
//						}
//					}
//				}
//				else
//				{
//					success = 2;
//				}
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//
//
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(7);
//				stream->_writeUChar(success);
//				stream->_writeInt(cardid);
//				stream->_writeUChar(cardtype);
//				stream->_writeUChar(btnindex);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvGetJiangKa,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//		}
//		if(m_netType == GameClient_Game)
//		{
//			unsigned char success =m_stream->_readUChar();
//			if(success == 1)
//			{
//				void *param;
//				crData *data =m_this->getDataClass();
//				int cardid = m_stream->_readInt();
//				unsigned char cardtype = m_stream->_readUChar();
//				unsigned char btnindex = m_stream->_readUChar();
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
//				JXJItemBagVec *jiangkavec = (JXJItemBagVec *)param;
//				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//				crTableIO::StrVec itemrecord;
//				itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),itemrecord);
//				int moneyid = itemtab->getTitleIndex("回收价格");
//				data->getParam(WCHDATA_JXJCoppercash,param);
//				int *mymoney = (int *)param;
//				*mymoney -= atoi(itemrecord[moneyid].c_str());
//				for(JXJItemBagVec::iterator itr = jiangkavec->begin(); itr!= jiangkavec->end();++itr)
//				{
//					if ((*itr) == NULL)
//					{
//						ref_ptr<crBagItemData> itemdata = new crBagItemData;
//						itemdata->setItemID(cardid);
//						itemdata->setItemCount(1);
//						(*itr) = itemdata;
//						success = 1;
//						break;
//					}
//				}
//				if(cardtype == 0)
//				{
//					data->getParam(WCHDATA_JXJHallCard,param);
//					int *hallCard = (int *)param;
//					*(hallCard + btnindex) = 0;
//					if(cardid != 0)
//					{
//						success = true;
//					}
//				}
//				else
//				{
//					data->getParam(WCHDATA_JXJPrivateCard,param);
//					int *privateCard = (int *)param;
//					*(privateCard + btnindex - 1) = 0;
//				}
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//			}
//			if (success == 0)
//			{
//				//提示背包空间不足
//			}
//			if (success == 2)
//			{
//				//提示铜钱不足
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJTestNodeSizeMethod
//
/////////////////////////////////////////
crJXJTestNodeSizeMethod::crJXJTestNodeSizeMethod()
{
}

crJXJTestNodeSizeMethod::crJXJTestNodeSizeMethod(const crJXJTestNodeSizeMethod& handle):
	crMethod(handle),
	m_equipList(handle.m_equipList),
	m_sizex(handle.m_sizex),
	m_sizey(handle.m_sizey),
	m_betweenx(handle.m_betweenx),
	m_betweeny(handle.m_betweeny),
	m_scrollbar(handle.m_scrollbar)
{
}

void crJXJTestNodeSizeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJTestNodeSizeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipList = str;
		break;
	case 1:
		m_sizex = atof(str.c_str());
		break;
	case 2:
		m_sizey = atof(str.c_str());
		break;
	case 3:
		m_betweenx = atof(str.c_str());
		break;
	case 4:
		m_betweeny = atof(str.c_str());
		break;
	case 5:
		m_scrollbar = str;
		break;
	}
}

void crJXJTestNodeSizeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		int count = 0;
		ref_ptr<crListControlWidgetNode> equipList = dynamic_cast<crListControlWidgetNode *>(m_this->getWidget(m_equipList));
		ref_ptr<crScrollBarWidgetNode> Vscrollbar = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbar));
		if (equipList.valid())
		{
			equipList->setNodeSize(crVector2f(m_sizex,m_sizey));
			equipList->setSpaceBetween(crVector2f(m_betweenx,m_betweeny));
			count = equipList->getListNodeCount();
		}
		if(count > 0 && Vscrollbar.valid())
		{
			Vscrollbar->setLineValue(m_sizey+m_betweeny);
			Vscrollbar->setPageValue((m_sizey+m_betweeny)*count);
			//Vscrollbar->setMinMoveValue(Vscrollbar->getLineValue());
		}
	}
}
/////////////////////////////////////////
//
//crJXJTestNodeSize2Method
//
/////////////////////////////////////////
crJXJTestNodeSize2Method::crJXJTestNodeSize2Method():
	m_charactersize(12),
	m_sizex(16),
	m_sizey(16),
	m_linespacing(5),
	m_underlinespacing(3)
{
}

crJXJTestNodeSize2Method::crJXJTestNodeSize2Method(const crJXJTestNodeSize2Method& handle):
	crMethod(handle),
	m_charactersize(handle.m_charactersize),
	m_sizex(handle.m_sizex),
	m_sizey(handle.m_sizey),
	m_linespacing(handle.m_linespacing),
	m_underlinespacing(handle.m_underlinespacing),
	m_scrollbar(handle.m_scrollbar),
	m_table(handle.m_table)
{
	for (int i = 0; i<9;i++)
	{
		m_equipList[i] = handle.m_equipList[i];
	}
}

void crJXJTestNodeSize2Method::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJTestNodeSize2Method::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_equipList[0] = str;
		break;
	case 1:
		m_charactersize = atof(str.c_str());
		break;
	case 2:
		m_sizex = atof(str.c_str());
		break;
	case 3:
		m_sizey = atof(str.c_str());
		break;
	case 4:
		m_linespacing = atof(str.c_str());
		break;
	case 5:
		m_underlinespacing = atof(str.c_str());
		break;
	case 6:
		m_scrollbar = str;
		break;
	case 7:
		m_table = str;
		break;
	case 8:
		m_equipList[1] = str;
		break;
	case 9:
		m_equipList[2] = str;
		break;
	case 10:
		m_equipList[3] = str;
		break;
	case 11:
		m_equipList[4] = str;
		break;
	case 12:
		m_equipList[5] = str;
		break;
	case 13:
		m_equipList[6] = str;
		break;
	case 14:
		m_equipList[7] = str;
		break;
	case 15:
		m_equipList[8] = str;
		break;
	}
}

void crJXJTestNodeSize2Method::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crListBoxWidgetNode> equipList[9] ={NULL};
		ref_ptr<crTableWidgetNode> tablelist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_table));
		ref_ptr<crScrollBarWidgetNode> Vscrollbar = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbar));
		for(int i = 0 ;i<9 ;i++)
		{
			equipList[i] = dynamic_cast<crListBoxWidgetNode *>(m_this->getWidget(m_equipList[i]));
			if (equipList[i].valid())
			{
				equipList[i]->setCharacterSize(m_charactersize);
				equipList[i]->setFontSize(crVector2f(m_sizex,m_sizey));
				equipList[i]->setLineSpacing(m_linespacing);
				equipList[i]->setUnderLineSpacing(m_underlinespacing);
			}
		}
		//if (tablelist)
		//{
		//	int count = tablelist->getRowCount();
		//	if (Vscrollbar)
		//	{
		//		Vscrollbar->setLineValue(m_linespacing+m_charactersize);
		//		Vscrollbar->setPageValue(Vscrollbar->getLineValue()*count);
		//		//Vscrollbar->setMinMoveValue(Vscrollbar->getLineValue());
		//	}
		//}
	}
}
/////////////////////////////////////////
//
//crJXJBattleScrollBarMethod
//
/////////////////////////////////////////
crJXJBattleScrollBarMethod::crJXJBattleScrollBarMethod()
{
}

crJXJBattleScrollBarMethod::crJXJBattleScrollBarMethod(const crJXJBattleScrollBarMethod& handle):
	crMethod(handle),
	m_listctrl(handle.m_listctrl),
	m_scrollbar(handle.m_scrollbar),
	m_linevalue(handle.m_linevalue)
{
}

void crJXJBattleScrollBarMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJBattleScrollBarMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_listctrl = str;
		break;
	case 1:
		m_scrollbar = str;
		break;
	case 2:
		m_linevalue = atoi(str.c_str());
		break;
	}
}

void crJXJBattleScrollBarMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		//ref_ptr<crTableWidgetNode> cityList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_listctrl));
		ref_ptr<crScrollBarWidgetNode> Vscrollbar = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbar));
	//	ref_ptr<crListBoxWidgetNode> listbox = dynamic_cast<crListBoxWidgetNode *>(cityList->getChild(0));
	//	int count = listbox->getDataSize();

		if(!Vscrollbar) return;

		Vscrollbar->setLineValue(m_linevalue);
	//	Vscrollbar->setPageValue(m_linevalue*count);
	//	Vscrollbar->setMinMoveValue(m_linevalue);
	}
}
/////////////////////////////////////////
//
//crJXJShowSystemNewsMethod
//
/////////////////////////////////////////
crJXJShowSystemNewsMethod::crJXJShowSystemNewsMethod():
	m_interval(0.0f)
{
}

crJXJShowSystemNewsMethod::crJXJShowSystemNewsMethod(const crJXJShowSystemNewsMethod& handle):
	crMethod(handle),
	m_input(handle.m_input),
	m_interval(handle.m_interval)

{
}

void crJXJShowSystemNewsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJShowSystemNewsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	case 1:
		m_interval = atof(str.c_str());
		break;
	}
}

void crJXJShowSystemNewsMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		m_this->setCanvasPos(CANVAS_BOTTOM);
		ref_ptr<crHypertextWidgetNode> input = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_input));
		if (input.valid())
		{
			void *param;
			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
			brainData->getParam(WCHDATA_JXJNewsCanvasStep,param);
			float *step = (float *)param;
			*step -= m_interval;
			const crBoundingBox &bbox = m_this->getBoundBox();
			const crBoundingBox &bbox2 = input->getBoundBox();
			float posx = bbox.m_max[0] + *step;
			float posy = 0;
			float boxlenth2 = bbox2.m_max[0] - bbox2.m_min[0];
			input->setMatrix(crMatrix::translate(posx,posy,0.0f));
			if (*step <= (/*bbox.m_min[0]*/-bbox.m_max[0] + bbox.m_min[0] - boxlenth2 * 0.5))
			{
				*step = boxlenth2 * 0.5;/* bbox.m_max[0] * 0.5;*/
			}
			brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIUpdateSystemNewsMethod
//
/////////////////////////////////////////
crJXJUIUpdateSystemNewsMethod::crJXJUIUpdateSystemNewsMethod()
{
}

crJXJUIUpdateSystemNewsMethod::crJXJUIUpdateSystemNewsMethod(const crJXJUIUpdateSystemNewsMethod& handle):
	crMethod(handle),
	m_input(handle.m_input)
{
}

void crJXJUIUpdateSystemNewsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIUpdateSystemNewsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	}
}

void crJXJUIUpdateSystemNewsMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		m_this->setCanvasPos(CANVAS_BOTTOM);
		m_this->setCanFocus(false);
		m_this->setEnable(false);
		m_this->setVisiable(false);
		ref_ptr<crHypertextWidgetNode> input = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_input));
		if (input.valid())
		{
			crData *data = playerData->getDataClass();
			std::string file = "helloplayer.cfg";
			data->getParam(WCHDATA_JXJCenterNotice, param);
			crStreamBuf *filestream = (crStreamBuf *)param;
			if (filestream)
			{
				rcfg::ConfigScript cfg_script;
				crGlobalHandle::getInstance()->getStreamScript(filestream,cfg_script);
				input->setHypertext(cfg_script);
				m_this->setVisiable(true);
				input->setEnableMatrix(true);
				input->setSingleLine(true);
				//data->inputParam(WCHDATA_JXJCenterNotice, filestream);
				//cfg_script.Write("12345.cfg");
			}
			else if(!file.empty())
			{
				input->clearText();
				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
				input->setHypertext(file);
				m_this->setVisiable(true);
				input->setEnableMatrix(true);
				input->setSingleLine(true);
				if (!file.empty())
				{
					rcfg::ConfigScript cfg_script;
					if (crScriptLoadManager::getInstance()->loadConfigScript(cfg_script, file))
					{
						ref_ptr<crStreamBuf> tempStream;
						crGlobalHandle::getInstance()->getScriptStream(cfg_script,tempStream);
						data->inputParam(WCHDATA_JXJCenterNotice, tempStream.get());
						data->inputParam(WCHDATA_JXJOldCenterNotice, tempStream.get());
					}
				}
				//input->setColor(crVector4f(255.0f,0,0,1));
			}
			else
			{
				m_this->setVisiable(false);
			}
			//std::string str = "祝各位玩家游戏愉快！！";
			//input->setHypertext(str);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSystemNewsMethod
//
/////////////////////////////////////////
crJXJRecvSystemNewsMethod::crJXJRecvSystemNewsMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvSystemNewsMethod::crJXJRecvSystemNewsMethod(const crJXJRecvSystemNewsMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input)
{
}
void crJXJRecvSystemNewsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvSystemNewsMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	}
}
void crJXJRecvSystemNewsMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			std::string text = m_stream->_readString();
//			void *param;
			crData *data = m_this->getDataClass();
			ref_ptr<crCanvasNode>ChatCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (ChatCanvas.valid())
			{
				ref_ptr<crEditWidgetNode> input = dynamic_cast<crEditWidgetNode *>(ChatCanvas->getWidget(m_input));
				if(input.valid())input->addString(text);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBigMapUpdateMethod
//
/////////////////////////////////////////
crJXJUIBigMapUpdateMethod::crJXJUIBigMapUpdateMethod():
	m_mapsize(2048.0f,2048.0f),
	m_mapscale(1.0f,1.0f),
	m_init(false)
{
}

crJXJUIBigMapUpdateMethod::crJXJUIBigMapUpdateMethod(const crJXJUIBigMapUpdateMethod& handle):
	crMethod(handle),
	m_citysmall(handle.m_citysmall),
	m_citymedian(handle.m_citymedian),
	m_citybig(handle.m_citybig),
	m_cityflag(handle.m_cityflag),
	m_citynamewhite(handle.m_citynamewhite),
	m_citynameyellow(handle.m_citynameyellow),
	m_gate(handle.m_gate),
	m_gateflag(handle.m_gateflag),
	m_gatename(handle.m_gatename),
	m_backboard(handle.m_backboard),
	m_mapsize(handle.m_mapsize),
	m_mapscale(handle.m_mapscale),
	m_init(handle.m_init),
	m_btnVec(handle.m_btnVec),
	m_flagVec(handle.m_flagVec),
	m_nameVec(handle.m_nameVec)
{
}

void crJXJUIBigMapUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIBigMapUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_citysmall = str;
		break;
	case 1:
		m_citymedian = str;
		break;
	case 2:
		m_citybig = str;
		break;
	case 3:
		m_cityflag = str;
		break;
	case 4:
		m_citynamewhite = str;
		break;
	case 5:
		m_citynameyellow = str;
		break;
	case 6:
		m_gate = str;
		break;
	case 7:
		m_gateflag = str;
		break;
	case 8:
		m_gatename = str;
		break;
	case 9:
		m_backboard = str;
		break;
	case 10:
		crArgumentParser::appAtoVec(str,m_mapsize);
		break;
	case 11:
		crArgumentParser::appAtoVec(str,m_mapscale);
		break;
	}
}

void crJXJUIBigMapUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
		//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
		int rowcount = chengchiTab->getRowCount();
		if (!m_init)
		{
			m_init = true;
			const crMatrix &scaleMat = crDisplaySettings::instance()->getUIScaleMatrix();
			const crMatrix &invScaleMat = crDisplaySettings::instance()->getInvUIScaleMatrix();

			// filter my side city
			crTableIO::DataVec records[4];
			int sizeid = chengchiTab->getTitleIndex("规模");
			int nameid = chengchiTab->getTitleIndex("名字");
			int posid = chengchiTab->getTitleIndex("坐标");
			int idid = chengchiTab->getTitleIndex("id");
			chengchiTab->queryRecords(sizeid,crArgumentParser::appItoa(CS_Small),records[CS_Small]);
			chengchiTab->queryRecords(sizeid,crArgumentParser::appItoa(CS_Median),records[CS_Median]);
			chengchiTab->queryRecords(sizeid,crArgumentParser::appItoa(CS_Big),records[CS_Big]);
			chengchiTab->queryRecords(sizeid,crArgumentParser::appItoa(CS_Gate),records[CS_Gate]);

			PosVec pos;
			m_btnVec.resize(rowcount,new crButtonWidgetNode);
			m_flagVec.resize(rowcount,new crWidgetNode);
			m_nameVec.resize(rowcount,new crStaticTextWidgetNode);
			pos.resize(rowcount);
			std::string str;
			int i = 0;
			CRCore::ref_ptr<crWidgetNode> backboard = dynamic_cast<CRCore::crWidgetNode *>(m_this->getWidget(m_backboard));
			ref_ptr<crStaticTextWidgetNode> Citynamew = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_citynamewhite));
			ref_ptr<crStaticTextWidgetNode> Citynamey = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_citynameyellow));
			ref_ptr<crStaticTextWidgetNode> Gatename = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gatename));
			ref_ptr<crButtonWidgetNode> btnSmall = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_citysmall));
			ref_ptr<crButtonWidgetNode> btnMedian = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_citymedian));
			ref_ptr<crButtonWidgetNode> btnBig = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_citybig));
			ref_ptr<crButtonWidgetNode> btnGate = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_gate));
			CRCore::ref_ptr<crWidgetNode> Cityflag = dynamic_cast<CRCore::crWidgetNode *>(m_this->getWidget(m_cityflag));
			CRCore::ref_ptr<crWidgetNode> Gateflag = dynamic_cast<CRCore::crWidgetNode *>(m_this->getWidget(m_gateflag));
			btnSmall->setVisiable(false);
			btnMedian->setVisiable(false);
			btnBig->setVisiable(false);
			btnGate->setVisiable(false);
			Cityflag->setVisiable(false);
			Citynamew->setVisiable(false);
			Citynamey->setVisiable(false);
			Gatename->setVisiable(false);
			Gateflag->setVisiable(false);

			crVector2 mapWidgetSize;
			const crBoundingBox &bbox = backboard->getBoundBox();
			mapWidgetSize.set(bbox.xLength(),bbox.yLength());
			crVector2 mapFactor/* = crMyPlayerData::getInstance()->getMapFactor(mapWidgetSize)*/;
			mapFactor[0] = mapWidgetSize[0]/(m_mapsize[0]*m_mapscale[0]);
			mapFactor[1] = mapWidgetSize[1]/(m_mapsize[1]*m_mapscale[1]);
			for (int j = CS_Small; j <= CS_Gate; j++)
			{
				for( crTableIO::DataVec::iterator itr = records[j].begin();
					itr != records[j].end();
					++itr,i++ )
				{
					if(btnSmall.valid()&&btnMedian.valid()&&btnBig.valid()&&btnGate.valid()&&Citynamew.valid()&&Citynamey.valid()&&Gatename.valid()&&Cityflag.valid()&&Gateflag.valid())
					{
						switch (j)
						{
						case CS_Small:
							m_btnVec[i] = dynamic_cast<crButtonWidgetNode*>(btnSmall->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_flagVec[i] = dynamic_cast<CRCore::crWidgetNode*>(Cityflag->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_nameVec[i] = dynamic_cast<crStaticTextWidgetNode*>(Citynamew->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							break;
						case CS_Median:
							m_btnVec[i] = dynamic_cast<crButtonWidgetNode*>(btnMedian->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_flagVec[i] = dynamic_cast<CRCore::crWidgetNode*>(Cityflag->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_nameVec[i] = dynamic_cast<crStaticTextWidgetNode*>(Citynamew->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							break;
						case CS_Big:
							m_btnVec[i] = dynamic_cast<crButtonWidgetNode*>(btnBig->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_flagVec[i] = dynamic_cast<CRCore::crWidgetNode*>(Cityflag->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_nameVec[i] = dynamic_cast<crStaticTextWidgetNode*>(Citynamey->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							break;
						case CS_Gate:
							m_btnVec[i] = dynamic_cast<crButtonWidgetNode*>(btnGate->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_flagVec[i] = dynamic_cast<CRCore::crWidgetNode*>(Gateflag->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							m_nameVec[i] = dynamic_cast<crStaticTextWidgetNode*>(Gatename->clone(crCopyOp::DEEP_COPY_NODES|crCopyOp::DEEP_COPY_DATAS));
							break;
						}
						//m_this->addChild(m_btnVec[i].get());
						//m_this->addChild(m_flagVec[i].get());
						//m_this->addChild(m_nameVec[i].get());
						crLoadManager::getInstance()->requestAddNode(m_this,m_btnVec[i].get(),false);
						crLoadManager::getInstance()->requestAddNode(m_this,m_flagVec[i].get(),false);
						crLoadManager::getInstance()->requestAddNode(m_this,m_nameVec[i].get(),false);
						m_btnVec[i]->initWindow();
						m_btnVec[i]->setParentCanvas(m_this);
						m_btnVec[i]->setVisiable(true);
						m_btnVec[i]->setEnable(true);
						//m_nameVec[i]->initWindow();
						m_nameVec[i]->setParentCanvas(m_this);
						m_nameVec[i]->initWindow();
						m_nameVec[i]->setString((*itr)[nameid]);
						m_nameVec[i]->setVisiable(true);
						//m_flagVec[i]->initWindow();
						m_flagVec[i]->setParentCanvas(m_this);
						m_flagVec[i]->initWindow();
						unsigned short cityid = atoi((*itr)[idid].c_str());
						str = (*itr)[posid];
						crArgumentParser::appAtoVec(str,pos[i]);
						crData *btdata = m_btnVec[i]->getDataClass();
						btdata->inputParam(WCHDATA_JXJBigMapCity,&cityid);
						float px = pos[i].x();// - myX;
						float py = pos[i].y();// - myY;
						px *= mapFactor[0];
						py *= mapFactor[1];
						px -= mapWidgetSize[0]*0.5;
						py -= mapWidgetSize[1]*0.5;
						m_flagVec[i]->setMatrix(invScaleMat  * scaleMat * crMatrix::translate(crVector3(px,py,0.0f)));
						m_btnVec[i]->setMatrix(invScaleMat  * scaleMat * crMatrix::translate(crVector3(px,py,0.0f)));
						m_nameVec[i]->setMatrix(invScaleMat  * scaleMat * crMatrix::translate(crVector3(px,py,0.0f)));
						//buttonAFirst->setPosition(crVector3f(0.0,0.0,0.0);
					}
				}
			}
		}

		data->getParam(WCHDATA_JXJChengChiMap,param);
		ChengchiMap *map_city = (ChengchiMap *)param;
		unsigned char chengzhu;
		crMultiSwitch *Cityflagsw;
		crData *btdata;
		ChengchiMap::iterator ccItr;
		unsigned short cityid;
		for (int i = 0; i < rowcount; i++)
		{
			Cityflagsw = dynamic_cast<crMultiSwitch *>(m_flagVec[i]->getChild(0));
			btdata = m_btnVec[i]->getDataClass();
			btdata->inputParam(WCHDATA_JXJBigMapCity,param);
			cityid = *(unsigned short*)param;
			ccItr = map_city->find(cityid);
			if(ccItr != map_city->end())
			{
				chengzhu = ccItr->second->getChengzhuShili();
				if (chengzhu > c_startShiliID)
				{
					Cityflagsw->setActiveSwitchSet(chengzhu - c_startShiliID);
					m_flagVec[i]->setVisiable(true);
				}
			}
			//for( ChengchiMap::iterator itr = map_city->begin(); itr != map_city->end(); ++itr)
			//{
			//	if(itr->first == cityid)
			//	{
			//		if (itr->second.first > c_startShiliID)
			//		{
			//			Cityflagsw->setActiveSwitchSet(itr->second.first - c_startShiliID);
			//			m_flagVec[i]->setVisiable(true);
			//		}
			//		break;
			//	}
			//}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIUpdateBattleListMethod
//
/////////////////////////////////////////
crJXJUIUpdateBattleListMethod::crJXJUIUpdateBattleListMethod()
{
}

crJXJUIUpdateBattleListMethod::crJXJUIUpdateBattleListMethod(const crJXJUIUpdateBattleListMethod& handle):
	crMethod(handle),
	m_gamelist(handle.m_gamelist)
{
}

void crJXJUIUpdateBattleListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIUpdateBattleListMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_gamelist = str;
		break;
	}
}

void crJXJUIUpdateBattleListMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crTableWidgetNode> battleList = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_gamelist));
		ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_this->getName()));
		if (battleList.valid())
		{
			int rowcount = battleList->getRowCount();
			ref_ptr<crTableIO>tab_city = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
			int buttonnameid = tab_city->getTitleIndex("buttonname");
			crTableIO::StrVec btnrecord;
			for (int i = 0; i<rowcount; i++)
			{
				unsigned short cityid = battleList->getData(i);
				if (tab_city->queryOneRecord(buttonnameid,m_this->getName(),btnrecord) >= 0)
				{
					ref_ptr<crButtonWidgetNode> citybtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(btnrecord[buttonnameid]));
					if (atoi(btnrecord[0].c_str()) == cityid)
					{
						if (citybtn.valid())
						{
							crMultiSwitch *btnswi = dynamic_cast<crMultiSwitch *>(btn->getChild(0));
							if (btnswi)
							{
								btnswi->setActiveSwitchSet(1);
								battleList->selectRow(i);
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISetBuildCanvasNameMethod
//
/////////////////////////////////////////
crJXJUISetBuildCanvasNameMethod::crJXJUISetBuildCanvasNameMethod()
{
}

crJXJUISetBuildCanvasNameMethod::crJXJUISetBuildCanvasNameMethod(const crJXJUISetBuildCanvasNameMethod& handle):
	crMethod(handle),
	m_name(handle.m_name),
	m_info(handle.m_info)
{
}

void crJXJUISetBuildCanvasNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUISetBuildCanvasNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_name = str;
		break;
	case 1:
		m_info = str;
		break;
	case 2:
		m_buildingname = str;
		break;
	}
}

void crJXJUISetBuildCanvasNameMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		bool ifset = true;
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->inputParam(WCHDATA_JXJIfSetArmyNum,&ifset);

		ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_name));
		ref_ptr<crHypertextWidgetNode> info = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_info));
		crMultiSwitch *nameswitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_buildingname));
		void *param;
		crData *canvasdata = m_this->getDataClass();
		canvasdata -> getParam(WCHDATA_JXJCheckBuildingID,param);
		int buildingid = *(int *)param;
		int buildingid2 = 0;
		if (buildingid >=WCHDATA_JXJMingjulv1 && buildingid <= WCHDATA_JXJMingjulv8)
		{
			buildingid2 = WCHDATA_JXJMingjulv;
		}
		if (buildingid >=WCHDATA_JXJNongtianlv1 && buildingid <= WCHDATA_JXJNongtianlv8)
		{
			buildingid2 = WCHDATA_JXJNongtianlv;
		}
		if (buildingid >=WCHDATA_JXJMuchanglv1 && buildingid <= WCHDATA_JXJMuchanglv4)
		{
			buildingid2 = WCHDATA_JXJMuchanglv;
		}
		if (buildingid >=WCHDATA_JXJLingdilv1 && buildingid <= WCHDATA_JXJLingdilv4)
		{
			buildingid2 = WCHDATA_JXJLingdilv;
		}
		if (buildingid >=WCHDATA_JXJKuangshanlv1 && buildingid <= WCHDATA_JXJKuangshanlv4)
		{
			buildingid2 = WCHDATA_JXJKuangshanlv;
		}
		if (buildingid2 == 0)
		{
			buildingid2 = buildingid;
		}
		ref_ptr<crTableIO>infoTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInfoTab);
		std::string idStr = crArgumentParser::appItoa(buildingid2);
		crTableIO::StrVec infoRec;
		int retVal = infoTab->queryOneRecord(0,idStr,infoRec);
		if (buildingid >=WCHDATA_JXJMingjulv1 && buildingid <= WCHDATA_JXJMingjulv8)
		{
			buildingid2 = WCHDATA_JXJMingjulv;
			if(nameswitch)nameswitch->setActiveSwitchSet(1);
		}
		if (buildingid >=WCHDATA_JXJNongtianlv1 && buildingid <= WCHDATA_JXJNongtianlv8)
		{
			buildingid2 = WCHDATA_JXJNongtianlv;
			if(nameswitch)nameswitch->setActiveSwitchSet(3);
		}
		if (buildingid >=WCHDATA_JXJMuchanglv1 && buildingid <= WCHDATA_JXJMuchanglv4)
		{
			buildingid2 = WCHDATA_JXJMuchanglv;
			if(nameswitch)nameswitch->setActiveSwitchSet(0);
		}
		if (buildingid >=WCHDATA_JXJLingdilv1 && buildingid <= WCHDATA_JXJLingdilv4)
		{
			buildingid2 = WCHDATA_JXJLingdilv;
			if(nameswitch)nameswitch->setActiveSwitchSet(4);
		}
		if (buildingid >=WCHDATA_JXJKuangshanlv1 && buildingid <= WCHDATA_JXJKuangshanlv4)
		{
			buildingid2 = WCHDATA_JXJKuangshanlv;
			if(nameswitch)nameswitch->setActiveSwitchSet(2);
		}
		if(title.valid())
		{
			//std::string name = infoRec[1];
			//title->setString(name);
		}
		if(info.valid())
		{
			if (retVal >= 0)
			{
				std::string file = infoRec[2];
				if(!file.empty())
				{
					file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
					info->setHypertext(file);
				}
				else
				{
					info->clearText();
				}
			}
		}

	}
}
/////////////////////////////////////////
//
//crJXJUISetDefaultRecruitNumMethod
//
/////////////////////////////////////////
crJXJUISetDefaultRecruitNumMethod::crJXJUISetDefaultRecruitNumMethod()
{
}

crJXJUISetDefaultRecruitNumMethod::crJXJUISetDefaultRecruitNumMethod(const crJXJUISetDefaultRecruitNumMethod& handle):
	crMethod(handle),
	m_input(handle.m_input),
	m_fomationsize(handle.m_fomationsize)
{
}

void crJXJUISetDefaultRecruitNumMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUISetDefaultRecruitNumMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_input = str;
		break;
	case 1:
		m_fomationsize = atoi(str.c_str());
		break;
	}
}

void crJXJUISetDefaultRecruitNumMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		crData *data = crBrain::getInstance()->getDataClass();
		data->getParam(WCHDATA_JXJIfSetArmyNum,param);
		bool ifsetarmynum = *(bool *)param;
		if (ifsetarmynum)
		{
			crRole *mainRole = playerData->getMainRole();
			crData *mainRoleData = mainRole->getDataClass();
			std::string str;
			int need = 0;
			bool setnum = false;
			int totallead = 0;
			int armynum = 0;
			ref_ptr<crEditWidgetNode> numinput = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_input));
			playerData->doEvent(WCH_JXJFormationGetLeaderPower,MAKECREPARAM(&totallead,NULL));
			crData *data = crBrain::getInstance()->getDataClass();
			data->getParam(WCHDATA_JXJCurSelRecruitArmAID,param);
			int selAbastactid = *(int *)param;
			data->inputParam(WCHDATA_JXJIfSetArmyNum, &setnum);
			if(selAbastactid>0)
			{
				crTableIO::StrVec record2;
				ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
				int needid = troopsTab->getTitleIndex("领导力");
				if (troopsTab->queryOneRecord(0,crArgumentParser::appItoa(selAbastactid),record2) >= 0)
					need = atoi(record2[needid].c_str());
			}
			if (need>0)
			{
				armynum = totallead / need * m_fomationsize;
				str = crArgumentParser::appItoa(armynum);
				if (numinput.valid())
				{
					numinput->setString(str);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJListCtrlScrollMethod
//
/////////////////////////////////////////
crJXJListCtrlScrollMethod::crJXJListCtrlScrollMethod()
{
}

crJXJListCtrlScrollMethod::crJXJListCtrlScrollMethod(const crJXJListCtrlScrollMethod& handle):
	crMethod(handle),
	m_srollbar(handle.m_srollbar),
	m_type(handle.m_type)
{
}

void crJXJListCtrlScrollMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJListCtrlScrollMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_srollbar = str;
		break;
	case 1:
		m_type = atoi(str.c_str());
		break;
	}
}

void crJXJListCtrlScrollMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crScrollBarWidgetNode> vScollbar = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_srollbar));
		if (vScollbar.valid())
		{
			if (!m_type)
			{
				vScollbar->setValue(vScollbar->getValue() - vScollbar->getLineValue());
			}
			else
			{
				vScollbar->setValue(vScollbar->getValue() + vScollbar->getLineValue());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJResetScrollBarValueMethod
//
/////////////////////////////////////////
crJXJResetScrollBarValueMethod::crJXJResetScrollBarValueMethod()
{
}

crJXJResetScrollBarValueMethod::crJXJResetScrollBarValueMethod(const crJXJResetScrollBarValueMethod& handle):
	crMethod(handle),
	m_srollbar(handle.m_srollbar)
{
}

void crJXJResetScrollBarValueMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJResetScrollBarValueMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_srollbar = str;
		break;
	}
}

void crJXJResetScrollBarValueMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crCanvasNode>canvas = m_this -> getParentCanvas();
		ref_ptr<crScrollBarWidgetNode> vScollbar = dynamic_cast<crScrollBarWidgetNode *>(canvas->getWidget(m_srollbar));

		if (vScollbar.valid())
		{
			vScollbar->setValue(0);
		}
	}
}
/////////////////////////////////////////
//
//crJXJAutoMakeEquipsMethod
//
/////////////////////////////////////////
crJXJAutoMakeEquipsMethod::crJXJAutoMakeEquipsMethod():
	m_copperColor(255,255,255,255)
{
}

crJXJAutoMakeEquipsMethod::crJXJAutoMakeEquipsMethod(const crJXJAutoMakeEquipsMethod& handle):
	crMethod(handle),
	m_inputneed(handle.m_inputneed),
	m_msgbox(handle.m_msgbox),
	m_inputMoney(handle.m_inputMoney),
	m_inputWood(handle.m_inputWood),
	m_inputIron(handle.m_inputIron),
	m_inputHorse(handle.m_inputHorse),
	m_inputFood(handle.m_inputFood),
	m_inputRecruitTime(handle.m_inputRecruitTime),
	m_inputRecruitTime_2(handle.m_inputRecruitTime_2),
	m_copperColor(handle.m_copperColor),
	m_recruitcount(handle.m_recruitcount)
{
}

void crJXJAutoMakeEquipsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJAutoMakeEquipsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_inputneed = str;
		break;
	case 1:
		m_msgbox = str;
		break;
	case 2:
		m_inputMoney = str;
		break;
	case 3:
		m_inputWood = str;
		break;
	case 4:
		m_inputIron = str;
		break;
	case 5:
		m_inputHorse = str;
		break;
	case 6:
		m_inputFood = str;
		break;
	case 7:
		m_inputRecruitTime = str;
		break;
	case 8:
		m_inputRecruitTime_2 = str;
		break;
	case 9:
		crArgumentParser::appAtoVec(str,m_copperColor);
		break;
	case 10:
		m_recruitcount = str;
		break;
	default:
		break;
	}
}

void crJXJAutoMakeEquipsMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		bool result = false;
		int equipmakecount = -1;
		int recruitcountnum = 0;
		//int moneyinput = 0;
		//int foodinput = 0;
		int timeneed = 0;
		int querysuccess = -1;
		RecruitCheckResult recruitCheck;
		crTableIO::StrVec record,record2;
		std::string name;
		crData *data2 = playerData->getDataClass();
		ref_ptr<crCanvasNode>canvas = m_this -> getParentCanvas();
		ref_ptr<crTableIO>equipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
		ref_ptr<crTableIO>troopTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
		if (canvas.valid() && equipTab.valid())
		{
			crData *data = crBrain::getInstance()->getDataClass();
			ref_ptr<crStaticTextWidgetNode> inputneed = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_inputneed));
			ref_ptr<crStaticTextWidgetNode> recruitcount = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_recruitcount));
			if (recruitcount.valid())
			{
				recruitcountnum = atoi(recruitcount->getUTF8String().c_str());
			}
			//if (inputmoney.valid())
			//{
			//	moneyinput = atoi(inputmoney->getUTF8String().c_str());
			//}
			//if (inputfood.valid())
			//{
			//	foodinput = atoi(inputfood->getUTF8String().c_str());
			//}
			if (data && inputneed.valid())
			{
				int equipgot = 0;
				int equipneed = 0;
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJCurSelRecruitArmAID,param);
				int curArmID = *(int *)param;
				if (troopTab.valid() && curArmID>0)
				{
					if (troopTab->queryOneRecord(0,crArgumentParser::appItoa(curArmID),record2) >= 0)
					{
						name = record2[troopTab->getTitleIndex("name")];
						equipneed = atoi(record2[troopTab->getTitleIndex("装备数量")].c_str()) * recruitcountnum;
					}
				}
				playerData->doEvent(WCH_JXJRecruitCheck,MAKECREPARAM(curArmID,&recruitCheck));
				timeneed = (int)(recruitCheck.m_timeNeed * (float)recruitcountnum);
				unsigned short equipid = recruitCheck.m_equipid;
				if(equipid>0)
				{
					////////////////////////////////////////////////
					querysuccess = equipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record);
					if(querysuccess >= 0 && data2)
					{
						data2->getParam(WCHDATA_JXJTroopsEquipMap,param);
						TroopsEquipMap *equipMap = (TroopsEquipMap *)param;
						data->inputParam(WCHDATA_JXJEquipID,&equipid);
						TroopsEquipMap::iterator itr = equipMap->find(recruitCheck.m_equipid);
						if(itr != equipMap->end())
						{
							equipgot = itr->second;
						}
					}
				}
				if (equipneed == 0)
				{
					equipmakecount = 0;
					data->inputParam(WCHDATA_JXJAutoMakeEquipCount,&equipmakecount);
					result = true;
				}
				else if(equipgot >= 0 && equipneed > 0)
				{
					equipmakecount = equipneed - equipgot;
					if (equipmakecount > 0)
					{
						data->inputParam(WCHDATA_JXJAutoMakeEquipCount,&equipmakecount);
						result = true;
					}
					else
					{
						equipmakecount = 0;
						data->inputParam(WCHDATA_JXJAutoMakeEquipCount,&equipmakecount);
						result = true;
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		if(result && data2)
		{
			if (querysuccess >= 0 && equipmakecount >= 0)
			{
				int needresource[5];
				int copperid = equipTab->getTitleIndex("铜钱");
				int woodid = equipTab->getTitleIndex("木材");
				int ironid = equipTab->getTitleIndex("铁矿");
				int horseid = equipTab->getTitleIndex("马匹");
				int foodid = equipTab->getTitleIndex("粮食");
				needresource[0] = ceil(atof(record[copperid].c_str()) * equipmakecount + recruitCheck.m_needresourcevec[T_Copper - T_Food] * recruitcountnum);//铜钱
				needresource[1] = ceil(atof(record[woodid].c_str()) * equipmakecount + recruitCheck.m_needresourcevec[T_Wood - T_Food] * recruitcountnum);//木材;
				needresource[2] = ceil(atof(record[ironid].c_str()) * equipmakecount + recruitCheck.m_needresourcevec[T_Iron - T_Food] * recruitcountnum);//铁矿;
				needresource[3] = ceil(atof(record[horseid].c_str()) * equipmakecount + recruitCheck.m_needresourcevec[T_Horse - T_Food] * recruitcountnum);//马匹;
				needresource[4] = ceil(atof(record[foodid].c_str()) * equipmakecount + +recruitCheck.m_needresourcevec[T_Food - T_Food] * recruitcountnum);//粮食;
				ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
				if (msgCanvas.valid())
				{
					ref_ptr<crStaticTextWidgetNode> inputMoneyText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputMoney));
					ref_ptr<crStaticTextWidgetNode> inputWoodText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputWood));
					ref_ptr<crStaticTextWidgetNode> inputIronText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputIron));
					ref_ptr<crStaticTextWidgetNode> inputHorseText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputHorse));
					ref_ptr<crStaticTextWidgetNode> inputFoodText = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_inputFood));
					ref_ptr<crHypertextWidgetNode> inputRecruitTime = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_inputRecruitTime));
					ref_ptr<crHypertextWidgetNode> inputRecruitTime_2 = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_inputRecruitTime_2));
					//ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
					//ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
					//ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
					//if(title)title->setString(L"打造装备提示");

					//char tmpText[160],tmpText2[80];
					char tmpText2[80];
					//char tmpText3[80];
					int	hour = timeneed / 3600;
					int t = timeneed % 3600;
					int minute = t / 60;
					int s = t % 60;
					bool btnenable = true;
					//sprintf(tmpText,"%d铜钱,%d木材,%d铁矿,%d马匹,%d粮食\0",copperneed,woodneed,ironneed,horseneed,foodneed);
					std::string tmpText[5];
					if(needresource[0]>=0) tmpText[0] = crArgumentParser::appItoa(needresource[0])/* + std::string("铜钱")*/;
					if(needresource[1]>=0) tmpText[1] = crArgumentParser::appItoa(needresource[1])/* + std::string("木材")*/;
					if(needresource[2]>=0) tmpText[2] = crArgumentParser::appItoa(needresource[2])/* + std::string("铁矿")*/;
					if(needresource[3]>=0) tmpText[3] = crArgumentParser::appItoa(needresource[3])/* + std::string("马匹")*/;
					if(needresource[4]>=0) tmpText[4] = crArgumentParser::appItoa(needresource[4])/* + std::string("粮食")*/;
					////////////////////////////////////////////////////////////////////
					if (inputMoneyText.valid() && inputWoodText.valid() && inputIronText.valid() && inputHorseText.valid() &&  inputFoodText.valid())
					{
						inputMoneyText->setString(tmpText[0]);
						inputWoodText->setString(tmpText[1]);
						inputIronText->setString(tmpText[2]);
						inputHorseText->setString(tmpText[3]);
						inputFoodText->setString(tmpText[4]);
					}
					if (inputRecruitTime.valid())
					{
						std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");

						cfg_script.Add("Content");
						cfg_script.Push("Content");
						cfg_script.Add("Text","您确认要花费");
						cfg_script.Pop();

						cfg_script.Pop();
						inputRecruitTime->setHypertext(cfg_script);
					}
					if (inputRecruitTime_2.valid())
					{
						std::string strInfo;
						std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");

						cfg_script.Add("Content");
						cfg_script.Push("Content");
						sprintf(tmpText2,"耗时%d小时%d分%d秒招募",hour,minute,s);
						cfg_script.Add("Text",std::string(tmpText2));
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content",2);
						v_i.clear();
						v_i.push_back(0.0f);
						v_i.push_back(153.0f);
						v_i.push_back(0.0f);
						v_i.push_back(255.0f);
						cfg_script.Add("Color",v_i);
						strInfo=crArgumentParser::appItoa(recruitcountnum);
						cfg_script.Add("Text",strInfo);
						cfg_script.Pop();

						cfg_script.Add("Content");
						cfg_script.Push("Content",3);
						memset(tmpText2,0,sizeof(tmpText2));
						sprintf(tmpText2,"【%s】吗？\0",name.c_str());
						cfg_script.Add("Text",std::string(tmpText2));
						cfg_script.Pop();


						cfg_script.Pop();
						inputRecruitTime_2->setHypertext(cfg_script);
					}
					crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
// 					////////////////////////////////////////////////////////////////////
// 					int myresource[5];
// 					data2->getParam(WCHDATA_JXJCoppercash,param);
// 					myresource[0] = *(int *)param;
// 					data2->getParam(WCHDATA_JXJWood,param);
// 					myresource[1] = *(int *)param;
// 					data2->getParam(WCHDATA_JXJIron,param);
// 					myresource[2] = *(int *)param;
// 					data2->getParam(WCHDATA_JXJHorse,param);
// 					myresource[3] = *(int *)param;
// 					data2->getParam(WCHDATA_JXJFood,param);
// 					myresource[4] = *(int *)param;
// 					/////////////////////////////////////
// 					int ntext = 1;
// 					std::vector<float>v_i;
// 					ItemMap itemMap;
// 					rcfg::ConfigScript cfg_script(&itemMap);
// 					crVector4f nowcolor;
// 					cfg_script.Add("Hypertext");
// 					cfg_script.Push("Hypertext");
// 					cfg_script.Add("Content");
// 					cfg_script.Push("Content",ntext++);
// 					cfg_script.Add("Text","您确认要花费");
// 					cfg_script.Pop();
// 
// 					for (int ii = 0; ii < 5; ii++)
// 					{
// 						if(tmpText[ii].empty()) continue;
// 						cfg_script.Add("Content");
// 						cfg_script.Push("Content",ntext++);
// 						v_i.clear();
// 						if (myresource[ii] >= needresource[ii])
// 						{
// 							nowcolor = m_copperColor;
// 						}
// 						else
// 						{
// 							nowcolor = COLOR_RED;
// 							btnenable = false;
// 						}
// 						for (int i = 0;i < 4; i++)
// 						{
// 							v_i.push_back(nowcolor[i]);
// 						}
// 						cfg_script.Add("Color",v_i);
// 
// 						cfg_script.Add("Text",tmpText[ii]);
// 						cfg_script.Pop();
// 					}
// 					cfg_script.Add("Content");
// 					cfg_script.Push("Content",ntext++);
// 					sprintf(tmpText2,"耗时%d小时%d分%d秒\0",hour,minute,s);
// 					cfg_script.Add("Text",tmpText2);
// 					cfg_script.Pop();
// 				
// 					cfg_script.Add("Content");
// 					cfg_script.Push("Content",ntext++);
// 					sprintf(tmpText3,"招募%d【%s】吗？\0",recruitcountnum,name.c_str());
// 					cfg_script.Add("Text",tmpText3);
// 					cfg_script.Pop();
// 
// 					cfg_script.Pop();
// 					//cfg_script.Write("1111111111.cfg");
// 					if(msg.valid())msg->setHypertext(cfg_script);
// 
// 					if(okBtn.valid())okBtn->setEnable(btnenable);
// 					crData *dlgData = msgCanvas->getDataClass();
// 					int commandtype = CDP_Widget;
// 					dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
// 					dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
//					crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIAutoMakeTroopsEquipMethod
//
/////////////////////////////////////////
crJXJUIAutoMakeTroopsEquipMethod::crJXJUIAutoMakeTroopsEquipMethod():
	m_this(NULL)
{
}
crJXJUIAutoMakeTroopsEquipMethod::crJXJUIAutoMakeTroopsEquipMethod(const crJXJUIAutoMakeTroopsEquipMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJUIAutoMakeTroopsEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIAutoMakeTroopsEquipMethod::addParam(int i, const std::string& str)
{
}
void crJXJUIAutoMakeTroopsEquipMethod::operator()(crHandle &handle)
{
	bool cancelTask = true;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if(myPlayer && netConductor)
	{
		crData *data = crBrain::getInstance()->getDataClass();
		if(data)
		{
			ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
			void *param;
			crTableIO::StrVec record;
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJEquipID,param);
			unsigned short equipID = *(unsigned short *)param;
			data->getParam(WCHDATA_JXJAutoMakeEquipCount,param);
			int makecount= *(int *)param;
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
			if(equipID>0  && troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(equipID),record) >= 0 )
			{
				if(makecount>0)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(6);
					stream->_writeUShort(equipID);
					stream->_writeInt(makecount);
					cancelTask = false;
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvMakeTroopsEquip,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				else if(makecount == 0)
				{
					cancelTask = false;
				}
			}
			else
			{
				myPlayer->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2052,NULL));//装备出错
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJSetJiangkaOpenCanvasMethod
//
/////////////////////////////////////////
crJXJSetJiangkaOpenCanvasMethod::crJXJSetJiangkaOpenCanvasMethod():
	m_this(NULL)
{
}
crJXJSetJiangkaOpenCanvasMethod::crJXJSetJiangkaOpenCanvasMethod(const crJXJSetJiangkaOpenCanvasMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_canvas2(handle.m_canvas2),
	m_radio1(handle.m_radio1),
	m_radio2(handle.m_radio2),
	m_radio3(handle.m_radio3),
	m_formcanvas(handle.m_formcanvas),
	m_orangeaddstarcanvas(handle.m_orangeaddstarcanvas),
	m_this(NULL)
{
}
void crJXJSetJiangkaOpenCanvasMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJSetJiangkaOpenCanvasMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_canvas2 = str;
		break;
	case 2:
		m_radio1 = str;
		break;
	case 3:
		m_radio2 = str;
		break;
	case 4:
		m_radio3 = str;
		break;
	case 5:
		m_formcanvas = str;
		break;
	case 6:
		m_orangeaddstarcanvas = str;
		break;
	}
}
void crJXJSetJiangkaOpenCanvasMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		void *param;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crCanvasNode>canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		ref_ptr<crCanvasNode>canvas3 = crFilterRenderManager::getInstance()->findCanvas(m_canvas2);
		ref_ptr<crCanvasNode>orangeaddstarcanvas = crFilterRenderManager::getInstance()->findCanvas(m_orangeaddstarcanvas);
		ref_ptr<crCanvasNode>formcanvas = crFilterRenderManager::getInstance()->findCanvas(m_formcanvas);
		ref_ptr<crRadioGroupWidgetNode> radio1 = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio1));
		ref_ptr<crRadioGroupWidgetNode> radio2 = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio2));
		ref_ptr<crRadioGroupWidgetNode> radio3 = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radio3));
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->getParam(WCHDATA_JXJSaleBagVec,param);
		JXJItemBagVec *salebagvec = (JXJItemBagVec *)param;
		if(canvas.valid() && canvas2.valid() && canvas3.valid() && formcanvas.valid()) 
		{
			if(radio3.valid())
			{
				crBoundingBox bbox = canvas->getBoundBox();
				crBoundingBox bbox2 = canvas2->getBoundBox();
				crBoundingBox bbox3 = canvas3->getBoundBox();
				switch (radio3->getSelect())
				{
				case JKBT_Jiangka:
					if (!formcanvas->getVisiable())
					{
						canvas->setMatrix(crMatrix::translate(0,0,0.0f));
					}
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);

					//braindata
					salebagvec->clear();
					break;
				case JKBT_Upgrade:
					canvas->setMatrix(crMatrix::translate(-0.3,0,0.0f));
					bbox = canvas->getBoundBox();
					if (formcanvas->getVisiable())
					{
						crFilterRenderManager::getInstance()->showCanvas(formcanvas.get(), 0);;
					}
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);

					/////////////////
					canvas2->setMatrix(crMatrix::translate(bbox.m_max[0] + 0.5*(bbox2.m_max[0] - bbox2.m_min[0]),0,0.0f));
					if(orangeaddstarcanvas.valid())orangeaddstarcanvas->setMatrix(crMatrix::translate(bbox.m_max[0] + 0.5*(bbox2.m_max[0] - bbox2.m_min[0]),0,0.0f));
					break;
				case JKBT_Sell:
					canvas->setMatrix(crMatrix::translate(-0.3,0,0.0f));
					bbox = canvas->getBoundBox();
					if (formcanvas->getVisiable())
					{
						crFilterRenderManager::getInstance()->showCanvas(formcanvas.get(), 0);;
					}
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);

					//braindata
					salebagvec->clear();
					/////////////////
					canvas3->setMatrix(crMatrix::translate(bbox.m_max[0] + 0.5*(bbox3.m_max[0] - bbox3.m_min[0]),0,0.0f));
					break;
				default:
					break;
				}
			}
		}
	}
}

///////////////////////////////////////////
////
////crJXJSetInviteTypeMethod
////
///////////////////////////////////////////
//crJXJSetInviteTypeMethod::crJXJSetInviteTypeMethod():
//	m_invitetype(0)
//{
//}
//crJXJSetInviteTypeMethod::crJXJSetInviteTypeMethod(const crJXJSetInviteTypeMethod& handle):
//	crMethod(handle),
//	m_invitetype(handle.m_invitetype)
//{
//}
//void crJXJSetInviteTypeMethod::inputParam(int i, void *param)
//{
//}
//void crJXJSetInviteTypeMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_invitetype = atoi(str.c_str());
//		break;
//	}
//}
//void crJXJSetInviteTypeMethod::operator()(crHandle &handle)
//{
//	crData *data = crBrain::getInstance()->getDataClass();
//	if (data)
//	{
//		data->excHandle(MAKECREPARAM(WCH_LockData,1));
//		data->inputParam(WCHDATA_JXJCurInviteType,&m_invitetype);
//		data->excHandle(MAKECREPARAM(WCH_LockData,0));
//	}
//}

/////////////////////////////////////////
//
//crJXJSetCityFlagMethod
//
/////////////////////////////////////////
crJXJSetCityFlagMethod::crJXJSetCityFlagMethod()
{
}
crJXJSetCityFlagMethod::crJXJSetCityFlagMethod(const crJXJSetCityFlagMethod& handle):
	crMethod(handle),
	m_flagname(handle.m_flagname),
	m_weiflag(handle.m_weiflag),
	m_shuflag(handle.m_shuflag),
	m_wuflag(handle.m_wuflag),
	m_qunflag(handle.m_qunflag)
{
}
void crJXJSetCityFlagMethod::inputParam(int i, void *param)
{
}
void crJXJSetCityFlagMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_flagname = str;
		break;
	case 1:
		m_weiflag = str;
		break;
	case 2:
		m_shuflag = str;
		break;
	case 3:
		m_wuflag = str;
		break;
	case 4:
		m_qunflag = str;
		break;
	}
}
void crJXJSetCityFlagMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	crRoom *room = crMyPlayerData::getInstance()->getSelectedRoom();
	if(playerData&&room&&room->getDataClass())
	{
		//////////////////////////////
		void *param;
		crGroup *root = crSceneManager::getInstance()->getStaticRoot();
		if(root)
		{
			crData *data = playerData->getDataClass();
			data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			unsigned char type = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
			unsigned short selectID = *(unsigned short *)param;
			data->getParam(WCHDATA_JXJChengChiMap,param);
			ChengchiMap *mapcity = (ChengchiMap *)param;
			if (type == FT_Chengchi && mapcity->size() > 0 && selectID > 0)
			{
				crData *roomData = room->getDataClass();
				roomData->getParam(WCHDATA_JXJBattleID,param);
				_crInt32 battleid = *(_crInt32 *)param;
				//unsigned char ashili = LOINT16(LOINT32(battleid));
				unsigned char dshili = HIINT16(LOINT32(battleid));//(*chengchimap)[chengchiid]->getChengzhuShili();
				//unsigned char shiliid = 0;
				// filter my side city
				//for( ChengchiMap::iterator itr = mapcity->begin(); itr != mapcity->end(); ++itr)
				//{
				//	if(itr->first == selectID)
				//	{
				//		shiliid = itr->second->getChengzhuShili();
				//		break;
				//	}
				//}
				//ChengchiMap::iterator itr = mapcity->find(selectID);
				//if(itr != mapcity->end())
				//{
				//	shiliid = itr->second->getChengzhuShili();
				//}
				if (dshili > 0)
				{
					unsigned char activechildindex = dshili - c_startShiliID;

					crCollectNodeBYNameVisitor collector(CRCore::OBJECT);
					collector.insertNodeNameId(m_flagname);
					root->accept(collector);
					NodeArray &nodeArray = collector.getResult();
					if(!nodeArray.empty())
					{
						crObject *obj;
						std::set<crStateSet *>ssset;
						for( NodeArray::iterator itr = nodeArray.begin();
							itr != nodeArray.end();
							++itr )
						{
							obj = dynamic_cast<crObject *>(itr->get());
							//ssset.insert(obj->getDrawable(0)->getStateSet());
							ssset.insert(obj->getOrCreateStateSet());
						}
						//crTexture2D *tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));

						//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
						std::string iconfile1 = m_qunflag;
						switch (activechildindex)
						{
						case 0:
							iconfile1 = m_weiflag;
							break;
						case 1:
							iconfile1 = m_shuflag;
							break;
						case 2:
							iconfile1 = m_wuflag;
							break;
						}
						ref_ptr<crTexture2D> tex2d = new crTexture2D;
						for( std::set<crStateSet *>::iterator itr = ssset.begin();
							itr != ssset.end();
							++itr )
						{
							tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
							tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
							tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
							tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d.get()));
							(*itr)->setTextureAttributeAndModes(0,tex2d.get(),crStateAttribute::ON|crStateAttribute::OVERRIDE);
						}
					}
					collector.reset();
					collector.setSearchNodeType(CRCore::MULTISWITCH);
					collector.insertNodeNameId(m_flagname);
					root->accept(collector);
					NodeArray &swArray = collector.getResult();
					if(!swArray.empty())
					{
						crMultiSwitch *swNode;
						for( NodeArray::iterator itr = swArray.begin();
							 itr != swArray.end();
							 ++itr )
						{
							swNode = dynamic_cast<crMultiSwitch *>(itr->get());
							switch (activechildindex)
							{
							case 0:
								swNode->setActiveSwitchSet(1);
								break;
							case 1:
								swNode->setActiveSwitchSet(2);
								break;
							case 2:
								swNode->setActiveSwitchSet(3);
								break;
							default:
								swNode->setActiveSwitchSet(0);
								break;
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetBarrackFlagMethod
//
/////////////////////////////////////////
crJXJSetBarrackFlagMethod::crJXJSetBarrackFlagMethod()
{
}
crJXJSetBarrackFlagMethod::crJXJSetBarrackFlagMethod(const crJXJSetBarrackFlagMethod& handle):
	crMethod(handle),
	m_flagname(handle.m_flagname),
	m_weiflag(handle.m_weiflag),
	m_shuflag(handle.m_shuflag),
	m_wuflag(handle.m_wuflag)
{
}
void crJXJSetBarrackFlagMethod::inputParam(int i, void *param)
{
}
void crJXJSetBarrackFlagMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_flagname = str;
		break;
	case 1:
		m_weiflag = str;
		break;
	case 2:
		m_shuflag = str;
		break;
	case 3:
		m_wuflag = str;
		break;
	}
}
void crJXJSetBarrackFlagMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	void *param;
	crData *gameData = playerGameData->getDataClass();
	gameData->getParam(WCHDATA_JXJBattleRoomID,param);
	_crInt64 battleroomid = *(_crInt64 *)param;
	int battleid = LOINT64(battleroomid);
	unsigned char offenseShiliid = (unsigned char)(LOINT16(LOINT32(battleid)));

	if(offenseShiliid > 0)
	{
		crGroup *root = crSceneManager::getInstance()->getStaticRoot();
		if (root)
		{
			crCollectNodeBYNameVisitor collector(CRCore::OBJECT);
			collector.insertNodeNameId(m_flagname);
			root->accept(collector);
			NodeArray &nodeArray = collector.getResult();
			if(nodeArray.empty())
			{
				return;
			}
			crObject *obj;
			std::set<crStateSet *>ssset;
			for( NodeArray::iterator itr = nodeArray.begin();
				itr != nodeArray.end();
				++itr )
			{
				obj = dynamic_cast<crObject *>(itr->get());
				//ssset.insert(obj->getDrawable(0)->getStateSet());
				ssset.insert(obj->getOrCreateStateSet());
			}
			//crTexture2D *tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));

			//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
			unsigned char activechildindex = offenseShiliid - c_startShiliID;
			std::string iconfile1;
			switch (activechildindex)
			{
			case 0:
				iconfile1 = m_weiflag;
				break;
			case 1:
				iconfile1 = m_shuflag;
				break;
			case 2:
				iconfile1 = m_wuflag;
				break;
			}
			ref_ptr<crTexture2D> tex2d = new crTexture2D;
			for( std::set<crStateSet *>::iterator itr = ssset.begin();
				itr != ssset.end();
				++itr )
			{
				tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
				tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
				tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
				tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
				tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d.get()));
				(*itr)->setTextureAttributeAndModes(0,tex2d.get(),crStateAttribute::ON|crStateAttribute::OVERRIDE);
			}
			/*if(tex2d)
			{
			if(tex2d->getImageNameID().compare(iconfile1)!=0)
			tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
			}
			else
			{
			tex2d = new crTexture2D;
			tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
			tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
			tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
			tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
			tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
			tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
			ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
			}*/
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGongfangEquipWalkMethod
//
/////////////////////////////////////////
crJXJUIGongfangEquipWalkMethod::crJXJUIGongfangEquipWalkMethod():
	m_this(NULL),
	m_step(1)
{
}
crJXJUIGongfangEquipWalkMethod::crJXJUIGongfangEquipWalkMethod(const crJXJUIGongfangEquipWalkMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_step(handle.m_step),
	m_makeequiptype(handle.m_makeequiptype),
	m_equiptype(handle.m_equiptype),
	m_equiplevel(handle.m_equiplevel)
{
}
void crJXJUIGongfangEquipWalkMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIGongfangEquipWalkMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = atoi(str.c_str());
		break;
	case 1:
		m_makeequiptype = str;
		break;
	case 2:
		m_equiptype = str;
		break;
	case 3:
		m_equiplevel = str;
		break;
	}
}
void crJXJUIGongfangEquipWalkMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crRadioGroupWidgetNode> makeequiptype = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_makeequiptype));
		ref_ptr<crRadioGroupWidgetNode> equiptype = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_equiptype));
		ref_ptr<crRadioGroupWidgetNode> equiplevel = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_equiplevel));
		ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
		ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		ref_ptr<crTableIO>lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		if(troopsTab.valid() && itemTab.valid() && lordEquipTab.valid())
		{
			int armtype;
			int armCount = 0;
			int currentSelectArmType = 0;
			int rowCount = 0;
			int canrecruittype;
			void *param;
			crData *data = crBrain::getInstance()->getDataClass();
			if (makeequiptype->getSelect() == 0)
			{
				currentSelectArmType = equiptype->getSelect();
				rowCount = troopsTab->getRowCount();
				int armtypeid = troopsTab -> getTitleIndex("兵种");
				int canrecruitid = troopsTab -> getTitleIndex("可招募");
				for( int i = 0; i<rowCount; i++)
				{
					armtype = atoi((*troopsTab)(i,armtypeid).c_str());
					canrecruittype = atoi((*troopsTab)(i,canrecruitid).c_str());
					if (canrecruittype == 1 && armtype == currentSelectArmType)
					{
						armCount++;
					}
				}
			}
			else if (makeequiptype->getSelect() == 1)
			{
				//currentSelectArmType = equiplevel->getSelect();
				//rowCount = itemTab->getRowCount();
				//int levelid = itemTab -> getTitleIndex("等级");
				//for( int i = 0; i<rowCount; i++)
				//{
				//	armtype = atoi((*itemTab)(i,levelid).c_str());
				//	if(armtype == currentSelectArmType)
				//	{
				//		armCount++;
				//	}
				//}
				data->getParam(WCHDATA_JXJGongfangLordPaperCount,param);
				armCount = *(int *)param;
			}
			data->getParam(WCHDATA_JXJCurForgeEquipID,param);
			int* curArmID = (int *)param;
			int tryID = *curArmID + m_step;
			if(tryID<0)
				*curArmID = 0;
			else if(tryID < armCount)
				*curArmID = tryID;
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGongfangEquipResetMethod
//
/////////////////////////////////////////
crJXJUIGongfangEquipResetMethod::crJXJUIGongfangEquipResetMethod()
{
}
crJXJUIGongfangEquipResetMethod::crJXJUIGongfangEquipResetMethod(const crJXJUIGongfangEquipResetMethod& handle):
	crMethod(handle)
{
}
void crJXJUIGongfangEquipResetMethod::inputParam(int i, void *param)
{
}
void crJXJUIGongfangEquipResetMethod::addParam(int i, const std::string& str)
{
}
void crJXJUIGongfangEquipResetMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = crBrain::getInstance()->getDataClass();
	data->getParam(WCHDATA_JXJCurForgeEquipID,param);
	int* curArmID = (int *)param;
	*curArmID = 0;
}
/////////////////////////////////////////
//
//crJXJUIGongfangEquipUpdateMethod
//
/////////////////////////////////////////
crJXJUIGongfangEquipUpdateMethod::crJXJUIGongfangEquipUpdateMethod()
{
}
crJXJUIGongfangEquipUpdateMethod::crJXJUIGongfangEquipUpdateMethod(const crJXJUIGongfangEquipUpdateMethod& handle):
	crMethod(handle),
	m_ForgeTypeRadio(handle.m_ForgeTypeRadio),
	m_EquipRadio(handle.m_EquipRadio),
	m_ArmyEquipRadio(handle.m_ArmyEquipRadio),
	m_LordEquipRadio(handle.m_LordEquipRadio),
	m_armUp(handle.m_armUp),
	m_armDown(handle.m_armDown),
	m_pagenum(handle.m_pagenum)
{
}
void crJXJUIGongfangEquipUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIGongfangEquipUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_ForgeTypeRadio = str;
		break;
	case 1:
		m_EquipRadio = str;
		break;
	case 2:
		m_ArmyEquipRadio = str;
		break;
	case 3:
		m_LordEquipRadio = str;
		break;
	case 4:
		m_armUp = str;
		break;
	case 5:
		m_armDown = str;
		break;
	case 6:
		m_pagenum = str;
		break;
	}
}
void crJXJUIGongfangEquipUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crRadioGroupWidgetNode> ForgeTypeRadio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_ForgeTypeRadio));
		ref_ptr<crRadioGroupWidgetNode> EquipRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_EquipRadio));
		ref_ptr<crRadioGroupWidgetNode> ArmyEquipRadio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_ArmyEquipRadio));
		ref_ptr<crRadioGroupWidgetNode> LordEquipRadio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_LordEquipRadio));
		ref_ptr<crStaticTextWidgetNode> pagenum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
		ref_ptr<crButtonWidgetNode> armUp = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_armUp));
		ref_ptr<crButtonWidgetNode> armDown = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_armDown));
		ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
		ref_ptr<crTableIO>troopsEuipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
		ref_ptr<crTableIO>itemTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		ref_ptr<crTableIO>lordEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
		crData *braindata = crBrain::getInstance()->getDataClass();
		crData *mydata = playerData->getDataClass();
		crData *canvasdata = m_this->getDataClass();
		if(troopsTab.valid() && troopsEuipTab.valid() && itemTab.valid() && lordEquipTab.valid() && ForgeTypeRadio.valid() && braindata && mydata && canvasdata)
		{
			void *param;
			crRadioGroupWidgetNode::RadioGroup&radioGroup = EquipRadioGroup->getRadioGroup();
			if (ForgeTypeRadio->getSelect() == 0)
			{
				int armType = ArmyEquipRadio->getSelect();
				crTableIO::DataVec recordVec;
				crTableIO::StrVec record;
				int armTypeid = troopsTab->getTitleIndex("兵种");
				int equipidid = troopsTab->getTitleIndex("装备ID");
				troopsTab->queryRecords(armTypeid,crArgumentParser::appItoa(armType),recordVec);
				braindata->getParam(WCHDATA_JXJCurForgeEquipID,param);
				int curForgeEquipRow = *(int *)param;
				if(pagenum.valid())pagenum->setString(crArgumentParser::appItoa(curForgeEquipRow/3+1));
				int rowCount = recordVec.size();
				if(armUp.valid())armUp->setEnable(curForgeEquipRow > 0);
				int count = rowCount - radioGroup.size();
				if(armDown.valid())armDown->setEnable(curForgeEquipRow < count);
				std::string iconfile1;
				crMultiSwitch *radioButton;
				crStateSet *ss1;
				crTexture2D *tex2d;
				crRadioGroupWidgetNode::RadioGroup::iterator itr = radioGroup.begin();
				int cursel = EquipRadioGroup->getSelect();
				unsigned short equipid = 0;
				//int abastactid = 0;
				//int selAbastactid = 0;
				unsigned short selequipid = 0;
				int iconid = troopsEuipTab->getTitleIndex("icon");
				int iconid1 = troopsEuipTab->getTitleIndex("icon灰");
				int moneyid = troopsEuipTab->getTitleIndex("铜钱");
				int woodid = troopsEuipTab->getTitleIndex("木材");
				int ironid = troopsEuipTab->getTitleIndex("铁矿");
				int horseid = troopsEuipTab->getTitleIndex("马匹");
				int foodid = troopsEuipTab->getTitleIndex("粮食");
				mydata->getParam(WCHDATA_JXJCoppercash,param);
				int mymoney = *(int *)param;
				mydata->getParam(WCHDATA_JXJWood,param);
				int mywood = *(int *)param;
				mydata->getParam(WCHDATA_JXJIron,param);
				int myiron = *(int *)param;
				mydata->getParam(WCHDATA_JXJHorse,param);
				int myhorse = *(int *)param;
				mydata->getParam(WCHDATA_JXJFood,param);
				int myfood = *(int *)param;
				int row = curForgeEquipRow;
				bool forgeresult = true;
				std::vector<int> DisableRowVec;
				int i = 0;
				for( ; row<rowCount && itr != radioGroup.end(); ++row)
				{
					equipid = atoi(recordVec[row][equipidid].c_str());
					if (troopsEuipTab->queryOneRecord(0,crArgumentParser::appItoa(equipid),record) >= 0)
					{
						if (atoi(record[moneyid].c_str())>mymoney
							||atoi(record[woodid].c_str())>mywood
							||atoi(record[ironid].c_str())>myiron
							||atoi(record[horseid].c_str())>myhorse
							||atoi(record[foodid].c_str())>myhorse)
						{
							forgeresult = false;
						}
						if(!forgeresult)
						{
							DisableRowVec.push_back(row);
							continue;
						}
						if(cursel == i)
							selequipid = equipid;
						iconfile1 = record[iconid];

						radioButton = itr->second->getButton();
						radioButton->setVisiable(true);
						ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

						tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
						if(tex2d)
						{
							if(tex2d->getImageNameID().compare(iconfile1)!=0)
								tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
						}
						else
						{
							tex2d = new crTexture2D;
							tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
							tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
							tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
							tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
							ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
						}
						++itr;
						++i;
					}
				}
				if(i<radioGroup.size())
				{
					if(!DisableRowVec.empty())
					{
						for( int j = 0;
							itr != radioGroup.end() && j<DisableRowVec.size();
							++itr,++j )
						{
							row = DisableRowVec[j];
							equipid = atoi(recordVec[row][0].c_str());
							if(cursel == i)
								selequipid = equipid;
							iconfile1 = record[iconid1];
							radioButton = itr->second->getButton();
							radioButton->setVisiable(true);
							ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

							tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
							if(tex2d)
							{
								if(tex2d->getImageNameID().compare(iconfile1)!=0)
									tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
							}
							else
							{
								tex2d = new crTexture2D;
								tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
								tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
								tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
								tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
								tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
								tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
								ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
							}
							++i;
						}
					}
				}
				for( ;
					itr != radioGroup.end();
					++itr )
				{
					radioButton = itr->second->getButton();
					radioButton->setVisiable(false);
				}
				if(i>0) i--;
				if(cursel>i)
				{
					cursel = i;
					EquipRadioGroup->select(i);
					selequipid = equipid;
				}
				canvasdata->inputParam(WCHDATA_JXJCurSelForgeTroopsEquipID,&selequipid);
			}
			else if (ForgeTypeRadio->getSelect() == 1)
			{
				int lordequiplevel = LordEquipRadio->getSelect();
				switch (lordequiplevel)
				{
				case 0:
					lordequiplevel = 2;
					break;
				case 1:
					lordequiplevel = 3;
					break;
				case 2:
					lordequiplevel = 4;
					break;
				case 3:
					lordequiplevel = 5;
					break;
				case 4:
					lordequiplevel = 6;
					break;
				case 5:
					lordequiplevel = 7;
					break;
				case 6:
					break;
				case 7:
					break;
				default:
					break;
				}
				crTableIO::DataVec recordVec;
				crTableIO::StrVec record;
				crTableIO::StrVec record2;
				int equiplevelid = itemTab->getTitleIndex("等级");
				int equiptypeid = itemTab->getTitleIndex("类型");
				itemTab->queryRecords(/*equiplevelid,crArgumentParser::appItoa(lordequiplevel),*/equiptypeid,crArgumentParser::appItoa(IT_Paper),recordVec);
				int itemlv;
				for( crTableIO::DataVec::iterator itr = recordVec.begin();
					 itr != recordVec.end();)
				{
					itemlv = atoi((*itr)[equiplevelid].c_str());
					if (itemlv/10 != lordequiplevel)
					{
						itr = recordVec.erase(itr);
					}
					else
					{
						++itr;
					}
				}
				braindata->getParam(WCHDATA_JXJCurForgeEquipID,param);
				int curForgeEquipRow = *(int *)param;
				if(pagenum.valid())pagenum->setString(crArgumentParser::appItoa(curForgeEquipRow/3+1));
				int rowCount = recordVec.size();
				std::string iconfile1;
				crMultiSwitch *radioButton;
				crStateSet *ss1;
				crTexture2D *tex2d;
				crRadioGroupWidgetNode::RadioGroup::iterator itr = radioGroup.begin();
				int cursel = EquipRadioGroup->getSelect();
				int equipid = 0;
				//int abastactid = 0;
				//int selAbastactid = 0;
				int selequipid = 0;
				int iconid = itemTab->getTitleIndex("icon");
				int iconid1 = itemTab->getTitleIndex("icon灰");
				int picid = lordEquipTab->getTitleIndex("图纸");
				int row = 0;
				std::vector<int> DisableRowVec;
				int i = 0;
				int papercount = 0;
				int tuzhiid = 0;
				mydata->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				canvasdata->getParam(WCHDATA_JXJGongFangTuZhiVec,param);
				GongFangTuZhiVec *tuZhiVec = (GongFangTuZhiVec *)param;
				tuZhiVec->clear();
				for( ; row<rowCount && itr != radioGroup.end(); ++row)
				{
					bool result = false;
					radioButton = itr->second->getButton();
					radioButton->setVisiable(false);
					equipid = atoi(recordVec[row][0].c_str());
					if (lordEquipTab->queryOneRecord(picid,crArgumentParser::appItoa(equipid),record) >= 0)
					{
						for (JXJItemBagVec::iterator itr2 = itembagvec->begin();
							itr2 != itembagvec->end();
							++itr2)
						{
							if ((*itr2!=NULL))
							{
								if ((*itr2)->getItemID() == atoi(record[picid].c_str()))
								{
									if ( (*itr2)->getItemCount() > 0 )
									{
										if (papercount >= curForgeEquipRow)
										{
											tuzhiid = atoi(record[picid].c_str());
											result = true;
											break;
										}
										else
										{
											papercount ++;
											break;
										}
									}
								}
							}
						}
						if(!result)
						{
							equipid = 0;
							//DisableRowVec.push_back(row);
							continue;
						}
						if(cursel == i)
							selequipid = equipid;
						iconfile1 = recordVec[row][iconid];

						radioButton->setVisiable(true);
						ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

						tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
						if(tex2d)
						{
							if(tex2d->getImageNameID().compare(iconfile1)!=0)
								tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
						}
						else
						{
							tex2d = new crTexture2D;
							tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
							tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
							tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
							tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
							tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
							ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
						}
						tuZhiVec->push_back(tuzhiid);
						++itr;
						++i;
					}
				}
				//if(i<radioGroup.size())
				//{
				//	if(!DisableRowVec.empty())
				//	{
				//		for( int j = 0;
				//			itr != radioGroup.end() && j<DisableRowVec.size();
				//			++itr,++j )
				//		{
				//			row = DisableRowVec[j];
				//			equipid = atoi(recordVec[row][0].c_str());
				//			if(cursel == i)
				//				selequipid = equipid;
				//			iconfile1 = recordVec[row][iconid1];
				//			radioButton = itr->second->getButton();
				//			radioButton->setVisiable(true);
				//			//ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();
				//			//tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
				//			//if(tex2d)
				//			//{
				//			//	if(tex2d->getImageNameID().compare(iconfile1)!=0)
				//			//		tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				//			//}
				//			//else
				//			//{
				//			//	tex2d = new crTexture2D;
				//			//	tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
				//			//	tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
				//			//	tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
				//			//	tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
				//			//	tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
				//			//	tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
				//			//	ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
				//			//}
				//			++i;
				//		}
				//	}
				//}
				int count = 0;
				for (JXJItemBagVec::iterator itr2 = itembagvec->begin();
					itr2 != itembagvec->end();
					++itr2)
				{
					if ((*itr2!=NULL))
					{
						if (itemTab->queryOneRecord(0,crArgumentParser::appItoa((*itr2)->getItemID()),record2) >= 0 )
						{
							if (atoi(record2[equiplevelid].c_str())/10 == lordequiplevel && atoi(record2[equiptypeid].c_str()) == IT_Paper)
							{
								count++;
							}
						}
					}
				}
				braindata->inputParam(WCHDATA_JXJGongfangLordPaperCount,&count);
				
				if(armUp.valid())armUp->setEnable(curForgeEquipRow > 0);
				count = count - radioGroup.size();
				if(armDown.valid())armDown->setEnable(curForgeEquipRow < count);
				for( ;
					itr != radioGroup.end();
					++itr )
				{
					radioButton = itr->second->getButton();
					radioButton->setVisiable(false);
				}
				if(i>0) i--;
				if(cursel>i)
				{
					cursel = i;
					EquipRadioGroup->select(i);
					selequipid = equipid;
				}
				canvasdata->inputParam(WCHDATA_JXJCurSelForgeLordEquipID,&selequipid);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIEquipListUpdateMethod
//
/////////////////////////////////////////
crJXJUIEquipListUpdateMethod::crJXJUIEquipListUpdateMethod()
{
}
crJXJUIEquipListUpdateMethod::crJXJUIEquipListUpdateMethod(const crJXJUIEquipListUpdateMethod& handle):
	crMethod(handle),
	m_troopsList(handle.m_troopsList),
	m_jinglianBtn(handle.m_jinglianBtn),
	m_fulianBtn(handle.m_fulianBtn),
	m_ronglianBtn(handle.m_ronglianBtn)
{
}
void crJXJUIEquipListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIEquipListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_troopsList = str;
		break;
	case 1:
		m_jinglianBtn = str;
		break;
	case 2:
		m_fulianBtn = str;
		break;
	case 3:
		m_ronglianBtn = str;
		break;
	}
}
void crJXJUIEquipListUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		crData *data = playerData->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		std::map<std::string,int> tempitemmap;
		ref_ptr<crTableIO>troopsTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsEquipTab);
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crVector3i openlv;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGongfangOpenlvVec3i,viplv).c_str(),openlv);
		crTableIO::StrVec record;
		ref_ptr<crTableWidgetNode> troopsList = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_troopsList));
		ref_ptr<crRadioWidgetNode> jinglianBtn = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_jinglianBtn));
		ref_ptr<crRadioWidgetNode> fulianBtn = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_fulianBtn));
		ref_ptr<crRadioWidgetNode> ronglianBtn = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_ronglianBtn));
		data->getParam(WCHDATA_JXJGongfanglv,param);
		unsigned char gongfanglv = *(unsigned char *)param;
		if(jinglianBtn.valid())jinglianBtn->setVisiable(false);
		if(fulianBtn.valid())fulianBtn->setVisiable(false);
		if(ronglianBtn.valid())ronglianBtn->setVisiable(false);

		data->getParam(WCHDATA_JXJSmeltEquipTechLv,param);
		unsigned char SmeltEquipTechLv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJEquipAttachTechLv,param);
		unsigned char EquipAttachTechLv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJEquipRefineTechLv,param);
		unsigned char equipRefineTechLv = *(unsigned char *)param;

		if (/*gongfanglv >= openlv[0]*/equipRefineTechLv>0 && jinglianBtn.valid())	
		{
			jinglianBtn->setVisiable(true);
		}
		if (/*gongfanglv >= openlv[1]*/EquipAttachTechLv>0 && fulianBtn.valid())
		{
			fulianBtn->setVisiable(true);
		}
		if (/*gongfanglv >= openlv[2]*/SmeltEquipTechLv>0 && ronglianBtn.valid())
		{
			ronglianBtn->setVisiable(true);
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		data->getParam(WCHDATA_JXJItemBagVec,param);
		JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
		//data->getParam(WCHDATA_JXJTroopsEquipMap,param);
		//TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
		troopsList->clearData();
		int row = 0;
		int nameindex = itemtab->getTitleIndex("name");
		int typeindex = itemtab->getTitleIndex("类型");
		std::map<std::string,int>::iterator finditr;
		for( JXJItemBagVec::iterator itr = itembagvec->begin();
			itr != itembagvec->end();
			++itr)
		{
			if (itr->get())
			{
				if (itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),record) >= 0 )
				{
					if (atoi(record[typeindex].c_str()) == IT_Material || atoi(record[typeindex].c_str()) == IT_SmeltMaterial)
					{
						finditr = tempitemmap.find(record[nameindex]);
						if (finditr != tempitemmap.end())
						{
							finditr->second += (*itr)->getItemCount();
						}
						else
						{
							tempitemmap.insert(std::make_pair(record[nameindex],(*itr)->getItemCount()));
						}
					}
				}
			}
		}
		for( std::map<std::string,int>::iterator itr = tempitemmap.begin();
			itr != tempitemmap.end();
			++itr)
		{
			troopsList->addData(0,row,itr->first);
			troopsList->addData(1,row,crArgumentParser::appItoa(itr->second));
			row++;
		}
		//for( TroopsEquipMap::iterator itr = troopsEquipMap->begin();
		//	itr != troopsEquipMap->end();
		//	++itr,row++ )
		//{
		//	if (troopsTab->queryOneRecord(0,crArgumentParser::appItoa(itr->first),record) >= 0 )
		//	{
		//		troopsList->addData(0,row,record[1]);
		//		troopsList->addData(1,row,crArgumentParser::appItoa(itr->second));
		//	}
		//}
		//troopsList->selectRow(0);
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUISellCardUpdateMethod
//
/////////////////////////////////////////
crJXJUISellCardUpdateMethod::crJXJUISellCardUpdateMethod()
{
}
crJXJUISellCardUpdateMethod::crJXJUISellCardUpdateMethod(const crJXJUISellCardUpdateMethod& handle):
	crMethod(handle),
	m_cardList(handle.m_cardList),
	m_sellcardbtn(handle.m_sellcardbtn),
	m_jianghun(handle.m_jianghun)
{
	for(int i = 0; i<10; i++)
	{
		m_cardframe[i] = handle.m_cardframe[i];
	}
}
void crJXJUISellCardUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUISellCardUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cardList = str;
		break;
	case 1:
		m_sellcardbtn = str;
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
	case 11:
		m_cardframe[i-2] = str;
		break;
	case 12:
		m_jianghun = str;
		break;
	}
}
void crJXJUISellCardUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		void *param;
		crTableIO::StrVec record;
		ref_ptr<crListControlWidgetNode> cardsaleList = dynamic_cast<crListControlWidgetNode *>(m_this->getWidget(m_cardList));
		ref_ptr<crButtonWidgetNode> sellcardbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_sellcardbtn));
		ref_ptr<crStaticTextWidgetNode> jianghunText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_jianghun));
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		int jianghun = 0;
		//crData *data = playerData->getDataClass();
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
		braindata->getParam(WCHDATA_JXJSaleBagVec,param);
		JXJItemBagVec *salebagvec = (JXJItemBagVec *)param;
		if (sellcardbtn.valid())
		{
			sellcardbtn->setEnable(false);
		}
		if (cardsaleList.valid())
		{
			cardsaleList->clearList();
			if (salebagvec->size()>0)
			{
				sellcardbtn->setEnable(true);
				braindata->getParam(WCHDATA_JXJCurSaleCardPageNum,param);
				int curpage = *(int *)param;
				cardsaleList->setListNodeCount(salebagvec->size());
				cardsaleList->setStartYPos(curpage - 1);
				crListControlWidgetNode::ListNodeVec& listNodeVec = cardsaleList->getListNodeVec();
				int i = 0;
				int iconid = itemtab->getTitleIndex("miniicon");
				int color = itemtab->getTitleIndex("品质");
				int priceid = itemtab->getTitleIndex("回收价格");
				int cardcolor = 0;
				for (JXJItemBagVec::iterator itr = salebagvec->begin();
					itr!=salebagvec->end();
					++itr,i++)
				{
					if ((*itr)!=NULL)
					{
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),record) >= 0 )
						{
							cardcolor = atoi(record[color].c_str());
							//if (cardcolor > CardColor_Orange)
							//{
							//	cardcolor = CardColor_Orange;
							//}
							jianghun += atoi(record[priceid].c_str());
							listNodeVec[i]->setData((*itr)->getItemID());
							listNodeVec[i]->setImageName(record[iconid]);
							listNodeVec[i]->setImageName(m_cardframe[cardcolor],1);
							listNodeVec[i]->setVisiable(true);
						}
					}

				}
			}
		}
		braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
		if(jianghunText.valid())
		{
			jianghunText->setString(crArgumentParser::appItoa(jianghun));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISellOneJiangkaMethod
//
/////////////////////////////////////////
crJXJUISellOneJiangkaMethod::crJXJUISellOneJiangkaMethod()
{
}
crJXJUISellOneJiangkaMethod::crJXJUISellOneJiangkaMethod(const crJXJUISellOneJiangkaMethod& handle):
	crMethod(handle),
	m_cardType(handle.m_cardType),
	m_cardList(handle.m_cardList),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
	// m_sellCanvas(handle.m_sellCanvas),
	// m_sellList(handle.m_sellList)
{
}
void crJXJUISellOneJiangkaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISellOneJiangkaMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cardType = str;
		break;
	case 1:
		m_cardList = str;
		break;
	case 2:
		m_tipcanvas = str;
		break;
	case 3:
		m_tiptitle = str;
		break;
	case 4:
		m_tipcontent = str;
		break;
	//case 2:
	//	m_sellCanvas = str;
	//	break;
	//case 3:
	//	m_sellList = str;
	//	break;
	}
}
void crJXJUISellOneJiangkaMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		crTableIO::StrVec record;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			ref_ptr<crRadioGroupWidgetNode> cardType = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_cardType));
			ref_ptr<crListControlWidgetNode> cardsaleList = dynamic_cast<crListControlWidgetNode *>(canvas->getWidget(m_cardList));
			crData *canvasdata = canvas->getDataClass();
			//	ref_ptr<crCanvasNode>sellCanvas = dynamic_cast<ref_ptr<crCanvasNode>>(crFilterRenderManager::getInstance()->findCanvas(m_sellCanvas));
			//	ref_ptr<crListControlWidgetNode> sellList = dynamic_cast<crListControlWidgetNode *>(sellCanvas->getWidget(m_sellList));
			if (cardsaleList.valid())
			{
				ref_ptr<crListControlNode> selectNode = cardsaleList->getSelectNode();
				if(selectNode.valid())
				{
					int selectindex = selectNode->getData();
					if (cardType->getSelect() == JKBT_Sell)
					{
						//playerdata
						//crData *data = playerData->getDataClass();
						//canvasdata
						if (selectindex >= 0)
						{
							if (canvasdata)
							{
								//braindata
								crData *braindata = crBrain::getInstance()->getDataClass();
								braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
								braindata->getParam(WCHDATA_JXJSaleBagVec,param);
								JXJItemBagVec *salebagvec = (JXJItemBagVec *)param;

								canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
								canvasdata->getParam(WCHDATA_JXJForJKVec,param);
								JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
								//
								if (salebagvec->size()<8 && (*jiangkabagvec)[selectindex] != NULL)
								{
									ref_ptr<crBagItemData>bag = new crBagItemData;
									bag->setItemID((*jiangkabagvec)[selectindex]->getItemID());
									bag->setItemCount((*jiangkabagvec)[selectindex]->getItemCount());
									//bag->setJiangkaData(selectNode->getData());
									salebagvec->push_back(bag);
									(*jiangkabagvec)[selectindex] = NULL;
								}
								else
								{
									std::string str ="出售列表已满！";
									ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
									if (tipcanvas.valid())
									{
										ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
										ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
										if (tipcontent.valid())
										{
											tipcontent->setString(str);
										}
										crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
									}
								}
								canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
								braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
							}
						}
					}
					//else if (cardType->getSelect() == JKBT_Upgrade)
					//{
					////crData *braindata = crBrain::getInstance()->getDataClass();
					////braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
					////braindata->getParam(WCHDATA_JXJUpgradeJiangkaIndex,param);
					////char *salejiangkaindex = (char *)param;
					////if(selectNode)
					////{
					////	int curindex = selectNode->getData();
					////	if(curindex > 0)
					////	{
					////		*salejiangkaindex = (char)curindex;
					////		if (canvasdata)
					////		{
					////			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
					////			canvasdata->getParam(WCHDATA_JXJForJKVec,param);
					////			JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
					////			crData *playerdata = playerData->getDataClass();
					////			playerdata->getParam(WCHDATA_JXJJiangkaBagVec,param);
					////			JXJItemBagVec *playercard = (JXJItemBagVec *)param;
					////			jiangkabagvec->clear();
					////			for(int i = 0; i < playercard->size(); i++)
					////			{
					////				ref_ptr<crBagItemData> temp = NULL;
					////				if((*playercard)[i].get())
					////				{
					////					temp = new crBagItemData;
					////					temp->setItemID((*playercard)[i]->getItemID());
					////					temp->setItemCount((*playercard)[i]->getItemCount());
					////				}
					////				jiangkabagvec->push_back(temp);
					////			}
					////			//playerData->doEvent(WCH_JXJUpdateCardCanvas);
					////			(*jiangkabagvec)[selectNode->getData()]->setItemCount(0) ;
					////			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
					////		}
					////	}
					////}
					////braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
					//}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISellAllSelJiangkaMethod
//
/////////////////////////////////////////
crJXJUISellAllSelJiangkaMethod::crJXJUISellAllSelJiangkaMethod():
	m_copperColor(255,0,255,255)
{
}
crJXJUISellAllSelJiangkaMethod::crJXJUISellAllSelJiangkaMethod(const crJXJUISellAllSelJiangkaMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_copperColor(handle.m_copperColor)
{
}
void crJXJUISellAllSelJiangkaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUISellAllSelJiangkaMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		m_ok = str;
		break;
	case 5:
		crArgumentParser::appAtoVec(str,m_copperColor);
		break;
	}
}
void crJXJUISellAllSelJiangkaMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		crTableIO::StrVec record;
		int coppergot = 0;
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
		braindata->getParam(WCHDATA_JXJSaleBagVec,param);
		JXJItemBagVec *salebagvec = (JXJItemBagVec *)param;
		//

		if (salebagvec->size()>0)
		{
			ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
			if (msgCanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
				ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
				ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				int priceid = itemtab->getTitleIndex("回收价格");
				for(JXJItemBagVec::iterator itr = salebagvec->begin();itr!=salebagvec->end();++itr )
				{
					if ((*itr)!=NULL)
					{
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),record) >= 0 )
						{
							coppergot += atoi(record[priceid].c_str());
						}
					}
				}

				//title->setString(L"出售将卡提示");

				std::vector<float>v_i;
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content");
				cfg_script.Add("Text","您确认要出售这些将卡吗？你将获得");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",2);
				v_i.clear();
				v_i.push_back(m_copperColor[0]);
				v_i.push_back(m_copperColor[1]);
				v_i.push_back(m_copperColor[2]);
				v_i.push_back(m_copperColor[3]);
				cfg_script.Add("Color",v_i);
				char tmpText[35]/*,tmpText2[35]*/;
				sprintf(tmpText,"%d将魂\0",coppergot);
				cfg_script.Add("Text",tmpText);
				cfg_script.Pop();

				//cfg_script.Add("Content");
				//cfg_script.Push("Content",3);
				//sprintf(tmpText2,"来自动打造装备并招募%d【%s】吗？\0",recruitcountnum,name.c_str());
				//cfg_script.Add("Text",tmpText2);
				//cfg_script.Pop();

				cfg_script.Pop();
				msg->setHypertext(cfg_script);
				okBtn->setEnable(true);
				crData *dlgData = msgCanvas->getDataClass();
				int commandtype = CDP_Widget;
				dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
				dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
				crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
			}
		}
		braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUISellAllSelJiangkaOKMethod
//
/////////////////////////////////////////
crJXJUISellAllSelJiangkaOKMethod::crJXJUISellAllSelJiangkaOKMethod()
{
}
crJXJUISellAllSelJiangkaOKMethod::crJXJUISellAllSelJiangkaOKMethod(const crJXJUISellAllSelJiangkaOKMethod& handle):
	crMethod(handle)
{
}
void crJXJUISellAllSelJiangkaOKMethod::inputParam(int i, void *param)
{
}
void crJXJUISellAllSelJiangkaOKMethod::addParam(int i, const std::string& str)
{
}
void crJXJUISellAllSelJiangkaOKMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerData && netConductor)
	{
		void *param;
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
		braindata->getParam(WCHDATA_JXJSaleBagVec,param);
		JXJItemBagVec *salebagvec = (JXJItemBagVec *)param;
		//
		if (!salebagvec->empty())
		{
			CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
			stream->createBuf(salebagvec->size() * 4 + 1);
			stream->_writeUChar(salebagvec->size());
			for(JXJItemBagVec::iterator itr = salebagvec->begin();itr!=salebagvec->end();++itr )
			{
				if ((*itr)!=NULL)
				{
					stream->_writeInt((*itr)->getItemID());
				}
			}
			CRNetApp::crPlayerDataEventPacket packet;
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvSellJiangkaOK, stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		salebagvec->clear();
		braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvSellJiangkaOKMethod
//
/////////////////////////////////////////
crJXJRecvSellJiangkaOKMethod::crJXJRecvSellJiangkaOKMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvSellJiangkaOKMethod::crJXJRecvSellJiangkaOKMethod(const crJXJRecvSellJiangkaOKMethod& handle):
	crMethod(handle)/*,
					m_canvas(handle.m_canvas),
					m_input(handle.m_input)*/
{
}
void crJXJRecvSellJiangkaOKMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvSellJiangkaOKMethod::addParam(int i, const std::string& str)
{
	//switch (i)
	//{
	//case 0:
	//	m_canvas = str;
	//	break;
	//case 1:
	//	m_input = str;
	//	break;
	//}
}
void crJXJRecvSellJiangkaOKMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameServer)
		{
			//bool result = true;
			int playerid = m_this->getPlayerID();
			crTableIO::StrVec record;
			//返回信息
			int itemid = 0;
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid())
			{
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
				//data->getParam(WCHDATA_JXJCardPieces,param);
				//int *mymoney = (int *)param;

				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				int priceid = itemtab->getTitleIndex("回收价格");

				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				unsigned char salebagsize = m_stream->_readUChar();
				int coppergot = 0;

				stream->createBuf(salebagsize*4 + 1);
				stream->_writeUChar(salebagsize);

				for (int i = 0; i<salebagsize; i++)
				{
					itemid = m_stream->_readInt();
					stream->_writeInt(itemid);
					for (int bagindex = 0; bagindex<jiangkabagvec->size();bagindex++)
					{
						if((*jiangkabagvec)[bagindex]!=NULL && (*jiangkabagvec)[bagindex]->getItemID() == itemid)
						{
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
							{
								coppergot += atoi(record[priceid].c_str());
								(*jiangkabagvec)[bagindex] = NULL;
								break;
							}
						}
					}
				}
				if (coppergot > 0)
				{
					m_this->doEvent(WCH_JXJChangePlayerData,MAKECREPARAM(&coppergot,T_JiangHun));
					//*mymoney += coppergot;
					//INTLIMITADD(*mymoney,coppergot,INT_MAX);
				}
				//for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
				//	itr != jiangkabagvec->end();)
				//{
				//	if ((*itr)==NULL)
				//	{
				//		itr = jiangkabagvec->erase(itr);
				//		continue;
				//	}
				//	++itr;
				//}
				//unsigned char bagnummax = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize).c_str()));
				//jiangkabagvec->resize(bagnummax);
				//stream->_writeInt(*mymoney);
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvSellJiangkaOK, stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				data->getParam(WCHDATA_JXJCardPieces,param);
				int mymoney = *(int *)param;
				std::string logdata = "出售将卡（出售ID，获得后总将魂，获得将魂）：" + crArgumentParser::appItoa(itemid) +"|"+ crArgumentParser::appItoa(mymoney) +"|"+crArgumentParser::appItoa(coppergot);
				GameLogData gamelog(Log_SellJiangka,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));				
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char salebagsize = m_stream->_readUChar();
			//			void *param;
			crData *data = m_this->getDataClass();
			//ref_ptr<crCanvasNode>ChatCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			//ref_ptr<crEditWidgetNode> input = dynamic_cast<crEditWidgetNode *>(ChatCanvas->getWidget(m_input));	

			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJJiangkaBagVec,param);
			JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
			
			//int *mymoney = (int *)param;
			for (int i = 0; i<salebagsize; i++)
			{
				int itemid = m_stream->_readInt();
				for (int bagindex = 0; bagindex<jiangkabagvec->size();bagindex++)
				{
					if((*jiangkabagvec)[bagindex]!=NULL && (*jiangkabagvec)[bagindex]->getItemID() == itemid)
					{
						(*jiangkabagvec)[bagindex] = NULL;
						break;
					}
				}
			}
		//	int coppergot = m_stream->_readInt();
			
		//	data->getParam(WCHDATA_JXJCardPieces,param);
		//	int total = *(int *)param;
		//	int extra = coppergot - total;
		//	data->inputParam(WCHDATA_JXJCardPieces,&coppergot);

			//crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_JiangHun,extra));
				//*mymoney += coppergot;
				//std::string text = crArgumentParser::appItoa(coppergot);
				//if(input)input->addString(text);
			
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		//	if(extra !=0)
		//		crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_JiangHun,extra));
			//int i = 0;
			//for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
			//	itr != jiangkabagvec->end();)
			//{
			//	if ((*itr)==NULL)
			//	{
			//		itr = jiangkabagvec->erase(itr);
			//		continue;
			//	}
			//	++itr;
			//}

			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
			braindata->getParam(WCHDATA_JXJSaleBagVec,param);
			JXJItemBagVec *salebagvec = (JXJItemBagVec *)param;
			if (!salebagvec->empty())
			{
				salebagvec->clear();
			}
			braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			//unsigned char bagnummax = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize).c_str()));
	//		jiangkabagvec->resize(bagnummax);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIUndoSellOneJiangkaMethod
//
/////////////////////////////////////////
crJXJUIUndoSellOneJiangkaMethod::crJXJUIUndoSellOneJiangkaMethod()
{
}
crJXJUIUndoSellOneJiangkaMethod::crJXJUIUndoSellOneJiangkaMethod(const crJXJUIUndoSellOneJiangkaMethod& handle):
	crMethod(handle),
	m_cardType(handle.m_cardType),
	m_cardList(handle.m_cardList),
	m_cardCanvas(handle.m_cardCanvas)
	// m_sellList(handle.m_sellList)
{
}
void crJXJUIUndoSellOneJiangkaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIUndoSellOneJiangkaMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cardType = str;
		break;
	case 1:
		m_cardList = str;
		break;
	case 2:
		m_cardCanvas = str;
		break;
	}
}
void crJXJUIUndoSellOneJiangkaMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		crTableIO::StrVec record;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crListControlWidgetNode> cardsaleList = dynamic_cast<crListControlWidgetNode *>(canvas->getWidget(m_cardList));
		ref_ptr<crListControlNode> selectNode = cardsaleList->getSelectNode();
		ref_ptr<crCanvasNode>cardcanvas = crFilterRenderManager::getInstance()->findCanvas(m_cardCanvas);
		if (cardcanvas.valid() && selectNode.valid())
		{
			ref_ptr<crRadioGroupWidgetNode> cardType = dynamic_cast<crRadioGroupWidgetNode *>(cardcanvas->getWidget(m_cardType));

			if (cardType->getSelect() == JKBT_Sell)
			{
				////playerdata
				//crData *data = playerData->getDataClass();
				//data->excHandle(MAKECREPARAM(WCH_LockData,1));
				//data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				//JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
				//data->excHandle(MAKECREPARAM(WCH_LockData,0));
				//canvasdata
				if (selectNode->getData()>0 && cardcanvas.valid())
				{
					crData *canvasdata = cardcanvas->getDataClass();
					if (canvasdata)
					{
						//braindata
						crData *braindata = crBrain::getInstance()->getDataClass();
						braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
						braindata->getParam(WCHDATA_JXJSaleBagVec,param);
						JXJItemBagVec *salebagvec = (JXJItemBagVec *)param;
						canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
						canvasdata->getParam(WCHDATA_JXJForJKVec,param);
						JXJItemBagVec *fjiangkabagvec = (JXJItemBagVec *)param;
						//
						ref_ptr<crBagItemData>bag = new crBagItemData;
						bag->setItemID(selectNode->getData());
						bag->setItemCount(1);
						//bag->setJiangkaData(selectNode->getData());
						//(*fjiangkabagvec)[selectNode->getData()] = bag;

						for (JXJItemBagVec::iterator itrf = fjiangkabagvec->begin();
							itrf!=fjiangkabagvec->end();
							++itrf)
						{
							if ((*itrf)==NULL)
							{
								(*itrf) = bag;
								break;
							}
						}
						for (JXJItemBagVec::iterator itr = salebagvec->begin();
							itr!=salebagvec->end();
							++itr)
						{
							if ((*itr)->getItemID() == selectNode->getData())
							{
								salebagvec->erase(itr);
								break;
							}
						}
						canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
						braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIJiangkaUpgradeOnShowMethod
//
/////////////////////////////////////////
crJXJUIJiangkaUpgradeOnShowMethod::crJXJUIJiangkaUpgradeOnShowMethod()
{
}
crJXJUIJiangkaUpgradeOnShowMethod::crJXJUIJiangkaUpgradeOnShowMethod(const crJXJUIJiangkaUpgradeOnShowMethod& handle):
	crMethod(handle),
	m_btn(handle.m_btn),
	m_pic(handle.m_pic)
{
	for (int i = 0;i<5;i++)
	{
		m_icon[i] = handle.m_icon[i];
	}
	for (int i = 0;i<3;i++)
	{
		m_input[i] = handle.m_input[i];
	}
}
void crJXJUIJiangkaUpgradeOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIJiangkaUpgradeOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_icon[0] = str;
		break;
	case 1:
		m_icon[1]  = str;
		break;
	case 2:
		m_icon[2]  = str;
		break;
	case 3:
		m_icon[3]  = str;
		break;
	case 4:
		m_icon[4]  = str;
		break;
	case 5:
		m_input[0]  = str;
		break;
	case 6:
		m_input[1]  = str;
		break;
	case 7:
		m_input[2]  = str;
		break;
	case 8:
		m_btn = str;
		break;
	case 9:
		m_pic = str;
		break;
	}
}
void crJXJUIJiangkaUpgradeOnShowMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crImageBoxWidgetNode> icon[5] = {NULL};
		ref_ptr<crStaticTextWidgetNode> input[3] = {NULL};
		ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_btn));
		for(int i = 0; i<5 ;i++)
		{
			icon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon[i]));
			if (icon[i].valid())
			{
				//icon[i]->setVisiable(false);
				icon[i]->setImageName(m_pic);
			}
			if (i<3)
			{
				input[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_input[i]));
				if (input[i].valid())
				{
					input[i]->clearString();
				}
			}

		}
		if (btn.valid())
		{
			btn->setEnable(false);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIJiangkaUpgradeUpdateMethod
//
/////////////////////////////////////////
crJXJUIJiangkaUpgradeUpdateMethod::crJXJUIJiangkaUpgradeUpdateMethod()
{
}
crJXJUIJiangkaUpgradeUpdateMethod::crJXJUIJiangkaUpgradeUpdateMethod(const crJXJUIJiangkaUpgradeUpdateMethod& handle):
	crMethod(handle),
	m_btn(handle.m_btn),
	//m_cardcanvas(handle.m_cardcanvas),
	m_pic(handle.m_pic),
	m_costinput(handle.m_costinput),
	m_cardUpgradeSw(handle.m_cardUpgradeSw)
{
	for (int i = 0;i<5;i++)
	{
		if (i < 2)
		{
			m_cardlvsw[i] = handle.m_cardlvsw[i];
		}
		if (i < 3)
		{
			m_input[i] = handle.m_input[i];
		}
		m_icon[i] = handle.m_icon[i];
		m_switch[i] = handle.m_switch[i];
	}
}
void crJXJUIJiangkaUpgradeUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIJiangkaUpgradeUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_icon[0] = str;
		break;
	case 1:
		m_icon[1]  = str;
		break;
	case 2:
		m_icon[2]  = str;
		break;
	case 3:
		m_icon[3]  = str;
		break;
	case 4:
		m_icon[4]  = str;
		break;
	case 5:
		m_input[0]  = str;
		break;
	case 6:
		m_input[1]  = str;
		break;
	case 7:
		m_input[2]  = str;
		break;
	case 8:
		m_btn = str;
		break;
	//case 9:
	//	m_cardcanvas = str;
	//	break;
	case 9:
		m_pic = str;
		break;
	case 10:
		m_costinput = str;
		break;
	case 11:
		m_switch[0] = str;
		break;
	case 12:
		m_switch[1] = str;
		break;
	case 13:
		m_switch[2] = str;
		break;
	case 14:
		m_switch[3] = str;
		break;
	case 15:
		m_switch[4] = str;
		break;
	case 16:
		m_cardlvsw[0] = str;
		break;
	case 17:
		m_cardlvsw[1] = str;
		break;
	case 18:
		m_cardUpgradeSw = str;
		break;
	}
}
void crJXJUIJiangkaUpgradeUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	//ref_ptr<crCanvasNode>cardcanvas = crFilterRenderManager::getInstance()->findCanvas(m_cardcanvas);
	if(playerData)
	{
		void *param;
		ref_ptr<crImageBoxWidgetNode> icon[5] = {NULL};
		ref_ptr<crStaticTextWidgetNode> input[3] = {NULL};
		crMultiSwitch *multiswitch[5] =  {NULL}; 
		crMultiSwitch *cardlvsw[2] =  {NULL}; 
		ref_ptr<crStaticTextWidgetNode> costinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_costinput));
		ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_btn));
		ref_ptr<crMultiSwitch> cardUpgradeSw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_cardUpgradeSw));
		if (costinput.valid())
		{
			costinput->clearString();
		}
		for(int i = 0; i<5 ;i++)
		{
			icon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon[i]));
			multiswitch[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_switch[i]));
			if (icon[i].valid())
			{
				//icon[i]->setVisiable(false);
				icon[i]->setImageName(m_pic);
				if (multiswitch[i])
				{
					multiswitch[i]->setActiveSwitchSet(0);
				}
			}
			if(i < 2)
			{
				cardlvsw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_cardlvsw[i]));
				if (cardlvsw[i])
				{
					cardlvsw[i]->setActiveSwitchSet(0);
				}
			}
			if (i<3)
			{
				input[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_input[i]));
				if (input[i].valid())
				{
					input[i]->clearString();
				}
			}

		}
		if (btn.valid())
		{
			btn->setEnable(false);
		}
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crTableIO::StrVec record,record2;
		crVector2 need;
		int needitemid  = 0;
		int needcount = 0;
		int itemcount = 0;
		bool canup = false;
		int untilneed = 0;
		std::string str1 = "1/1";
		std::string str2 = "0/1";
		//playerdata
		crData *data = playerData->getDataClass();
		//canvasdata
		JXJItemBagVec *jiangkabagvec = NULL;
		crData *canvasdata = m_this->getDataClass();
		if (data && canvasdata)
		{
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJForJKVec,param);
			jiangkabagvec = (JXJItemBagVec *)param;
			//braindata
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
			braindata->getParam(WCHDATA_JXJUpgradeJiangkaIndex,param);
			short upgradejiangkaindex = *(short *)param;
			braindata->getParam(WCHDATA_JXJUpgradeNewJiangkaId,param);
			int *newjiangkaindex = (int *)param;

			int needindex = itemtab->getTitleIndex("升级材料");
			int upitemindex = itemtab->getTitleIndex("升级所得物品");
			int iconindex = itemtab->getTitleIndex("icon");
			int icondisindex = itemtab->getTitleIndex("icon灰");
			int nameindex = itemtab->getTitleIndex("name");
			int color = itemtab->getTitleIndex("品质");
			int costindex = itemtab->getTitleIndex("升级价格");
			int matecountindex = itemtab->getTitleIndex("升级材料数量");
			int magicidindex = itemtab->getTitleIndex("升级材料magicid");
			int itemid = 0;
			unsigned char cardlv = 0;
			if (upgradejiangkaindex >= 0 && jiangkabagvec && upgradejiangkaindex<jiangkabagvec->size())
			{
				if ((*jiangkabagvec)[upgradejiangkaindex]!=NULL)
				{
					itemid = (*jiangkabagvec)[upgradejiangkaindex]->getItemID();
					//cardlv = LOINT16(LOINT32((*jiangkabagvec)[upgradejiangkaindex]->getEquipMagic()));
				}
			}
			if (itemid>0)
			{
				if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
				{
					data->getParam(WCHDATA_JXJCoppercash,param);
					int mycash = *(int *)param;
					if (costinput.valid())
					{
						if (mycash < atoi(record[costindex].c_str()))
						{
							costinput->setColor(crVector4f(0.8f,0.1f,0.1f,1.0f));
						}
						else
						{
							costinput->setColor(crVector4f(1.0f,1.0f,1.0f,1.0f));
						}
						costinput->setString(record[costindex]);
					}
					int upitemid = atoi(record[upitemindex].c_str());
					if(upitemid > 0)
					{
						*newjiangkaindex = upitemid;
						if (atoi(record[color].c_str()) < CardColor_Orange)
						{
							if(cardUpgradeSw->getActiveSwitchSet()!=0)
							{
								cardUpgradeSw->setActiveSwitchSet(0);
								m_this->doEvent(WCH_UI_UpdateData);
							}
							if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(upitemid),record2) >= 0 )
							{
								needcount = atoi(record[needindex].c_str());
								needitemid = itemid;
								for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
									itr!= jiangkabagvec->end();
									++itr)
								{
									if ((*itr)!=NULL)
									{
										if((*itr)->getItemID() == needitemid && (*itr)->getItemCount()>0)
										{
											itemcount++;
										}
									}
								}
								if (itemcount >= needcount)
								{
									canup = true;
								}
								else
								{
									untilneed = needcount - itemcount;
								}
								if (btn.valid())
								{
									if (canup)
									{
										btn->setEnable(true);
									}
									else
									{
										btn->setEnable(false);
									}
								}
								for(int i = 0; i<needcount+2 ;i++)
								{
									//icon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon[i]));
									//if (i<3)
									//{
									//	input[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_input[i]));
									//}
									if (icon[i].valid())
									{
										icon[i]->setVisiable(true);
										switch (i)
										{
										case 0:
											if(icon[i].valid())icon[i]->setImageName(record[iconindex]);
											if(multiswitch[i])multiswitch[i]->setActiveSwitchSet(atoi(record[color].c_str())+1);
											break;
										case 1:
											//if (canup)
											//{
											if(icon[i].valid())icon[i]->setImageName(record2[iconindex]);
											if(multiswitch[i])multiswitch[i]->setActiveSwitchSet(atoi(record2[color].c_str()));
											//}
											//else
											//{
											//	icon[i]->setImageName(record2[icondisindex]);
											//}
											break;
										case 2:
											if(icon[i].valid())icon[i]->setImageName(record[iconindex]);
											if(multiswitch[i])multiswitch[i]->setActiveSwitchSet(atoi(record[color].c_str())+1);
											if ((needcount == 3 && untilneed<3)||(needcount == 2 && untilneed<2))
											{
												//icon[i]->setImageName(record[iconindex]);
												if(input[i-2].valid())
												{
													input[i-2]->setColor(COLOR_WHITE/255.0f);
													input[i-2]->setString(str1);
												}
											}
											else
											{
												//icon[i]->setImageName(record[icondisindex]);
												if(input[i-2].valid())
												{
													input[i-2]->setColor(COLOR_RED/255.0f);
													input[i-2]->setString(str2);
												}
											}
											break;
										case 3:
											if(icon[i].valid())icon[i]->setImageName(record[iconindex]);
											if(multiswitch[i])multiswitch[i]->setActiveSwitchSet(atoi(record[color].c_str())+1);
											if ((needcount == 3 && untilneed<2)||(needcount == 2 && untilneed<1))
											{
												//icon[i]->setImageName(record[iconindex]);
												if(input[i-2].valid())
												{
													input[i-2]->setColor(COLOR_WHITE/255.0f);
													input[i-2]->setString(str1);
												}
											}
											else
											{
												//icon[i]->setImageName(record[icondisindex]);
												if(input[i-2].valid())
												{
													input[i-2]->setColor(COLOR_RED/255.0f);
													input[i-2]->setString(str2);
												}
											}
											break;
										case 4:
											if(icon[i].valid())icon[i]->setImageName(record[iconindex]);
											if(multiswitch[i])multiswitch[i]->setActiveSwitchSet(atoi(record[color].c_str())+1);
											if (canup)
											{
												//icon[i]->setImageName(record[iconindex]);
												if(input[i-2].valid())
												{
													input[i-2]->setColor(COLOR_WHITE/255.0f);
													input[i-2]->setString(str1);
												}
											}
											else if(needcount == 3 && untilneed >=1)
											{
												//icon[i]->setImageName(record[icondisindex]);
												if(input[i-2].valid())
												{
													input[i-2]->setColor(COLOR_RED/255.0f);
													input[i-2]->setString(str2);
													//unsigned int xxx = -1;
													//input[i-2]->setString(crArgumentParser::appItoa(xxx));
												}
											}
											break;
										}
									}
								}
							}
						}
						else
						{//将卡冲星
							if(cardUpgradeSw->getActiveSwitchSet()!=2)
							{
								cardUpgradeSw->setActiveSwitchSet(2);
								m_this->doEvent(WCH_UI_UpdateData);
							}
							data->getParam(WCHDATA_JXJItemBagVec,param);
							JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
							int needmagicid = 0;
							for (int i = 0; i < 2; i++)
							{
								//cardlv = atoi(record[color].c_str()) - CardColor_Orange;
								if(icon[i].valid())icon[i]->setImageName(record[iconindex]);
								if(cardlvsw[i])cardlvsw[i]->setActiveSwitchSet(atoi(record[color].c_str())+1+i);
								//if(cardlvsw[i])cardlvsw[i]->setActiveSwitchSet(cardlv + 1);
							}
							std::vector <int> cardmatevec,matecountvec,matemagicvec;
							crArgumentParser::appAtoVec(record[needindex].c_str(),cardmatevec);
							crArgumentParser::appAtoVec(record[matecountindex].c_str(),matecountvec);
							crArgumentParser::appAtoVec(record[magicidindex].c_str(),matemagicvec);
							int ifcanup = -((int)cardmatevec.size());
							for (int i = 0; i < cardmatevec.size() ;++i)
							{
								canup = false;
								itemcount = 0;
								needitemid = cardmatevec[i];
								needcount = matecountvec[i];
								needmagicid = matemagicvec[i];
								if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(needitemid),record2) >= 0 )
								{
									for (JXJItemBagVec::iterator itr = itembagvec->begin();
										itr!= itembagvec->end();
										++itr)
									{
										if ((*itr)!=NULL)
										{
											if((*itr)->getItemID() == needitemid && (*itr)->getEquipMagic() == needmagicid && (*itr)->getItemCount()>0)
											{
												itemcount += (*itr)->getItemCount();
											}
										}
									}
									if (itemcount >= needcount)
									{
										canup = true;
										ifcanup++;
									}
									if(icon[i + 2].valid())icon[i + 2]->setImageName(record2[iconindex]);
									if(multiswitch[i + 2])multiswitch[i + 2]->setActiveSwitchSet(atoi(record2[color].c_str())+1);
									if(input[i].valid())
									{
										input[i]->setString(crArgumentParser::appItoa(itemcount) + "/" + crArgumentParser::appItoa(needcount));
									}
									if (canup)
									{
										if(input[i].valid())input[i]->setColor(COLOR_WHITE/255.0f);
									}
									else
									{
										if(input[i].valid())input[i]->setColor(COLOR_RED/255.0f);
									}
								}
							}
							if (ifcanup >= 0)
							{
								if(btn.valid())btn->setEnable(true);
							}
						}
					}
				}
			}
			braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJIconjiangkaTipInfoMethod
//
/////////////////////////////////////////
crJXJIconjiangkaTipInfoMethod::crJXJIconjiangkaTipInfoMethod():
	m_ea(NULL),
	m_mailCardIndex(-1),
	m_this(NULL),
	m_cardlvsw("XingJi")
{
}
crJXJIconjiangkaTipInfoMethod::crJXJIconjiangkaTipInfoMethod(const crJXJIconjiangkaTipInfoMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_backboard(handle.m_backboard),
	m_ea(NULL),
	m_this(NULL),
	m_card(handle.m_card),
	m_guojia(handle.m_guojia),
	m_shuxing(handle.m_shuxing),
	m_bingzhong(handle.m_bingzhong),
	m_leixing(handle.m_leixing),
	m_jinengmiaoshu(handle.m_jinengmiaoshu),
	m_nameimage(handle.m_nameimage),
	m_jineng(handle.m_jineng),
	m_cardindex(handle.m_cardindex),
	m_mailCardIndex(handle.m_mailCardIndex),
	m_cardlvsw(handle.m_cardlvsw)
{
}
void crJXJIconjiangkaTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJIconjiangkaTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_card = str;
		break;
	case 2:
		m_backboard = str;
		break;
	case 3:
		m_guojia = str;
		break;
	case 4:
		m_shuxing = str;
		break;
	case 5:
		m_bingzhong = str;
		break;
	case 6:
		m_leixing = str;
		break;
	case 7:
		m_jinengmiaoshu = str;
		break;
	case 8:
		m_nameimage = str;
		break;
	case 9:
		m_jineng = str;
		break;
	case 10:
		m_infotype = atoi(str.c_str());
		break;
	case 11:
		m_cardindex = atoi(str.c_str());
		break;
	case 12:
		m_ExchangeCanvas = str;
		break;
	case 13:
		m_mailCardIndex = atoi(str.c_str());
		break;
	case 14:
		m_mailCanvas = str;
		break;
	case 15:
		m_onlineRewardIndex = atoi(str.c_str());
		break;
	}
}
void crJXJIconjiangkaTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(tipsCanvas.valid() && playerData)
	{
		//ref_ptr<crHypertextWidgetNode> info2 = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_info2));

		ref_ptr<crHypertextWidgetNode> jinengmiaoshu = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_jinengmiaoshu));
		ref_ptr<crImageBoxWidgetNode> card = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_card));
		ref_ptr<crImageBoxWidgetNode> nameimage = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_nameimage));
		crMultiSwitch *backboard = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_backboard));
		crMultiSwitch *cardlvsw = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_cardlvsw));
		crData *data = playerData->getDataClass();
		//unsigned char openbagnum = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize).c_str()));
		int itemid = 0;
		int equipmagic = 0;
		if(m_this)
		{
			void *param;
			//braindata
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
			braindata->getParam(WCHDATA_JXJUpgradeJiangkaIndex,param);
			short upgradejiangkaindex = *(short *)param;
			braindata->getParam(WCHDATA_JXJUpgradeNewJiangkaId,param);
			int newjiangkaid = *(int *)param;
			braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			if (m_infotype == 0)
			{
				void *param;
				crData *cdata = m_this->getParentCanvas()->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				if (itembagvec && upgradejiangkaindex>=0 && upgradejiangkaindex<itembagvec->size())
				{
					if ( (*itembagvec)[upgradejiangkaindex]!=NULL)
					{
						itemid = (*itembagvec)[upgradejiangkaindex]->getItemID();
					}
					else
					{
						crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
					}
				}
				else
				{
					crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			else if (m_infotype == 1)
			{
				itemid = newjiangkaid;
			}
			else if (m_infotype == 2)
			{
				void *param;
				ref_ptr<crCanvasNode>exchangeCanvas = crFilterRenderManager::getInstance()->findCanvas(m_ExchangeCanvas);
				if (exchangeCanvas.valid())
				{
					crData *canvasdata = exchangeCanvas->getDataClass();
					canvasdata->getParam(WCHDATA_JXJCardShopCurPage,param);
					int curpage = *(int *)param;
					canvasdata->getParam(WCHDATA_JXJCardShopItemDeq,param);
					ShopCardIDDeq *cardiddeq = (ShopCardIDDeq *)param;
					if(m_cardindex<cardiddeq->size())
						itemid = (*cardiddeq)[m_cardindex];
				}
			}
			else if (m_infotype == 3)
			{
				ref_ptr<crCanvasNode>mailCanvas = crFilterRenderManager::getInstance()->findCanvas(m_mailCanvas);
				if(mailCanvas.valid())mailCanvas->doEvent(WCH_JXJUIMailTip,MAKECREPARAM(&itemid,m_mailCardIndex-1));
			}
			else if (m_infotype == 4)
			{
				data->getParam(WCHDATA_JXJLuckyCard,param);
				int *luckycard = (int *)param;
				itemid = *(luckycard + m_cardindex);
			}
			else if(m_infotype == 5 && m_onlineRewardIndex > -1 && m_onlineRewardIndex < 5)
			{
				crTableIO::StrVec record,itemrecord;
				ref_ptr<crTableIO>olRewardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJOnlineRewardTab);
				int item1index = olRewardTab->getTitleIndex("道具1");	
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				int typeindex = itemtab->getTitleIndex("类型");
				void *param;
				crMyPlayerData *myPalyer = crMyPlayerData::getInstance();
				myPalyer->getPlayerGameData()->getDataClass()->getParam(WCHDATA_JXJOnlineRewardCount,param);
				unsigned char count = *(unsigned char *)param;
				if(olRewardTab->queryOneRecord(0,crArgumentParser::appItoa(count),record) >= 0 )
				{
					crVector3i vec3;
					crArgumentParser::appAtoVec(record[item1index], vec3);
					if(itemtab->queryOneRecord(0, crArgumentParser::appItoa(vec3[0]), itemrecord) >= 0 )
					{
						int itemTypeId = atoi(itemrecord[typeindex].c_str());
						if(itemTypeId == IT_Jiangka)
						{
							itemid = vec3[0];
							equipmagic = vec3[1];
						}
					}
				}
			}
			else if (m_infotype == 6 || m_infotype == 7)
			{
				int index_ = m_infotype - 6;
				ref_ptr<crCanvasNode>pricecanvas = crFilterRenderManager::getInstance()->findCanvas(m_ExchangeCanvas);
				if (pricecanvas.valid() && pricecanvas->getDataClass())
				{
					crData *pricedata = pricecanvas->getDataClass();
					pricedata->getParam(WCHDATA_JXJRenwuRewardVec, param);
					RenWuRewardVec* renwurewardvec = (RenWuRewardVec *)param;
					if (index_ < renwurewardvec->size())
					{
						itemid = (*renwurewardvec)[index_][0];
						equipmagic = (*renwurewardvec)[index_][1];
					}
				}
			}
			else if (m_infotype == 8)
			{
				ref_ptr<crTableIO> _7DaysAwardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJ7DaysAwardTab	);
				crTableIO::StrVec awardRecord,itemRecord;
				crTableIO::DataVec dataVec;

				if (_7DaysAwardTab.valid())
				{
					int awardIdx = _7DaysAwardTab->getTitleIndex("奖励");
					int orderIdx = _7DaysAwardTab->getTitleIndex("顺序");
					crVector3i awardVec;
					if (_7DaysAwardTab->queryOneRecord(orderIdx,crArgumentParser::appItoa(7) ,awardRecord) >= 0)
					{
						crArgumentParser::appAtoVec(awardRecord[awardIdx],awardVec);
						itemid = awardVec[0];
						equipmagic = awardVec[1];
					}
				}
			}
			else if (m_infotype == 9)
			{
				int i = 0;
				crVector3i vec3;			
				ref_ptr<crTableIO> shouchongAwardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShouchongAwardTab);
				if(crArgumentParser::appAtoVec((*shouchongAwardTab)(i,1),vec3))
				{
					itemid = vec3[0];
					equipmagic = vec3[1];
				}
			}
			else if(m_infotype == 10)
			{

				//int index_ = m_mailCardIndex;
				//ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
				//ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);

				//int taskidindex = tasktitletab->getTitleIndex("taskid");

				//crTableIO::StrVec recordtask,recorditem;
				//int itemaward1index = tasktitletab->getTitleIndex("奖励1");
				//crVector3i vec3;

				//crData *brainData = crBrain::getInstance()->getDataClass();
				//brainData->getParam(WCHDATA_JXJCurChooseTaskID,param);
				//int taskid = *(int *)param;

				//if (taskidindex > 0 && tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),recordtask)>=0)
				//{
				//	crArgumentParser::appAtoVec(recordtask[itemaward1index+(index_-1)*2],vec3);
				//	if (vec3[0]>0 && itemtab->queryOneRecord(0,crArgumentParser::appItoa(vec3[0]),recorditem)>=0)
				//	{
				//		itemid = vec3[0];
				//	}

				//}

			}
			else if(m_infotype == 11)
			{
				data->getParam(WCHDATA_JXJForeignCard, param);
				crVector3i foreignCard = *(crVector3i *)param;
				itemid = foreignCard[m_cardindex];
			}
			else if (m_infotype == 12)
			{//轮回界面将卡tips
				std::string boxname = m_this->getName();
				ref_ptr<crCanvasNode>  Canvas = m_this->getParentCanvas();
				if (boxname.find("XLunhui_Card") != std::string::npos && Canvas.valid())
				{
					ref_ptr<crRadioGroupWidgetNode> cardPage = dynamic_cast<crRadioGroupWidgetNode *>(Canvas->getWidget("XLunhui_jiangka_qieye"));
					int page = cardPage->getSelect();
					int offset = page*CycleCardOnePageCount;
					std::string strindex = boxname.substr(boxname.find('d') + 1, boxname.size() - boxname.find('d') - 1);
					int index = atoi(strindex.c_str()) - 1;
					index += offset;
					crData *canvasData = Canvas->getDataClass();
					if (index < CycleCardCount)
					{
						canvasData->getParam(WCHDATA_JXJLunHuiCardMap, param);
						ItemOrCardMap *cardoritemMap = (ItemOrCardMap *)param;
						if (cardoritemMap)
						{
							ItemOrCardMap::iterator iter = cardoritemMap->find((char)index);
							if (iter != cardoritemMap->end() && iter->second.valid())
							{
								itemid = iter->second->getItemID();
							}
						}
						if (itemid == 0)
						{
							data->getParam(WCHDATA_JXJPlayerStore, param);
							ref_ptr<crJXJPlayerStore> playerStore = (crJXJPlayerStore *)param;
							if (playerStore.valid())
							{
								crData *playerStoreData = playerStore->getDataClass();
								if (playerStoreData)
								{
									playerStoreData->excHandle(MAKECREPARAM(WCH_LockData, 1));
									playerStoreData->getParam(WCHDATA_JXJJiangkaBagVec, param);
									JXJStoreItemBagVec *cardVec = (JXJStoreItemBagVec *)param;
									if (index < cardVec->size() && (*cardVec)[index].valid())
									{
										itemid = (*cardVec)[index]->getItemID();
									}
									playerStoreData->excHandle(MAKECREPARAM(WCH_LockData, 0));
								}
							}
						}
					}
				}
			}
			if(itemid>0)
			{
				ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);

				//int jinengmiaoshuid = troopsEquipTab->getTitleIndex("技能描述");
				int cardid = troopsEquipTab->getTitleIndex("picture");
				int nameimageid = troopsEquipTab->getTitleIndex("姓名");
				int backboardid = troopsEquipTab->getTitleIndex("品质");
				int guojiaid = troopsEquipTab->getTitleIndex("国家");
				crTableIO::StrVec record;
				if (troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
				{
					//std::string file;
					if(jinengmiaoshu.valid())
					{
						//file = record[jinengmiaoshuid];
						//if(!file.empty())
						//{
						//	jinengmiaoshu->clearText();
						//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						//	jinengmiaoshu->setHypertext(file);
						//}
						//else
						//{
						//	jinengmiaoshu->clearText();
						//}
						ItemMap itemMap;
						rcfg::ConfigScript outscript(&itemMap);
						crVector2i item(itemid,equipmagic);
						playerData->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
						jinengmiaoshu->setHypertext(outscript);
					}
					if(card.valid())
					{
						card->setImageName(record[cardid].c_str());
					}
					if(nameimage.valid())
					{
						nameimage->setImageName(record[nameimageid].c_str());
					}
					if(backboard)
					{
						int cardcolor = atoi(record[backboardid].c_str());
						backboard->setActiveSwitchSet(cardcolor);
						//if (cardcolor < CardColor_Orange)
						//{
						//	backboard->setActiveSwitchSet(cardcolor);
						//	if (cardlvsw)
						//	{
						//		cardlvsw->setActiveSwitchSet(0);
						//	}
						//}
						//else
						//{
						//	backboard->setActiveSwitchSet(cardcolor);//CardColor_Orange
						//	if (cardlvsw)
						//	{
						//		cardlvsw->setActiveSwitchSet(cardcolor - CardColor_Orange + 1);
						//	}
						//}
					}

					const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
					const crBoundingBox &iconbox = m_this->getBoundBox();
					const crBoundingBox &tips = tipsCanvas->getBoundBox();
					float posx = (tips.m_max[0]-tips.m_min[0])*0.5;
					float posy = (tips.m_max[1]-tips.m_min[1])*0.5;
					crVector3 pos(iconbox.m_max[0],iconbox.m_max[1],0.0f);
					/////////////////////////////////////////
					crVector3 pos2(iconbox.m_min[0] ,iconbox.m_min[1],0.0f);
					float posx2,posy2;
					/////////////////////////////////////////
					if ((pos[0]+pos2[0])*0.5f >= 0.0f)
					{
						posx2 = pos2[0] - posx;
					}
					else
					{
						posx2 = pos[0] + posx;
					}
					if ((pos[1]+pos2[1])*0.5f >= 0.0f)
					{
						posy2 = pos[1] - posy;
					}
					else
					{
						posy2 = pos2[1] + posy;
					}
					crVector2 mouse(crVector2(posx2,posy2));
					/////////////////////////////////////////
					tipsCanvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f) * mat);
					tipsCanvas->setCanFocus(false);
					crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
				}
			}
			else
			{
				crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
			}
		}
		else
		{
			crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIJiangkaUpgradeMethod
//
/////////////////////////////////////////
crJXJUIJiangkaUpgradeMethod::crJXJUIJiangkaUpgradeMethod()
{
}
crJXJUIJiangkaUpgradeMethod::crJXJUIJiangkaUpgradeMethod(const crJXJUIJiangkaUpgradeMethod& handle):
	crMethod(handle),
	m_orangecanvas(handle.m_orangecanvas)
{
	for(int i = 0; i < 5; ++i)
	{
		m_orangedonghua[i] = handle.m_orangedonghua[i];
	}
}
void crJXJUIJiangkaUpgradeMethod::inputParam(int i, void *param)
{
}
void crJXJUIJiangkaUpgradeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_orangecanvas = str;
		break;
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		m_orangedonghua[i - 1] = str;
		break;
	default:
		break;
	}
}
void crJXJUIJiangkaUpgradeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerData && netConductor)
	{
		void *param;
		int itemid = 0;
		bool enoughmoney = false;
		int cardcolor = 0;
		ref_ptr<crTableIO>cardcosttab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crTableIO::StrVec recordcost;
		int costindex = cardcosttab->getTitleIndex("升级价格");
		int colorindex = cardcosttab->getTitleIndex("品质");
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
		braindata->getParam(WCHDATA_JXJUpgradeJiangkaIndex,param);
		short cardindex = *(short *)param;
		braindata->getParam(WCHDATA_JXJUpgradeNewJiangkaId,param);
		int newjiangkaid = *(int *)param;
		braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
		//
		crData *data = playerData->getDataClass();
		data->getParam(WCHDATA_JXJJiangkaBagVec,param);
		JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
		if (cardindex>=0 && jiangkabagvec && cardindex < jiangkabagvec->size())
		{
			if ((*jiangkabagvec)[cardindex]!=NULL)
			{
				itemid = (*jiangkabagvec)[cardindex]->getItemID();
				if (cardcosttab.valid())
				{
					if (cardcosttab->queryOneRecord(0,crArgumentParser::appItoa(itemid),recordcost) >= 0 )
					{
						cardcolor = atoi(recordcost[colorindex].c_str());
						data->getParam(WCHDATA_JXJCoppercash,param);
						int mycash = *(int *)param;
						if (mycash > atoi(recordcost[costindex].c_str()))
						{
							enoughmoney = true;
						}
					}
				}
			}
		}
		if(cardindex>=0 && newjiangkaid > 0 && itemid > 0 && enoughmoney)
		{
			CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
			stream->createBuf(8);
			stream->_writeInt(itemid);
			stream->_writeInt(newjiangkaid);
			CRNetApp::crPlayerDataEventPacket packet;
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUpgradeJiangka, stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
			//

			ref_ptr<crCanvasNode>orangecanvas = crFilterRenderManager::getInstance()->findCanvas(m_orangecanvas);
			if (orangecanvas.valid())
			{
				if (cardcolor >= CardColor_Orange && cardcolor < CardColor_Ten)
				{
					crSequence *sequence = dynamic_cast<crSequence *>(orangecanvas->getChildNode(m_orangedonghua[cardcolor - CardColor_Orange]));
					crData *ocanvasdata = orangecanvas->getDataClass();
					if(sequence && ocanvasdata)
					{
						sequence->setVanishWhenStop(true);
						//sequence->setDuration(0.1f, 1);
						sequence->startEffect();
						//int flag = 1;
						//ocanvasdata->inputParam(WCHDATA_JXJRecvChengKaUpgradeFlag,&flag);
					}
				}
			}
		}
		else
		{
			playerData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2032,NULL));//铜钱不足
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvJiangkaUpgradeMethod
//
/////////////////////////////////////////
crJXJRecvJiangkaUpgradeMethod::crJXJRecvJiangkaUpgradeMethod():
	m_netType(GameClient_Game)
{
}
crJXJRecvJiangkaUpgradeMethod::crJXJRecvJiangkaUpgradeMethod(const crJXJRecvJiangkaUpgradeMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_input(handle.m_input),
	m_card(handle.m_card),
	m_nameimage(handle.m_nameimage),
	m_backboard(handle.m_backboard),
	m_guojia(handle.m_guojia),
	m_cardlvsw(handle.m_cardlvsw)
{
	for (int i = 0; i < 5; ++i)
	{
		 m_orangedonghua[i] = handle. m_orangedonghua[i];
	}
}
void crJXJRecvJiangkaUpgradeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvJiangkaUpgradeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_input = str;
		break;
	case 2:
		m_card = str;
		break;
	case 3:
		m_nameimage = str;
		break;
	case 4:
		m_backboard = str;
		break;
	case 5:
		m_guojia = str;
		break;
	case 6:
		m_cardlvsw = str;
		break;
	case 7:
		m_orangecanvas = str;
		break;
	case 8:
	case 9:
	case 10:
	case 11:
	case 12:
		m_orangedonghua[i - 8] = str;
		break;
	}
}
void crJXJRecvJiangkaUpgradeMethod::operator()(crHandle &handle)
{	
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameServer)
		{
			RewardItemVec rewardItems;
			DeductItemMap deductitemmap;
			bool enoughcopper = false;
			unsigned char upgradetype = CardUpgradeType_ChangeColor;
			unsigned char result = 0;
			int playerid = m_this->getPlayerID();
			int itemid  = m_stream->_readInt();
			int newcardid = m_stream->_readInt();
			//int itemequipmagic = m_stream->_readInt();
			crTableIO::StrVec record,itemrecord;
			int cardcount = 0;
			int needcount = 0;
			int needequipmagic = 0;
			int cardcolor = 0;
			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid())
			{
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
				data->getParam(WCHDATA_JXJCoppercash,param);
				int *mycopper = (int *)param;
				data -> getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				////////////////////////////////////////////
				int newitemid = 0;
				if (itemid > 0)
				{
					int costindex = itemtab->getTitleIndex("升级价格");
					if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
					{
						if (atoi(record[costindex].c_str())<= *mycopper)
						{
							enoughcopper = true;
						}
					}
					if (enoughcopper)
					{
						int colorindex = itemtab->getTitleIndex("品质");
						int materialid = itemtab->getTitleIndex("升级材料");
						int newcardindex = itemtab->getTitleIndex("升级所得物品");
						int matecountindex = itemtab->getTitleIndex("升级材料数量");
						int magicidindex = itemtab->getTitleIndex("升级材料magicid");

						needcount = atoi(record[materialid].c_str());
						newitemid = atoi(record[newcardindex].c_str());
						cardcolor = atoi(record[colorindex].c_str());
						if (newitemid > 0)
						{
							if (cardcolor < CardColor_Orange)
							{
								upgradetype = CardUpgradeType_ChangeColor;
								if (newitemid == newcardid)
								{
									//check card count
									for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
										itr != jiangkabagvec->end();++itr)
									{
										if ((*itr)!=NULL)
										{
											if ((*itr)->getItemID() == itemid)
											{
												cardcount++;
											}
										}
									}
									if (cardcount >= needcount+1)
									{
										int i = 0;
										result = 1;
										int needdeduct = atoi(record[costindex].c_str());
										m_this->doEvent(WCH_JXJDeductCopperCash,MAKECREPARAM(&needdeduct,NULL));
										//*mycopper -= atoi(record[costindex].c_str());
										//for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
										//	itr != jiangkabagvec->end();++itr)
										//{
										//	if (i >= needcount + 1)
										//	{
										//		break;
										//	}
										//	if ((*itr)!=NULL)
										//	{
										//		if ((*itr)->getItemID() == itemid)
										//		{
										//			*itr = NULL;//jiangkabagvec->erase(itr);
										//			i++;
										//		}
										//	}
										//}
										ref_ptr<crBagItemData> deductcard;
										deductcard =new crBagItemData;
										deductcard->setItemID(itemid);
										deductcard->setItemDeductCount(needcount + 1);
										deductitemmap.insert(std::make_pair(itemid,deductcard));
										m_this->doEvent(WCH_JXJRecvDeductItems,MAKECREPARAM(&deductitemmap,0));
										ref_ptr<crBagItemData> newcard =new crBagItemData;
										newcard->setItemID(newitemid);
										newcard->setItemCount(1);
										rewardItems.push_back(newcard);
									}
									else
									{
										result = 3;//材料不足
									}
								}
							}
							else
							{

								//data -> getParam(WCHDATA_JXJOrangeCardUpgradeTechLv,param);
								//unsigned char OrangeCardUpgradeTechLv = *(unsigned char *)param;
								//将卡升星不再受科技限制
								//if (OrangeCardUpgradeTechLv > 0)
								//{
									upgradetype = CardUpgradeType_AddStar;
									data->getParam(WCHDATA_JXJItemBagVec,param);
									JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
									//int cardlvmax = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCardLvMax).c_str());
									int needitemid = 0;
									std::vector<int> matevec,matecountvec,matemagicidvec;
									crArgumentParser::appAtoVec(record[materialid].c_str(), matevec);
									crArgumentParser::appAtoVec(record[matecountindex].c_str(), matecountvec);
									crArgumentParser::appAtoVec(record[magicidindex].c_str(), matemagicidvec);

									for (int i = 0; i < matevec.size(); i++)
									{
										needitemid = matevec[i];
										needcount = matecountvec[i];
										cardcount = 0;
										for (JXJItemBagVec::iterator itr = itembagvec->begin();
											itr != itembagvec->end();++itr)
										{
											if ((*itr)!=NULL)
											{
												if ((*itr)->getItemID() == needitemid && (*itr)->getEquipMagic() == needequipmagic)
												{
													cardcount += (*itr)->getItemCount();
												}
											}
										}
										if (cardcount < needcount)
										{
											result = 3;
											break;
										}
									}
									int curitemcount = 0;
									DeductItemMap::iterator fitr;
									ref_ptr<crBagItemData> deductcard;
									if (result == 0)
									{
										deductcard =new crBagItemData;
										deductcard->setItemID(itemid);
										deductcard->setItemDeductCount(1);
										deductcard->setEquipMagic(0);
										deductitemmap.insert(std::make_pair(itemid,deductcard));
										for (int i = 0; i < matevec.size(); ++i)
										{
											fitr = deductitemmap.find(matevec[i]);
											if (fitr != deductitemmap.end())
											{
												curitemcount = fitr->second->getItemDeductCount();
												fitr->second->setItemDeductCount(curitemcount + matecountvec[i]);
											}
											else
											{
												deductcard =new crBagItemData;
												deductcard->setItemID(matevec[i]);
												deductcard->setItemDeductCount( matecountvec[i]);
												deductcard->setEquipMagic(0);
												deductitemmap.insert(std::make_pair(matevec[i],deductcard));
											}
										}
										m_this->doEvent(WCH_JXJRecvDeductItems,MAKECREPARAM(&deductitemmap,0));
										result = 1;
										int needdeduct = atoi(record[costindex].c_str());
										m_this->doEvent(WCH_JXJDeductCopperCash,MAKECREPARAM(&needdeduct,NULL));
										//itemequipmagic += 1;
										//if (itemequipmagic > cardlvmax)
										//{
										//	itemequipmagic = cardlvmax;
										//}
										ref_ptr<crBagItemData> newcard =new crBagItemData;
										newcard->setItemID(newitemid);
										newcard->setItemCount(1);
										newcard->setEquipMagic(0);
										rewardItems.push_back(newcard);
									}
								//}
								//else
								//{
								//	result = 4;//科技未开启
								//}
							}
						}
					}
					else
					{
						result = 2;//铜钱不足
					}
				}
				unsigned char bagnummax = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
				jiangkabagvec->resize(bagnummax);
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				if (result == 1)
				{
					stream->createBuf(10);
					stream->_writeUChar(result);
					stream->_writeUChar(upgradetype);
					stream->_writeInt(itemid);
					stream->_writeInt(newitemid);
				}
				else
				{
					stream->createBuf(1);
					stream->_writeUChar(result);
				}
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUpgradeJiangka, stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				if (result == 1)
				{
					//增加活跃度/////////////////////////////////
					//m_this->doEvent(WCH_JXJRecvHuoyuedu, MAKECREPARAM(HYD_UpgradeCard, 1));
					///////////////////////////////////////////////
					m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				///游戏日志
				std::string logdata = "升级将卡（result，获得将卡id）" + crArgumentParser::appVectoa(crVector2i(result,newitemid));
				GameLogData gamelog(Log_UpgradeJiangka,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool cancelTask = false;
			unsigned char result = m_stream->_readUChar();
			if(result == 1)
			{
				crData *braindata = crBrain::getInstance()->getDataClass();
				braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
				braindata->getParam(WCHDATA_JXJNewguideUpgradeCardCount,param);
				int *upgradecardcount = (int *)param;
				(*upgradecardcount) += 1;
				braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
				int newitemid = 0;
				//int itemequipmagic = 0;
				unsigned char upgradetype = m_stream->_readUChar();
				int itemid = m_stream->_readInt();
				newitemid = m_stream->_readInt();
				void *param;
				crTableIO::StrVec record;
				int cardcount = 0;
				//int needcount;
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
				if (itemid > 0)
				{
					int materialid = itemtab->getTitleIndex("升级材料");
					int newcardid = itemtab->getTitleIndex("升级所得物品");

					//itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record);

					//if (upgradetype == CardUpgradeType_ChangeColor)
					//{
						//needcount = atoi(record[materialid].c_str());
						//check card count

					//	for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
					//		itr != jiangkabagvec->end();++itr)
					//	{
					//		if (cardcount >= needcount + 1)
					//		{
					//			break;
					//		}
					//		if ((*itr)!=NULL)
					//		{
					//			if ((*itr)->getItemID() == itemid)
					//			{
					//				//itr = jiangkabagvec->erase(itr);
					//				*itr = NULL;
					//				cardcount++;
					//			}
					//		}
					//	}
					//}
					//ref_ptr<crBagItemData> newcard =new crBagItemData;
					//newcard->setItemID(newitemid);
					//newcard->setItemCount(1);
					//RewardItemVec rewardItems;
					//rewardItems.push_back(newcard);
					//m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
					//unsigned char bagnummax = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize).c_str()));
					//jiangkabagvec->resize(bagnummax);


					ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
					//ref_ptr<crCanvasNode>orangecanvas = crFilterRenderManager::getInstance()->findCanvas(m_orangecanvas);
					crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
					if(tipsCanvas.valid() && playerData)
					{
						//ref_ptr<crHypertextWidgetNode> info2 = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_info2));

						ref_ptr<crHypertextWidgetNode> jinengmiaoshu = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_input));
						ref_ptr<crImageBoxWidgetNode> card = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_card));
						ref_ptr<crImageBoxWidgetNode> nameimage = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_nameimage));
						crMultiSwitch *backboard = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_backboard));
						crMultiSwitch *guojia = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_guojia));
						crMultiSwitch *cardlvsw = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_cardlvsw));
						ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);

						//int jinengmiaoshuid = troopsEquipTab->getTitleIndex("技能描述");
						int cardid = troopsEquipTab->getTitleIndex("picture");
						int nameimageid = troopsEquipTab->getTitleIndex("姓名");
						int backboardid = troopsEquipTab->getTitleIndex("品质");
						int guojiaid = troopsEquipTab->getTitleIndex("国家");
						crTableIO::StrVec record2;
						if (troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(newitemid),record2) >= 0 )
						{
							//std::string file;
							if(jinengmiaoshu.valid())
							{
								ItemMap itemMap;
								rcfg::ConfigScript outscript(&itemMap);
								crVector2i item(newitemid,0);
								playerData->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
								jinengmiaoshu->setHypertext(outscript);
							}
							if(card.valid())
							{
								card->setImageName(record2[cardid].c_str());
							}
							if(nameimage.valid())
							{
								nameimage->setImageName(record2[nameimageid].c_str());
							}
							int cardcolor = atoi(record2[backboardid].c_str());
							if(backboard)
							{
								backboard->setActiveSwitchSet(cardcolor);
								//if (cardcolor < CardColor_Orange)
								//{
								//	backboard->setActiveSwitchSet(cardcolor);
								//	if(cardlvsw)cardlvsw->setActiveSwitchSet(0);
								//}
								//else
								//{
								//	backboard->setActiveSwitchSet(cardcolor);//CardColor_Orange
								//	if(cardlvsw)cardlvsw->setActiveSwitchSet(cardcolor - CardColor_Orange);
								//}
							}
							if(guojia)
							{
								guojia->setActiveSwitchSet(atoi(record2[guojiaid].c_str()));
							}
							//if (orangecanvas.valid())
							//{
							//	if (cardcolor > CardColor_Orange && cardcolor <= CardColor_Ten)
							//	{
							//		crSequence *sequence = dynamic_cast<crSequence *>(orangecanvas->getChildNode(m_orangedonghua[cardcolor - CardColor_Orange - 1]));
							//		if(sequence)
							//		{
							//			sequence->setVanishWhenStop(true);
							//			//sequence->setDuration(0.1f, 1);
							//			sequence->startEffect();
							//		}
							//	}
							//}
							//if (cardcolor <= CardColor_Orange)
							//{//忽略橙卡升星动画，直接弹出升级成功对话框
								//crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
								crFilterRenderManager::getInstance()->doModal(tipsCanvas.get());
							//}
						}
						//braindata
						crData *braindata = crBrain::getInstance()->getDataClass();
						braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
						braindata->getParam(WCHDATA_JXJUpgradeJiangkaIndex,param);
						short *upgradejiangkaindex = (short *)param;
						braindata->getParam(WCHDATA_JXJUpgradeNewJiangkaId,param);
						int *newjiangkaid = (int *)param;
						*upgradejiangkaindex = -1;
						*newjiangkaid = 0;
						braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			else
			{
				int tipindex = 0;
				switch (result)
				{
				case 0:
					tipindex = 2029;
					break;
				case 2:
					tipindex = 2032;
					break;
				case 3:
					tipindex = 2045;
					break;
				case 4:
					tipindex = 2083;
					break;
				default:
					break;
				}
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(tipindex,NULL));//失败
				cancelTask = true;
			}
			handle.outputParam(0,&cancelTask);
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetCanvasStartPosMethod
//
/////////////////////////////////////////
crJXJSetCanvasStartPosMethod::crJXJSetCanvasStartPosMethod()
{
}
crJXJSetCanvasStartPosMethod::crJXJSetCanvasStartPosMethod(const crJXJSetCanvasStartPosMethod& handle):
	crMethod(handle)
{
}
void crJXJSetCanvasStartPosMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJSetCanvasStartPosMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_startpos = atof(str.c_str());
		break;
	}
}
void crJXJSetCanvasStartPosMethod::operator()(crHandle &handle)
{
	//crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this)
	{
		crVector3 pos = m_this->getTrans();
		pos[0] = m_startpos;
		m_this->setPosition(pos);
	}
}
/////////////////////////////////////////
//
//crJXJCheckBattleFubenBtnMethod
//
/////////////////////////////////////////
crJXJCheckBattleFubenBtnMethod::crJXJCheckBattleFubenBtnMethod()
{
}
crJXJCheckBattleFubenBtnMethod::crJXJCheckBattleFubenBtnMethod(const crJXJCheckBattleFubenBtnMethod& handle):
	crMethod(handle)
{
}
void crJXJCheckBattleFubenBtnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJCheckBattleFubenBtnMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_btn = str;
		break;
	case 2:
		m_canvas2 = str;
		break;
	case 3:
		m_btn2 = str;
		break;
	}
}
void crJXJCheckBattleFubenBtnMethod::operator()(crHandle &handle)
{
	//crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if(canvas.valid())ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_btn));
		ref_ptr<crCanvasNode>canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_canvas2);
		if(canvas2.valid())ref_ptr<crButtonWidgetNode> btn2 = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_btn2));
		//if ()
		//{
		//}
	}
}
/////////////////////////////////////////
//
//crJXJWriteLetterSwitchMethod
//
/////////////////////////////////////////
JXJ::crJXJWriteLetterSwitchMethod::crJXJWriteLetterSwitchMethod():
	m_this(NULL),
	m_index(0)
{}
JXJ::crJXJWriteLetterSwitchMethod::crJXJWriteLetterSwitchMethod(const crJXJWriteLetterSwitchMethod& handle):
	crMethod(handle), 
	m_this(handle.m_this),
	m_switch(handle.m_switch),
	m_send_to(handle.m_send_to),
	m_title(handle.m_title),
	m_nameinput(handle.m_nameinput),
	m_nameinput2(handle.m_nameinput2),
	m_titleinput(handle.m_titleinput),
	m_titleinput2(handle.m_titleinput2),
	m_index(handle.m_index)
{}
void JXJ::crJXJWriteLetterSwitchMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRCore::crWidgetNode *)param;
		break;
	}
}
void JXJ::crJXJWriteLetterSwitchMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_send_to = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_switch = str;
		break;
	case 3:
		m_nameinput = str;
		break;
	case 4:
		m_nameinput2 = str;
		break;
	case 5:
		m_index = atoi(str.c_str());
		break;
	case 6:
		m_titleinput = str;
		break;
	case 7:
		m_titleinput2 = str;
		break;
	}
}
void JXJ::crJXJWriteLetterSwitchMethod::operator()(crHandle &handle)
{
	// temp usage

	// 显示mail 窗口

	// 绑定显示好友列表
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	if (player)
	{
		std::string sendname;
		std::string sendtitle;
		//ref_ptr<crCanvasNode>friend_list_node = crFilterRenderManager::getInstance()->findCanvas(m_friend_canvas);
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crStaticTextWidgetNode> nameinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_nameinput));
		ref_ptr<crEditWidgetNode> nameinput2 = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_nameinput2));
		ref_ptr<crStaticTextWidgetNode> titleinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_titleinput));
		ref_ptr<crEditWidgetNode> titleinput2 = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_titleinput2));
		if (nameinput.valid())
		{
			sendname = nameinput->getUTF8String();
		}
		if (nameinput2.valid())
		{
			nameinput2->clearString();
			if (m_index == 1)
			{
				nameinput2->setString(sendname);
			}
		}
		if (titleinput.valid())
		{
			sendtitle = titleinput->getUTF8String();
		}
		if (titleinput2.valid())
		{
			titleinput2->clearString();
			if (m_index == 1)
			{
				titleinput2->setString("回复："+sendtitle);
			}
		}
		crMultiSwitch *pageswitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_switch));
		if (pageswitch)
		{
			pageswitch->setActiveSwitchSet(0);
		}

		// show titles
		ref_ptr<crStaticTextWidgetNode> send_to_stxt = 
			dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_send_to));
		if (send_to_stxt.valid())
		{
			send_to_stxt->setString(std::string("收件人:"));
			send_to_stxt->setVisiable(true);
		}
		ref_ptr<crStaticTextWidgetNode> mail_title_stxt = 
			dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_title));
		if (mail_title_stxt.valid())
		{
			mail_title_stxt->setString(std::string("主题:"));
			mail_title_stxt->setVisiable(true);
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetMailSendNameMethod
//
/////////////////////////////////////////
JXJ::crJXJSetMailSendNameMethod::crJXJSetMailSendNameMethod():
	m_this(NULL)
{}
JXJ::crJXJSetMailSendNameMethod::crJXJSetMailSendNameMethod(const crJXJSetMailSendNameMethod& handle):
	crMethod(handle), 
	m_this(handle.m_this),
	m_recvname(handle.m_recvname),
	m_friendlist(handle.m_friendlist),
	m_friendtab(handle.m_friendtab)
{}
void JXJ::crJXJSetMailSendNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListBoxWidgetNode *)param;
		break;
	}
}
void JXJ::crJXJSetMailSendNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_recvname = str;
		break;
	case 1:
		m_friendlist = str;
		break;
	case 2:
		m_friendtab = str;
		break;
	}
}
void JXJ::crJXJSetMailSendNameMethod::operator()(crHandle &handle)
{
	// temp usage

	// 显示mail 窗口

	// 绑定显示好友列表
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	if (player && m_this)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			ref_ptr<crTableWidgetNode> friendtable = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_friendtab));
			std::wstring name;
			if(friendtable.valid())friendtable->getData(0,m_this->getSelect(),name);
			std::string str = CRIOManager::convertUTF16toUTF8(name);
			ref_ptr<crStaticTextWidgetNode> recvname = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_recvname));
			ref_ptr<crWidgetNode> gamelist = dynamic_cast<crWidgetNode *>(canvas->getWidget(m_friendlist));
			if (recvname.valid())
			{
				recvname->setString(str);
			}
			if(gamelist.valid())
			{
				gamelist->setVisiable(false);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckOneMailSuccessMethod
//
/////////////////////////////////////////
crJXJCheckOneMailSuccessMethod::crJXJCheckOneMailSuccessMethod()
{
}
crJXJCheckOneMailSuccessMethod::crJXJCheckOneMailSuccessMethod(const crJXJCheckOneMailSuccessMethod& handle):
	crMethod(handle),
	m_mailcanvas(handle.m_mailcanvas),
	m_switch(handle.m_switch)
{
	for (int i = 0; i<5; i++)
	{
		m_mailchoice[i] = handle.m_mailchoice[i];
		m_mailinput[i] = handle.m_mailinput[i];
		m_newmailflag[i] = handle.m_newmailflag[i];
	}
	for (int i = 0; i<5; i++)
	{
		m_itemIcon[i] = handle.m_itemIcon[i];
		m_iconSwitch[i] = handle.m_iconSwitch[i];
		m_cardIcon[i] = handle.m_cardIcon[i];
		m_cardSwitch[i] = handle.m_cardSwitch[i];
	}
}
void crJXJCheckOneMailSuccessMethod::inputParam(int i, void *param)
{
	//switch(i) 
	//{
	//case 0:
	//	if(param == 0)
	//	{//释放
	//		m_this = NULL;
	//	}
	//	break;
	//case 1:
	//	m_this = (crWidgetNode*)param;
	//	break;
	//}
}
void crJXJCheckOneMailSuccessMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_mailchoice[0] = str;
		break;
	case 1:
		m_mailchoice[1] = str;
		break;
	case 2:
		m_mailchoice[2] = str;
		break;
	case 3:
		m_mailchoice[3] = str;
		break;
	case 4:
		m_mailchoice[4] = str;
		break;
	case 5:
		m_mailinput[0] = str;
		break;
	case 6:
		m_mailinput[1] = str;
		break;
	case 7:
		m_mailinput[2] = str;
		break;
	case 8:
		m_mailinput[3] = str;
		break;
	case 9:
		m_mailinput[4] = str;
		break;
	case 10:
		m_iconSwitch[0] = str;
		break;
	case 11:
		m_iconSwitch[1] = str;
		break;
	case 12:
		m_iconSwitch[2] = str;
		break;
	case 13:
		m_iconSwitch[3] = str;
		break;
	case 14:
		m_iconSwitch[4] = str;
		break;
	case 15:
		m_newmailflag[0] = str;
		break;
	case 16:
		m_newmailflag[1] = str;
		break;
	case 17:
		m_newmailflag[2] = str;
		break;
	case 18:
		m_newmailflag[3] = str;
		break;
	case 19:
		m_newmailflag[4] = str;
		break;
	case 20:
		m_mailcanvas = str;
		break;
	case 21:
		m_switch = str;
		break;
	case 22:
		m_itemIcon[0] = str;
		break;
	case 23:
		m_itemIcon[1] = str;
		break;
	case 24:
		m_itemIcon[2] = str;
		break;
	case 25:
		m_itemIcon[3] = str;
		break;
	case 26:
		m_itemIcon[4] = str;
		break;
	case 27:
		m_cardIcon[0] = str;
		break;
	case 28:
		m_cardIcon[1] = str;
		break;
	case 29:
		m_cardIcon[2] = str;
		break;
	case 30:
		m_cardIcon[3] = str;
		break;
	case 31:
		m_cardIcon[4] = str;
		break;
	case 32:
		m_cardSwitch[0] = str;
		break;
	case 33:
		m_cardSwitch[1] = str;
		break;
	case 34:
		m_cardSwitch[2] = str;
		break;
	case 35:
		m_cardSwitch[3] = str;
		break;
	case 36:
		m_cardSwitch[4] = str;
		break;
	}
}
void crJXJCheckOneMailSuccessMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		ref_ptr<crTableIO>itemtable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);	
		int iconidindex = itemtable->getTitleIndex("icon"); 
		int colorIndex = itemtable->getTitleIndex("品质");
		void *param;
		RewardItemVec *itemVec = NULL;
		crTableIO::StrVec	record;		
		std::vector<float> v_i;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJRecvMailVec,param);
		JXJRecvMailVec *mailvec = (JXJRecvMailVec *)param;
		brainData->getParam(WCHDATA_JXJRecvMailCacheMap,param);
		MailCacheMap *mailcacheMap = (MailCacheMap *)param;

		brainData->getParam(WCHDATA_JXJCheckMailIndex,param);
		unsigned char mailindex = *(unsigned char *)param;
		//ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_mailcanvas);
		ref_ptr<crRadioWidgetNode> mailchoice[5] = {NULL};
		ref_ptr<crStaticTextWidgetNode> mailinput[4] = {NULL};
		ref_ptr<crImageBoxWidgetNode> itemicon[5] = {NULL};
		ref_ptr<crImageBoxWidgetNode> cardIcon[5] = {NULL};
		crMultiSwitch *cardSwitch[5] = {NULL};
		crMultiSwitch *iconSwitch[5] = {NULL};

		rcfg::ConfigScript outscript;
		ref_ptr<crNode> background = NULL;

		if(canvas.valid() && mailindex < mailvec->size() && (*mailvec)[mailindex]!=NULL)
		{
			crMultiSwitch *pageswitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_switch));
			if (pageswitch)
			{
				pageswitch->setActiveSwitchSet(1);
			}
			ref_ptr<crCheckBoxWidgetNode> newmailflag = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_newmailflag[mailindex]));
			if(newmailflag.valid())
			{
				newmailflag->select(false);
			}
			ref_ptr<crHypertextWidgetNode> bodyinput = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_mailinput[4]));
			int mailid = (*mailvec)[mailindex]->getID();
			//for(JXJRecvMailVec::iterator itr = mailbodyvec->begin();itr!=mailbodyvec->end();++itr)
			MailCacheMap::iterator itr = mailcacheMap->find(mailid);
			if (itr!=mailcacheMap->end() /*&& m_mailID!=mailid*/)
			{
				//m_mailID = mailid;
				CRCore::ref_ptr<CRCore::crStreamBuf> bodystream = itr->second->getBody();
				if(bodystream.valid() && bodyinput.valid())
				{
					crGlobalHandle::getInstance()->getStreamScript(bodystream.get(),outscript);
					bodyinput->clearText();
					//bodyinput->updateData()
					crData *bodydata = bodyinput->getDataClass();
					if (bodydata)
					{
						bodydata->getParam(WCHDATA_JXJGiftsPackItemInfo,param);
						itemVec = (RewardItemVec *)param;
						itemVec->clear();
					}
					bodyinput->setHypertext(outscript);
					if (bodydata)
					{
						bodydata->getParam(WCHDATA_JXJGiftsPackItemInfo,param);
						itemVec = (RewardItemVec *)param;
						//itemVec->clear();
					}
				}
				
// 				if (bodyinput)
// 				{
// 					//////////////test
// 					//std::string file = "senditemmodel.cfg";
// 					//if(!file.empty())
// 					//{
// 					//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
// 					//	bodyinput->clearText();
// 					//	bodyinput->setHypertext(file);
// 					//}
// 					//////////testend
// 					
// 				}
				for (int i = 0; i< 5; i++)
				{
					if (i<5)
					{
						mailchoice[i] = dynamic_cast<crRadioWidgetNode *>(canvas->getWidget(m_mailchoice[i]));
						if (mailchoice[i].valid())
						{
							if (i!=mailindex)
							{
								//mailchoice[i]->setEnable(true);
								mailchoice[i]->select(false);
							}
							else
							{
								mailchoice[i]->select(true);
								//mailchoice[i]->setEnable(false);
							}
						}
						if (i<4)
						{
							mailinput[i] = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_mailinput[i]));
							if (mailinput[i].valid())
							{
								switch (i)
								{
								case 0:
									mailinput[i]->setString(std::string("发件人"));
									break;
								case 1:
									mailinput[i]->setString(std::string("主题"));
									break;
								case 2:
									mailinput[i]->setString((*mailvec)[mailindex]->getSenderName());
									break;
								case 3:
									{
										  std::string title = (*mailvec)[mailindex]->getTitle();
// 										  if ((*mailvec)[mailindex]->getState() == Mail_HasEx)
// 										  {
// 											  title += std::string("(附件)");
// 										  }
// 										  else if ((*mailvec)[mailindex]->getState() == Mail_BeenGetted)
// 										  {
// 											  title += std::string("(已领取)");
// 										  }
										  mailinput[i]->setString(title);
									}
									
									break;
								}
							} 
						}
					}

					iconSwitch[i] = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_iconSwitch[i]));
					if(iconSwitch[i])
						iconSwitch[i]->setActiveSwitchSet(2);
					if(itemVec && (*mailvec)[mailindex]->getState()==Mail_HasEx)
					{
						if(iconSwitch[i] && i<itemVec->size())
						{
							int itemtype = -1;
							crBrain::getInstance()->doEvent(WCH_JXJCheckItemType,MAKECREPARAM((*itemVec)[i]->getItemID(),&itemtype));
							if(itemtype == IT_Jiangka)
							{
								iconSwitch[i]->setActiveSwitchSet(1);
								cardSwitch[i] = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_cardSwitch[i]));
								cardIcon[i] = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_cardIcon[i]));
								if(cardSwitch[i] && cardIcon[i].valid() && itemtable->queryOneRecord(0,	crArgumentParser::appItoa((*itemVec)[i]->getItemID()),record) >= 0 )
								{
									int quality = atoi(record[colorIndex].c_str());
									//if (quality > CardColor_Orange) quality = CardColor_Orange;
									cardSwitch[i]->setActiveSwitchSet(quality);
									cardIcon[i]->setImageName(record[iconidindex]);
								}
							}
							else
							{
								iconSwitch[i]->setActiveSwitchSet(0);
								itemicon[i] = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_itemIcon[i]));
								if(itemicon[i].valid() && itemtable->queryOneRecord(0,	crArgumentParser::appItoa((*itemVec)[i]->getItemID()),record) >= 0 )
								{
									itemicon[i]->setImageName(record[iconidindex]);
								}
							}
						}
					}
				}
			}
		}
		brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJCheckOneMailMethod
//
/////////////////////////////////////////
crJXJCheckOneMailMethod::crJXJCheckOneMailMethod()
{
}
crJXJCheckOneMailMethod::crJXJCheckOneMailMethod(const crJXJCheckOneMailMethod& handle):
	crMethod(handle),
	m_this(handle.m_this),
	m_index(handle.m_index),
	m_deletebtn(handle.m_deletebtn),
	m_friendList(handle.m_friendList)
{
	for (int i = 0; i < 5; i++)
	{
		m_mailradio[i] = handle.m_mailradio[i];
	}
}
void crJXJCheckOneMailMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRadioWidgetNode*)param;
		break;
	}
}
void crJXJCheckOneMailMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_deletebtn = str;
		break;
	case 2:
		m_friendList = str;
		break;
	case 3:
		m_mailradio[i - 3] = str;
		break;
	case 4:
		m_mailradio[i - 3] = str;
		break;
	case 5:
		m_mailradio[i - 3] = str;
		break;
	case 6:
		m_mailradio[i - 3] = str;
		break;
	case 7:
		m_mailradio[i - 3] = str;
		break;
	}
}
void crJXJCheckOneMailMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		bool findbody = false;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			ref_ptr<crButtonWidgetNode> deletebtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_deletebtn));
			ref_ptr<crWidgetNode> friendList = dynamic_cast<crWidgetNode *>(canvas->getWidget(m_friendList));
			if (deletebtn.valid() && friendList.valid())
			{
				if(m_this->getEnable())deletebtn->setEnable(true);
				friendList->setVisiable(false);
				ref_ptr<crRadioWidgetNode> mailradio[5] = {NULL};
				for (int i = 0; i < 5; i++)
				{
					mailradio[i] = dynamic_cast<crRadioWidgetNode *>(canvas->getWidget(m_mailradio[i]));
					if (mailradio[i].valid())
					{
						mailradio[i]->select(false);
					}
				}
			}
		}
		m_this->select(true);
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJRecvMailVec,param);
		JXJRecvMailVec *mailvec = (JXJRecvMailVec *)param;
		if(!mailvec || mailvec->empty())
		{
			brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
			return;
		}
		brainData->getParam(WCHDATA_JXJRecvMailCacheMap,param);
		MailCacheMap *mailbodymap = (MailCacheMap *)param;
		brainData->getParam(WCHDATA_JXJCheckMailIndex,param);
		unsigned char *mailindex = (unsigned char *)param;
		*mailindex = (unsigned char)m_index;
		brainData->getParam(WCHDATA_JXJDeleteAllMailFlag,param);
		unsigned char *deleteall = (unsigned char *)param;
		*deleteall = 0;
		if (mailvec && m_index < mailvec->size())
		{
			if((*mailvec)[m_index]!=NULL)
			{
				MailCacheMap::iterator itr = mailbodymap->find((*mailvec)[m_index]->getID());
				
				if (itr!=mailbodymap->end() && itr->second->getBody().valid())
				{
					findbody = true;
					playerData->doEvent(WCH_JXJCheckOneMailSuccess);
				}
			}
		}

		if(!findbody && m_index < mailvec->size())
		{
			CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
			stream->createBuf(5);
			//stream->_writeInt(playerData->getPlayerID());
			stream->_writeInt((*mailvec)[m_index]->getID());
			stream->_writeUChar((*mailvec)[m_index]->getState());
			CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
			CRNetApp::crPlayerDataEventPacket packet;
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJMailBodyRequest, stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJMailBodyRequestMethod
//
/////////////////////////////////////////
JXJ::crJXJMailBodyRequestMethod::crJXJMailBodyRequestMethod()
{}
JXJ::crJXJMailBodyRequestMethod::crJXJMailBodyRequestMethod(const crJXJMailBodyRequestMethod& handle):
	m_mail_canvas(handle.m_mail_canvas),
	m_input_body(handle.m_input_body)
{}
void JXJ::crJXJMailBodyRequestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (CRNetApp::crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (CRCore::crStreamBuf *)(LOCREPARAM(param64));
			m_net_type = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void JXJ::crJXJMailBodyRequestMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_mail_canvas = str;
		break;
	case 1:
		m_input_body = str;
		break;
	default:
		break;
	}
}
void JXJ::crJXJMailBodyRequestMethod::operator()(crHandle &handle)
{
	if(!m_this)
	{
		return;
	}

	if(m_net_type == CRNetApp::GameServer)
	{
		int playerid = m_this->getPlayerID();
		int mailid = m_stream->_readInt();
		unsigned char state = m_stream->_readUChar();
		// make query 
		void *param;
		crData *server_data = crServerBrainHandle::getInstance()->getDataClass();
		server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
		server_data->getParam(WCHDATA_JXJMailBodyQueryList, param);
		MailQueryDeque *query_deque = (MailQueryDeque *)param;

		// check de remove new query to end
		bool found = false;
		for(MailQueryDeque::iterator itr = query_deque->begin(); itr != query_deque->end(); ++itr)
		{
			if((*itr)->getQueryID() == playerid)
			{
				(*itr)->setID(mailid);
				(*itr)->setState(state);
				found = true;
				//query_deque->erase(itr);
				break;
			}
		}
		if(!found)
		{
			CRCore::ref_ptr<crMailQuery> query = new crMailQuery;
			query->setQueryID(playerid);
			query->setID(mailid);
			query->setState(state);
			// input to queue
			query_deque->push_back(query);
		}

		server_data->excHandle(MAKECREPARAM(WCH_LockData,0));
		///游戏日志
		std::string logdata = "查看邮件（ID）：" + crArgumentParser::appItoa(mailid);
		GameLogData gamelog(Log_RequestMailBody,logdata);
		crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
	}
	else if(m_net_type == CRNetApp::GameClient_Game)
	{
		// TODO:
		// parse and show data
		CRCore::ref_ptr<CRCore::crStreamBuf> bodystream = new crStreamBuf;
		int mailid = m_stream->_readInt();
		bodystream = m_stream;

		if (bodystream.valid())
		{
			void *param;
			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
			brainData->getParam(WCHDATA_JXJRecvMailCacheMap,param);
			MailCacheMap *mailbodymap = (MailCacheMap *)param;
			MailCacheMap::iterator itr = mailbodymap->find(mailid);
			
			if(itr!=mailbodymap->end())
			{
				itr->second->setBody(bodystream);
				itr->second->setID(mailid);
			}
			else
			{
				CRCore::ref_ptr<crMailInfo> mailinfo = new crMailInfo;
				mailinfo->setID(mailid);
				mailinfo->setBody(bodystream);
				if(mailbodymap)
					mailbodymap->insert(std::make_pair(mailid,mailinfo));
			}
			
			//brainData->getParam(WCHDATA_JXJRecvMailVec,param);
			//JXJRecvMailVec *mailvec = (JXJRecvMailVec *)param;
			//brainData->getParam(WCHDATA_JXJCheckMailIndex,param);
			//unsigned char mailindex = *(unsigned char *)param;

			//if(mailindex < mailvec->size() && (*mailvec)[mailindex]!=NULL)
			//{
			//	(*mailvec)[mailindex]->setBody(bodystream);
			//}
			brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
			m_this->doEvent(WCH_JXJCheckOneMailSuccess);
		}
	}
}
/////////////////////////////////////////
//
//crJXJMailBodyQueryingMethod
//
/////////////////////////////////////////
crJXJMailBodyQueryingMethod::crJXJMailBodyQueryingMethod():
	m_taskcount(10)
{}
crJXJMailBodyQueryingMethod::crJXJMailBodyQueryingMethod(const crJXJMailBodyQueryingMethod& handle):
	m_taskcount(handle.m_taskcount)
{}
void crJXJMailBodyQueryingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle *)param;
		break;
	default:
		break;
	}
}
void crJXJMailBodyQueryingMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_taskcount = atoi(str.c_str());
		break;
	}
}
void crJXJMailBodyQueryingMethod::operator()(crHandle &handle)
{
	m_taskVec.resize(0);
	m_taskVec.reserve(m_taskcount);
	// get waiting deque
	void *param;
	crData *server_data = m_this->getDataClass();
	CRCore::ref_ptr<crMailQuery> query;
	server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
	server_data->getParam(WCHDATA_JXJMailBodyQueryList, param);
	MailQueryDeque *query_deque = (MailQueryDeque *)param;
	int i = 0;
	while(!query_deque->empty() && i<m_taskcount)
	{
		query = query_deque->front();
		query_deque->pop_front();
		m_taskVec.push_back(query);
		i++;
	}
	server_data->excHandle(MAKECREPARAM(WCH_LockData,0));

	//// timer
	//const Timer& timer = *Timer::instance();
	//Timer_t start_tick = timer.tick();
	//float elapsed_time = 0.0f;

	// database
	if(!m_taskVec.empty())
	{
		crNetConductor *db_net = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
		crDataBase *global_db = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
		ref_ptr<crMailBodyQueryData> body_query = new crMailBodyQueryData;
		ref_ptr<crStreamBuf> query_result = new crStreamBuf;
		CRNet::crNetConductor *server_net = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		ref_ptr<crGameServerPlayerData> player_net_data;
		ref_ptr<crDataBase> db_session = global_db->beginSession();
		for( std::vector<CRCore::ref_ptr<crMailQuery> >::iterator titr = m_taskVec.begin();
			titr != m_taskVec.end();
			++titr )
		{
			query = *titr;
			//CRCore::ref_ptr<crMailQuery> query = query_deque->front();
			//query_deque->pop_front();
			//int mailcount = 0;
			if (!query->getState())
			{
				ref_ptr<crUpdateMail> state_query = new crUpdateMail;
				state_query->buildUpdateSql(query->getID(),Mail_Readed);
				crDBSavePacket packet;
				crDBSavePacket::buildRequestPacket(packet,GameGlobalDB,state_query.get());
				db_net->getNetManager()->sendPacket("all",packet);
			}
			body_query->buildQuerySql(query->getID());
			db_session->executeQuery(body_query.get());
			// parse and return
			crDataBase::QueryResultVec &body_reuslt_vec = db_session->getQueryResult();
			if (!body_reuslt_vec.empty())
			{
				crMailBodyQueryData *body_record = dynamic_cast<crMailBodyQueryData *>(body_reuslt_vec[0].get());
				if (body_record)
				{
					CRCore::ref_ptr<CRCore::crStreamBuf> query_body = body_record->getBody();
					query_result->createBuf(4+query_body->getRemainSize());
					query_result->_writeInt(query->getID());
					query_result->write(query_body->getPtr(),query_body->getRemainSize());
				}
			}
			else
			{
				query_result->createBuf(4);
				query_result->_writeInt(query->getID());
			}
			db_session->releaseQuery();
			// send back
			player_net_data = dynamic_cast<CRNetApp::crGameServerPlayerData *>(server_net->getNetDataManager()->getPlayerData(query->getQueryID()));
			if(player_net_data.valid())
			{
				crPlayerDataEventPacket ppacket;
				crPlayerDataEventPacket::buildReplyPacket(ppacket,query->getQueryID(),WCH_JXJMailBodyRequest,query_result.get());
				server_net->getNetManager()->sendPacket(player_net_data->getPlayerConnectServerAddress(),ppacket);
			}
			//elapsed_time += timer.delta_s(start_tick,timer.tick());
		}
		global_db->endSession(db_session.get());
	}
}

/////////////////////////////////////////
//
//crJXJWriteLetterSwitchMethod
//
/////////////////////////////////////////
JXJ::crJXJReturnToCheckSwitchMethod::crJXJReturnToCheckSwitchMethod():
	m_this(NULL)
{}
JXJ::crJXJReturnToCheckSwitchMethod::crJXJReturnToCheckSwitchMethod(const crJXJReturnToCheckSwitchMethod& handle):
	crMethod(handle), 
	m_this(handle.m_this),
	m_switch(handle.m_switch)
{}
void JXJ::crJXJReturnToCheckSwitchMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (CRCore::crWidgetNode *)param;
		break;
	}
}
void JXJ::crJXJReturnToCheckSwitchMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_switch = str;
		break;
	}
}
void JXJ::crJXJReturnToCheckSwitchMethod::operator()(crHandle &handle)
{
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	if (player && m_this)
	{
		std::string sendname;
		//ref_ptr<crCanvasNode>friend_list_node = crFilterRenderManager::getInstance()->findCanvas(m_friend_canvas);
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if(canvas.valid())
		{
			crMultiSwitch *pageswitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_switch));
			if (pageswitch)
			{
				pageswitch->setActiveSwitchSet(1);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckMailWriteSizeMethod
//
/////////////////////////////////////////
JXJ::crJXJCheckMailWriteSizeMethod::crJXJCheckMailWriteSizeMethod():
	m_this(NULL)
{}
JXJ::crJXJCheckMailWriteSizeMethod::crJXJCheckMailWriteSizeMethod(const crJXJCheckMailWriteSizeMethod& handle):
	crMethod(handle), 
	m_this(handle.m_this),
	m_sizeinput(handle.m_sizeinput),
	m_precontent(handle.m_precontent)
{}
void JXJ::crJXJCheckMailWriteSizeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crEditWidgetNode *)param;
		break;
	}
}
void JXJ::crJXJCheckMailWriteSizeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_sizeinput = str;
		break;
	}
}
void JXJ::crJXJCheckMailWriteSizeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	if (player && m_this)
	{
		void *param;
		crData *data = player ->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxsize = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMailContentSizeMax,viplv).c_str()));
		std::string content;
		content = m_this->getUTF8String();
		int textsize = content.size()/2;
		if (textsize > maxsize)
		{
			content = m_precontent;
			m_this->setString(content);
			textsize = content.size()/2;
		}
		else
		{
			m_precontent = content;
		}
		//ref_ptr<crCanvasNode>friend_list_node = crFilterRenderManager::getInstance()->findCanvas(m_friend_canvas);
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if(canvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> sizeinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_sizeinput));
			if (sizeinput.valid())
			{
				if (textsize >= maxsize)
				{
					sizeinput->setString(std::string("字数已满"));
					sizeinput->setColor(crVector4(255.0,0.0,0.0,255.0));
				}
				else
				{
					sizeinput->setString(crArgumentParser::appItoa(textsize));
					sizeinput->setColor(crVector4(255.0,255.0,255.0,255.0));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSystemMailMethod
//
/////////////////////////////////////////
crJXJRecvSystemMailMethod::crJXJRecvSystemMailMethod(){}
crJXJRecvSystemMailMethod::crJXJRecvSystemMailMethod(const crJXJRecvSystemMailMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSystemMailMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSystemMailMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvSystemMailMethod::operator()(crHandle &handle)
{
	if(!m_this)
	{
		return;
	}

		// parse mail data
	ref_ptr<crMailInfo> mail = new crMailInfo; 
	mail->setRecvName(m_stream->_readString());
	mail->setTitle(m_stream->_readString());
	mail->setBody(m_stream.get());
	//mail->setText(m_stream->_readString());

	//MailInfo mail;
	//mail.receiver_name = m_stream->_readString();
	//mail.title = m_stream->_readString();
	//mail.content = m_stream->_readString();
	bool is_sended = false;
	int receiver_id = 0;
	//crGlobalHandle::getInstance()->getScriptStream();
	// get receiver id
	CRNet::crNetConductor *server_net = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer); // packet replay and tip 
	crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(server_net->getNetDataManager()->getNetCallback());
	receiver_id = CRNetApp::crGlobalHandle::getInstance()->gameServerQueryPlayerID(mail->getRecvName(),callback->getServerID());

	//crNetDataManager *netDataManager = server_net->getNetDataManager();
	//netDataManager->lockPlayerDataMap();
	//crNetDataManager::PlayerDataMap &player_map = netDataManager->getPlayerDataMap();
	////for(crNetDataManager::PlayerDataMap::iterator itr = player_map.begin(); itr != player_map.end(); itr++)
	////{
	////	ref_ptr<crGameServerPlayerData> send_to = dynamic_cast<crGameServerPlayerData *>(itr->second.get());
	////	if (send_to.valid())
	////	{
	////		if (send_to->getCharacterName() == mail->getRecvName())
	////		{
	////			receiver_id = send_to->getPlayerID();
	////		}
	////	}
	////}
	//netDataManager->unLockPlayerDataMap();
	// check and parse result

	int player_id = 0;
	if(receiver_id > 0)
	{
		// parse data
		mail->setSenderID(player_id);
		mail->setRecvID(receiver_id);
		mail->setSenderName(std::string("系统邮件"));
		//mail.sender_id = player_id;
		//mail.receiver_id = receiver_id;
		//mail.sender_name = m_this->getCharacterName();
		//crGlobalHandle::getInstance()->getScriptStream();
		// input into sending queue
		crData *server_data = crServerBrainHandle::getInstance()->getDataClass();
		server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
		void *param;
		server_data->getParam(WCHDATA_JXJMailTaskList, param);
		MailTaskDeque *mail_deque = (MailTaskDeque *)param;
		mail_deque->push_back(mail);
		server_data->excHandle(MAKECREPARAM(WCH_LockData,0));
		is_sended = true;

		//ref_ptr<crStreamBuf> query_result = new crStreamBuf;
		//query_result->createBuf(1);
		//query_result->_writeBool(is_sended);
		crPlayerDataEventPacket packet;
		packet.buildReplyPacket(packet,receiver_id,WCH_JXJNewMailRequest,NULL);
		CRNet::crNetConductor *server_net = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		ref_ptr<crGameServerPlayerData> player_net_data = dynamic_cast<CRNetApp::crGameServerPlayerData *>(server_net->getNetDataManager()->getPlayerData(receiver_id));
		if(player_net_data.valid())
		{
			server_net->getNetManager()->sendPacket(player_net_data->getPlayerConnectServerAddress(),packet);
		}
	}

	// send back
	CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
	stream->createBuf(1);
	stream->_writeBool(is_sended);
	crNetConductor *db_net = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB); // database operations
	ref_ptr<crGameServerPlayerData> player_net_data = dynamic_cast<CRNetApp::crGameServerPlayerData *>(server_net->getNetDataManager()->getPlayerData(player_id));
	if (player_net_data.valid())
	{
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildReplyPacket(packet,player_id,WCH_JXJClientRecvSystemMail,stream.get());
		server_net->getNetManager()->sendPacket(player_net_data->getPlayerConnectServerAddress(),packet);
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvSystemMailMethod
//
/////////////////////////////////////////
crJXJClientRecvSystemMailMethod::crJXJClientRecvSystemMailMethod():
	m_netType(GameClient_Game)
{
}
crJXJClientRecvSystemMailMethod::crJXJClientRecvSystemMailMethod(const crJXJClientRecvSystemMailMethod& handle):
	crMethod(handle),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJClientRecvSystemMailMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJClientRecvSystemMailMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tiptitle = str;
		break;
	case 2:
		m_tipcontent = str;
		break;
	}
}
void crJXJClientRecvSystemMailMethod::operator()(crHandle &handle)
{	
	if(m_netType == GameClient_Game)
	{
		////
		bool issend = m_stream->_readBool();
		if(issend)
		{
			std::string tipstr = "系统邮件已发送，请稍后查收。";
			ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
			if (tipcanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
				if (tiptitle.valid())
				{
					tiptitle->setString(std::string("系统邮件"));
				}
				ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
				if (tipcontent.valid())
				{
					tipcontent->setColor(crVector4f(255.0f,0.0f,0.0f,255.0f));
					tipcontent->setString(tipstr);
				}
				crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIDeleteOneMailMethod
//
/////////////////////////////////////////
crJXJUIDeleteOneMailMethod::crJXJUIDeleteOneMailMethod()
{
}

crJXJUIDeleteOneMailMethod::crJXJUIDeleteOneMailMethod(const crJXJUIDeleteOneMailMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok)
{
}

void crJXJUIDeleteOneMailMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIDeleteOneMailMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	}
}

void crJXJUIDeleteOneMailMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		std::string sendername;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJRecvMailVec,param);
		JXJRecvMailVec *mailvec = (JXJRecvMailVec *)param;
		brainData->getParam(WCHDATA_JXJCheckMailIndex,param);
		unsigned char mailindex = *(unsigned char *)param;
		brainData->getParam(WCHDATA_JXJDeleteAllMailFlag,param);
		unsigned char deleteall = *(unsigned char *)param;
		///
		if (mailvec)
		{
			if (mailindex < mailvec->size() && (*mailvec)[mailindex]!=NULL)
			{
				sendername = (*mailvec)[mailindex]->getSenderName();
			}
		}
		brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		//
		ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
		//if(title)title->setString(L"删除邮件");

		if (msgCanvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
			ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
			ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
			std::vector<float>v_i;
			ItemMap itemMap;
			rcfg::ConfigScript cfg_script(&itemMap);
			if (!deleteall)
			{
				if (sendername.size())
				{
					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");
					cfg_script.Add("Content");
					cfg_script.Push("Content");
					cfg_script.Add("Text","您确认要删除");
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",2);
					v_i.clear();
					v_i.push_back(0.0);
					v_i.push_back(255.0);
					v_i.push_back(255.0);
					v_i.push_back(255.0);
					cfg_script.Add("Color",v_i);
					char tmpText[20];
					sprintf(tmpText,"【%s】\0",sendername.c_str());
					cfg_script.Add("Text",tmpText);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",3);
					cfg_script.Add("Text","发来的这封邮件吗？");
					cfg_script.Pop();

					cfg_script.Pop();

					if(msg.valid())msg->setHypertext(cfg_script);
					if(okBtn.valid())okBtn->setEnable(true);
					if (msgCanvas.valid())
					{
						crData *dlgData = msgCanvas->getDataClass();
						int commandtype = CDP_Widget;
						dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
						dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
						crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
					}
				}
			}
			else
			{
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content");
				v_i.clear();
				v_i.push_back(0.0);
				v_i.push_back(255.0);
				v_i.push_back(255.0);
				v_i.push_back(255.0);
				cfg_script.Add("Color",v_i);
				cfg_script.Add("Text","您确认要删除本页所有邮件吗？");
				cfg_script.Pop();
				cfg_script.Pop();

				if (msgCanvas.valid())
				{
					if(msg.valid())msg->setHypertext(cfg_script);
					if(okBtn.valid())okBtn->setEnable(true);
					crData *dlgData = msgCanvas->getDataClass();
					int commandtype = CDP_Widget;
					dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
					dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
					crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJDeleteOneMailMethod
//
/////////////////////////////////////////
crJXJDeleteOneMailMethod::crJXJDeleteOneMailMethod()
{
}

crJXJDeleteOneMailMethod::crJXJDeleteOneMailMethod(const crJXJDeleteOneMailMethod& handle):
	crMethod(handle)
{
}

void crJXJDeleteOneMailMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJDeleteOneMailMethod::addParam(int i, const std::string& str)
{
}

void crJXJDeleteOneMailMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		int mailid = 0;
		int queryid = 0;
		crData *brainData = crBrain::getInstance()->getDataClass();
		brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		brainData->getParam(WCHDATA_JXJRecvMailVec,param);
		JXJRecvMailVec *mailvec = (JXJRecvMailVec *)param;
		brainData->getParam(WCHDATA_JXJCheckMailIndex,param);
		unsigned char mailindex = *(unsigned char *)param;
		brainData->getParam(WCHDATA_JXJDeleteAllMailFlag,param);
		unsigned char deleteall = *(unsigned char *)param;
		brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		///
		if (!deleteall)
		{
			if (mailvec)
			{
				if (mailindex < mailvec->size() && (*mailvec)[mailindex]!=NULL)
				{
					mailid = (*mailvec)[mailindex]->getID();
				}
			}
			if (mailid > 0)
			{
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(mailid);
				CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvDeleteMail,stream.get());
				net_conductor->getNetManager()->sendPacket("all",packet);
			}
		}
		else
		{
			for (int i = 0;i<mailvec->size();i++)
			{
				if (mailvec)
				{
					if (i < mailvec->size() && (*mailvec)[i]!=NULL)
					{
						mailid = (*mailvec)[i]->getID();
					}
				}
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(mailid);
				CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvDeleteMail,stream.get());
				net_conductor->getNetManager()->sendPacket("all",packet);
			}
		}
		//
	}
}
/////////////////////////////////////////
//
//crJXJRecvDeleteOneMailMethod
//
/////////////////////////////////////////
crJXJRecvDeleteOneMailMethod::crJXJRecvDeleteOneMailMethod()
{}
crJXJRecvDeleteOneMailMethod::crJXJRecvDeleteOneMailMethod(const crJXJRecvDeleteOneMailMethod& handle):
	m_tipcanvas(handle.m_tipcanvas),
	m_title(handle.m_title),
	m_inputbody(handle.m_inputbody)
{}
void crJXJRecvDeleteOneMailMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (CRNetApp::crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (CRCore::crStreamBuf *)(LOCREPARAM(param64));
			m_net_type = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvDeleteOneMailMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_inputbody = str;
		break;
	default:
		break;
	}
}
void crJXJRecvDeleteOneMailMethod::operator()(crHandle &handle)
{
	if(!m_this)
	{
		return;
	}

	if(m_net_type == CRNetApp::GameServer)
	{
		int playerid = m_this->getPlayerID();
		int mailid = m_stream->_readInt();
		// make query 
		void *param;
		crData *server_data = crServerBrainHandle::getInstance()->getDataClass();
		server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
		server_data->getParam(WCHDATA_JXJMailDeleteList, param);
		MailQueryDeque *delete_deque = (MailQueryDeque *)param;

		// check de remove new query to end
		bool found = false;
		for(MailQueryDeque::iterator itr = delete_deque->begin(); itr != delete_deque->end(); ++itr)
		{
			if((*itr)->getQueryID() == playerid && (*itr)->getID() == mailid)
			{
				found = true;
				break;
			}
		}
		if(!found)
		{
			CRCore::ref_ptr<crMailQuery> deletemail = new crMailQuery;
			deletemail->setID(mailid);
			deletemail->setQueryID(playerid);
			delete_deque->push_back(deletemail);
		}
		server_data->excHandle(MAKECREPARAM(WCH_LockData,0));
		///游戏日志
		std::string logdata = crArgumentParser::appItoa(mailid);
		GameLogData gamelog(Log_DeleteMail,logdata);
		crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
	}
	else if(m_net_type == CRNetApp::GameClient_Game)
	{
		bool success = m_stream->_readUChar();
		std::string  tipstr = "邮件删除成功!";
		if (success)
		{
			crData *brainData = crBrain::getInstance()->getDataClass();
			unsigned char mailindex = 0;
			brainData->inputParam(WCHDATA_JXJCheckMailIndex,&mailindex);
		}
		if (!success)
		{
			tipstr = "邮件删除失败!";
		}
		ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
		if (tipcanvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_title));
			if (tiptitle.valid())
			{
				tiptitle->setString(std::string("删除邮件"));
			}
			ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_inputbody));
			if (tipcontent.valid())
			{
				tipcontent->setString(tipstr);
			}
			crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
		}
	}
}
/////////////////////////////////////////
//
//crJXJDeleteMailDisposeMethod
//
/////////////////////////////////////////
crJXJDeleteMailDisposeMethod::crJXJDeleteMailDisposeMethod():
	m_taskcount(10)
{}
crJXJDeleteMailDisposeMethod::crJXJDeleteMailDisposeMethod(const crJXJDeleteMailDisposeMethod& handle):
	m_taskcount(handle.m_taskcount)
{}
void crJXJDeleteMailDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle *)param;
		break;
	}
}
void crJXJDeleteMailDisposeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_taskcount = atoi(str.c_str());
		break;
	}
}
void crJXJDeleteMailDisposeMethod::operator()(crHandle &handle)
{
	m_taskVec.resize(0);
	m_taskVec.reserve(m_taskcount);
	crData *server_data = m_this->getDataClass();
	void *param;
	CRCore::ref_ptr<crMailQuery> query;
	server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
	server_data->getParam(WCHDATA_JXJMailDeleteList, param);
	MailQueryDeque *query_deque = (MailQueryDeque *)param;
	int i = 0;
	while(!query_deque->empty() && i<m_taskcount)
	{
		query = query_deque->front();
		query_deque->pop_front();
		m_taskVec.push_back(query);
		i++;
	}
	server_data->excHandle(MAKECREPARAM(WCH_LockData,0));

	if(!m_taskVec.empty())
	{
		// database
		bool success = false;
		crNetConductor *db_net = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
		CRNet::crNetConductor *server_net = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
		//crDataBase *global_db = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
		//ref_ptr<crDataBase> db_session = global_db->beginSession();
		//ref_ptr<crMailBodyQueryData> body_query = new crMailBodyQueryData;
		crDBSavePacket dbpacket;
		crPlayerDataEventPacket packet;
		ref_ptr<crUpdateMail> deletemail = new crUpdateMail;
		ref_ptr<crStreamBuf> query_result = new crStreamBuf;
		query_result->createBuf(1);
		ref_ptr<crGameServerPlayerData> player_net_data;
		for( std::vector<CRCore::ref_ptr<crMailQuery> >::iterator titr = m_taskVec.begin();
			titr != m_taskVec.end();
			++titr )
		{
			query = *titr;
			success = false;
			if (query->getID()>0)
			{
				deletemail->buildUpdateSql(query->getID(),Mail_Deleted);
				crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,deletemail.get());
				db_net->getNetManager()->sendPacket("all",dbpacket);
				success = true;
			}

			query_result->seekBegin();
			query_result->_writeUChar(success);
			crPlayerDataEventPacket::buildReplyPacket(packet,query->getQueryID(),WCH_JXJRecvDeleteMail,query_result.get());
			player_net_data = dynamic_cast<CRNetApp::crGameServerPlayerData *>(server_net->getNetDataManager()->getPlayerData(query->getQueryID()));
			if(player_net_data.valid())
			{
				server_net->getNetManager()->sendPacket(player_net_data->getPlayerConnectServerAddress(),packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJResetMailCurPageMethod
//
/////////////////////////////////////////
crJXJResetMailCurPageMethod::crJXJResetMailCurPageMethod()
{
}

crJXJResetMailCurPageMethod::crJXJResetMailCurPageMethod(const crJXJResetMailCurPageMethod& handle)
{
}

void crJXJResetMailCurPageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJResetMailCurPageMethod::addParam(int i, const std::string& str)
{
}

void crJXJResetMailCurPageMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param; // parameter extracting
		CRCore::ref_ptr<crCanvasNode>mail_canvas = m_this->getParentCanvas();
		if (mail_canvas.valid())
		{
			CRCore::crData *mail_canvas_data = mail_canvas->getDataClass();	
			if (mail_canvas_data)
			{
				mail_canvas_data->getParam(WCHDATA_JXJMailCurPage, param);
				int *cur_page = ((int *)param);
				*cur_page = 1;
			}	
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUpdateLordLvInfoMethod
//
/////////////////////////////////////////
crJXJRecvUpdateLordLvInfoMethod::crJXJRecvUpdateLordLvInfoMethod()
{}
crJXJRecvUpdateLordLvInfoMethod::crJXJRecvUpdateLordLvInfoMethod(const crJXJRecvUpdateLordLvInfoMethod& handle)
{
	for (int i = 0; i < 3; ++i)
	{
		m_donghuacanvas[i] = handle.m_donghuacanvas[i];
		m_donghuasequence[i] = handle.m_donghuasequence[i];
	}
}
void crJXJRecvUpdateLordLvInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (CRNetApp::crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (CRCore::crStreamBuf *)(LOCREPARAM(param64));
			m_net_type = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvUpdateLordLvInfoMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
	case 1:
	case 2:
		m_donghuacanvas[i] = str;
		break;
	case 3:
	case 4:
	case 5:
		m_donghuasequence[i - 3] = str;
		break;
	default:
		break;
	}
}
void crJXJRecvUpdateLordLvInfoMethod::operator()(crHandle &handle)
{
	if(m_net_type == CRNetApp::GameClient_Game)
	{
		void *param;
		crRole *mainRole = m_this->getMainRole();
		if (mainRole && mainRole->getDataClass())
		{
			crData *data = m_this->getDataClass();
			crData *maindata = mainRole->getDataClass();
			data->getParam(WCHDATA_VipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			maindata->excHandle(MAKECREPARAM(WCH_LockData,1));
			maindata->getParam(WCHDATA_Level,param);
			unsigned char *mylv = (unsigned char *)param;
			unsigned char oldlv = (*mylv);
			//兵法
			maindata->getParam(WCHDATA_JXJBingFa,param);
			short *bingfa = (short *)param;
			//阵法
			maindata->getParam(WCHDATA_JXJZhenFa,param);
			short *zhenfa = (short *)param;
			//洞察
			maindata->getParam(WCHDATA_JXJDongCha,param);
			short *dongcha = (short *)param;
			//统率
			maindata->getParam(WCHDATA_JXJTongShuai,param);
			short *tongshuai = (short *)param;
			//经验
			maindata->getParam(WCHDATA_Experience,param) ;
			int *experience = (int*)param;
			int oldexp = *experience;
			/////
			*experience = m_stream->_readInt();
			*mylv = m_stream->_readUChar();
			*bingfa = m_stream->_readShort();
			*zhenfa = m_stream->_readShort();
			*dongcha = m_stream->_readShort();
			*tongshuai = m_stream->_readShort();
			int extra = *experience-oldexp;
			maindata->excHandle(MAKECREPARAM(WCH_LockData,0));
			//m_this->doEvent(WCH_JXJCheckResBuildingLevel);
			if(extra!=0)
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Exp,extra));

			unsigned char firstlv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFormation1stRowOpenLv,viplv).c_str()));
			unsigned char secondlv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFormation2ndRowOpenLv,viplv).c_str()));

			ref_ptr<crCanvasNode>donghuacanvas[3] = {NULL};
			ref_ptr<crSequence>donghuasequence[3] = {NULL};
			for (int i = 0; i < 3; ++i)
			{
				donghuacanvas[i] = crFilterRenderManager::getInstance()->findCanvas(m_donghuacanvas[i]);
				if(donghuacanvas[i].valid())donghuasequence[i] = dynamic_cast<crSequence*>(donghuacanvas[i]->getChildNode(m_donghuasequence[i]));
			}
			if ((*mylv) >= secondlv && oldlv < secondlv && donghuacanvas[0].valid() && donghuasequence[0].valid())
			{
				crFilterRenderManager::getInstance()->showCanvas(donghuacanvas[0].get(),true);
				donghuasequence[0]->setMode(crSequence::START);
				donghuasequence[0]->setVanishWhenStop(true);
			}
			if ((*mylv) >= firstlv && oldlv < firstlv && donghuacanvas[1].valid() && donghuasequence[1].valid())
			{
				crFilterRenderManager::getInstance()->showCanvas(donghuacanvas[1].get(),true);
				donghuasequence[1]->setMode(crSequence::START);
				donghuasequence[1]->setVanishWhenStop(true);
			}
			if ((*mylv) > oldlv && donghuacanvas[2].valid() && donghuasequence[2].valid())
			{
				crFilterRenderManager::getInstance()->showCanvas(donghuacanvas[2].get(),true);
				donghuasequence[2]->setMode(crSequence::START);
				donghuasequence[2]->setVanishWhenStop(true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJShowUIFxMethod
//
/////////////////////////////////////////
crJXJShowUIFxMethod::crJXJShowUIFxMethod():
	m_time(1.5f),
	m_lv(0)
{}
crJXJShowUIFxMethod::crJXJShowUIFxMethod(const crJXJShowUIFxMethod& handle):
	m_fxcanvas(handle.m_fxcanvas),
	m_time(handle.m_time),
	m_lv(handle.m_lv)
{}
void crJXJShowUIFxMethod::inputParam(int i, void *param)
{
}
void crJXJShowUIFxMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_fxcanvas = str;
		break;
	case 1:
		m_time = atof(str.c_str());
		break;
	case 2:
		m_lv = atoi(str.c_str());
		break;
	}
}
void crJXJShowUIFxMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>fxcanvas = crFilterRenderManager::getInstance()->findCanvas(m_fxcanvas);
	if(fxcanvas.valid() && fxcanvas->getDataClass())
	{
		crData *data = fxcanvas->getDataClass();
		data->inputParam(WCHDATA_JXJVisiableTime,&m_time);
		//
		if(m_lv>0)
		{
			void *param;
			crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
			crRole *mainRole = playerGameData->getMainRole();
			crData *mainRoleData = mainRole->getDataClass();
			mainRoleData->getParam(WCHDATA_Level,param);
			unsigned char nowlv = *(unsigned char *)param;
			if ((int)nowlv > m_lv)
			{
				crFilterRenderManager::getInstance()->showCanvas(fxcanvas.get(),true);
			}
		}
		else
		{
			crFilterRenderManager::getInstance()->showCanvas(fxcanvas.get(),true);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFxFrameMethod
//
/////////////////////////////////////////
crJXJUIFxFrameMethod::crJXJUIFxFrameMethod():
	m_this(NULL),
	m_dt(NULL)
{
}

crJXJUIFxFrameMethod::crJXJUIFxFrameMethod(const crJXJUIFxFrameMethod& handle):
	crMethod(handle),
	m_btn(handle.m_btn),
	m_this(NULL),
	m_dt(NULL)
{
}
void crJXJUIFxFrameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = (float*)LOCREPARAM(param64);
		}
		break;
	}
}
void crJXJUIFxFrameMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_btn = str;
		break;
	default:
		break;
	}
}

void crJXJUIFxFrameMethod::operator()(crHandle &handle)
{
	void *param;
	crData *canvasData = m_this->getDataClass();
	if(canvasData)
	{
		canvasData->getParam(WCHDATA_JXJVisiableTime,param);
		float *timer = (float *)param;
		if(*timer <= 0.0f)
		{
			*timer = 0.0f;
			crFilterRenderManager::getInstance()->showCanvas(m_this,false);
			ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_btn));
			if (btn.valid())btn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON, crGUIEventAdapter::RELEASE));
		}
		else
		{
			*timer-=*m_dt;
		}
	}
}
/////////////////////////////////////////
//
//crJXJSelCurPageAllMailMethod
//
/////////////////////////////////////////
crJXJSelCurPageAllMailMethod::crJXJSelCurPageAllMailMethod()
{
}

crJXJSelCurPageAllMailMethod::crJXJSelCurPageAllMailMethod(const crJXJSelCurPageAllMailMethod& handle):
	m_deletebtn(handle.m_deletebtn)
{
	for (int i = 0;i<5;i++)
	{
		m_mailchoice[i] = handle.m_mailchoice[i];
	}
}

void crJXJSelCurPageAllMailMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJSelCurPageAllMailMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_mailchoice[0] = str;
		break;
	case 1:
		m_mailchoice[1] = str;
		break;
	case 2:
		m_mailchoice[2] = str;
		break;
	case 3:
		m_mailchoice[3] = str;
		break;
	case 4:
		m_mailchoice[4] = str;
		break;
	case 5:
		m_deletebtn = str;
		break;
	default:
		break;
	}
}

void crJXJSelCurPageAllMailMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		//void *param; // parameter extracting
		CRCore::ref_ptr<crCanvasNode>mail_canvas = m_this->getParentCanvas();
		if (mail_canvas.valid())
		{
			void *param;
			ref_ptr<crButtonWidgetNode> deletebtn = dynamic_cast<crButtonWidgetNode *>(mail_canvas->getWidget(m_deletebtn));
			if(deletebtn.valid())
			{
				deletebtn->setEnable(true);
			}
			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
			brainData->getParam(WCHDATA_JXJRecvMailVec,param);
			JXJRecvMailVec *mailvec = (JXJRecvMailVec *)param;
			for (int i = 0; i < mailvec->size();i++)
			{
				ref_ptr<crRadioWidgetNode> mailchoice = dynamic_cast<crRadioWidgetNode *>(mail_canvas->getWidget(m_mailchoice[i]));
				mailchoice->select(true);
			}
			unsigned char deleteall = 1;
			brainData->inputParam(WCHDATA_JXJDeleteAllMailFlag,&deleteall);
			brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckNewMailMethod
//
/////////////////////////////////////////
crJXJCheckNewMailMethod::crJXJCheckNewMailMethod()
{
}
crJXJCheckNewMailMethod::crJXJCheckNewMailMethod(const crJXJCheckNewMailMethod& handle):
	crMethod(handle)
{}
void crJXJCheckNewMailMethod::inputParam(int i, void *param)
{
}
void crJXJCheckNewMailMethod::addParam(int i, const std::string& str)
{
}
void crJXJCheckNewMailMethod::operator()(crHandle &handle)
{
	//crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(netConductor)
	{
		//CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJNewMailRequest,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJNewMailRequestMethod
//
/////////////////////////////////////////
JXJ::crJXJNewMailRequestMethod::crJXJNewMailRequestMethod()
{}
JXJ::crJXJNewMailRequestMethod::crJXJNewMailRequestMethod(const crJXJNewMailRequestMethod& handle):
	m_canvas(handle.m_canvas),
	m_mailbtn(handle.m_mailbtn),
	m_mailplay(handle.m_mailplay)
{}
void JXJ::crJXJNewMailRequestMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (CRNetApp::crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (CRCore::crStreamBuf *)(LOCREPARAM(param64));
			m_net_type = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void JXJ::crJXJNewMailRequestMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_mailbtn = str;
		break;
	case 2:
		m_mailplay = str;
		break;
	case 3:
		m_strMailCanvas = str;
		break;
	default:
		break;
	}
}
void JXJ::crJXJNewMailRequestMethod::operator()(crHandle &handle)
{
	if(m_net_type == CRNetApp::GameServer)
	{
		// make query 
		void *param;
		crData *server_data = crServerBrainHandle::getInstance()->getDataClass();
		server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
		server_data->getParam(WCHDATA_JXJNewMailQueryList, param);
		MailQueryDeque *query_deque = (MailQueryDeque *)param;

		// check de remove new query to end
		bool found = false;
		for(MailQueryDeque::iterator itr = query_deque->begin(); itr != query_deque->end(); ++itr)
		{
			if((*itr)->getQueryID() == m_this->getPlayerID())
			{
				(*itr)->setState(0);
				found = true;
				break;
			}
		}
		if(!found)
		{// input to queue
			CRCore::ref_ptr<crMailQuery> query = new crMailQuery;
			query->setQueryID(m_this->getPlayerID());
			query->setState(0);
			query_deque->push_back(query);
		}
		server_data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
	else if(m_net_type == CRNetApp::GameClient_Game)
	{
		// TODO:
		// parse and show data
		//bool newmail = m_stream->_readBool();
		ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if(!msgCanvas)	return;
		ref_ptr<crButtonWidgetNode> title = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_mailbtn));
		if(!title)	return;
		crMultiSwitch *mailplay = dynamic_cast<crMultiSwitch *>(msgCanvas->getChildNode(m_mailplay));
		if(!mailplay)	return;
		//if(newmail)
		//{
		mailplay->setActiveSwitchSet(1);
		//}
		//else
		//{
		//	mailplay->setActiveSwitchSet(0);
		//}

		ref_ptr<crCanvasNode>mailCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strMailCanvas);
		if(mailCanvas.valid() && mailCanvas->getVisiable() == true)
			mailCanvas->doEvent(WCH_UI_UpdateData);
	}
}
/////////////////////////////////////////
//
//crJXJNewMailQueryingMethod
//
/////////////////////////////////////////
crJXJNewMailQueryingMethod::crJXJNewMailQueryingMethod()
{}
crJXJNewMailQueryingMethod::crJXJNewMailQueryingMethod(const crJXJNewMailQueryingMethod& handle)
{}
void crJXJNewMailQueryingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{
			//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle *)param;
		break;
	default:
		break;
	}
}
void crJXJNewMailQueryingMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_avail_time = atof(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJNewMailQueryingMethod::operator()(crHandle &handle)
{
	// get waiting deque
	if (m_this)
	{
		crData *server_data = m_this->getDataClass();
		if (server_data)
		{
			void *param;
			server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
			server_data->getParam(WCHDATA_JXJNewMailQueryList, param);
			MailQueryDeque *query_deque = (MailQueryDeque *)param;

			if(query_deque->empty())
			{
				server_data->excHandle(MAKECREPARAM(WCH_LockData,0));
				return;
			}


			// timer
			const Timer& timer = *Timer::instance();
			Timer_t start_tick = timer.tick();
			float elapsed_time = 0.0f;

			// database
			int mailcount = 0;
			crNetConductor *db_net = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
			CRNet::crNetConductor *server_net = CRNet::crNetContainer::getInstance()->getNetConductor(GameServer);
			crDataBase *global_db = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
			ref_ptr<crDataBase> db_session = global_db->beginSession();
			ref_ptr<crCountMailByStatsQueryData> newmail_query = new crCountMailByStatsQueryData;
			//crDBSavePacket packet;
			crPlayerDataEventPacket packet;
			while(elapsed_time < m_avail_time && !query_deque->empty())
			{
				CRCore::ref_ptr<crMailQuery> query = query_deque->front();
				query_deque->pop_front();


				newmail_query->buildQuerySql(query->getQueryID(),query->getState());
				db_session->executeQuery(newmail_query.get());
				// parse and return
				bool newmail = false;
				crDataBase::QueryResultVec &newmail_reuslt_vec = db_session->getQueryResult();
				if(!newmail_reuslt_vec.empty())
				{
					crCountMailByStatsQueryData *newmail_record = dynamic_cast<crCountMailByStatsQueryData *>(newmail_reuslt_vec[0].get());
					if (newmail_record && newmail_record->getCount()>0)
					{
						newmail = true;
					}
				}
				db_session->releaseQuery();
				// send back
				//ref_ptr<crStreamBuf> query_result = new crStreamBuf;
				//query_result->createBuf(1);
				//query_result->_writeBool(newmail);
				if(newmail)
				{
					ref_ptr<crGameServerPlayerData> player_net_data = dynamic_cast<CRNetApp::crGameServerPlayerData *>(server_net->getNetDataManager()->getPlayerData(query->getQueryID()));
					if(player_net_data.valid())
					{
						packet.buildReplyPacket(packet,query->getQueryID(),WCH_JXJNewMailRequest,NULL);
						server_net->getNetManager()->sendPacket(player_net_data->getPlayerConnectServerAddress(),packet);
					}
				}
				elapsed_time += timer.delta_s(start_tick,timer.tick());
			}
			global_db->endSession(db_session.get());
			server_data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetMakeEquipNumMaxMethod
//
/////////////////////////////////////////
crJXJSetMakeEquipNumMaxMethod::crJXJSetMakeEquipNumMaxMethod()
{
}

crJXJSetMakeEquipNumMaxMethod::crJXJSetMakeEquipNumMaxMethod(const crJXJSetMakeEquipNumMaxMethod& handle):
m_numinput(handle.m_numinput)
{
}

void crJXJSetMakeEquipNumMaxMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJSetMakeEquipNumMaxMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_numinput = str;
		break;
	}
}

void crJXJSetMakeEquipNumMaxMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		//void *param; // parameter extracting
		CRCore::ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			void *param;

			ref_ptr<crStaticTextWidgetNode> mailplay = dynamic_cast<crStaticTextWidgetNode *>(canvas->getChildNode(m_numinput));
			crRole *mainrole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
			crData *mainroledata = mainrole->getDataClass();
			crTableIO::StrVec govrecord;
			ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
			int postnameid = postTab->getTitleIndex("govpost");
			mainroledata->getParam(WCHDATA_JXJGovPost,param);
			unsigned char govpost = *(unsigned char *)param;
			if(postTab->queryOneRecord(0,crArgumentParser::appItoa(govpost),govrecord) >= 0 )
			{
				int armycountid = postTab->getTitleIndex("领导力");
				if(mailplay.valid())mailplay->setString(govrecord[armycountid]);
			}
			//领导力
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIFubenUpdateMethod
//
/////////////////////////////////////////
crJXJUIFubenUpdateMethod::crJXJUIFubenUpdateMethod():
	m_chapterindex(-1),
	m_chapterfubensize(-1),
	m_hardlvindex(-1),
	m_chaptersize(0),
	m_value(0),
	m_modeindex(0),
	m_characterSize(16),
	m_textColor(crVector4f(100.0f,190.0f,12.0f,255.0f))
{
}
crJXJUIFubenUpdateMethod::crJXJUIFubenUpdateMethod(const crJXJUIFubenUpdateMethod& handle):
	crMethod(handle),
	m_modeRaido(handle.m_modeRaido),
	m_chapterRadioGroup(handle.m_chapterRadioGroup),
	m_fubenRadio(handle.m_fubenRadio),
	m_resetBtn(handle.m_resetBtn),
	m_chapterindex(handle.m_chapterindex),
	m_chapterfubensize(handle.m_chapterfubensize),
	m_hardlvRadio(handle.m_hardlvRadio),
	m_hardlvindex(handle.m_hardlvindex),
	m_fubenpic(handle.m_fubenpic),
	m_bosspic(handle.m_bosspic),
	m_enter(handle.m_enter),
	m_sweep(handle.m_sweep),
	m_chapterscroll(handle.m_chapterscroll),
	m_chaptersize(handle.m_chaptersize),
	m_value(handle.m_value),
	m_modeindex(handle.m_modeindex),
	m_pagesw(handle.m_pagesw),
	m_pagesw2(handle.m_pagesw2),
	m_mingjianginput(handle.m_mingjianginput),
	m_chongzhiinput(handle.m_chongzhiinput),
	m_mingjiangBtn(handle.m_mingjiangBtn),
	m_defaultpic(handle.m_defaultpic),
	m_characterSize(handle.m_characterSize),
	m_textColor(handle.m_textColor)
{
	for (int i = 0; i < 3; i++)
	{
		m_formationinput[i] = handle.m_formationinput[i];
		m_formationicon[i] = handle.m_formationicon[i];
		m_cardsw[i] = handle.m_cardsw[i];
		m_fubensw[i] = handle.m_fubensw[i];
		m_ratesw[i] = handle.m_ratesw[i];
	}
	for (int i = 0; i < 6; i++)
	{
		m_fubenopensw[i] = handle.m_fubenopensw[i];
		m_fubenbackpic[i] = handle.m_fubenbackpic[i];
		m_fubenrushbtn[i] = handle.m_fubenrushbtn[i];
		m_fubenenterbtn[i] = handle.m_fubenenterbtn[i];
		m_cardcolor[i] = handle.m_cardcolor[i];
		m_cardpic[i] = handle.m_cardpic[i];
	}
	for (int i = 0; i < 11; i++)
	{
		m_chapteropensw[i] = handle.m_chapteropensw[i];
	}
}
void crJXJUIFubenUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIFubenUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_modeRaido = str;
		break;
	case 1:
		m_chapterRadioGroup = str;
		break;
	case 2:
		m_fubenRadio = str;
		break;
	case 3:
		m_hardlvRadio = str;
		break;
	case 4:
		m_resetBtn = str;
		break;
	case 5:
		m_fubenopensw[0] = str;
		break;
	case 6:
		m_fubenopensw[1] = str;
		break;
	case 7:
		m_fubenopensw[2] = str;
		break;
	case 8:
		m_fubenopensw[3] = str;
		break;
	case 9:
		m_fubenopensw[4] = str;
		break;
	case 10:
		m_fubenopensw[5] = str;
		break;
	case 11:
		m_chapteropensw[0] = str;
		break;
	case 12:
		m_chapteropensw[1] = str;
		break;
	case 13:
		m_chapteropensw[2] = str;
		break;
	case 14:
		m_chapteropensw[3] = str;
		break;
	case 15:
		m_chapteropensw[4] = str;
		break;
	case 16:
		m_chapteropensw[5] = str;
		break;
	case 17:
		m_chapteropensw[6] = str;
		break;
	case 18:
		m_chapteropensw[7] = str;
		break;
	case 19:
		m_chapteropensw[8] = str;
		break;
	case 20:
		m_chapteropensw[9] = str;
		break;
	case 21:
		m_chapteropensw[10] = str;
		break;
	case 22:
		m_formationicon[0] = str;
		break;
	case 23:
		m_formationicon[1] = str;
		break;
	case 24:
		m_formationicon[2] = str;
		break;
	case 25:
		m_formationinput[0] = str;
		break;
	case 26:
		m_formationinput[1] = str;
		break;
	case 27:
		m_formationinput[2] = str;
		break;
	case 28:
		m_fubenbackpic[0] = str;
		break;
	case 29:
		m_fubenbackpic[1] = str;
		break;
	case 30:
		m_fubenbackpic[2] = str;
		break;
	case 31:
		m_fubenbackpic[3] = str;
		break;
	case 32:
		m_fubenbackpic[4] = str;
		break;
	case 33:
		m_fubenbackpic[5] = str;
		break;
	case 34:
		m_fubenrushbtn[0] = str;
		break;
	case 35:
		m_fubenrushbtn[1] = str;
		break;
	case 36:
		m_fubenrushbtn[2] = str;
		break;
	case 37:
		m_fubenrushbtn[3] = str;
		break;
	case 38:
		m_fubenrushbtn[4] = str;
		break;
	case 39:
		m_fubenrushbtn[5] = str;
		break;
	case 40:
		m_fubenenterbtn[0] = str;
		break;
	case 41:
		m_fubenenterbtn[1] = str;
		break;
	case 42:
		m_fubenenterbtn[2] = str;
		break;
	case 43:
		m_fubenenterbtn[3] = str;
		break;
	case 44:
		m_fubenenterbtn[4] = str;
		break;
	case 45:
		m_fubenenterbtn[5] = str;
		break;
	case 46:
		m_cardsw[0] = str;
		break;
	case 47:
		m_cardsw[1] = str;
		break;
	case 48:
		m_cardsw[2] = str;
		break;
	case 49:
		m_cardcolor[0] = str;
		break;
	case 50:
		m_cardcolor[1] = str;
		break;
	case 51:
		m_cardcolor[2] = str;
		break;
	case 52:
		m_cardcolor[3] = str;
		break;
	case 53:
		m_cardcolor[4] = str;
		break;
	case 54:
		m_cardcolor[5] = str;
		break;
	case 55:
		m_fubensw[0] = str;
		break;
	case 56:
		m_fubensw[1] = str;
		break;
	case 57:
		m_fubensw[2] = str;
		break;
	case 58:
		m_ratesw[0] = str;
		break;
	case 59:
		m_ratesw[1] = str;
		break;
	case 60:
		m_ratesw[2] = str;
		break;
	case 61:
		m_pageupbtn = str;
		break;
	case 62:
		m_pagedownbtn = str;
		break;
	case 63:
		m_cardpic[0] = str;
		break;
	case 64:
		m_cardpic[1] = str;
		break;
	case 65:
		m_cardpic[2] = str;
		break;
	case 66:
		m_cardpic[3] = str;
		break;
	case 67:
		m_cardpic[4] = str;
		break;
	case 68:
		m_cardpic[5] = str;
		break;
	case 69:
		m_fubenpic = str;
		break;
	case 70:
		m_bosspic = str;
		break;
	case 71:
		m_enter = str;
		break;
	case 72:
		m_sweep = str;
		break;
	case 73:
		m_chapterscroll = str;
		break;
	case 74:
		m_defaultpic = str;
		break;
	case 75:
		m_pagesw = str;
		break;
	case 76:
		m_pagesw2 = str;
		break;
	case 77:
		m_mingjianginput = str;
		break;
	case 78:
		m_chongzhiinput = str;
		break;
	case 79:
		m_mingjiangBtn = str;
		break;
	case 80:
		m_characterSize = atoi(str.c_str());
		break;
	case 81:
		crArgumentParser::appAtoVec(str,m_textColor);
		break;
	case 82:
		m_strBtZuDui = str;
		break;
	}
}
void crJXJUIFubenUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		crData *canvasdata = m_this->getDataClass();
		if (canvasdata)
		{		////

			void *param;
			crData *data = playerData ->getDataClass();
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int perpagenum = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFubenPerPageNum,viplv).c_str()));
			unsigned char mingJiangOpenLv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMingJiangZhiLuOpenLv,viplv).c_str()));

			unsigned char mylv = 0;
			bool chapterchange = false;
			bool fubensizechange = false;
			crStateSet *ss1;
			crTexture2D *tex2d;
			canvasdata->getParam(WCHDATA_JXJFubenCurPage,param);
			int curpage = *(int *)param;
			canvasdata->getParam(WCHDATA_JXJCanvasFubenIDVec,param);
			std::vector<int> *fubenidvec = (std::vector<int> *)param;
			fubenidvec->clear();
			data->getParam(WCHDATA_JXJFormationInfoVec, param);
			FormationInfoVec *formationinfovec = (FormationInfoVec *)param;
			if (playerData->getMainRole())
			{
				crData *mainroledata = playerData->getMainRole()->getDataClass();
				mainroledata->getParam(WCHDATA_Level,param);
				mylv = *(unsigned char *)param;
			}
			data->getParam(WCHDATA_JXJFormationInfoVec, param);
			crTableIO::StrVec trecord,crecord;

			ref_ptr<crTableIO>trooptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
			ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
			ref_ptr<crTableIO>chaptertab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChapterTab);
			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			ref_ptr<crRadioGroupWidgetNode> modeRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_modeRaido));
			ref_ptr<crRadioGroupWidgetNode> chapterRadioGroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_chapterRadioGroup));
			ref_ptr<crRadioGroupWidgetNode> fubenRadio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_fubenRadio));
			ref_ptr<crRadioGroupWidgetNode> hardlvRadio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_hardlvRadio));
			ref_ptr<crButtonWidgetNode> resetBtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_resetBtn));
			ref_ptr<crButtonWidgetNode> pageupbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_pageupbtn));
			ref_ptr<crButtonWidgetNode> pagedownbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_pagedownbtn));
			ref_ptr<crImageBoxWidgetNode> fubenpic = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_fubenpic));
			ref_ptr<crImageBoxWidgetNode> bosspic = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_bosspic));
			ref_ptr<crButtonWidgetNode> enter = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_enter));
			ref_ptr<crButtonWidgetNode> sweep = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_sweep));
			ref_ptr<crScrollBarWidgetNode> chapterscroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_chapterscroll));
			crMultiSwitch *pagesw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_pagesw));
			crMultiSwitch *pagesw2 = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_pagesw2));
			ref_ptr<crHypertextWidgetNode> mingjianginput = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_mingjianginput));
			//ref_ptr<crStaticTextWidgetNode> chongzhiinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_chongzhiinput));
			ref_ptr<crMultiSwitch>  jiangliSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_chongzhiinput));
			ref_ptr<crRadioWidgetNode> mingjiangBtn = dynamic_cast<crRadioWidgetNode *>(m_this->getWidget(m_mingjiangBtn));
			//if(mingjiangBtn)mingjiangBtn->setVisiable(false);
			ref_ptr<crNode> fubenbackpic[6] = {NULL};
			crMultiSwitch *fubenopensw[6] = {NULL};
			crMultiSwitch *chapteropensw[11] = {NULL};
			ref_ptr<crButtonWidgetNode> formationicon[3] = {NULL};
			ref_ptr<crStaticTextWidgetNode> formationinput[3] = {NULL};
			crMultiSwitch *cardsw[3] = {NULL};
			crMultiSwitch *fubensw[3] = {NULL};
			crMultiSwitch *ratesw[3] = {NULL};
			crMultiSwitch *cardcolor[6] = {NULL};
			ref_ptr<crImageBoxWidgetNode> cardpic[6] = {NULL};
			ref_ptr<crButtonWidgetNode> fubenrushbtn[6] = {NULL};
			ref_ptr<crButtonWidgetNode> fubenenterbtn[6] = {NULL};
			ref_ptr<crButtonWidgetNode> btZuDui = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_strBtZuDui));
			if (mingjiangBtn.valid() && mylv < mingJiangOpenLv)
			{
				mingjiangBtn->setVisiable(false);
			}
			if (trooptab.valid())
			{
				if(fubenpic.valid())
				{
					fubenpic->setVisiable(false);
				}
				if (enter.valid())
				{
					enter->setEnable(false);
				}
				if (sweep.valid())
				{
					sweep->setEnable(false);
				}
				for(int i = 0; i < 6; i++)
				{
					if (i < 3)
					{
						formationicon[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_formationicon[i]));
						formationinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_formationinput[i]));
						cardsw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_cardsw[i]));
						fubensw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_fubensw[i]));
						ratesw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_ratesw[i]));
						if (formationicon[i].valid())
						{
							formationicon[i]->setVisiable(true);
						}
						if (formationinput[i].valid())
						{
							formationinput[i]->setVisiable(false);
						}
						if (cardsw[i])
						{
							cardsw[i]->setActiveSwitchSet(0);
						}
						if (fubensw[i])
						{
							fubensw[i]->setActiveSwitchSet(0);
						}
						if (ratesw[i])
						{
							ratesw[i]->setActiveSwitchSet(0);
						}
					}
					fubenopensw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_fubenopensw[i]));
					fubenrushbtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_fubenrushbtn[i]));
					fubenenterbtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_fubenenterbtn[i]));
					fubenbackpic[i] = m_this->getChildNode(m_fubenbackpic[i]);
					cardcolor[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_cardcolor[i]));
					cardpic[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_cardpic[i]));
					if (fubenopensw[i])
					{
						fubenopensw[i]->setActiveSwitchSet(0);
					}
					if (fubenbackpic[i].valid())
					{
						fubenbackpic[i]->setVisiable(false);
					}
					//if (fubenrushbtn[i])
					//{
					//	fubenrushbtn[i]->setVisiable(false);
					//}
					//if (fubenenterbtn[i])
					//{
					//	fubenenterbtn[i]->setVisiable(false);
					//}
					if (cardcolor[i])
					{
						cardcolor[i]->setActiveSwitchSet(0);
					}
				}
			}
			int iconindex = trooptab->getTitleIndex("icon");
			int colorindex = itemtab->getTitleIndex("品质");
			int iconindex2 = itemtab->getTitleIndex("icon");
			int tindex = 0;
			bool ifhaspic;
			//////////////////编队
			for (FormationInfoVec::iterator fitr = formationinfovec->begin();
				 tindex < 3;++tindex)
			{
				ifhaspic = false;
				if (fitr != formationinfovec->end())
				{
					if ((*fitr)!=NULL && (*fitr)->getAbstractID() > 0)
					{
						if (trooptab->queryOneRecord(0,crArgumentParser::appItoa((*fitr)->getAbstractID()),trecord) >= 0 )
						{
							if (formationicon[tindex].valid())
							{
								ifhaspic = true;
								formationicon[tindex]->setVisiable(true);
								crStateSet *state_set = dynamic_cast<crObject *>(( dynamic_cast<crGroup *>(formationicon[tindex]->getChild(0)))->getChild(0))->getDrawable(0)->getStateSet();
								crTexture2D *texture_2d = dynamic_cast<CRCore::crTexture2D *>(state_set->getTextureAttribute(0,crStateAttribute::TEXTURE));
								if(texture_2d)
									texture_2d->setImage(0,texture_2d->getImageDataRequestHandler()->requestImageFile(trecord[iconindex],texture_2d));

								//formationicon[tindex]->setImageName(trecord[iconindex]);
								//formationicon[tindex]->setVisiable(true);
							}
							if (formationinput[tindex].valid())
							{
								formationinput[tindex]->setString(crArgumentParser::appItoa((*fitr)->getCount()));
								formationinput[tindex]->setVisiable(true);
							}
						}
						crVector2i equips = (*fitr)->getEquips();
						if (cardsw[tindex])
						{
							//
							if (equips[0] > 0)
							{
								if (equips[1] > 0)
								{
									cardsw[tindex]->setActiveSwitchSet(3);
								}
								else
								{
									cardsw[tindex]->setActiveSwitchSet(1);
								}
							}
							else
							{
								if (equips[1] > 0)
								{
									cardsw[tindex]->setActiveSwitchSet(2);
								}
								else
								{
									cardsw[tindex]->setActiveSwitchSet(0);
								}
							}
							//+
							int _cardcolor = 0;
							for (int i = 0 ; i < 2 ; i++)
							{
								if (equips[i] > 0)
								{
									crecord.clear();
									if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(equips[i]),crecord) >= 0 )
									{
										_cardcolor = atoi(crecord[colorindex].c_str());
										//if (_cardcolor > CardColor_Orange)
										//{
										//	_cardcolor = CardColor_Orange;
										//}
										if (cardcolor[tindex * 2 + i])
										{
											cardcolor[tindex * 2 + i]->setActiveSwitchSet(_cardcolor+1);
										}
										if (cardpic[tindex * 2 + i].valid())
										{
											cardpic[tindex * 2 + i]->setImageName(crecord[iconindex2]);
										}
									}
								}
							}
							//
						}
					}
					++fitr;
				}
				if(!ifhaspic)
				{
					crStateSet *state_set = dynamic_cast<crObject *>(( dynamic_cast<crGroup *>(formationicon[tindex]->getChild(0)))->getChild(0))->getDrawable(0)->getStateSet();
					crTexture2D *texture_2d = dynamic_cast<CRCore::crTexture2D *>(state_set->getTextureAttribute(0,crStateAttribute::TEXTURE));
					if(texture_2d)
						texture_2d->setImage(0,texture_2d->getImageDataRequestHandler()->requestImageFile(m_defaultpic,texture_2d));
				}
			}
			if (modeRadioGroup.valid() && chapterRadioGroup.valid()/* && hardlvRadio*/)
			{
				//for (int k = 0; k<modeRadioGroup->getRadioGroup().size();k++)
				//{
				//	modeRadioGroup->getRadio(k)->setEnable(false);
				//}
				int mode = modeRadioGroup->getSelect();
				int chapterindex = chapterRadioGroup->getSelect() + chapterscroll->getValue() + 0.5;
				int hardlvindex = 0;//hardlvRadio->getSelect();
				if (m_chapterindex != chapterindex)
				{
					m_chapterindex = chapterindex;
					chapterchange = true;
				}
				if (pagesw && pagesw2)
				{
					pagesw->setActiveSwitchSet(mode);
					pagesw2->setActiveSwitchSet(mode);
					chapterchange = true;
				}
				if (m_modeindex != mode)
				{
					m_modeindex = mode;
					chapterchange = true;
				}
				//if (m_hardlvindex!=hardlvindex)
				//{
				//	m_hardlvindex = hardlvindex;
				//	chapterchange = true;
				//}
				int cursel = fubenRadio->getSelect();
				////////////////////////////////////////////////
				int chapteridindex = chaptertab->getTitleIndex("id");
				int modeid = chaptertab->getTitleIndex("mode");
				int prochapidindex = chaptertab->getTitleIndex("前置id");
				int ciconid = chaptertab->getTitleIndex("chaptericon");
				int cicon1id = chaptertab->getTitleIndex("chaptericon高亮");
				int cicon2id = chaptertab->getTitleIndex("chaptericon灰");
				/////////////////////////////////////////////////
				int chapterid = fubentab->getTitleIndex("chapterid");
				//int sceneidindex = fubentab->getTitleIndex("sceneid");
				int iconid = fubentab->getTitleIndex("icon");
				int icon1id = fubentab->getTitleIndex("icon高亮");
				int icon2id = fubentab->getTitleIndex("icon灰");
				int profubenidindex = fubentab->getTitleIndex("前置id");
				int hardlvid = fubentab->getTitleIndex("难度");
				int fubenpicindex = fubentab->getTitleIndex("副本pic");
				int bosspicindex = fubentab->getTitleIndex("将领icon");
				int needlvindex = fubentab->getTitleIndex("需求等级");
				int mingjianginfo = fubentab->getTitleIndex("副本描述");
				bool result = true;
				std::vector<int> DisableRowVec;
				std::string iconfile1;
				crMultiSwitch *radioButton;
				crTableIO::DataVec records,records2;
				crTableIO::StrVec recordpic;
				chaptertab->queryRecords(modeid,crArgumentParser::appItoa(mode),records2);
				if (records2.size()>chapterindex)
				{
					fubentab->queryRecords(chapterid,records2[chapterindex][chapteridindex],hardlvid,crArgumentParser::appItoa(hardlvindex),records);
				}
				std::string iconfile;
				int i = 0;
				unsigned short fubenid = 0;
				unsigned short selfubenid = 0;
				int row = - (curpage - 1) * perpagenum;
				int rowcount = records.size();
				crRadioGroupWidgetNode::RadioGroup&radioGroup = fubenRadio->getRadioGroup();
				crRadioGroupWidgetNode::RadioGroup&radioGroup2 = chapterRadioGroup->getRadioGroup();
				crRadioGroupWidgetNode::RadioGroup::iterator itr2 = radioGroup.begin();
				crTableIO::DataVec::iterator itr = records.begin();
				crRadioGroupWidgetNode::RadioGroup::iterator itrchap2 = radioGroup2.begin();
				crTableIO::DataVec::iterator itrchap = records2.begin();
				if(mingjianginput.valid())mingjianginput->clearText();
				crTableIO::StrVec record;
				if (data)
				{
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJFubenProgressMap,param);
					FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
					/////////////////////////////////////////////////////////////
					///////												 ////////
					///////               fubenradio                     ////////
					///////												 ////////
					/////////////////////////////////////////////////////////////
					int totalpagenum = ceil((float)rowcount/(float)perpagenum);
					canvasdata->inputParam(WCHDATA_JXJFubenTotalPage,&totalpagenum);
					for(;itr != records.end() && row<rowcount; ++row)
					{
						if (row < 0)
						{
							itr++;
							continue;
						}
						if(itr2 != radioGroup.end())
						{
							fubenid = atoi((*itr)[0].c_str());
							if (fubenid > 0)
							{
								fubenidvec->push_back(fubenid);
								crVector2i profubenid;
								FubenProgressMap::iterator itrcur;
								crArgumentParser::appAtoVec((*itr)[profubenidindex].c_str(),profubenid);
								if (profubenid[0]>0 || profubenid[1]>0)
								{
									if (fubenProgress->size()>0)
									{
										for (int k = 0; k < 2; k++)
										{
											if (profubenid[k]>0)
											{
												FubenProgressMap::iterator itrpro = fubenProgress->find((unsigned short)profubenid[k]);
												if (itrpro == fubenProgress->end())
												{
													result = false;
												}
												else if (itrpro->second->getComplete() == 0)
												{
													result = false;
												}
											}
										}
									}
									else
									{
										result = false;
									}
								}
								if (mylv < atoi((*itr)[needlvindex].c_str()))
								{
									result = false;
								}
								if(!result)
								{
									//不可进入
									DisableRowVec.push_back(row);
									continue;
								}
								fubenRadio->getRadio(i)->setEnable(true);
								//int childindex = 0;
								iconfile1 = (*itr)[icon1id];
								if(cursel == i)
								{
									selfubenid = fubenid;
									//childindex = 1;
									iconfile1 = (*itr)[iconid];
									itrcur = fubenProgress->find((unsigned short)fubenid);
									if (itrcur != fubenProgress->end() && itrcur->second->getComplete() > 0)
									{
										if (sweep.valid())
										{
											sweep->setEnable(true);
										}
									}
									if (enter.valid())
									{
										enter->setEnable(true);
									}
								}

								radioButton = itr2->second->getButton();
								radioButton->setVisiable(true);
								ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

								tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
								if(tex2d)
								{
									if(tex2d->getImageNameID().compare(iconfile1)!=0)
										tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
								}
								else
								{
									tex2d = new crTexture2D;
									tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
									tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
									tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
									tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
									tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
									tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
									ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
								}

								//if (fubenopensw[i])
								//{
								//	fubenopensw[i]->setActiveSwitchSet(1);
								//}
								itrcur = fubenProgress->find((unsigned short)fubenid);
								if (itrcur == fubenProgress->end())
								{
									//if (fubenopensw[i])
									//{
									//	fubenopensw[i]->setActiveSwitchSet(1);
									//}
									//if (fubenrushbtn[i])
									//{
									//	fubenrushbtn[i]->setVisiable(true);
									//}
									if(fubensw[i])
									{
										fubensw[i]->setActiveSwitchSet(1);
									}

								}
								if (itrcur != fubenProgress->end() && itrcur->second->getComplete() == 0)
								{
									if(fubensw[i])
									{
										fubensw[i]->setActiveSwitchSet(1);
									}
								}

								if (itrcur != fubenProgress->end() && itrcur->second->getComplete() > 0)
								{
									if (ratesw[i])
									{
										int starcount = itrcur->second->getStarCount();
										if (starcount > 0)
										{
											ratesw[i]->setActiveSwitchSet(starcount);
										}
									}
								}
								if (fubenbackpic[i].valid())
								{
									fubenbackpic[i]->setVisiable(true);
								}
								//if (fubenenterbtn[i])
								//{
								//	fubenenterbtn[i]->setVisiable(true);
								//}
							}
						}
						else
						{
							break;
						}
						++itr2;
						++i;
						++itr;
						//data->inputParam(WCHDATA_JXJCurSelForgeEquipID,&selfubenid);
					}
					if (i != m_chapterfubensize)
					{
						m_chapterfubensize = i;
						fubensizechange = true;
					}
					if(i<radioGroup.size())
					{
						if(!DisableRowVec.empty())
						{
							for( int j = 0;
								itr2 != radioGroup.end() && j<DisableRowVec.size() &&itr != records.end();
								++itr2,++itr,++j )
							{
								//fubenRadio->getRadio(i)->setEnable(false);
								fubenid = atoi((*itr)[0].c_str());
								if(cursel == i)
								{
									selfubenid = fubenid;
									//if (fubenpic && fubenpicindex>0)
									//{
									//	fubenpic->setImageName((*itr)[fubenpicindex]);
									//}
									//if (bosspic && bosspicindex > 0)
									//{
									//	bosspic->setImageName((*itr)[bosspicindex]);
									//}
								}
								iconfile1 = (*itr)[icon2id];
								radioButton = itr2->second->getButton();
								radioButton->setVisiable(true);
								ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

								tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
								if(tex2d)
								{
									if(tex2d->getImageNameID().compare(iconfile1)!=0)
										tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
								}
								else
								{
									tex2d = new crTexture2D;
									tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
									tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
									tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
									tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
									tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
									tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
									ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
								}
								if (fubenbackpic[i].valid())
								{
									fubenbackpic[i]->setVisiable(true);
								}
								++i;
							}
						}
					}
					else if(fubensizechange)
					{
						chapterchange = true;
					}
					for( ;
						itr2 != radioGroup.end();
						++itr2 )
					{
						radioButton = itr2->second->getButton();
						radioButton->setVisiable(false);
					}
					if(i>0) i--;
					if(cursel>i)
					{
						crTableIO::StrVec currecord;
						cursel = i;
						fubenRadio->select(i);
						//fubenRadio->doEvent(WCH_UI_SelectChange);
						selfubenid = fubenid;
					}
					if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) >= 0 )
					{
						if(btZuDui.valid())
						{
							if(mylv<atoi(record[needlvindex].c_str()))
							{
								btZuDui->setEnable(false);
								if(resetBtn.valid())
									resetBtn->setEnable(false);
							}
							else
							{
								btZuDui->setEnable(true);
								if(resetBtn.valid())
									resetBtn->setEnable(true);
							}
						}
						
						std::string file;
						//file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						//if(mingjianginput)mingjianginput->setHypertext(file);
						if(mingjianginput.valid())mingjianginput->clearText();
						file = record[mingjianginfo];
						std::vector<float>v_i;
						ItemMap itemMap;
						rcfg::ConfigScript cfg_script(&itemMap);
						cfg_script.Add("Hypertext");
						cfg_script.Push("Hypertext");
						cfg_script.Add("CharacterSize",m_characterSize);
						v_i.clear();
						for (int vi = 0; vi < 4; vi++)
						{
							v_i.push_back(m_textColor[vi]);
						}
						cfg_script.Add("Color",v_i);

						cfg_script.Add("Content");
						cfg_script.Push("Content",1);
						cfg_script.Add("Text",file);
						cfg_script.Pop();

						cfg_script.Pop();
						if(mingjianginput.valid())mingjianginput->setHypertext(cfg_script);
					}
					if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(selfubenid),recordpic) >= 0 )
					{
						if (fubenpic.valid() && fubenpicindex>0)
						{
							fubenpic->setVisiable(true);
							fubenpic->setImageName(recordpic[fubenpicindex]);
						}
						if (bosspic.valid() && bosspicindex > 0)
						{
							bosspic->setImageName(recordpic[bosspicindex]);
						}
					}
					FubenProgressMap::iterator itrcur2;
					itrcur2 = fubenProgress->find((unsigned short)selfubenid);
					if (itrcur2 != fubenProgress->end() && itrcur2->second->getComplete() > 1)
					{
						if (jiangliSwitch.valid())jiangliSwitch->setActiveSwitchSet(1);
						if (resetBtn.valid() && mode == 1)
						{
							unsigned char type = FT_Fuben;
							data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
							data->inputParam(WCHDATA_JXJFubenOrChengchiID,&selfubenid);
						}
					}
					else if (jiangliSwitch.valid())jiangliSwitch->setActiveSwitchSet(0);
					canvasdata->inputParam(WCHDATA_JXJSelFubenID,&selfubenid);
					if(fubenRadio.valid())
					{
						fubenRadio->doEvent(WCH_JXJFubenSelectChange);
					}
					/////////////////////////////////////////////////////////////
					///////												 ////////
					///////              chapterradio                    ////////
					///////												 ////////
					/////////////////////////////////////////////////////////////
					DisableRowVec.clear();
					if (m_value != chapterscroll->getValue())
					{
						chapterchange = true;
					}
					if (chapterchange)
					{
						//////////////////////////////////////////////////////////////////////////
						for (int i_ = 0; i_ < 11; i_++)
						{
							chapteropensw[i_] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_chapteropensw[i_]));
							if (chapteropensw[i_])
							{
								chapteropensw[i_]->setActiveSwitchSet(0);
							}
						}
						//////////////////////////////////////////////////////////////////////////
						i = 0;
						row = 0;
						int count = 0;
						int chapterid = 0;
						rowcount = records2.size();
						for( ;itrchap != records2.end() && row<rowcount; ++row)
						{
							result = true;
							if (row < 0)
							{
								itrchap++;
								continue;
							}
							chapterid = atoi((*itrchap)[0].c_str());
							if (chapterid > 0)
							{
								if (atoi((*itrchap)[prochapidindex].c_str())>0)
								{
									if (fubenProgress->size()>0)
									{
										FubenProgressMap::iterator itrpro = fubenProgress->find((unsigned short)atoi((*itrchap)[prochapidindex].c_str()));
										if (itrpro == fubenProgress->end())
										{
											result = false;
										}
										else if (itrpro->second->getComplete() == 0)
										{
											result = false;
										}
									}
									else
									{
										result = false;
									}
									if(!result)
									{
										count++;
									}
								}
								++itrchap;
							}
						}
						itrchap2 = radioGroup2.begin();
						itrchap = records2.begin();
						int maxsize = radioGroup2.size();
						//if (rowcount != m_chaptersize)
						//{
						//	m_chaptersize = rowcount;
						m_value = chapterscroll->getValue();
						if (chapterscroll.valid())
						{
							if (rowcount - count <=  maxsize)
							{
								chapterscroll->outerSetValue(0.0f);
								chapterscroll->setEnable(false);
								//chapterscroll->setRange(0,rowcount - count - maxsize);
							}
							else
							{
								chapterscroll->setEnable(true);
								chapterscroll->setRange(0,rowcount - count - maxsize);
								chapterscroll->setLineValue(1.0f);
								chapterscroll->setPageValue(maxsize);
							}
						}
						//}
						if (chapterscroll.valid())
						{
							row = -(int)(chapterscroll->getValue() + 0.5);
						}
						int chapterindex2 = chapterRadioGroup->getSelect();
						for( ;itrchap != records2.end() && row<rowcount; ++row)
						{
							result = true;
							if (row < 0)
							{
								itrchap++;
								continue;
							}
							if(itrchap2 != radioGroup2.end())
							{
								chapterid = atoi((*itrchap)[0].c_str());
								if (chapterid > 0)
								{
									if (atoi((*itrchap)[prochapidindex].c_str())>0)
									{
										if (fubenProgress->size()>0)
										{
											FubenProgressMap::iterator itrpro = fubenProgress->find((unsigned short)atoi((*itrchap)[prochapidindex].c_str()));
											if (itrpro == fubenProgress->end())
											{
												result = false;
											}
											else if (itrpro->second->getComplete() == 0)
											{
												result = false;
											}
										}
										else
										{
											result = false;
										}
										if(!result)
										{
											DisableRowVec.push_back(row);
											continue;
										}
									}
									chapterRadioGroup->getRadio(i)->setEnable(true);
									int childindex = 0;
									iconfile1 = (*itrchap)[ciconid];
									if(chapterindex2 == i)
									{
										//selfubenid = fubenid;
										//childindex = 1;
										iconfile1 = (*itrchap)[cicon1id];
									}

									radioButton = itrchap2->second->getButton();
									radioButton->setVisiable(true);
									ss1 = dynamic_cast<crObject *>(radioButton->getChild(childindex))->getDrawable(0)->getStateSet();

									tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
									if(tex2d)
									{
										if(tex2d->getImageNameID().compare(iconfile1)!=0)
											tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
									}
									else
									{
										tex2d = new crTexture2D;
										tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
										tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
										tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
										tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
										tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
										tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
										ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
									}
									if (rowcount - count <=  maxsize)
									{
										if (chapteropensw[i])
										{
											chapteropensw[i]->setActiveSwitchSet(1);
										}
										if (i > 0)
										{
											if (chapteropensw[i - 1])
											{
												chapteropensw[i - 1]->setActiveSwitchSet(0);
											}
										}
									}
									else
									{
										if (chapteropensw[i])
										{
											chapteropensw[i]->setActiveSwitchSet(0);
										}
										if (m_value >= rowcount - count - maxsize)
										{
											if (chapteropensw[i])
											{
												chapteropensw[i]->setActiveSwitchSet(1);
											}
											if (i > 0)
											{
												if (chapteropensw[i - 1])
												{
													chapteropensw[i - 1]->setActiveSwitchSet(0);
												}
											}
										}
									}
								}
							}
							else
							{
								break;
							}
							++itrchap2;
							++i;
							++itrchap;
							//data->inputParam(WCHDATA_JXJCurSelForgeEquipID,&selfubenid);
						}
						////////////////////////////////////////////////////////////
						
						crTableIO::DataVec recordfVec,recordffVec,recordfbVec;
						chaptertab->queryRecords(modeid,crArgumentParser::appItoa(0),recordfVec);
						int chapterCountIndex = recordfVec.size() - 1;
						int lastfubenid = atoi(recordfVec[chapterCountIndex][prochapidindex].c_str());

						fubentab->queryRecords(0,recordfVec[chapterCountIndex][0],recordffVec);
						int maxfubenid = lastfubenid + recordffVec.size();

						fubentab->queryRecords(0,recordfVec[0][0],recordffVec);
						int startfubenid = atoi(recordffVec[0][0].c_str());
						int Count = 0;
						data->getParam(WCHDATA_JXJFubenProgressMap,param);
						FubenProgressMap *fubenProgress = (FubenProgressMap *)param;
						for (FubenProgressMap::iterator itr = fubenProgress->begin();
							itr != fubenProgress->end();
							++itr)
						{
							if(itr->first >= startfubenid && itr->first <= maxfubenid)
							{
								Count++;
							}
						}
						if (startfubenid + Count > lastfubenid)
						{
							for (int i_ = 0; i_ < 11; i_++)
							{
								chapteropensw[i_] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_chapteropensw[i_]));
								if (chapteropensw[i_])
								{
									chapteropensw[i_]->setActiveSwitchSet(0);
								}
							}
						}
						///////////////////////////////////////////////////////////////////
						if(i<radioGroup2.size())
						{
							if(!DisableRowVec.empty())
							{
								for( int j = 0;
									itrchap2 != radioGroup2.end() && j<DisableRowVec.size() &&itrchap != records2.end();
									++itrchap2,++itrchap,++j )
								{
									chapterRadioGroup->getRadio(i)->setEnable(false);
									iconfile1 = (*itrchap)[cicon2id];
									radioButton = itrchap2->second->getButton();
									if(iconfile1.empty())
									{
										radioButton->setVisiable(false);
									}
									else
									{
										radioButton->setVisiable(true);
										ss1 = dynamic_cast<crObject *>(radioButton->getChild(0))->getDrawable(0)->getStateSet();

										tex2d = dynamic_cast<crTexture2D *>(ss1->getTextureAttribute(0,crStateAttribute::TEXTURE));
										if(tex2d)
										{
											if(tex2d->getImageNameID().compare(iconfile1)!=0)
												tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
										}
										else
										{
											tex2d = new crTexture2D;
											tex2d->setFilter(crTexture2D::MIN_FILTER, crTexture::LINEAR);
											tex2d->setFilter(crTexture2D::MAG_FILTER, crTexture::LINEAR);
											tex2d->setWrap(crTexture::WRAP_S,crTexture::CLAMP_TO_BORDER);
											tex2d->setWrap(crTexture::WRAP_T,crTexture::CLAMP_TO_BORDER);
											tex2d->setWrap(crTexture::WRAP_R,crTexture::CLAMP_TO_BORDER);
											tex2d->setImage(0,tex2d->getImageDataRequestHandler()->requestImageFile(iconfile1,tex2d));
											ss1->setTextureAttributeAndModes(0,tex2d,crStateAttribute::ON);
										}
									}
									++i;
								}
							}
						}
						for( ;
							itrchap2 != radioGroup2.end();
							++itrchap2 )
						{
							radioButton = itrchap2->second->getButton();
							radioButton->setVisiable(false);
						}
						if(i>0) i--;
						if(chapterindex2>i)
						{
							//cursel = i;
							chapterRadioGroup->select(i);
						}
					}

					canvasdata->getParam(WCHDATA_JXJFubenTotalPage,param);
					int totalpage = *(int *)param;
					if (pagedownbtn.valid())
					{
						if (curpage == totalpage)
						{
							pagedownbtn->setVisiable(false);
						}
						else
						{
							pagedownbtn->setVisiable(true);
						}

					}
					if (pageupbtn.valid())
					{
						if (curpage == 1)
						{
							pageupbtn->setVisiable(false);
						}
						else
						{
							pageupbtn->setVisiable(true);
						}
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}
		}

	}
	/////
}
/////////////////////////////////////////
//
//crJXJUISelectFubenMethod
//
/////////////////////////////////////////
crJXJUISelectFubenMethod::crJXJUISelectFubenMethod():
	m_this(NULL){}
crJXJUISelectFubenMethod::crJXJUISelectFubenMethod(const crJXJUISelectFubenMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJUISelectFubenMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUISelectFubenMethod::addParam(int i, const std::string& str)
{
}

void crJXJUISelectFubenMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crData *canvasdata = canvas->getDataClass();
		void *param;
		canvasdata->getParam(WCHDATA_JXJSelFubenID,param);
		unsigned short fubenid = *(unsigned short *)param;
		unsigned char type = FT_Fuben;
		crData *playerData = playerGameData->getDataClass();
		playerData->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
		playerData->inputParam(WCHDATA_JXJFubenOrChengchiID,&fubenid);
	}
}
/////////////////////////////////////////
//
//crJXJUICheckFubenNeedMethod
//
/////////////////////////////////////////
crJXJUICheckFubenNeedMethod::crJXJUICheckFubenNeedMethod():
	m_this(NULL){}
crJXJUICheckFubenNeedMethod::crJXJUICheckFubenNeedMethod(const crJXJUICheckFubenNeedMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_enterFuben(handle.m_enterFuben),
	m_info(handle.m_info)
{
}
void crJXJUICheckFubenNeedMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUICheckFubenNeedMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_enterFuben = str;
		break;
	case 1:
		m_info = str;
		break;
	}
}

void crJXJUICheckFubenNeedMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crData *canvasdata = canvas->getDataClass();
		ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		void *param;
		canvasdata->getParam(WCHDATA_JXJSelFubenID,param);
		unsigned short fubenid = *(unsigned short *)param;
		crTableIO::StrVec record;
		if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) >= 0 )
		{
			int junlingid = fubentab->getTitleIndex("军令");
			int nameid = fubentab->getTitleIndex("name");
			int junlingneed = atoi(record[junlingid].c_str());
			crData *playerData = playerGameData->getDataClass();
			playerData->getParam(WCHDATA_JXJJunling,param);
			unsigned short junling = *(unsigned short *)param;
			if (junling>=junlingneed*100)
			{
				ref_ptr<crCanvasNode>enterFuben = crFilterRenderManager::getInstance()->findCanvas(m_enterFuben);
				if (enterFuben.valid())
				{
					ref_ptr<crStaticTextWidgetNode> info = dynamic_cast<crStaticTextWidgetNode *>(enterFuben->getWidget(m_info));
					if(info.valid())
					{
						std::string param1 = record[nameid];
						std::string param2 = crArgumentParser::appItoa(junlingneed);
						int texid = 1040;//是否进入副本[%s]并扣除[%s个军令]?
						crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 2;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
						noticeHandle->inputParam(WCHDATA_NoticeParam2,&param2);
						std::string output;
						noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
						crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						info->setString(output);
					}
				}
				unsigned char type = FT_Fuben;
				playerData->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
				playerData->inputParam(WCHDATA_JXJFubenOrChengchiID,&fubenid);
				crFilterRenderManager::getInstance()->doModal(m_enterFuben);
			}
			else
			{
				int texid = 1041;//"军令不足，请购买军令！"
				crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
				noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
				int mode = 1;
				noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
				crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
				//std::string tipstr = "军令不足，请购买军令！";
				//ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
				//if (tipcanvas)
				//{
				//	ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
				//	if (tiptitle)
				//	{
				//		//tiptitle->setString(std::string("购买军令"));
				//	}
				//	ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
				//	if (tipcontent)
				//	{
				//		tipcontent->setString(tipstr);
				//	}
				//	crFilterRenderManager::getInstance()->doModal(tipcanvas);
				//}
			}
		}
	}
}
///////////////////////////////////////////
////
////crJXJRecvvCheckFubenNeedMethod
////
///////////////////////////////////////////
//crJXJRecvvCheckFubenNeedMethod::crJXJRecvvCheckFubenNeedMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvvCheckFubenNeedMethod::crJXJRecvvCheckFubenNeedMethod(const crJXJRecvvCheckFubenNeedMethod& handle):
//	crMethod(handle),
//	m_enterFuben(handle.m_enterFuben),
//	m_info(handle.m_info),
//	m_tiptitle(handle.m_tiptitle),
//	m_tipcontent(handle.m_tipcontent),
//	m_tipcanvas(handle.m_tipcanvas)
//{
//}
//void crJXJRecvvCheckFubenNeedMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvvCheckFubenNeedMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_enterFuben = str;
//		break;
//	case 1:
//		m_info = str;
//		break;
//	case 2:
//		m_tipcanvas = str;
//		break;
//	case 3:
//		m_tiptitle = str;
//		break;
//	case 4:
//		m_tipcontent = str;
//		break;
//	}
//}
//
//void crJXJRecvvCheckFubenNeedMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			unsigned char success = 0;
//			int playerid = m_this->getPlayerID();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{//验证军令是否充足
//				int fubenid = m_stream->_readInt();
//				void *param;
//				//ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
//				//if(fubentab)
//				//{
//				crRole *mainrole = m_this->getMainRole();
//				if (mainrole)
//				{
//					crData *mainroledata = mainrole->getDataClass();
//					if (mainroledata)
//					{
//						mainroledata->getParam(WCHDATA_JXJJunling,param);
//						unsigned char junling = *(unsigned char *)param;
//						if (junling>0)
//						{
//							success = 1;
//						}
//					}
//				}
//				//}
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(5);
//				stream->_writeUChar(success);
//				stream->_writeInt(fubenid);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvvCheckFubenNeed,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			unsigned char success = m_stream->_readUChar();
//			int fubenid = m_stream->_readInt();
//			//ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
//			//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
//			if(success == 1)
//			{
//				ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
//				crTableIO::StrVec record;
//				fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record);
//				int nameid = fubentab->getTitleIndex("name");
//				ref_ptr<crCanvasNode>enterFuben = dynamic_cast<ref_ptr<crCanvasNode>>(crFilterRenderManager::getInstance()->findCanvas(m_enterFuben));
//				ref_ptr<crStaticTextWidgetNode> info = dynamic_cast<crStaticTextWidgetNode *>(enterFuben->getWidget(m_info));
//				if(info)
//				{
//					std::string str = "是否进入副本【"+record[nameid]+"】并扣除【1个军令】?";
//					info->setString(str);
//				}
//				crFilterRenderManager::getInstance()->doModal(m_enterFuben);
//			}
//			else
//			{
//				std::string tipstr = "军令不足，请购买军令！";
//				ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
//				if (tipcanvas)
//				{
//					ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
//					if (tiptitle)
//					{
//						//tiptitle->setString(std::string("购买军令"));
//					}
//					ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
//					if (tipcontent)
//					{
//						tipcontent->setString(tipstr);
//					}
//					crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIDeductJunlingMethod
//
/////////////////////////////////////////
crJXJUIDeductJunlingMethod::crJXJUIDeductJunlingMethod()
{}
crJXJUIDeductJunlingMethod::crJXJUIDeductJunlingMethod(const crJXJUIDeductJunlingMethod& handle):
	crMethod(handle)
{
}
void crJXJUIDeductJunlingMethod::inputParam(int i, void *param)
{
}
void crJXJUIDeductJunlingMethod::addParam(int i, const std::string& str)
{
}

void crJXJUIDeductJunlingMethod::operator()(crHandle &handle)
{
	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if (playerData && net_conductor)
	{
		void *param;
		playerData->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short fubenid = *(unsigned short *)param;
		ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
		crTableIO::StrVec record;
		if(type==FT_Fuben && fubenid>0 && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) >= 0 )
		{
			CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
			stream->createBuf(2);
			stream->_writeUShort(fubenid);
			CRNetApp::crPlayerDataEventPacket packet;
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvDeductJunling,stream.get());
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvDeductJunlingMethod
//
/////////////////////////////////////////
crJXJRecvDeductJunlingMethod::crJXJRecvDeductJunlingMethod():
	m_netType(GameClient_Game){}
crJXJRecvDeductJunlingMethod::crJXJRecvDeductJunlingMethod(const crJXJRecvDeductJunlingMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvDeductJunlingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvDeductJunlingMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvDeductJunlingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
		//	unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{//验证军令是否充足
				ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
				unsigned short fubenid = m_stream->_readUShort();
				int deductjunlingcount = 0;
				crTableIO::StrVec record;
				if(fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) >= 0 )
				{
					int junlingid = fubentab->getTitleIndex("军令");
					int junlingneed = atoi(record[junlingid].c_str());
					void *param;
					unsigned short nowjunling = 0;
					crData *data = m_this->getDataClass();
					if (data)
					{
						data->excHandle(MAKECREPARAM(WCH_LockData,1));
						data->getParam(WCHDATA_JXJJunling,param);
						unsigned short *junling = (unsigned short *)param;
						if (*junling>=junlingneed*100)
						{
							*junling -= junlingneed*100;
							deductjunlingcount = junlingneed;
							//success = 1;
						}
						else
						{
							*junling = 0;
						}
						nowjunling = *junling;
						data->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(2);
					//stream->_writeUChar(success);
					stream->_writeUShort(nowjunling);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvDeductJunling,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				///游戏日志
				std::string logdata = crArgumentParser::appItoa(fubenid) + "," + crArgumentParser::appItoa(deductjunlingcount);
				GameLogData gamelog(Log_DeductJunling,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			//unsigned char success = m_stream->_readUChar();
			unsigned short nowjunling = m_stream->_readUShort();
			//void*param;
			//ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
			//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
			crData *data = m_this->getDataClass();
			data->inputParam(WCHDATA_JXJJunling,&nowjunling);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIBuyJunlingMethod
//
/////////////////////////////////////////
crJXJUIBuyJunlingMethod::crJXJUIBuyJunlingMethod():
	m_copperColor(255,255,255,255)
{
}

crJXJUIBuyJunlingMethod::crJXJUIBuyJunlingMethod(const crJXJUIBuyJunlingMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_copperColor(handle.m_copperColor)
{
}

void crJXJUIBuyJunlingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIBuyJunlingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_copperColor);
		break;
	}
}

void crJXJUIBuyJunlingMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		void *param;
		crData *data = playerData->getDataClass();
		bool goldenough = false;
		bool ifjunling = false;
		bool ifbuycount = false;
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str()));
		//int perprice = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJunlingPrice,viplv).c_str()));
		int totalcount = 0;//(int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuyJunlingOnceCount,viplv).c_str()));
		int goldneed = 0;//perprice * totalcount;
		crTableIO::StrVec record;
		ref_ptr<crTableIO>junlingcosttab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJunlingCostTab);
		data->getParam(WCHDATA_JXJBuyJunlingTimer,param);
		unsigned short timer = *(unsigned short *)param;
		data->getParam(WCHDATA_JXJBuyJunlingCount,param);
		unsigned char count = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJTechBuyJunlingLv, param);
		unsigned char techjunlinglv = *(unsigned char *)param;
		int totalpriceindex = 0; 
		if (techjunlinglv == 0)
		{
			totalpriceindex = junlingcosttab->getTitleIndex("购买价格");
		}
		else
		{
			totalpriceindex = junlingcosttab->getTitleIndex("科技价格");
		}
		int totalcountindex = junlingcosttab->getTitleIndex("获得数量");
		int id = timer + 1; 
		if (id < 1)
		{
			id = 1;
		}
		if(junlingcosttab->queryOneRecord(0,crArgumentParser::appItoa(id),record) >= 0)
		{
			goldneed = atoi(record[totalpriceindex].c_str());
			totalcount = atoi(record[totalcountindex].c_str());
		}
	
		ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
		if (msgCanvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
			ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
			ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));

			data->getParam(WCHDATA_JXJGoldingot,param);
			int mygold = *(int *)param;
			data->getParam(WCHDATA_JXJGiftGold,param);
			int giftgold = *(int*)param;
			mygold += giftgold;
			if(count > 0)
			{
				ifbuycount = true;
				//if(okBtn)okBtn->setEnable(true);
			}
			else
			{
				ifbuycount = false;
				//if(okBtn)okBtn->setEnable(false);
			}
			if(goldneed < mygold)
			{
				goldenough = true;
				//if(okBtn)okBtn->setEnable(true);
			}
			else
			{
				goldenough = false;
				//if(okBtn)okBtn->setEnable(false);
			}
			data->getParam(WCHDATA_JXJJunling,param);
			unsigned short junling = *(unsigned short *)param;
			if (junling/100 + totalcount <= maxcount)
			{
				ifjunling = true;
				//success = 1;
			}
			else
			{
				ifjunling = false;
			}
			//if(title)title->setString(L"购买军令");

			data->getParam(WCHDATA_JXJGoldCostHintInt,param);
			unsigned int ifhint = *(unsigned int *)param & JXJGoldCostType_BuyJunlingHint;
			if (ifbuycount)
			{
				if (ifjunling)
				{
					if (goldenough)
					{
						if(okBtn.valid())okBtn->setEnable(true);
						if (ifhint)
						{
							int hinttype = JXJGoldCostType_BuyJunlingHint;
							crData *braindata = crBrain::getInstance()->getDataClass();
							braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);
							std::vector<float>v_i;
							ItemMap itemMap;
							rcfg::ConfigScript cfg_script(&itemMap);
							cfg_script.Add("Hypertext");
							cfg_script.Push("Hypertext");
							cfg_script.Add("Content");
							cfg_script.Push("Content");
							cfg_script.Add("Text","您确认要花费");
							cfg_script.Pop();

							cfg_script.Add("Content");
							cfg_script.Push("Content",2);
							v_i.clear();
							v_i.push_back(m_copperColor[0]);
							v_i.push_back(m_copperColor[1]);
							v_i.push_back(m_copperColor[2]);
							v_i.push_back(m_copperColor[3]);
							cfg_script.Add("Color",v_i);
							char tmpText[160],tmpText2[80];
							sprintf(tmpText,"%d礼金/元宝\0",goldneed);
							cfg_script.Add("Text",tmpText);
							cfg_script.Pop();

							cfg_script.Add("Content");
							cfg_script.Push("Content",3);
							sprintf(tmpText2,"来购买【%d个军令】吗？\0",totalcount);
							cfg_script.Add("Text",tmpText2);
							cfg_script.Pop();
							cfg_script.Pop();
							if(msg.valid())msg->setHypertext(cfg_script);
						}

						if (msgCanvas.valid())
						{
							crData *dlgData = msgCanvas->getDataClass();
							int commandtype = CDP_Widget;
							dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
							dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
							if (ifhint)
							{
								crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
							}
							else
							{
								if(okBtn.valid())okBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
							}
						}
					}
					else
					{
						playerData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2036,NULL));//元宝不足
					}
				}
				else
				{
					playerData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2037,NULL));//军令过多
				}
			}
			else
			{
				playerData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2038,NULL));//购买次数已用完
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJBuyJunlingMethod
//
/////////////////////////////////////////
crJXJBuyJunlingMethod::crJXJBuyJunlingMethod()
{}
crJXJBuyJunlingMethod::crJXJBuyJunlingMethod(const crJXJBuyJunlingMethod& handle):
	crMethod(handle)
{
}
void crJXJBuyJunlingMethod::inputParam(int i, void *param)
{
}
void crJXJBuyJunlingMethod::addParam(int i, const std::string& str)
{
}

void crJXJBuyJunlingMethod::operator()(crHandle &handle)
{
	//CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
	//stream->createBuf(0);
	//stream->_writeUChar(1);
	CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	CRNetApp::crPlayerDataEventPacket packet;
	CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvBuyJunling,NULL/*stream.get()*/);
	net_conductor->getNetManager()->sendPacket("all",packet);
}
/////////////////////////////////////////
//
//crJXJRecvBuyJunlingMethod
//
/////////////////////////////////////////
crJXJRecvBuyJunlingMethod::crJXJRecvBuyJunlingMethod():
	m_netType(GameClient_Game){}
crJXJRecvBuyJunlingMethod::crJXJRecvBuyJunlingMethod(const crJXJRecvBuyJunlingMethod& handle):
	crMethod(handle),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent),
	m_tipcanvas(handle.m_tipcanvas)
{
}
void crJXJRecvBuyJunlingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvBuyJunlingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tiptitle = str;
		break;
	case 2:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvBuyJunlingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			crTableIO::StrVec record;
			ref_ptr<crTableIO>junlingcosttab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJunlingCostTab);
			int perprice = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJunlingPrice,viplv).c_str()));
			int totalcount = 0;//(int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBuyJunlingOnceCount,viplv).c_str()));
			int maxcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str()));
			int totalprice = 0;//totalcount * perprice;
			bool needdeductgold = false;
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJBuyJunlingCount,param);
			unsigned char *count = (unsigned char *)param;
			data->getParam(WCHDATA_JXJBuyJunlingTimer,param);
			unsigned short *buyjunlingtimer = (unsigned short *)param;
			data->getParam(WCHDATA_JXJTechBuyJunlingLv, param);
			unsigned char techjunlinglv = *(unsigned char *)param;
			//*buyjunlingtimer = 0 ;
			int totalpriceindex = 0;
			if (techjunlinglv == 0)
			{
				totalpriceindex = junlingcosttab->getTitleIndex("购买价格");
			}
			else
			{
				totalpriceindex = junlingcosttab->getTitleIndex("科技价格");
			}
			int totalcountindex = junlingcosttab->getTitleIndex("获得数量");
			int id = *buyjunlingtimer + 1;//maxcount - *count + 1; 
			if (id < 1)
			{
				id = 1;
			}
			if(junlingcosttab->queryOneRecord(0,crArgumentParser::appItoa(id),record) >= 0)
			{
				totalprice = atoi(record[totalpriceindex].c_str());
				totalcount = atoi(record[totalcountindex].c_str());
			}
			if (totalcount > 0)
			{
				unsigned char success = 0;
				int playerid = m_this->getPlayerID();
				//int nowmygold = 0;
				unsigned char nowbuyjunlingcount = 0;
				unsigned short nowjunling = 0;
				//返回信息
				if(playerData.valid())
				{
					//int fubenid = m_stream->_readInt();
					if(*count > 0)
					{
						data->getParam(WCHDATA_JXJJunling,param);
						unsigned short *junling = (unsigned short *)param;
						if ((*junling)/100 <= maxcount - totalcount)
						{
							if (data)
							{
								MoneyChangeData moneydata(totalprice,"购买军令");
								m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
								//data->getParam(WCHDATA_JXJGoldingot,param);
								//int *mygold = (int *)param;
								if (moneydata.first == 0)
								{
									//*mygold -= totalprice;
									*junling += totalcount*100;
									if(*junling>maxcount*100)
										*junling = maxcount*100;
									*count -= 1;
									*buyjunlingtimer += 1 ;
									success = 1;
								}
								else
								{
									success = 3;
								}
								//nowmygold = *mygold;
								nowbuyjunlingcount = *count;
							}
							//success = 1;
						}
						else
						{
							success = 0;
						}
						nowjunling = *junling;
					}
					else
					{
						success = 2;
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(6);
					stream->_writeUChar(success);
					stream->_writeUShort(nowjunling);
					//stream->_writeInt(nowmygold);
					stream->_writeUChar(nowbuyjunlingcount);
					stream->_writeUShort(*buyjunlingtimer);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvBuyJunling,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					///游戏日志
					std::string logdata = crArgumentParser::appVectoa(crVector2i(success,nowjunling));
					GameLogData gamelog(Log_BuyJunling,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
			if (needdeductgold && playerData.valid())
			{
				crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
				callback->savePlayerData(playerData.get());
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			unsigned char success = m_stream->_readUChar();
			unsigned short nowjunling = m_stream->_readUShort();
			//int nowgold = m_stream->_readInt();
			unsigned char nowjunlingcount = m_stream->_readUChar();
			unsigned short nowjunlingtimer = m_stream->_readUShort();
			//ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
			//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
			crData *data = m_this -> getDataClass();
			if(data)
			{
				data->getParam(WCHDATA_JXJJunling,param);
				unsigned short *oldjunling = (unsigned short *)param;
				data->inputParam(WCHDATA_JXJBuyJunlingCount,&nowjunlingcount);
				data->inputParam(WCHDATA_JXJBuyJunlingTimer,&nowjunlingtimer);
				int extra = nowjunling/100 - (*oldjunling/100);
				if(extra>0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_JunLing,extra));
				(*oldjunling) = nowjunling;
			}
			std::string tipstr = "购买后军令将超限，【购买失败】，请先去副本战斗吧！"; //0
			if (success == 1)  //1
			{
				tipstr = "购买军令成功！";
			}
			if (success == 2)
			{
				tipstr = "今日已达最大购买次数，请明天再购买军令吧！";
			}
			if (success == 3)
			{
				tipstr = "元宝不足，请充值！";
			}
			if (success != 1)
			{
				ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
				if (tipcanvas.valid())
				{
					ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
					if (tiptitle.valid())
					{
						tiptitle->setString(std::string("购买军令"));
					}
					ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
					if (tipcontent.valid())
					{
						tipcontent->setString(tipstr);
					}
					crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckItemTypeMethod
//
/////////////////////////////////////////
crJXJCheckItemTypeMethod::crJXJCheckItemTypeMethod():
	m_this(NULL)
{
}
crJXJCheckItemTypeMethod::crJXJCheckItemTypeMethod(const crJXJCheckItemTypeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_usebtn(handle.m_usebtn),
	m_displaybtn(handle.m_displaybtn),
	m_salebtn(handle.m_salebtn),
	m_splitbtn(handle.m_splitbtn)
{
}
void crJXJCheckItemTypeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJCheckItemTypeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_usebtn = str;
		break;
	case 1:
		m_displaybtn = str;
		break;
	case 2:
		m_salebtn = str;
		break;
	case 3:
		m_splitbtn = str;
		break;
	}
}
void crJXJCheckItemTypeMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		void *param;
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		if (itemtab.valid())
		{
			ref_ptr<crButtonWidgetNode> usebtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_usebtn));
			ref_ptr<crButtonWidgetNode> displaybtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_displaybtn));
			ref_ptr<crButtonWidgetNode> salebtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_salebtn));
			ref_ptr<crButtonWidgetNode> splitbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_splitbtn));
			int priceindex = itemtab->getTitleIndex("回购价格");
			int typeindex = itemtab->getTitleIndex("类型");
			/*int selectid = selectNode->getData();*/
			crTableIO::StrVec record;
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->getParam(WCHDATA_JXJSaleItemID,param);//第几个格子
			unsigned char selectid = *(unsigned char*)param;
			if (usebtn.valid())
			{
				usebtn->setEnable(true);
			}
			if(displaybtn.valid())
			{
				displaybtn->setEnable(true);
			}
			if(selectid>=0)
			{
				crData *data = myPlayer->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				int count = 0;
				int itemid = 0;
				if(selectid < itembagvec->size() && !(*itembagvec)[selectid])
				{
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					return;
				}
				itemid = (*itembagvec)[selectid]->getItemID();
				count = (*itembagvec)[selectid]->getItemCount();
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0)
				{
					int price = atoi(record[priceindex].c_str());
					int type = atoi(record[typeindex].c_str());
					int scriptindex = itemtab->getTitleIndex("脚本");
					if (type != IT_Equip)
					{
						if (record[scriptindex].empty())
						{
							if (usebtn.valid())
							{
								usebtn->setEnable(false);
							}
						}
					}
					if (salebtn.valid())
					{
						if (price>0)
						{
							salebtn->setEnable(true);
						}
						else
						{
							salebtn->setEnable(false);
						}
					}
				}
				else 
				{
					if(usebtn.valid())usebtn->setEnable(false);
					if(splitbtn.valid())splitbtn->setEnable(false);
					if(salebtn.valid())salebtn->setEnable(false);
					if(displaybtn.valid())displaybtn->setEnable(false);
				}
				if (splitbtn.valid())
				{
					if (count>1)
					{
						splitbtn->setEnable(true);
					}
					else
					{
						splitbtn->setEnable(false);
					}
				}

			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJFormationEditMethod
//
/////////////////////////////////////////
crJXJFormationEditMethod::crJXJFormationEditMethod():
	m_this(NULL),
	m_index(0)
{
}
crJXJFormationEditMethod::crJXJFormationEditMethod(const crJXJFormationEditMethod& handle):
	crMethod(handle),
	m_scrollbar(handle.m_scrollbar),
	m_totallead(handle.m_totallead),
	m_totaltroops(handle.m_totaltroops),
	m_perlead(handle.m_perlead),
	m_deductlead1(handle.m_deductlead1),
	m_deductlead2(handle.m_deductlead2),
	m_index(handle.m_index)
{
}
void crJXJFormationEditMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crEditWidgetNode*)param;
		break;
	}
}
void crJXJFormationEditMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_scrollbar = str;
		break;
	case 1:
		m_totallead = str;
		break;
	case 2:
		m_totaltroops = str;
		break;
	case 3:
		m_perlead = str;
		break;
	case 4:
		m_deductlead1 = str;
		break;
	case 5:
		m_deductlead2 = str;
		break;
	case 6:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJFormationEditMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			void *param;
			crData *canvasdata = canvas->getDataClass();
			if (canvasdata)
			{
				canvasdata->getParam(WCHDATA_JXJTempFormationVec,param);
				canvasdata->lock();
				FormationInfoVec *formationinfovec = (FormationInfoVec *)param;
				if (m_index < formationinfovec->size())
				{
					if ((*formationinfovec)[m_index] == NULL)
					{
						canvasdata->unlock();
						m_this->clearString();
						return;
					}
				}
				canvasdata->unlock();
			}
			int totalleadcount = 0;
			int totaltroopscount = 0;
			int perleadcount = 0;
			int countmax = 0;
			int deductleadcount1 = 0;
			int deductleadcount2 = 0;
			int leftleadcount = 0;
			bool ifclearstring = false;
			ref_ptr<crScrollBarWidgetNode> scrollbar = dynamic_cast<crScrollBarWidgetNode *>(canvas->getWidget(m_scrollbar));

			ref_ptr<crStaticTextWidgetNode> totallead = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_totallead));
			ref_ptr<crStaticTextWidgetNode> totaltroops = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_totaltroops));
			ref_ptr<crStaticTextWidgetNode> perlead = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_perlead));
			ref_ptr<crStaticTextWidgetNode> deductlead1 = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_deductlead1));
			ref_ptr<crStaticTextWidgetNode> deductlead2 = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_deductlead2));

			if (totallead.valid())
			{
				totalleadcount = atoi(totallead->getUTF8String().c_str());
			}
			if (totaltroops.valid())
			{
				totaltroopscount = atoi(totaltroops->getUTF8String().c_str());
			}
			if (perlead.valid())
			{
				perleadcount = atoi(perlead->getUTF8String().c_str());
			}
			if (deductlead1.valid())
			{
				deductleadcount1 = atoi(deductlead1->getUTF8String().c_str());
			}
			if (deductlead2.valid())
			{
				deductleadcount2 = atoi(deductlead2->getUTF8String().c_str());
			}
			leftleadcount = totalleadcount - deductleadcount1 - deductleadcount2;
			if (perleadcount!=0)
			{
				if (leftleadcount/perleadcount > totaltroopscount)
				{
					countmax = totaltroopscount;
				}
				else
				{
					countmax = leftleadcount/perleadcount;
				}
				int count = atoi(m_this->getUTF8String().c_str());
				if (count < 0)
				{
					count = 0;
				}
				else
				{
					if (count>countmax)
					{
						count = countmax;
					}
				}

				if (!m_this->getUTF8String().empty())
				{
					m_this->setString(crArgumentParser::appItoa(count));
				}
				else
				{
					ifclearstring = true;
				}
				if (scrollbar.valid())
				{
					scrollbar->setValue(count);
				}
				if(ifclearstring)
				{
					m_this->clearString();
				}
			}
		}

	}
}
/////////////////////////////////////////
//
//crJXJFormationjiangkaTipInfoMethod
//
/////////////////////////////////////////
crJXJFormationjiangkaTipInfoMethod::crJXJFormationjiangkaTipInfoMethod():
	m_ea(NULL),
	m_this(NULL),
	m_cardlvsw("XingJi")
{
}
crJXJFormationjiangkaTipInfoMethod::crJXJFormationjiangkaTipInfoMethod(const crJXJFormationjiangkaTipInfoMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_backboard(handle.m_backboard),
	m_ea(NULL),
	m_this(NULL),
	m_card(handle.m_card),
	m_guojia(handle.m_guojia),
	m_shuxing(handle.m_shuxing),
	m_bingzhong(handle.m_bingzhong),
	m_leixing(handle.m_leixing),
	m_jinengmiaoshu(handle.m_jinengmiaoshu),
	m_nameimage(handle.m_nameimage),
	m_jineng(handle.m_jineng),
	m_row(handle.m_row),
	m_col(handle.m_col),
	m_cardlvsw(handle.m_cardlvsw)
{
}
void crJXJFormationjiangkaTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJFormationjiangkaTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_card = str;
		break;
	case 2:
		m_backboard = str;
		break;
	case 3:
		m_guojia = str;
		break;
	case 4:
		m_shuxing = str;
		break;
	case 5:
		m_bingzhong = str;
		break;
	case 6:
		m_leixing = str;
		break;
	case 7:
		m_jinengmiaoshu = str;
		break;
	case 8:
		m_nameimage = str;
		break;
	case 9:
		m_jineng = str;
		break;
	case 10:
		m_row = atoi(str.c_str());
		break;
	case 11:
		m_col = atoi(str.c_str());
		break;
	}
}
void crJXJFormationjiangkaTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(tipsCanvas.valid() && playerData)
	{
		//ref_ptr<crHypertextWidgetNode> info2 = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_info2));

		void *param;
		ref_ptr<crHypertextWidgetNode> jinengmiaoshu = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_jinengmiaoshu));
		ref_ptr<crImageBoxWidgetNode> card = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_card));
		ref_ptr<crImageBoxWidgetNode> nameimage = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_nameimage));
		crMultiSwitch *backboard = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_backboard));
		crMultiSwitch *cardlvsw = dynamic_cast<crMultiSwitch *>(tipsCanvas->getChildNode(m_cardlvsw));
		crData *data = playerData->getDataClass();
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		unsigned char openbagnum = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
		int itemid = 0;
		if(m_this)
		{
			//playerdata
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			crData *canvasdata = canvas ->getDataClass();
			canvasdata->lock();
			canvasdata->getParam(WCHDATA_JXJTempFormationVec, param);
			FormationInfoVec *tempfomationvec = (FormationInfoVec *)param;
			itemid = (*tempfomationvec)[m_row]->getEquips()[m_col];
			canvasdata->unlock();
			if(itemid>0)
			{
				ref_ptr<crTableIO>troopsEquipTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);

				//int jinengmiaoshuid = troopsEquipTab->getTitleIndex("技能描述");
				int cardid = troopsEquipTab->getTitleIndex("picture");
				int nameimageid = troopsEquipTab->getTitleIndex("姓名");
				int backboardid = troopsEquipTab->getTitleIndex("品质");
				int guojiaid = troopsEquipTab->getTitleIndex("国家");
				crTableIO::StrVec record;
				if (troopsEquipTab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
				{
					//std::string file;
					if(jinengmiaoshu.valid())
					{
						//file = record[jinengmiaoshuid];
						//if(!file.empty())
						//{
						//	jinengmiaoshu->clearText();
						//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
						//	jinengmiaoshu->setHypertext(file);
						//}
						//else
						//{
						//	jinengmiaoshu->clearText();
						//}
						ItemMap itemMap;
						rcfg::ConfigScript outscript(&itemMap);
						crVector2i item(itemid,0);
						playerData->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
						jinengmiaoshu->setHypertext(outscript);
					}
					if(card.valid())
					{
						card->setImageName(record[cardid].c_str());
					}
					if(nameimage.valid())
					{
						nameimage->setImageName(record[nameimageid].c_str());
					}
					if(backboard)
					{
						int cardcolor = atoi(record[backboardid].c_str());
						backboard->setActiveSwitchSet(cardcolor);
						//if (cardcolor < CardColor_Orange)
						//{
						//	backboard->setActiveSwitchSet(cardcolor);
						//	if (cardlvsw)
						//	{
						//		cardlvsw->setActiveSwitchSet(0);
						//	}
						//}
						//else
						//{
						//	backboard->setActiveSwitchSet(cardcolor);//CardColor_Orange
						//	if (cardlvsw)
						//	{
						//		cardlvsw->setActiveSwitchSet(cardcolor - CardColor_Orange + 1);
						//	}
						//}
					}

					const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
					const crBoundingBox &iconbox = m_this->getBoundBox();
					const crBoundingBox &tips = tipsCanvas->getBoundBox();
					float posx = (tips.m_max[0]-tips.m_min[0])*0.5;
					float posy = (tips.m_max[1]-tips.m_min[1])*0.5;
					crVector3 pos(iconbox.m_max[0],iconbox.m_max[1],0.0f);
					/////////////////////////////////////////
					crVector3 pos2(iconbox.m_min[0] ,iconbox.m_min[1],0.0f);
					float posx2,posy2;
					/////////////////////////////////////////
					if (pos2[0] >= 0)
					{
						posx2 = pos2[0] - posx;
					}
					else
					{
						posx2 = pos[0] + posx;
					}
					if (pos2[1] >= 0)
					{
						posy2 = pos[1] - posy;
					}
					else
					{
						posy2 = pos2[1] + posy;
					}
					crVector2 mouse(crVector2(posx2,posy2));
					/////////////////////////////////////////
					tipsCanvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f) * mat);
					tipsCanvas->setCanFocus(false);
					crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
				}
			}
			else
			{
				crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
			}
		}
		else
		{
			crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),false);
		}
	}
}
///////////////////////////////////////////
////
////crJXJUIUpdateTechLvMethod
////
///////////////////////////////////////////
//crJXJUIUpdateTechLvMethod::crJXJUIUpdateTechLvMethod():
//	m_this(NULL)
//{
//}
//crJXJUIUpdateTechLvMethod::crJXJUIUpdateTechLvMethod(const crJXJUIUpdateTechLvMethod& handle):
//	crMethod(handle),
//	m_index(handle.m_index),
//	m_tiptitle(handle.m_tiptitle),
//	m_tipcontent(handle.m_tipcontent),
//	m_tipcanvas(handle.m_tipcanvas)
//{
//
//}
//void crJXJUIUpdateTechLvMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crJXJUIUpdateTechLvMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_index = atoi(str.c_str());
//		break;
//	case 1:
//		m_tipcanvas = str;
//		break;
//	case 2:
//		m_tiptitle = str;
//		break;
//	case 3:
//		m_tipcontent = str;
//		break;
//	}
//}
//void crJXJUIUpdateTechLvMethod::operator()(crHandle &handle)
//{	
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this)
//	{
//		int techid = 0;
//		crData *roledata = playerGameData->getMainRole()->getDataClass();
//		crData *data = playerGameData->getDataClass();
//		data->excHandle(MAKECREPARAM(WCH_LockData,1));
//		roledata->excHandle(MAKECREPARAM(WCH_LockData,1));
//		if (roledata)
//		{
//			void *param;
//			switch (m_index)
//			{
//			case Tech_Jingbing:
//				techid = WCHDATA_JXJTechJingBinglv;
//				data->getParam(WCHDATA_JXJTechJingBinglv, param);
//				break;
//			case Tech_JianJia:
//				techid = WCHDATA_JXJTechJianJialv;
//				data->getParam(WCHDATA_JXJTechJianJialv, param);
//				break;
//			case Tech_QiangRen:
//				techid = WCHDATA_JXJTechQiangRenlv;
//				data->getParam(WCHDATA_JXJTechQiangRenlv, param);
//				break;
//			case Tech_GuiMou:
//				techid = WCHDATA_JXJTechGuiMoulv;
//				data->getParam(WCHDATA_JXJTechGuiMoulv, param);
//				break;
//			case Tech_GongCheng:
//				techid = WCHDATA_JXJTechGongChenglv;
//				data->getParam(WCHDATA_JXJTechGongChenglv, param);
//				break;
//			case Tech_YuanGong:
//				techid = WCHDATA_JXJTechYuanGonglv;
//				data->getParam(WCHDATA_JXJTechYuanGonglv, param);
//				break;
//			case Tech_SuGong:
//				techid = WCHDATA_JXJTechSuGonglv;
//				data->getParam(WCHDATA_JXJTechSuGonglv, param);
//				break;
//			case Tech_QiangXing:
//				techid = WCHDATA_JXJTechQiangXinglv;
//				data->getParam(WCHDATA_JXJTechQiangXinglv, param);
//				break;
			//case Tech_TunTian:
			//	techid = WCHDATA_JXJTechFoodlv;
			//	data->getParam(WCHDATA_JXJTechFoodlv, param);
			//	break;
			//case Tech_FanZhi:
			//	techid = WCHDATA_JXJTechHorselv;
			//	data->getParam(WCHDATA_JXJTechHorselv, param);
			//	break;
			//case Tech_YeLian:
			//	techid = WCHDATA_JXJTechIronlv;
			//	data->getParam(WCHDATA_JXJTechIronlv, param);
			//	break;
			//case Tech_FanMao:
			//	techid = WCHDATA_JXJTechWoodlv;
			//	data->getParam(WCHDATA_JXJTechWoodlv, param);
			//	break;
//			case Tech_ZhaoMu:
//				techid = WCHDATA_JXJTechZhaoMulv;
//				data->getParam(WCHDATA_JXJTechZhaoMulv, param);
//				break;
//			case Tech_QiaoJiang:
//				techid = WCHDATA_JXJTechBuildingCDlv;
//				data->getParam(WCHDATA_JXJTechBuildingCDlv, param);
//				break;
//			case Tech_RenDe:
//				techid = WCHDATA_JXJTechRenDelv;
//				data->getParam(WCHDATA_JXJTechRenDelv, param);
//				break;
//			case Tech_ZhengShui:
//				techid = WCHDATA_JXJTechZhengShuilv;
//				data->getParam(WCHDATA_JXJTechZhengShuilv, param);
//				break;
//			default:
//				break;
//			}
//			if (techid>0)
//			{
//				unsigned char nowlv = *(unsigned char *)param;
//				unsigned char nextlv = nowlv+1;
//				crTableIO::StrVec record;
//				ref_ptr<crTableIO>techtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
//				int lvindex = techtab->getTitleIndex("lv");
//				int achievementindex = techtab->getTitleIndex("战功");
//				int characterlvindex = techtab->getTitleIndex("人物等级");
//				roledata->getParam(WCHDATA_JXJAchievement, param);
//				int achievement = *(int *)param;
//				roledata->getParam(WCHDATA_Level, param);
//				unsigned char characterlevel = *(unsigned char *)param;
//				if(techtab->queryOneRecord(0,crArgumentParser::appItoa(techid),lvindex,crArgumentParser::appItoa((int)nextlv),record) >= 0 )
//				{
//					std::string tipstr;
//					bool success = false;
//					if (characterlevel >= atoi(record[characterlvindex].c_str()))
//					{
//						if(achievement >= atoi(record[achievementindex].c_str()))
//						{
//							success = true;
//						}
//						else
//						{
//							tipstr = "战功不足!";
//						}
//					}
//					else
//					{
//						tipstr = "领主等级不足!";
//					}
//					if (success)
//					{
//						CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
//						stream->createBuf(4);
//						stream->_writeInt(techid);
//						CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
//						CRNetApp::crPlayerDataEventPacket packet;
//						CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUpdateTechLv,stream.get());
//						net_conductor->getNetManager()->sendPacket("all",packet);
//					}
//					else
//					{
//						ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
//						if (tipcanvas)
//						{
//							ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
//							ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
//							if (tipcontent)
//							{
//								tipcontent->setString(tipstr);
//							}
//							crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
//						}
//					}
//				}
//			}
//		}
//		roledata->excHandle(MAKECREPARAM(WCH_LockData,0));
//		data->excHandle(MAKECREPARAM(WCH_LockData,0));
//	}
//}
//
///////////////////////////////////////////
////
////crJXJRecvUpdateTechLvMethod
////
///////////////////////////////////////////
//crJXJRecvUpdateTechLvMethod::crJXJRecvUpdateTechLvMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvUpdateTechLvMethod::crJXJRecvUpdateTechLvMethod(const crJXJRecvUpdateTechLvMethod& handle):
//	crMethod(handle),
//	m_tiptitle(handle.m_tiptitle),
//	m_tipcontent(handle.m_tipcontent),
//	m_tipcanvas(handle.m_tipcanvas)
//{
//}
//void crJXJRecvUpdateTechLvMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvUpdateTechLvMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_tipcanvas = str;
//		break;
//	case 1:
//		m_tiptitle = str;
//		break;
//	case 2:
//		m_tipcontent = str;
//		break;
//	}
//}
//
//void crJXJRecvUpdateTechLvMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_this->getMainRole() && m_this->getMainRole()->getDataClass() && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			unsigned char success = 0;
//			//0 升级失败
//			//1 升级成功
//			//2 人物等级不足
//			//3 战功不足
//			int playerid = m_this->getPlayerID();
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
//			{
//				void *param;
//				int techid = m_stream -> _readInt();
//				crData *roledata = m_this->getMainRole()->getDataClass();
//				crData *data = m_this->getDataClass();
//
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				roledata->excHandle(MAKECREPARAM(WCH_LockData,1));
//				data->getParam(techid,param);
//				unsigned char *nowlv = (unsigned char *)param;
//				unsigned char nextlv = *nowlv+1;
//				crTableIO::StrVec record;
//				ref_ptr<crTableIO>techtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
//				int lvindex = techtab->getTitleIndex("lv");
//				int achievementindex = techtab->getTitleIndex("战功");
//				int characterlvindex = techtab->getTitleIndex("人物等级");
//				roledata->getParam(WCHDATA_JXJAchievement, param);
//				int *achievement = (int *)param;
//				roledata->getParam(WCHDATA_Level, param);
//				unsigned char characterlevel = *(unsigned char *)param;
//				if(techtab->queryOneRecord(0,crArgumentParser::appItoa(techid),lvindex,crArgumentParser::appItoa((int)nextlv),record) >= 0 )
//				{
//					if (characterlevel >= atoi(record[characterlvindex].c_str()))
//					{
//						if(*achievement >= atoi(record[achievementindex].c_str()))
//						{
//							success = 1;
//							*achievement -= atoi(record[achievementindex].c_str());
//							*nowlv = nextlv;
//						}
//						else
//						{
//							success = 3;
//						}
//					}
//					else
//					{
//						success = 2;
//					}
//				}
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				stream->createBuf(10);
//				stream->_writeUChar(success);
//				stream->_writeInt(techid);
//				stream->_writeUChar(*nowlv);
//				stream->_writeInt(*achievement);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUpdateTechLv,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//				roledata->excHandle(MAKECREPARAM(WCH_LockData,0));
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//				///游戏日志
//				std::string logdata = crArgumentParser::appVectoa(crVector3i(success,techid,*nowlv));
//				GameLogData gamelog(Log_UpgradeTechLv,logdata);
//				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			bool cancelTask = false;
//			unsigned char success = m_stream->_readUChar();
//			int techid = m_stream->_readInt();
//			unsigned char nowlv = m_stream->_readUChar();
//			int nowachievement = m_stream->_readInt();
//			void*param;
//			//ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
//			//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
//			crRole *mainrole = m_this->getMainRole();
//			//crRole *mainrole = crMyPlayerData::getInstance()->getCurrentRole();
//			if (mainrole)
//			{
//				crData *mainroledata = mainrole->getDataClass();
//				if (mainroledata)
//				{
//					mainroledata->excHandle(MAKECREPARAM(WCH_LockData,1));
//					mainroledata->getParam(WCHDATA_JXJAchievement,param);
//					int *achievement = (int *)param;
//					*achievement = nowachievement;
//					mainroledata->excHandle(MAKECREPARAM(WCH_LockData,0));
//				}
//			}
//			crData *data = m_this->getDataClass();
//			if (data)
//			{
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				data->getParam(techid,param);
//				unsigned char *techlv = (unsigned char *)param;
//				*techlv = nowlv;
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//			}
//			if (success != 1)
//			{
//				cancelTask = true;
//				std::string tipstr = "升级科技失败！"; //0
//				if (success == 2)
//				{
//					tipstr = "领主等级不足！";
//				}
//				if (success == 3)
//				{
//					tipstr = "战功不足！";
//				}
//				ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
//				if (tipcanvas)
//				{
//					ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
//					ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
//					if (tipcontent)
//					{
//						tipcontent->setString(tipstr);
//					}
//					crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
//				}
//			}
//			handle.outputParam(0,&cancelTask);
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJUpdateTechCanvasMethod
////
///////////////////////////////////////////
//crJXJUpdateTechCanvasMethod::crJXJUpdateTechCanvasMethod():
//	m_this(NULL)
//{
//}
//crJXJUpdateTechCanvasMethod::crJXJUpdateTechCanvasMethod(const crJXJUpdateTechCanvasMethod& handle):
//	crMethod(handle),
//	m_this(NULL),
//	m_achievementinput(handle.m_achievementinput)
//{
//	for (int i = 0; i < 16; i++)
//	{
//		m_techwidget[i] = handle.m_techwidget[i];
//		m_techupgradebtn[i] = handle.m_techupgradebtn[i];
//		m_techlvinput[i] = handle.m_techlvinput[i];
//	}
//}
//void crJXJUpdateTechCanvasMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//void crJXJUpdateTechCanvasMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_techwidget[i] = str;
//		break;
//	case 1:
//		m_techwidget[i] = str;
//		break;
//	case 2:
//		m_techwidget[i] = str;
//		break;
//	case 3:
//		m_techwidget[i] = str;
//		break;
//	case 4:
//		m_techwidget[i] = str;
//		break;
//	case 5:
//		m_techwidget[i] = str;
//		break;
//	case 6:
//		m_techwidget[i] = str;
//		break;
//	case 7:
//		m_techwidget[i] = str;
//		break;
//	case 8:
//		m_techwidget[i] = str;
//		break;
//	case 9:
//		m_techwidget[i] = str;
//		break;
//	case 10:
//		m_techwidget[i] = str;
//		break;
//	case 11:
//		m_techwidget[i] = str;
//		break;
//	case 12:
//		m_techwidget[i] = str;
//		break;
//	case 13:
//		m_techwidget[i] = str;
//		break;
//	case 14:
//		m_techwidget[i] = str;
//		break;
//	case 15:
//		m_techwidget[i] = str;
//		break;
//	case 16:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 17:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 18:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 19:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 20:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 21:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 22:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 23:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 24:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 25:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 26:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 27:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 28:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 29:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 30:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 31:
//		m_techupgradebtn[i-16] = str;
//		break;
//	case 32:
//		m_techlvinput[i-32] = str;
//		break;
//	case 33:
//		m_techlvinput[i-32] = str;
//		break;
//	case 34:
//		m_techlvinput[i-32] = str;
//		break;
//	case 35:
//		m_techlvinput[i-32] = str;
//		break;
//	case 36:
//		m_techlvinput[i-32] = str;
//		break;
//	case 37:
//		m_techlvinput[i-32] = str;
//		break;
//	case 38:
//		m_techlvinput[i-32] = str;
//		break;
//	case 39:
//		m_techlvinput[i-32] = str;
//		break;
//	case 40:
//		m_techlvinput[i-32] = str;
//		break;
//	case 41:
//		m_techlvinput[i-32] = str;
//		break;
//	case 42:
//		m_techlvinput[i-32] = str;
//		break;
//	case 43:
//		m_techlvinput[i-32] = str;
//		break;
//	case 44:
//		m_techlvinput[i-32] = str;
//		break;
//	case 45:
//		m_techlvinput[i-32] = str;
//		break;
//	case 46:
//		m_techlvinput[i-32] = str;
//		break;
//	case 47:
//		m_techlvinput[i-32] = str;
//		break;
//	case 48:
//		m_achievementinput = str;
//		break;
//	}
//}
//void crJXJUpdateTechCanvasMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(myPlayer && m_this)
//	{
//		void *param;
//		crData *data = myPlayer->getDataClass();
//		crData *roledata = myPlayer->getMainRole()->getDataClass();
//		if (data)
//		{
//			data->excHandle(MAKECREPARAM(WCH_LockData,1));
//			roledata->excHandle(MAKECREPARAM(WCH_LockData,1));
//			int techid = 0;
//			ref_ptr<crWidgetNode> techwidget[16] = {NULL};
//			ref_ptr<crButtonWidgetNode> techupgradebtn[16] = {NULL};
//			ref_ptr<crStaticTextWidgetNode> techlvinput[16] = {NULL};
//			crTableIO::StrVec record;
//			ref_ptr<crTableIO>techtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
//			ref_ptr<crStaticTextWidgetNode> achievementinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_achievementinput));
//			for (int i = 0; i<16;i++)
//			{
//				techid = 0;
//				techwidget[i] = m_this->getWidget(m_techwidget[i]);
//				techupgradebtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_techupgradebtn[i]));
//				techlvinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_techlvinput[i]));
//				if (techwidget[i])
//				{
//					crMultiSwitch *multiswitch = dynamic_cast<crMultiSwitch *>(techwidget[i]->getChild(0));
//					if (multiswitch)
//					{
//						multiswitch->setActiveSwitchSet(1);
//					}
//				}
//				if(techupgradebtn[i])
//				{
//					techupgradebtn[i]->setEnable(false);
//				}
//
//				switch (i)
//				{
//				case Tech_Jingbing:
//					techid = WCHDATA_JXJTechJingBinglv;
//					data->getParam(WCHDATA_JXJTechJingBinglv, param);
//					break;
//				case Tech_JianJia:
//					techid = WCHDATA_JXJTechJianJialv;
//					data->getParam(WCHDATA_JXJTechJianJialv, param);
//					break;
//				case Tech_QiangRen:
//					techid = WCHDATA_JXJTechQiangRenlv;
//					data->getParam(WCHDATA_JXJTechQiangRenlv, param);
//					break;
//				case Tech_GuiMou:
//					techid = WCHDATA_JXJTechGuiMoulv;
//					data->getParam(WCHDATA_JXJTechGuiMoulv, param);
//					break;
//				case Tech_GongCheng:
//					techid = WCHDATA_JXJTechGongChenglv;
//					data->getParam(WCHDATA_JXJTechGongChenglv, param);
//					break;
//				case Tech_YuanGong:
//					techid = WCHDATA_JXJTechYuanGonglv;
//					data->getParam(WCHDATA_JXJTechYuanGonglv, param);
//					break;
//				case Tech_SuGong:
//					techid = WCHDATA_JXJTechSuGonglv;
//					data->getParam(WCHDATA_JXJTechSuGonglv, param);
//					break;
//				case Tech_QiangXing:
//					techid = WCHDATA_JXJTechQiangXinglv;
//					data->getParam(WCHDATA_JXJTechQiangXinglv, param);
//					break;
//				case Tech_TunTian:
//					techid = WCHDATA_JXJTechFoodlv;
//					data->getParam(WCHDATA_JXJTechFoodlv, param);
//					break;
//				case Tech_FanZhi:
//					techid = WCHDATA_JXJTechHorselv;
//					data->getParam(WCHDATA_JXJTechHorselv, param);
//					break;
//				case Tech_YeLian:
//					techid = WCHDATA_JXJTechIronlv;
//					data->getParam(WCHDATA_JXJTechIronlv, param);
//					break;
//				case Tech_FanMao:
//					techid = WCHDATA_JXJTechWoodlv;
//					data->getParam(WCHDATA_JXJTechWoodlv, param);
//					break;
//				case Tech_ZhaoMu:
//					techid = WCHDATA_JXJTechZhaoMulv;
//					data->getParam(WCHDATA_JXJTechZhaoMulv, param);
//					break;
//				case Tech_QiaoJiang:
//					techid = WCHDATA_JXJTechBuildingCDlv;
//					data->getParam(WCHDATA_JXJTechBuildingCDlv, param);
//					break;
//				case Tech_RenDe:
//					techid = WCHDATA_JXJTechRenDelv;
//					data->getParam(WCHDATA_JXJTechRenDelv, param);
//					break;
//				case Tech_ZhengShui:
//					techid = WCHDATA_JXJTechZhengShuilv;
//					data->getParam(WCHDATA_JXJTechZhengShuilv, param);
//					break;
//				default:
//					break;
//				}
//				if (techid > 0)
//				{
//					unsigned char nowlv = *(unsigned char *)param;
//
//					if(techlvinput[i])
//					{
//						techlvinput[i]->clearString();
//					}			
//					int lvindex = techtab->getTitleIndex("lv");
//					int achievementindex = techtab->getTitleIndex("战功");
//					int characterlvindex = techtab->getTitleIndex("人物等级");
//					roledata->getParam(WCHDATA_JXJAchievement, param);
//					int achievement = *(int *)param;
//					roledata->getParam(WCHDATA_Level, param);
//					unsigned char characterlevel = *(unsigned char *)param;
//					if(techtab->queryOneRecord(0,crArgumentParser::appItoa(techid),lvindex,crArgumentParser::appItoa((int)nowlv),record) >= 0 )
//					{
//
//						if(characterlevel >= atoi(record[characterlvindex].c_str()))
//						{
//							if(techlvinput[i])
//							{
//								techlvinput[i]->setString(crArgumentParser::appItoa(nowlv));
//							}			
//							if (techupgradebtn[i])
//							{
//								techupgradebtn[i]->setEnable(true);
//							}
//							if (techwidget[i])
//							{
//								crMultiSwitch *multiswitch = dynamic_cast<crMultiSwitch *>(techwidget[i]->getChild(0));
//								if (multiswitch)
//								{
//									multiswitch->setActiveSwitchSet(0);
//								}
//							}
//						}
//					}
//					if (achievementinput)
//					{
//						achievementinput->setString(crArgumentParser::appItoa(achievement));
//					}
//				}
//			}
//			roledata->excHandle(MAKECREPARAM(WCH_LockData,0));
//			data->excHandle(MAKECREPARAM(WCH_LockData,0));
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUITaskListUpdateMethod
//
/////////////////////////////////////////
crJXJUITaskListUpdateMethod::crJXJUITaskListUpdateMethod():
	m_this(NULL)
{
	m_taskColor.set(255.0f,255.0f,255.0f,255.0f);
	m_titleColor.set(0.0f,0.0f,255.0f,255.0f);
}
crJXJUITaskListUpdateMethod::crJXJUITaskListUpdateMethod(const crJXJUITaskListUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_taskradio(handle.m_taskradio),
	m_taskinfo(handle.m_taskinfo),
	m_taskgoal(handle.m_taskgoal),
	m_taskreward(handle.m_taskreward),
	m_getrewardbtn(handle.m_getrewardbtn),
	m_taskColor(handle.m_taskColor),
	m_titleColor(handle.m_titleColor)
{
	for (int i = 0;i<11 ;i++)
	{
		m_foldbtn[i] = handle.m_foldbtn[i];
		m_taskinput[i] = handle.m_taskinput[i];
		if (i<4)
		{
			m_rewardicon[i] = handle.m_rewardicon[i];
		}
	}
}
void crJXJUITaskListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUITaskListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_foldbtn[i] = str;
		break;
	case 1:
		m_foldbtn[i] = str;
		break;
	case 2:
		m_foldbtn[i] = str;
		break;
	case 3:
		m_foldbtn[i] = str;
		break;
	case 4:
		m_foldbtn[i] = str;
		break;
	case 5:
		m_foldbtn[i] = str;
		break;
	case 6:
		m_foldbtn[i] = str;
		break;
	case 7:
		m_foldbtn[i] = str;
		break;
	case 8:
		m_foldbtn[i] = str;
		break;
	case 9:
		m_foldbtn[i] = str;
		break;
	case 10:
		m_foldbtn[i] = str;
		break;
	case 11:
		m_taskinput[i - 11] = str;
		break;
	case 12:
		m_taskinput[i - 11] = str;
		break;
	case 13:
		m_taskinput[i - 11] = str;
		break;
	case 14:
		m_taskinput[i - 11] = str;
		break;
	case 15:
		m_taskinput[i - 11] = str;
		break;
	case 16:
		m_taskinput[i - 11] = str;
		break;
	case 17:
		m_taskinput[i - 11] = str;
		break;
	case 18:
		m_taskinput[i - 11] = str;
		break;
	case 19:
		m_taskinput[i - 11] = str;
		break;
	case 20:
		m_taskinput[i - 11] = str;
		break;
	case 21:
		m_taskinput[i - 11] = str;
		break;
	case 22:
		m_taskradio = str;
		break;
	case 23:
		m_taskinfo = str;
		break;
	case 24:
		m_taskgoal = str;
		break;
	case 25:
		m_taskreward = str;
		break;
	case 26:
		m_rewardicon[0] = str;
		break;
	case 27:
		m_rewardicon[1] = str;
		break;
	case 28:
		m_rewardicon[2] = str;
		break;
	case 29:
		m_rewardicon[3] = str;
		break;
	case 30:
		m_getrewardbtn = str;
		break;
	}
}
void crJXJUITaskListUpdateMethod::displayTaskName(bool expand,std::string title,crGameTask *task,bool &titleresult,int &i,unsigned char mode,int &count)
{
	bool ifvisible = false;
	if (!titleresult)
	{
		if (count == 0)
		{
			if(i != 0)
				i--;
		}
		else
			count = 0;
		
		titleresult=true;
		if (i >= 0)
		{
			if (m_taskinputWidget[i].valid() && m_foldbtnWidget[i].valid())
			{
				m_taskinputWidget[i]->setVisiable(true);
				m_taskinputWidget[i]->setColor(m_titleColor);
				m_taskinputWidget[i]->setString(title);
				m_foldbtnWidget[i]->setVisiable(true);
				if (!expand)
				{
					m_foldbtnWidget[i]->select(false);
				}
				else
				{
					m_foldbtnWidget[i]->select(true);
				}
				i++;
			}
		}
		else
		{
			i++;
		}
	}
	if (expand)
	{
		if (i >= 0)
		{
			if (i<11)
			{
				if (m_taskinputWidget[i].valid() && m_foldbtnWidget[i].valid())
				{
					m_taskinputWidget[i]->setColor(m_taskColor);
					std::string strtaskname = task->getTaskName();
					crRole *mainRole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
					bool isTaskCanActive = false;
					mainRole->doMetierEvent(WCH_IsTaskCanActive, MAKECREPARAM(task,&isTaskCanActive));
					if (mode == 1)
					{
						if (!task->isComplete() && !task->getActivation())
						{
							if(isTaskCanActive)
							{
								strtaskname += "(可接)";
								ifvisible = true;
							}
						}
					}
					else if(!task->isComplete())
					{
						if(task->isTaskCanRefer())
						{
							strtaskname += "(已完成)";
							ifvisible = false;
						}
						else if(task->getActivation())
						{
							strtaskname += "(进行中)";
							ifvisible = true;
						}
					}
					if (ifvisible)
					{
						m_taskinputWidget[i]->setVisiable(true);
						m_taskinputWidget[i]->setString(strtaskname);
						m_foldbtnWidget[i]->setVisiable(false);
						i++;
						count++;
					}
				}
			}
		}
		else
		{
			i++;
		}
	}
	else
	{
		if(!task->isComplete())
		{
			if(task->isTaskCanRefer())
			{	
			}
			else if(task->getActivation())
			{
				count++;
			}
		}
	}
}
void crJXJUITaskListUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		//		void *param;
		ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		if (tasktitletab.valid())
		{
			unsigned char mode;
			bool mainresult = false;
			bool secondaryresult = false;
			bool dailyresult = false;
			bool specialresult = false;
			//ref_ptr<crCheckBoxWidgetNode> foldbtn[11] = {NULL}; 
			//ref_ptr<crStaticTextWidgetNode> taskinput[11] = {NULL}; 
			ref_ptr<crImageBoxWidgetNode> rewardicon[4] = {NULL}; 
			ref_ptr<crRadioGroupWidgetNode> taskradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_taskradio));
			ref_ptr<crHypertextWidgetNode> taskinfo = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_taskinfo));
			ref_ptr<crHypertextWidgetNode> taskgoal = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_taskgoal));
			ref_ptr<crStaticTextWidgetNode> taskreward = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_taskreward));
			ref_ptr<crButtonWidgetNode> getrewardbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_getrewardbtn));

			if (taskradio.valid())
			{
				mode = taskradio->getSelect();
			}
			if (taskinfo.valid())
			{
				taskinfo->clearText();
			}
			if (taskgoal.valid())
			{
				taskgoal->clearText();
			}
			if (taskreward.valid())
			{
				taskreward->clearString();
			}
			if (getrewardbtn.valid())
			{
				//getrewardbtn->setVisiable(false);
				getrewardbtn->setEnable(false);
			}
			int i = 0;
			for (i = 0 ; i< 11; i++)
			{
				m_foldbtnWidget[i] = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_foldbtn[i]));
				m_taskinputWidget[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_taskinput[i]));
				if(m_foldbtnWidget[i].valid())
				{
					m_foldbtnWidget[i]->select(false);
					m_foldbtnWidget[i]->setVisiable(false);
				}
				if(m_taskinputWidget[i].valid())
				{
					m_taskinputWidget[i]->clearString();
					m_taskinputWidget[i]->setVisiable(false);
				}
				if (i < 4)
				{
					rewardicon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_rewardicon[i]));
					if(rewardicon[i].valid())
					{
						rewardicon[i]->setVisiable(false);
					}
				}
			}
			int taskidindex = tasktitletab->getTitleIndex("taskid");
			int titleindex = tasktitletab->getTitleIndex("主题");
			crTableIO::StrVec record,itemrecord;

			crRole *mainRole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
			if(!mainRole) return;
			crData *myMetierData = mainRole->getMetierDataClass();
			if(!myMetierData) return;
			void *param;
			myMetierData->excHandle(MAKECREPARAM(WCH_LockData,1));
			myMetierData->getParam(WCHDATA_GameTaskMap,param);
			GameTaskMap *gameTaskMap = (GameTaskMap *)param;
			if(!gameTaskMap||gameTaskMap->empty())
			{
				myMetierData->excHandle(MAKECREPARAM(WCH_LockData,0));
				return;
			}
			std::string str1,str2,str3,str4,strtaskname;
			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->getParam(WCHDATA_JXJUnfoldTaskType1,param);
			bool mainunfold = *(bool *)param;
			brainData->getParam(WCHDATA_JXJUnfoldTaskType2,param);
			bool secondaryunfold = *(bool *)param;
			brainData->getParam(WCHDATA_JXJUnfoldTaskType3,param);
			bool dailyunfold = *(bool *)param;
			brainData->getParam(WCHDATA_JXJUnfoldTaskType4,param);
			bool specialunfold = *(bool *)param;
			brainData->getParam(WCHDATA_JXJCurChooseTaskID,param);
			int curchoosetaskid = *(int *)param;
			///道具奖励
			crTableIO::StrVec recordtask,recorditem;
			//int awardtype1index = tasktitletab->getTitleIndex("类型1");
			//int itemaward1index = tasktitletab->getTitleIndex("奖励1");
			//crVector3i vec3;

			i = 0;
			std::string textdir = crGlobalHandle::getInstance()->getTextDir();
			std::string file;
			int count = 0;
			for( GameTaskMap::iterator itr = gameTaskMap->begin();
				itr != gameTaskMap->end() && i<11;
				++itr )
			{
				int taskid = itr->second->getTaskID();
				if(tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),record) >= 0 )
				{
					if (taskid == curchoosetaskid)
					{
						file = textdir+itr->second->getHyperText();
						if (taskinfo.valid())
						{
							taskinfo->setHypertext(file);
						}
						if (taskgoal.valid())
						{
							taskgoal->clearText();
							mainRole->doMetierEvent(WCH_DisplayTaskGoal, MAKECREPARAM(itr->second.get(),taskgoal.get()));
						}
						if (taskreward.valid())
						{
							if (itr->second->getGold() > 0)
							{
								taskreward->setString("金钱："+crArgumentParser::appItoa(itr->second->getGold())+"  经验："+crArgumentParser::appItoa(itr->second->getExp()));
							}
							else
							{
								taskreward->setString("经验："+crArgumentParser::appItoa(itr->second->getExp()));
							}
						}
						if (taskidindex > 0 && tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),recordtask)>=0)
						{
							int awardIdx[2] = {0};
							awardIdx[0] = tasktitletab->getTitleIndex("奖励1");
							awardIdx[1] = tasktitletab->getTitleIndex("奖励2");
							crVector4i awardVec;
							//int iconboxindex = 0;
							for (int i = 0; i < 2; i++)
							{
								if (recordtask[awardIdx[i]] == "") continue;
								crArgumentParser::appAtoVec(recordtask[awardIdx[i]],awardVec);
								setRewardInfo(awardVec,rewardicon[i].get(),NULL,NULL);
							}
							//for (int j = 0;j<2;j++)
							//{
							//	if (atoi(recordtask[awardtype1index+j*2].c_str()) == T_Item)
							//	{
							//		crArgumentParser::appAtoVec(recordtask[itemaward1index+j*2],vec3);
							//		if (vec3[0]>0 && itemtab->queryOneRecord(0,crArgumentParser::appItoa(vec3[0]),recorditem)>=0)
							//		{
							//			if (rewardicon[j].valid())
							//			{
							//				rewardicon[j]->setVisiable(true);
							//				rewardicon[j]->setImageName(recorditem[itemtab->getTitleIndex("icon")]);
							//			}
							//		}
							//	}
							//	else if(atoi(recordtask[awardtype1index+j*2].c_str()) == T_Zhanquan)
							//	{
							//		if (rewardicon[j].valid())
							//		{
							//			rewardicon[j]->setVisiable(true);
							//			rewardicon[j]->setImageName("T_Icon_Zhengzhanjuan.img");
							//		}
							//	}
							//}
						}
						//if (itr->second->getAwardItemMap().size() >0)
						//{
						//	AwardItemMap::iterator itr2 = itr->second->getAwardItemMap().begin();
						//	for (int j = 0; j < itr->second->getAwardItemMap().size(); j++,++itr)
						//	{
						//		if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itr2->first),itemrecord) >= 0 )
						//		{
						//			if (rewardicon[j])
						//			{
						//				rewardicon[j]->setVisiable(true);
						//				rewardicon[j]->setImageName(itemrecord[itemtab->getTitleIndex("icon")]);
						//			}
						//		}
						//	}
						//}
						if(itr->second->isComplete())
						{
							if (getrewardbtn.valid())
							{
								getrewardbtn->setVisiable(true);
								getrewardbtn->setEnable(true);
							}
						}
					}
					switch (atoi(record[0].c_str()))
					{
					case Task_Main:
						displayTaskName(mainunfold,record[titleindex],itr->second.get(),mainresult,i,mode,count);
						break;
					case Task_Secondary:
						displayTaskName(secondaryunfold,record[titleindex],itr->second.get(),secondaryresult,i,mode,count);
						break;
					case Task_Daily:
						displayTaskName(dailyunfold,record[titleindex],itr->second.get(),dailyresult,i,mode,count);
						break;
					case Task_Special:
						displayTaskName(specialunfold,record[titleindex],itr->second.get(),specialresult,i,mode,count);
						break;
					}
				}
			}
			if (count == 0)
			{
				int ii = --i;
				m_foldbtnWidget[ii]->select(false);
				m_foldbtnWidget[ii]->setVisiable(false);
				m_taskinputWidget[ii]->clearString();
				m_taskinputWidget[ii]->setVisiable(false);
			}
			//int index = 0;
			//if (mainresult)
			//{
			//	if (foldbtn[index])
			//	{
			//		foldbtn[index]->setVisiable(true);
			//	}
			//	if (taskinput[index])
			//	{
			//		taskinput[index]->setString(str1);
			//	}
			//	index++;
			//}
			//if (secondaryresult)
			//{
			//	if (foldbtn[index])
			//	{
			//		foldbtn[index]->setVisiable(true);
			//	}
			//	if (taskinput[index])
			//	{
			//		taskinput[index]->setString(str2);
			//	}
			//	index++;
			//}
			//if (dailyresult)
			//{
			//	if (foldbtn[index])
			//	{
			//		foldbtn[index]->setVisiable(true);
			//	}
			//	if (taskinput[index])
			//	{
			//		taskinput[index]->setString(str3);
			//	}
			//	index++;
			//}
			//if (specialresult)
			//{
			//	if (foldbtn[index])
			//	{
			//		foldbtn[index]->setVisiable(true);
			//	}
			//	if (taskinput[index])
			//	{
			//		taskinput[index]->setString(str4);
			//	}
			//}
			myMetierData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIChooseOneTaskMethod
//
/////////////////////////////////////////
crJXJUIChooseOneTaskMethod::crJXJUIChooseOneTaskMethod():
	m_this(NULL),
	m_index(0)
{
}
crJXJUIChooseOneTaskMethod::crJXJUIChooseOneTaskMethod(const crJXJUIChooseOneTaskMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_index(handle.m_index)
{
	for (int i = 0;i<11 ;i++)
	{
		m_foldbtn[i] = handle.m_foldbtn[i];
		m_taskinput[i] = handle.m_taskinput[i];
	}
}
void crJXJUIChooseOneTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIChooseOneTaskMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_foldbtn[i] = str;
		break;
	case 1:
		m_foldbtn[i] = str;
		break;
	case 2:
		m_foldbtn[i] = str;
		break;
	case 3:
		m_foldbtn[i] = str;
		break;
	case 4:
		m_foldbtn[i] = str;
		break;
	case 5:
		m_foldbtn[i] = str;
		break;
	case 6:
		m_foldbtn[i] = str;
		break;
	case 7:
		m_foldbtn[i] = str;
		break;
	case 8:
		m_foldbtn[i] = str;
		break;
	case 9:
		m_foldbtn[i] = str;
		break;
	case 10:
		m_foldbtn[i] = str;
		break;
	case 11:
		m_taskinput[i - 11] = str;
		break;
	case 12:
		m_taskinput[i - 11] = str;
		break;
	case 13:
		m_taskinput[i - 11] = str;
		break;
	case 14:
		m_taskinput[i - 11] = str;
		break;
	case 15:
		m_taskinput[i - 11] = str;
		break;
	case 16:
		m_taskinput[i - 11] = str;
		break;
	case 17:
		m_taskinput[i - 11] = str;
		break;
	case 18:
		m_taskinput[i - 11] = str;
		break;
	case 19:
		m_taskinput[i - 11] = str;
		break;
	case 20:
		m_taskinput[i - 11] = str;
		break;
	case 21:
		m_taskinput[i - 11] = str;
		break;
	case 22:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJUIChooseOneTaskMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
		crTableIO::StrVec record;
		if (tasktitletab.valid())
		{
			void *param;
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			if (canvas.valid())
			{
				std::string str;
				ref_ptr<crCheckBoxWidgetNode> foldbtn = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_foldbtn[m_index]));
				ref_ptr<crStaticTextWidgetNode> taskinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_taskinput[m_index]));

				for (int i = 0; i<11;i++)
				{
					if (i!=m_index)
					{
						ref_ptr<crStaticTextWidgetNode> taskinputother = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_taskinput[i]));
						crMultiSwitch *inputswitch = dynamic_cast<crMultiSwitch *>(taskinputother->getChild(0));
						if (inputswitch)
						{
							inputswitch->setActiveSwitchSet(0);
						}
					}
				}
				bool *unfold = false;
				crData *brainData = crBrain::getInstance()->getDataClass();
				brainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				if (foldbtn.valid())
				{
					int tasktitleindex = tasktitletab->getTitleIndex("主题");
					if (taskinput.valid())
					{
						str = taskinput->getUTF8String();
						crMultiSwitch *inputswitch = dynamic_cast<crMultiSwitch *>(taskinput->getChild(0));
						if (inputswitch)
						{
							inputswitch->setActiveSwitchSet(1);
						}
					}
					if (foldbtn->getVisiable())
					{
						if(tasktitletab->queryOneRecord(tasktitleindex,str,record) >= 0 )
						{
							switch (atoi(record[0].c_str()))
							{
							case Task_Main:
								brainData->getParam(WCHDATA_JXJUnfoldTaskType1,param);
								unfold = (bool *)param;
								break;
							case Task_Secondary:
								brainData->getParam(WCHDATA_JXJUnfoldTaskType2,param);
								unfold = (bool *)param;
								break;
							case Task_Daily:
								brainData->getParam(WCHDATA_JXJUnfoldTaskType3,param);
								unfold = (bool *)param;
								break;
							case Task_Special:
								brainData->getParam(WCHDATA_JXJUnfoldTaskType4,param);
								unfold = (bool *)param;
								break;
							}
							*unfold = !*unfold;
						}
					}
					else
					{
						std::string str1;
						if(str.find('(') != std::string::npos)
							str1 = str.substr(0,str.find('('));

						crRole *mainRole = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole();
						if(!mainRole) return;
						crData *myMetierData = mainRole->getMetierDataClass();
						if(!myMetierData) return;
						void *param;
						myMetierData->excHandle(MAKECREPARAM(WCH_LockData,1));
						myMetierData->getParam(WCHDATA_GameTaskMap,param);
						GameTaskMap *gameTaskMap = (GameTaskMap *)param;
						for( GameTaskMap::iterator itr = gameTaskMap->begin();
							itr != gameTaskMap->end();
							++itr )
						{
							if (/*str.find(itr->second->getTaskName()) == 0*/itr->second->getTaskName() == str1)
							{
								int taskid = itr->second->getTaskID();
								brainData->inputParam(WCHDATA_JXJCurChooseTaskID,&taskid);
								break;
							}
						}
						myMetierData->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
				}
				brainData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJGetTechResProductPercentMethod
///////////////////////////////////////////
crJXJGetTechResProductPercentMethod::crJXJGetTechResProductPercentMethod():
	m_this(NULL),
	m_output(NULL),
	m_thingtype(0){}
crJXJGetTechResProductPercentMethod::crJXJGetTechResProductPercentMethod(const crJXJGetTechResProductPercentMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(NULL),
	m_thingtype(0)
{
}
void crJXJGetTechResProductPercentMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_output = (float *)(LOCREPARAM(param64));
			m_thingtype = (unsigned char)(HICREPARAM(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetTechResProductPercentMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetTechResProductPercentMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		float percent = 0.0f;
		//委任将卡加成		
		//if (playerData)
		{
			void *param;
			crData *data = m_this->getDataClass();
		//	crData *roledata = m_this->getMainRole()->getDataClass();
			if (data)
			{
				////科技加成
				crTableIO::StrVec techrecord;
				ref_ptr<crTableIO>techlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
				int shuxingindex = techlvtab->getTitleIndex("属性加成");
				//int lvindex = techlvtab->getTitleIndex("lv");
				int techid = 0;
				switch (m_thingtype)
				{
				case T_Food:
					techid = WCHDATA_JXJTechFoodlv;
					break;
				case T_Wood:
					techid = WCHDATA_JXJTechWoodlv;
					break;
				case T_Iron:
					techid = WCHDATA_JXJTechIronlv;
					break;
				case T_Horse:
					techid = WCHDATA_JXJTechHorselv;
					break;
				default:
					break;
				}
				if (techid > 0)
				{
					data->getParam(techid,param);
					unsigned char techlv = *(unsigned char *)param;
					if (techlv > 0)
					{
						if(techlvtab->queryOneRecord(0,crArgumentParser::appItoa(techid),techrecord) >= 0 )
						{
							percent += atof(techrecord[shuxingindex].c_str());
						}
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				//委任将卡加成
				//crTableIO::StrVec cardrecord;
				//ref_ptr<crTableIO>cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
				//int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
				//int addpercentindex = cardtab->getTitleIndex("政卡加成");
				//data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
				//JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

				//int zhengcardtype = -1;
				int countrybuildingtype = -1;
				int countrybuildingmsgid = -1;
				switch (m_thingtype)
				{
				case T_Food:
					//zhengcardtype = ZhengAdd_IncreaseFoodGet;
					countrybuildingtype = BuildCountryType_CaoYun;
					countrybuildingmsgid = WCHDATA_JXJShenNongMiao;
					break;
				case T_Wood:
					//zhengcardtype = ZhengAdd_IncreaseWoodGet;
					countrybuildingtype = BuildCountryType_ShangLinYuan;
					countrybuildingmsgid = WCHDATA_JXJShangLinYuan;
					break;
				case T_Iron:
					//zhengcardtype = ZhengAdd_IncreaseIronGet;
					countrybuildingtype = BuildCountryType_TongQueTai;
					countrybuildingmsgid = WCHDATA_JXJSijintai;
					break;
				case T_Horse:
					//zhengcardtype = ZhengAdd_IncreaseHoreseGet;
					countrybuildingtype = BuildCountryType_SiMaJian;
					countrybuildingmsgid = WCHDATA_JXJSiMaJian;
					break;
				default:
					break;
				}
				//if (zhengcardtype >= 0)
				//{
				//	for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
				//		carditr!=appjiangkavec->end();
				//		++carditr)
				//	{
				//		if ((*carditr)!=NULL)
				//		{
				//			if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord) >= 0 )
				//			{
				//				if(atoi(cardrecord[zhengkatypeindex].c_str()) == zhengcardtype)
				//				{
				//					percent +=atof(cardrecord[addpercentindex].c_str());
				//					break;
				//				}
				//			}
				//		}
				//	}
				//}
				//资源加成建筑加成
				if(crGlobalHandle::isClient())
				{//客户端显示用，服务器另外计算了
					crTableIO::StrVec ResAddBuildingrecord;
					ref_ptr<crTableIO> ResAddBuildingTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJResAddBuildingTab);
					int buildinglvindex = ResAddBuildingTab->getTitleIndex("lv");
					int addindex = ResAddBuildingTab->getTitleIndex("加成");
					if (buildinglvindex >= 0 && addindex >= 0)
					{
						int time = 0;
						int buildingid = 0;
						data->getParam(WCHDATA_JXJExtraProduceMap, param);
						ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
						for (ExtraProduceMap::iterator itr = extraProduceMap->begin(); itr != extraProduceMap->end(); ++itr)
						{
							if (itr->first == m_thingtype)
							{
								//percent += (float)itr->second->getPercent();
								time += itr->second->timer();
							}
						}
						if (time > 0)
						{
							switch (m_thingtype)
							{
							case T_Food:
								buildingid = WCHDATA_JXJShuichelv;
								break;
							case T_Wood:
								buildingid = WCHDATA_JXJGongshelv;
								break;
							case T_Iron:
								buildingid = WCHDATA_JXJRonglulv;
								break;
							case T_Horse:
								buildingid = WCHDATA_JXJMochuanlv;
								break;
							default:
								break;
							}
							data->getParam(buildingid, param);
							unsigned char buildinglv = *(unsigned char *)param;
							if(ResAddBuildingTab->queryOneRecord(0, crArgumentParser::appItoa(buildingid), buildinglvindex, crArgumentParser::appItoa(buildinglv), ResAddBuildingrecord) >= 0)
								percent += atof(ResAddBuildingrecord[addindex].c_str());
						}
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				//国家建设加成
				int gongxian = 0;
				data -> getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *( unsigned char *)param;
				if(shiliid>=c_startShiliID)
				{
					if(crGlobalHandle::isClient())
					{
						//crData *braindata = crBrain::getInstance()->getDataClass();
						//braindata->getParam(WCHDATA_JXJMyCountryData,param);
							
						
						data->getParam(WCHDATA_JXJMyCountryData,param);
						crJXJShili *shili = (crJXJShili *)param;
						if (shili && shili->getDataClass())
						{
							crData *shilidata = shili->getDataClass();	
							shilidata->getParam(countrybuildingmsgid,param);
							gongxian = *(int *)param;
						}
					}
					else
					{
						crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
						if (gsBrainData)
						{
							gsBrainData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
							crJXJShili *shili = (crJXJShili *)param;
							if (shili && shili->getDataClass())
							{
								crData *shilidata = shili->getDataClass();	
								shilidata->getParam(countrybuildingmsgid,param);
								gongxian = *(int *)param;
							}
						}
					}
				}
				if(gongxian > 0)
				{
					ref_ptr<crTableIO>countrybuildtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCountryBuildTab);
					crTableIO::DataVec records;
					crTableIO::StrVec recordc;
					int typeindex = countrybuildtab->getTitleIndex("type");
					int addindex = countrybuildtab->getTitleIndex("加成");
					int moneyneedindex = countrybuildtab->getTitleIndex("铜钱");
					countrybuildtab->queryRecords(typeindex,crArgumentParser::appItoa(countrybuildingtype),records);
					crTableIO::DataVec::iterator itr;
					crTableIO::DataVec::iterator peritr;
					int lv;
					if(!records.empty())
					{
						peritr = records.begin();
						itr = peritr;
						itr++;
						for (;
							itr != records.end();
							++itr,++peritr)
						{
							if (gongxian <  atoi((*itr)[moneyneedindex].c_str()))
							{
								break;
							}
						}
						lv = atoi((*peritr)[0].c_str());
					}
					if(countrybuildtab->queryOneRecord(0,crArgumentParser::appItoa(lv),recordc) >= 0 )
					{
						percent += atof(recordc[addindex].c_str());
					}
				}
				//VIP加成
				int vipaffairid = 0;
				switch (m_thingtype)
				{
				case T_Food:
					vipaffairid = WCHDATA_JXJVIPNongTianShuiLi;
					break;
				case T_Wood:
					vipaffairid = WCHDATA_JXJVIPZhiShuZaoLin;
					break;
				case T_Iron:
					vipaffairid = WCHDATA_JXJVIPJingKuangShenWa;
					break;
				case T_Horse:
					vipaffairid = WCHDATA_JXJVIPYouZhiCaoChang;
					break;
				default:
					break;
				}
				if (vipaffairid > 0)
				{
					data->getParam(vipaffairid, param);
					unsigned char affairlv = *(unsigned char *)param;
					ref_ptr<crTableIO>VipAffairsLvTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJVipAffairsLvTab);
					crTableIO::StrVec  afflvrecord;
					int addindex = VipAffairsLvTab->getTitleIndex("add");
					int lvindex = VipAffairsLvTab->getTitleIndex("lv");
					if (VipAffairsLvTab->queryOneRecord(0, crArgumentParser::appItoa(vipaffairid), lvindex, crArgumentParser::appItoa(affairlv), afflvrecord) >= 0)
					{
						percent += atof(afflvrecord[addindex].c_str()) / 10.0f;
					}
				}
			}
		}
		*m_output = percent * 0.01f;
	}
}
/////////////////////////////////////////
//
//crJXJUIAppointJangkaListUpdateMethod
//
/////////////////////////////////////////
crJXJUIAppointJangkaListUpdateMethod::crJXJUIAppointJangkaListUpdateMethod(){}
crJXJUIAppointJangkaListUpdateMethod::crJXJUIAppointJangkaListUpdateMethod(const crJXJUIAppointJangkaListUpdateMethod& handle):
	crMethod(handle),
	m_myBagList(handle.m_myBagList),
	m_pagenum(handle.m_pagenum),
	m_itemtype(handle.m_itemtype),
	m_defaulticon(handle.m_defaulticon),
	m_lineoneswitch(handle.m_lineoneswitch),
	m_linetwoswitch(handle.m_linetwoswitch),
	m_linethreeswitch(handle.m_linethreeswitch),
	m_appointcardicon2(handle.m_appointcardicon2),
	m_appointcardicon1(handle.m_appointcardicon1),
	m_appointcardicon3(handle.m_appointcardicon3),
	m_leftbtn(handle.m_leftbtn),
	m_curPageNum(handle.m_curPageNum)
{
	for (int i = 0; i<3;i++)
	{
		m_infoinput[i] = handle.m_infoinput[i];
		m_colorswitch[i] = handle.m_colorswitch[i];
		m_cardtitle[i] = handle.m_cardtitle[i];
		m_buyswitch[i] = handle.m_buyswitch[i];
		m_buyBtn[i] = handle.m_buyBtn[i];
	}
	for (int i = 0; i<10;i++)
	{
		m_frame[i] = handle.m_frame[i];
	}
}
void crJXJUIAppointJangkaListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIAppointJangkaListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_myBagList = str;
		break;
	case 1:
		m_pagenum = str;
		break;
	case 2:
		m_itemtype = str;
		break;
	case 3:
		m_defaulticon = str;
		break;
	case 4:
		m_lineoneswitch = str;
		break;
	case 5:
		m_linetwoswitch = str;
		break;
	case 6:
		m_linethreeswitch = str;
		break;
	case 7:
		m_appointcardicon1 = str;
		break;
	case 8:
		m_appointcardicon2 = str;
		break;
	case 9:
		m_appointcardicon3 = str;
		break;
	case 10:
		m_leftbtn = str;
		break;
	case 11:
		m_rightbtn = str;
		break;
	case 12:
		m_defaulticon2 = str;
		break;
	//case 13:
	//	m_whiteframe = str;
	//	break;
	//case 14:
	//	m_greenframe = str;
	//	break;
	//case 15:
	//	m_blueframe = str;
	//	break;
	//case 16:
	//	m_purpleframe = str;
	//	break;
	//case 17:
	//	m_orangeframe = str;
	//	break;
	case 13:
		m_infoinput[0] = str;
		break;
	case 14:
		m_infoinput[1] = str;
		break;
	case 15:
		m_infoinput[2] = str;
		break;
	case 16:
		m_colorswitch[0] = str;
		break;
	case 17:
		m_colorswitch[1] = str;
		break;
	case 18:
		m_colorswitch[2] = str;
		break;
	case 19:
		m_cardtitle[0] = str;
		break;
	case 20:
		m_cardtitle[1] = str;
		break;
	case 21:
		m_cardtitle[2] = str;
		break;
	case 22:
	case 23:
	case 24:
	case 25:
	case 26:
	case 27:
	case 28:
	case 29:
	case 30:
	case 31:
		m_frame[i-22] = str;
		break;
	case 32:
		m_curPageNum = str;
		break;
	case 33:
		m_buyswitch[0] = str;
		break;
	case 34:
		m_buyswitch[1] = str;
		break;
	case 35:
		m_buyswitch[2] = str;
		break;
	case 36:
		m_buyBtn[0] = str;
		break;
	case 37:
		m_buyBtn[1] = str;
		break;
	case 38:
		m_buyBtn[2] = str;
		break;
	default:
		break;
	}
}
void crJXJUIAppointJangkaListUpdateMethod::operator()(crHandle &handle)
{
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		crData *canvasdata = m_this->getDataClass();
		crData *data = myPlayer->getDataClass();
		crData *roledata = myPlayer->getMainRole()->getDataClass();
		if (data && canvasdata && roledata)
		{
			void *param;
			int typeitem = 0,typeitem2 = JiangkaType_zheng,curpage = 0;
			ref_ptr<crListControlWidgetNode> backPackList = dynamic_cast<crListControlWidgetNode *>(m_this->getWidget(m_myBagList));
			//ref_ptr<crStaticTextWidgetNode> pagenum = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenum));
			ref_ptr<crRadioGroupWidgetNode> itemtype = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_itemtype));
			ref_ptr<crRadioGroupWidgetNode> AppointcurPageNum = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_curPageNum));
			crMultiSwitch *lineswitch1 = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_lineoneswitch));
			crMultiSwitch *lineswitch2 = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_linetwoswitch));
			crMultiSwitch *lineswitch3 = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_linethreeswitch));
			ref_ptr<crImageBoxWidgetNode> appointcardicon1 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_appointcardicon1));
			ref_ptr<crImageBoxWidgetNode> appointcardicon2 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_appointcardicon2));
			ref_ptr<crImageBoxWidgetNode> appointcardicon3 = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_appointcardicon3));
			ref_ptr<crButtonWidgetNode> leftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_leftbtn));
			ref_ptr<crButtonWidgetNode> rightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_rightbtn));
			ref_ptr<crHypertextWidgetNode> infoinput[3];
			ref_ptr<crMultiSwitch> colorswitch[3];
			ref_ptr<crImageBoxWidgetNode> cardtitle[3];
			ref_ptr<crMultiSwitch> buyswitch[3];
			ref_ptr<crButtonWidgetNode> buyBtn[3];
			for (int i = 0; i < 3;i++)
			{
				infoinput[i] = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_infoinput[i]));
				colorswitch[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_colorswitch[i]));
				cardtitle[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_cardtitle[i]));
				buyswitch[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_buyswitch[i]));
				buyBtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getChildNode(m_buyBtn[i]));
				if (infoinput[i].valid())
				{
					infoinput[i]->clearText();
				}
				if (colorswitch[i].valid())
				{
					colorswitch[i]->setActiveSwitchSet(0);
				}
				if (cardtitle[i].valid())
				{
					cardtitle[i]->setVisiable(false);
				}
				if (buyswitch[i].valid())
				{
					buyswitch[i]->setActiveSwitchSet(1);
				}
				if (buyBtn[i].valid())
				{
					buyBtn[i]->setEnable(true);
					buyBtn[i]->setVisiable(true);
				}
			}
			roledata->getParam(WCHDATA_Level, param);
			unsigned char characterlevel = *(unsigned char *)param;
			roledata->getParam(WCHDATA_JXJAppointColumnsVec, param);
			unsigned char appointColumns = 3;
			if (param) appointColumns = *(unsigned char *)param;
			data -> getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			unsigned char secondrowopenlv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSecondRowOpenLevel,viplv).c_str()));
			unsigned char threerowopenlv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJThreeRowOpenLevel,viplv).c_str()));
			unsigned int Appointcurpage = 0;
			if (AppointcurPageNum.valid())
			{
				Appointcurpage= AppointcurPageNum->getSelect();
			}
			switch (Appointcurpage)
			{
			case 0:
				//委任第一行
				if (lineswitch1)
				{
					lineswitch1->setActiveSwitchSet(0);
					if (appointcardicon1.valid())
					{
						appointcardicon1->setVisiable(true);
						appointcardicon1->setImageName(m_defaulticon2);
						appointcardicon1->setImageName("", 1);
						ref_ptr<crMultiSwitch> appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon1->getChild(0));
						if (appointcardiconswitch.valid())
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
					}
				}
				//委任第二行
				if (lineswitch2)
				{
					if (appointcardicon2.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon2->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (characterlevel >= secondrowopenlv)
						{
							appointcardicon2->setVisiable(true);
							appointcardicon2->setImageName(m_defaulticon2);
							appointcardicon2->setImageName("", 1);
							lineswitch2->setActiveSwitchSet(1);
						}
						else
						{
							appointcardicon2->setVisiable(false);
							lineswitch2->setActiveSwitchSet(0);
						}
					}
				}
				//委任第三行
				if (lineswitch3)
				{
					if (appointcardicon3.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon3->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (viplv >= threerowopenlv)
						{
							appointcardicon3->setVisiable(true);
							appointcardicon3->setImageName(m_defaulticon2);
							appointcardicon3->setImageName("", 1);
							lineswitch3->setActiveSwitchSet(1);
						}
						else
						{
							appointcardicon3->setVisiable(false);
							lineswitch3->setActiveSwitchSet(0);
						}
					}
				}
				break;
			case 1:
				//委任第一行
				if (lineswitch1)
				{
					//lineswitch1->setActiveSwitchSet(0);
					if (appointcardicon1.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon1->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (appointColumns >= 4)
						{
							appointcardicon1->setVisiable(true);
							appointcardicon1->setImageName(m_defaulticon2);
							appointcardicon1->setImageName("", 1);
							lineswitch1->setActiveSwitchSet(0);
						}
						else
						{
							appointcardicon1->setVisiable(false);
							lineswitch1->setActiveSwitchSet(2);
						}
					}
				}
				//委任第二行
				if (lineswitch2)
				{
					if (appointcardicon2.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon2->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (appointColumns >= 5)
						{
							appointcardicon2->setVisiable(true);
							appointcardicon2->setImageName(m_defaulticon2);
							appointcardicon2->setImageName("", 1);
							lineswitch2->setActiveSwitchSet(1);
						}
						else
						{
							appointcardicon2->setVisiable(false);
							lineswitch2->setActiveSwitchSet(3);
						}
					}
				}
				//委任第三行
				if (lineswitch3)
				{
					if (appointcardicon3.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon3->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (appointColumns >= 6)
						{
							appointcardicon3->setVisiable(true);
							appointcardicon3->setImageName(m_defaulticon2);
							appointcardicon3->setImageName("", 1);
							lineswitch3->setActiveSwitchSet(1);
						}
						else
						{
							appointcardicon3->setVisiable(false);
							lineswitch3->setActiveSwitchSet(3);
						}
					}
				}
				break;
			case 2:
				//委任第一行
				if (lineswitch1)
				{
					//lineswitch1->setActiveSwitchSet(0);
					if (appointcardicon1.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon1->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (appointColumns >= 7)
						{
							appointcardicon1->setVisiable(true);
							appointcardicon1->setImageName(m_defaulticon2);
							appointcardicon1->setImageName("", 1);
							lineswitch1->setActiveSwitchSet(0);
						}
						else
						{
							lineswitch1->setActiveSwitchSet(2);
							appointcardicon1->setVisiable(false);
							if (buyswitch[0].valid())
							{
								buyswitch[0]->setActiveSwitchSet(1);
							}
							if (buyBtn[0].valid())
							{
								buyBtn[0]->setEnable(false);
								buyBtn[0]->setVisiable(false);
							}
						}
					}
				}
				//委任第二行
				if (lineswitch2)
				{
					if (appointcardicon2.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon2->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (appointColumns >= 8)
						{
							appointcardicon2->setVisiable(true);
							appointcardicon2->setImageName(m_defaulticon2);
							appointcardicon2->setImageName("", 1);
							lineswitch2->setActiveSwitchSet(1);
						}
						else
						{
							appointcardicon2->setVisiable(false);
							lineswitch2->setActiveSwitchSet(3);
							if (buyswitch[1].valid())
							{
								buyswitch[1]->setActiveSwitchSet(1);
							}
							if (buyBtn[1].valid())
							{
								buyBtn[1]->setEnable(false);
								buyBtn[1]->setVisiable(false);
							}
						}
					}
				}
				//委任第三行
				if (lineswitch3)
				{
					if (appointcardicon3.valid())
					{
						crMultiSwitch *appointcardiconswitch = dynamic_cast<crMultiSwitch *>(appointcardicon3->getChild(0));
						if (appointcardiconswitch)
						{
							appointcardiconswitch->setActiveSwitchSet(0);
						}
						if (appointColumns >= 9)
						{
							appointcardicon3->setVisiable(true);
							appointcardicon3->setImageName(m_defaulticon2);
							appointcardicon3->setImageName("", 1);
							lineswitch3->setActiveSwitchSet(1);
						}
						else
						{
							appointcardicon3->setVisiable(false);
							lineswitch3->setActiveSwitchSet(3);
							if (buyswitch[2].valid())
							{
								buyswitch[2]->setActiveSwitchSet(1);
							}
							if (buyBtn[2].valid())
							{
								buyBtn[2]->setEnable(false);
								buyBtn[2]->setVisiable(false);
							}
						}
					}
				}
				break;
			default:
				break;
			}
			//委任将卡背包
			if(backPackList.valid())
			{
				int totalcount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize,viplv).c_str()));
				int onepagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAppointCardPerPageNum,viplv).c_str()));
				if(itemtype.valid())
				{
					typeitem = itemtype->getSelect();
				}
				//if (itemtype2)
				//{
				//	typeitem2 = itemtype2->getSelect();
				//}
				crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				ref_ptr<crTableIO>itemtab2 = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
				if (!itemtab || !itemtab2)
				{
					return;
				}
				void *param;
				//braindata
				canvasdata->getParam(WCHDATA_JXJCurAppointJiangkaBagPageNum,param);
				curpage = *(int *)param;
				//playerdata
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
				JXJAppointCardVec *appointjiangkabagvec = (JXJAppointCardVec *)param;
				crTableIO::StrVec itemrecord3;
				////////////////////////////////////////////////////
				int nameid = itemtab->getTitleIndex("name");
				int iconid = itemtab->getTitleIndex("icon");
				int miniiconid = itemtab->getTitleIndex("miniicon");
				int attrid = itemtab->getTitleIndex("将卡类型");
				int color = itemtab->getTitleIndex("品质");
				int quality = 0;
				//int jinengindex = itemtab->getTitleIndex("技能描述");
				int jinengiconindex = itemtab->getTitleIndex("委任技能icon");
				//std::string file;
				//////////////////////////////////////////////
				switch (Appointcurpage)
				{
				case 0:
					for (int i = 0; i<appointjiangkabagvec->size() && i < 3;i++)
					{
						if ((*appointjiangkabagvec)[i]!=NULL)
						{
							if ((*appointjiangkabagvec)[i]->getItemID()>0)
							{
								if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*appointjiangkabagvec)[i]->getItemID()),itemrecord3) >= 0 )
								{
									quality = atoi(itemrecord3[color].c_str());
									switch (i)
									{
									case 0:
										if (lineswitch1)
										{
											lineswitch1->setActiveSwitchSet(1);
											if (appointcardicon1.valid())
											{
												appointcardicon1->setImageName(itemrecord3[iconid]);
												appointcardicon1->setImageName(m_frame[quality], 1,crTexEnv::ADD);
												appointcardicon1->setVisiable(true);
											}
										}
										break;
									case 1:
										if (lineswitch2)
										{
											lineswitch2->setActiveSwitchSet(2);

											if (appointcardicon2.valid())
											{
												appointcardicon2->setImageName(itemrecord3[iconid]);
												appointcardicon2->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon2->setVisiable(true);
											}
										}
										break;
									case 2:

										if (lineswitch3)
										{
											lineswitch3->setActiveSwitchSet(2);

											if (appointcardicon3.valid())
											{
												appointcardicon3->setImageName(itemrecord3[iconid]);
												appointcardicon3->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon3->setVisiable(true);
											}
										}
										break;
									default:
										break;
									}
									if (infoinput[i].valid())
									{
										//file = itemrecord3[jinengindex];
										//if(!file.empty())
										//{
										//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
										//	infoinput[i]->setHypertext(file);
										//}
										//else
										//{
										//	infoinput[i]->clearText();
										//}
										ItemMap itemMap;
										rcfg::ConfigScript outscript(&itemMap);
										crVector2i item((*appointjiangkabagvec)[i]->getItemID(),0);
										myPlayer->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
										infoinput[i]->setHypertext(outscript);
									}
									if (colorswitch[i].valid())
									{
										if (quality >= 4)
										{
											colorswitch[i]->setActiveSwitchSet(5);
										}
										else
										{
											colorswitch[i]->setActiveSwitchSet(quality + 1);
										}
									}
									if (cardtitle[i].valid())
									{
										cardtitle[i]->setVisiable(true);
										cardtitle[i]->setImageName(itemrecord3[jinengiconindex]);
									}
								}
							}
						}
					}
					break;
				case 1:
					for (int i = 0; i<appointjiangkabagvec->size() && i < 3;i++)
					{
						if ((*appointjiangkabagvec)[i+3]!=NULL)
						{
							if ((*appointjiangkabagvec)[i+3]->getItemID()>0)
							{
								if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*appointjiangkabagvec)[i+3]->getItemID()),itemrecord3) >= 0 )
								{
									quality = atoi(itemrecord3[color].c_str());
									switch (i)
									{
									case 0:
										if (lineswitch1)
										{
											lineswitch1->setActiveSwitchSet(1);
											if (appointcardicon1.valid())
											{
												appointcardicon1->setImageName(itemrecord3[iconid]);
												appointcardicon1->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon1->setVisiable(true);
											}
										}
										break;
									case 1:
										if (lineswitch2)
										{
											lineswitch2->setActiveSwitchSet(2);

											if (appointcardicon2.valid())
											{
												appointcardicon2->setImageName(itemrecord3[iconid]);
												appointcardicon2->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon2->setVisiable(true);
											}
										}
										break;
									case 2:

										if (lineswitch3)
										{
											lineswitch3->setActiveSwitchSet(2);

											if (appointcardicon3.valid())
											{
												appointcardicon3->setImageName(itemrecord3[iconid]);
												appointcardicon3->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon3->setVisiable(true);
											}
										}
										break;
									default:
										break;
									}
									if (infoinput[i].valid())
									{
										//file = itemrecord3[jinengindex];
										//if(!file.empty())
										//{
										//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
										//	infoinput[i]->setHypertext(file);
										//}
										//else
										//{
										//	infoinput[i]->clearText();
										//}
										ItemMap itemMap;
										rcfg::ConfigScript outscript(&itemMap);
										crVector2i item((*appointjiangkabagvec)[i+3]->getItemID(),0);
										myPlayer->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
										infoinput[i]->setHypertext(outscript);
									}
									if (colorswitch[i].valid())
									{
										if (quality >= 4)
										{
											colorswitch[i]->setActiveSwitchSet(5);
										}
										else
										{
											colorswitch[i]->setActiveSwitchSet(quality + 1);
										}
									}
									if (cardtitle[i].valid())
									{
										cardtitle[i]->setVisiable(true);
										cardtitle[i]->setImageName(itemrecord3[jinengiconindex]);
									}
								}
							}
						}
					}
					break;
				case 2:
					for (int i = 0; i<appointjiangkabagvec->size() && i < 3;i++)
					{
						if ((*appointjiangkabagvec)[i+6]!=NULL)
						{
							if ((*appointjiangkabagvec)[i+6]->getItemID()>0)
							{
								if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*appointjiangkabagvec)[i+6]->getItemID()),itemrecord3) >= 0 )
								{
									quality = atoi(itemrecord3[color].c_str());
									switch (i)
									{
									case 0:
										if (lineswitch1)
										{
											lineswitch1->setActiveSwitchSet(1);
											if (appointcardicon1.valid())
											{
												appointcardicon1->setImageName(itemrecord3[iconid]);
												appointcardicon1->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon1->setVisiable(true);
											}
										}
										break;
									case 1:
										if (lineswitch2)
										{
											lineswitch2->setActiveSwitchSet(2);

											if (appointcardicon2.valid())
											{
												appointcardicon2->setImageName(itemrecord3[iconid]);
												appointcardicon2->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon2->setVisiable(true);
											}
										}
										break;
									case 2:

										if (lineswitch3)
										{
											lineswitch3->setActiveSwitchSet(2);

											if (appointcardicon3.valid())
											{
												appointcardicon3->setImageName(itemrecord3[iconid]);
												appointcardicon3->setImageName(m_frame[quality], 1, crTexEnv::ADD);
												appointcardicon3->setVisiable(true);
											}
										}
										break;
									default:
										break;
									}
									if (infoinput[i].valid())
									{

										ItemMap itemMap;
										rcfg::ConfigScript cfg_script(&itemMap);
										std::vector<float>v_i;
										cfg_script.Add("Hypertext");
										cfg_script.Push("Hypertext");

										cfg_script.Add("Content");
										cfg_script.Push("Content", 1);
										v_i.clear();
										v_i.push_back(140.0f);
										v_i.push_back(40.0f);
										v_i.push_back(40.0f);
										v_i.push_back(255.0f);

										cfg_script.Add("Color", v_i);
										cfg_script.Add("Text", "    暂未开放");
										cfg_script.Pop();

										cfg_script.Pop();
										infoinput[i]->setHypertext(cfg_script);

										////file = itemrecord3[jinengindex];
										////if(!file.empty())
										////{
										////	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
										////	infoinput[i]->setHypertext(file);
										////}
										////else
										////{
										////	infoinput[i]->clearText();
										////}
										//ItemMap itemMap;
										//rcfg::ConfigScript outscript(&itemMap);
										//crVector2i item((*appointjiangkabagvec)[i+6]->getItemID(),0);
										//myPlayer->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
										//infoinput[i]->setHypertext(outscript);
									}
									if (colorswitch[i].valid())
									{
										if (quality >= 4)
										{
											colorswitch[i]->setActiveSwitchSet(5);
										}
										else
										{
											colorswitch[i]->setActiveSwitchSet(quality + 1);
										}
									}
									if (cardtitle[i].valid())
									{
										cardtitle[i]->setVisiable(true);
										cardtitle[i]->setImageName(itemrecord3[jinengiconindex]);
									}
								}
							}
						}
					}
					break;
				default:
					break;
				}
				//canvas_data->getParam(WCHDATA_JXJForJKVec, param);
				//JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				crTableIO::StrVec itemrecord,itemrecord2;
				std::string iconfile;
				//std::string title,title2;
				//backPackList->clearList();
				backPackList->setListNodeCount(totalcount);
				backPackList->setStartYPos(curpage - 1);
				crListControlWidgetNode::ListNodeVec& listNodeVec = backPackList->getListNodeVec();
				//int index = 0;
				int count = 0;
				//itembagvec->resize(openbagnum);
				/////////////////////////////////////////////

				//JXJItemBagVec newitembagvec,newitembagvec2;
				//BagItemMultiMap2 bagitemmap,bagitemmap2;
				//for (JXJItemBagVec::iterator itr = itembagvec->begin();
				//	itr != itembagvec->end();
				//	++itr)
				//{
				//	if((*itr)!= NULL)
				//	{
				//		if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
				//			bagitemmap.insert(std::make_pair(atoi(itemrecord[color].c_str()),(*itr).get()));
				//	}
				//}

				//for (BagItemMultiMap2::iterator itr2 = bagitemmap.begin();
				//	itr2 != bagitemmap.end();
				//	++itr2 )
				//{
				//	if(newitembagvec.empty())
				//		newitembagvec.push_back(itr2->second);
				//	else
				//	{
				//		crBagItemData *backitem;
				//		backitem = (newitembagvec.back()).get();
				//		{
				//			newitembagvec.push_back(itr2->second);
				//		}

				//	}
				//}
				//newitembagvec.resize(itembagvec->size());
				//itembagvec->swap(newitembagvec);
				////////////////////////////////////////////
				std::string framefile;
				int dataid = 0;
				for(int index = 0;index<totalcount;index++)
				{
					listNodeVec[index]->setData(-1);
					listNodeVec[index]->setImageName(m_defaulticon);
					listNodeVec[index]->setImageName("",1);
					listNodeVec[index]->setVisiable(true);
					listNodeVec[index]->setEnable(false);
				}
				//index = 0;
				if(!typeitem)
				{
					for( JXJItemBagVec::iterator itr = itembagvec->begin();
						itr != itembagvec->end();
						++itr,/*++index,*/++dataid )
					{
						if(count<totalcount)
						{
							if((*itr)!=NULL && (*itr)->getItemID()!=0)
							{
								if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
								{
									int nowcount = (*itr)->getItemCount();
									if (nowcount == 0)
									{
										//index--;
										continue;
									}
									if (typeitem2>0)
									{
										if (atoi(itemrecord[attrid].c_str()) != typeitem2)
										{
											//index--;
											continue;
										}
									}
									quality = atoi(itemrecord[color].c_str());
									//title = itemrecord[nameid];
									//title2 = crArgumentParser::appItoa(nowcount);
									iconfile = itemrecord[miniiconid];
									//listNodeVec[index]->setTitle(title);
									//listNodeVec[index]->setTitle2(title2);
									listNodeVec[count]->setData(/*curpage*onepagecount+*/dataid);
									listNodeVec[count]->setImageName(iconfile);
									listNodeVec[count]->setImageName(m_frame[quality],1);
									listNodeVec[count]->setVisiable(true);
									listNodeVec[count]->setEnable(true);
									count++;
								}
							}
						}
					}
				}
				else
				{
					for( JXJItemBagVec::iterator itr = itembagvec->begin();
						itr != itembagvec->end();
						++itr,/*++index,*/++dataid )
					{
						if(count<totalcount)
						{
							if((*itr)!=NULL && (*itr)->getItemID()!=0)
							{
								if(itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),itemrecord) >= 0 )
								{
									int nowcount = (*itr)->getItemCount();
									if (nowcount == 0 || (typeitem2 > 0 && atoi(itemrecord[attrid].c_str()) != typeitem2))
									{
										//index--;
										continue;
									}
									quality = atoi(itemrecord[color].c_str());
									if (typeitem < 5)
									{//非橙卡
										if (quality != typeitem - 1)
										{
											//index--;
											continue;
										}
									}
									else if(quality<4)
									{//橙卡及以上显示
										continue;
									}
									/*switch (atoi(itemrecord[color].c_str()))
									{
									case 0:
										framefile = m_whiteframe;
										break;
									case 1:
										framefile = m_greenframe;
										break;
									case 2:
										framefile = m_blueframe;
										break;
									case 3:
										framefile = m_purpleframe;
										break;
									case 4:
									case 5:
									case 6:
									case 7:
									case 8:
									case 9:
										framefile = m_orangeframe;
										break;
									default:
										framefile = "";
										break;
									}*/
									//title = itemrecord[nameid];
									//title2 = crArgumentParser::appItoa(nowcount);
									iconfile = itemrecord[miniiconid];
									//listNodeVec[index]->setTitle(title);
									//listNodeVec[index]->setTitle2(title2);
									listNodeVec[count]->setData(/*curpage*onepagecount+*/dataid);
									listNodeVec[count]->setImageName(iconfile);
									listNodeVec[count]->setImageName(m_frame[quality],1);
									listNodeVec[count]->setVisiable(true);
									listNodeVec[count]->setEnable(true);
									count++;
								}
							}
							//else
							//{
							//	index--;
							//}
						}
					}
				}
				//////////////////////////////////////////////

				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				//if(i<0)i=0;
				int totalpage = ceil((float)count/(float)onepagecount);
				if (totalpage<1)
				{
					totalpage = 1;
				}
				canvasdata->inputParam(WCHDATA_JXJTotalAppointJiangkaBagPageNum,&totalpage);
				if (leftbtn.valid())
				{
					leftbtn->setEnable(true);
				}
				if (rightbtn.valid())
				{
					rightbtn->setEnable(true);
				}
				if (curpage <= 1)
				{
					if (leftbtn.valid())
					{
						leftbtn->setEnable(false);
					}
				}
				if(curpage >= totalpage)
				{
					if (rightbtn.valid())
					{
						rightbtn->setEnable(false);
					}
				}
				//if(pagenum)pagenum->setString(crArgumentParser::appItoa(curpage)+"/"+crArgumentParser::appItoa(totalpage));
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJAppointCardValidTimeMethod
//
/////////////////////////////////////////
crJXJAppointCardValidTimeMethod::crJXJAppointCardValidTimeMethod():
	m_dt(0),
	m_totaltime(0.0f)
{
}
crJXJAppointCardValidTimeMethod::crJXJAppointCardValidTimeMethod(const crJXJAppointCardValidTimeMethod& handle):
	crMethod(handle),
	m_dt(handle.m_dt),
	m_totaltime(handle.m_totaltime)
{
}
void crJXJAppointCardValidTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = *((int*)(LOCREPARAM(param64)));
		}
		else
		{
			m_dt = 0;
		}
		break;
	}
}
void crJXJAppointCardValidTimeMethod::addParam(int i, const std::string& str)
{
}
void crJXJAppointCardValidTimeMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			void *param;
			float validtime = 0.0f;
			bool ifneedsendpacket = false;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKECREPARAM(WCH_LockData,1));
			thisData->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
			JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			crPlayerDataEventPacket packet;
			stream->createBuf(12);
			for (int i = 0; i < appointcardvec->size(); i++)
			{
				if ((*appointcardvec)[i]!=NULL)
				{
					validtime = (*appointcardvec)[i]->getValidTime() - m_dt;
					if (validtime < 0)
					{
						validtime = 0.0f;
						if ((*appointcardvec)[i]->getValidTime() > 0)
						{
							ifneedsendpacket = true;
						}
					}
					(*appointcardvec)[i]->setValidTime(validtime);
					stream->_writeFloat((*appointcardvec)[i]->getValidTime());
				}
				//else
				//{
				//	stream->_writeUShort(0);
				//}
			}
			m_totaltime += m_dt;
			if (m_totaltime >= 30.0f)
			{
				ifneedsendpacket = true;
				m_totaltime = 0.0f;//
			}
			if (ifneedsendpacket)
			{
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvAppointValidTime,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvAppointValidTimeMethod
//
/////////////////////////////////////////
crJXJRecvAppointValidTimeMethod::crJXJRecvAppointValidTimeMethod():
	m_this(NULL)
{
}
crJXJRecvAppointValidTimeMethod::crJXJRecvAppointValidTimeMethod(const crJXJRecvAppointValidTimeMethod& handle):
	crMethod(handle),
	m_this(handle.m_this)
{
}
void crJXJRecvAppointValidTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvAppointValidTimeMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvAppointValidTimeMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKECREPARAM(WCH_LockData,1));
		thisData->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
		JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
		for (int i = 0; i < appointcardvec->size(); i++)
		{
			if ((*appointcardvec)[i]!=NULL)
			{
				(*appointcardvec)[i]->setValidTime(m_stream->_readFloat());
			}
		}
		thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUpdateAppointCardValidTimeMethod
//
/////////////////////////////////////////
crJXJUpdateAppointCardValidTimeMethod::crJXJUpdateAppointCardValidTimeMethod():
	m_this(NULL)
{
	for (int i = 0;i<3;i++)
	{
		m_oldvalidtime[i] = 0;
		m_newvalidtime[i] = 0;
	}
}
crJXJUpdateAppointCardValidTimeMethod::crJXJUpdateAppointCardValidTimeMethod(const crJXJUpdateAppointCardValidTimeMethod& handle):
	crMethod(handle),
	m_curPageNum(handle.m_curPageNum)
{
	for (int i =0;i<3;i++)
	{
		m_timelimitinput[i] = handle.m_timelimitinput[i];
		m_oldvalidtime[i] = handle.m_oldvalidtime[i];
		m_newvalidtime[i] = handle.m_newvalidtime[i];
	}
}
void crJXJUpdateAppointCardValidTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUpdateAppointCardValidTimeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_timelimitinput[i] = str;
		break;
	case 1:
		m_timelimitinput[i] = str;
		break;
	case 2:
		m_timelimitinput[i] = str;
		break;
	case 3:
		m_curPageNum = str;
		break;
	default:
		break;
	}
}
void crJXJUpdateAppointCardValidTimeMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this)
	{
		void *param;
		ref_ptr<crStaticTextWidgetNode> timelimitinput[3] = {NULL};
		ref_ptr<crRadioGroupWidgetNode> AppointcurPageNum = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_curPageNum));
		crData *thisData = playerGameData->getDataClass();
		thisData->excHandle(MAKECREPARAM(WCH_LockData,1));
		thisData->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
		JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
		unsigned int Appointcurpage = 0;
		if (AppointcurPageNum.valid())
		{
			Appointcurpage= AppointcurPageNum->getSelect();
		}
		if (appointcardvec)
		{
			switch (Appointcurpage)
			{
			case 0:
				for (int i = 0; i < appointcardvec->size() && i < 3; i++)
				{
					if ((*appointcardvec)[i]!=NULL)
					{
						if((int)(*appointcardvec)[i]->getValidTime() != m_oldvalidtime[i])
						{
							m_oldvalidtime[i] = (int)(*appointcardvec)[i]->getValidTime();
							m_newvalidtime[i] = (int)(*appointcardvec)[i]->getValidTime();
						}
						else
						{
							m_newvalidtime[i] -= 1;
							if (m_newvalidtime[i] <= 0)
							{
								m_newvalidtime[i] = 0;
							}
						}
						timelimitinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_timelimitinput[i]));
						if (timelimitinput[i].valid())
						{
							if (m_newvalidtime[i] > 0)
							{
								timelimitinput[i]->setColor(crVector4f(255.0f,0.0f,0.0f,255.0f));
								int hour = m_newvalidtime[i]/3600;
								int t = m_newvalidtime[i]%3600;
								int minute = t/60;
								int s = t%60;
								timelimitinput[i]->setString(std::string("撤销委任")+crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
							}
							else
							{
								timelimitinput[i]->setColor(crVector4f(255.0f,50.0f,50.0f,255.0f));
								timelimitinput[i]->setString(std::string("可以重新委任啦"));//("/*委任时间已到*/"));
							}
						}
					}
				}
				break;
			case 1:
				for (int i = 0; i < appointcardvec->size() && i < 3; i++)
				{
					if ((*appointcardvec)[i+3]!=NULL)
					{
						if((int)(*appointcardvec)[i+3]->getValidTime() != m_oldvalidtime[i])
						{
							m_oldvalidtime[i] = (int)(*appointcardvec)[i+3]->getValidTime();
							m_newvalidtime[i] = (int)(*appointcardvec)[i+3]->getValidTime();
						}
						else
						{
							m_newvalidtime[i] -= 1;
							if (m_newvalidtime[i] <= 0)
							{
								m_newvalidtime[i] = 0;
							}
						}
						timelimitinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_timelimitinput[i]));
						if (timelimitinput[i].valid())
						{
							if (m_newvalidtime[i] > 0)
							{
								timelimitinput[i]->setColor(crVector4f(255.0f,0.0f,0.0f,255.0f));
								int hour = m_newvalidtime[i]/3600;
								int t = m_newvalidtime[i]%3600;
								int minute = t/60;
								int s = t%60;
								timelimitinput[i]->setString(std::string("撤销委任")+crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
							}
							else
							{
								timelimitinput[i]->setColor(crVector4f(255.0f,50.0f,50.0f,255.0f));
								timelimitinput[i]->setString(std::string("可以重新委任啦"));//("/*委任时间已到*/"));
							}
						}
					}
				}
				break;
			case 2:
				for (int i = 0; i < appointcardvec->size() && i < 3; i++)
				{
					if ((*appointcardvec)[i+6]!=NULL)
					{
						if((int)(*appointcardvec)[i+6]->getValidTime() != m_oldvalidtime[i])
						{
							m_oldvalidtime[i] = (int)(*appointcardvec)[i+6]->getValidTime();
							m_newvalidtime[i] = (int)(*appointcardvec)[i+6]->getValidTime();
						}
						else
						{
							m_newvalidtime[i] -= 1;
							if (m_newvalidtime[i] <= 0)
							{
								m_newvalidtime[i] = 0;
							}
						}
						timelimitinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_timelimitinput[i]));
						if (timelimitinput[i].valid())
						{
							if (m_newvalidtime[i] > 0)
							{
								timelimitinput[i]->setColor(crVector4f(255.0f,0.0f,0.0f,255.0f));
								int hour = m_newvalidtime[i]/3600;
								int t = m_newvalidtime[i]%3600;
								int minute = t/60;
								int s = t%60;
								timelimitinput[i]->setString(std::string("撤销委任")+crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
							}
							else
							{
								timelimitinput[i]->setColor(crVector4f(255.0f,50.0f,50.0f,255.0f));
								timelimitinput[i]->setString(std::string("可以重新委任啦"));//("/*委任时间已到*/"));
							}
						}
					}
				}
				break;
			default:
				break;
			}
		}
		thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUIAppointOneJiangkaMethod
//
/////////////////////////////////////////
crJXJUIAppointOneJiangkaMethod::crJXJUIAppointOneJiangkaMethod():
	m_ea(NULL),
	m_this(NULL),
	m_namecolor(crVector4f(100.0f,190.0f,12.0f,255.0f))
{}
crJXJUIAppointOneJiangkaMethod::crJXJUIAppointOneJiangkaMethod(const crJXJUIAppointOneJiangkaMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_namecolor(handle.m_namecolor),
	m_ea(NULL),
	m_this(NULL),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
	for (int i = 0;i<3;i++)
	{
		m_image[i] = handle.m_image[i];
	}
}
void crJXJUIAppointOneJiangkaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crListControlWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIAppointOneJiangkaMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_namecolor);
		break;
	case 5:
		m_image[0] = str;
		break;
	case 6:
		m_image[1] = str;
		break;
	case 7:
		m_image[2] = str;
		break;
	case 8:
		m_tipcanvas = str;
		break;
	case 9:
		m_tiptitle = str;
		break;
	case 10:
		m_tipcontent = str;
		break;
	}
}
void crJXJUIAppointOneJiangkaMethod::operator()(crHandle &handle)
{
	bool ifequip = false;
	bool ifhavesamecard = false;
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	ref_ptr<crListControlNode> selectNode = m_this->getSelectNode();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();

	if(myPlayer && netConductor && selectNode.valid() && canvas.valid() && canvas->getDataClass()/* && selectNode->getVisiable()*/)
	{
		crData *canvasdata = canvas->getDataClass();
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crTableIO::StrVec record,record2;
		crData *data = myPlayer->getDataClass();
		crData *roledata = myPlayer->getMainRole()->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		void *param;
		data->getParam(WCHDATA_JXJJiangkaBagVec,param);
		JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
		data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
		JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
		unsigned char appointColumns = 3;
		if (roledata)
		{
			roledata->getParam(WCHDATA_JXJAppointColumnsVec, param);
			if (param) appointColumns = *(unsigned char *)param;
		}
		//braindata
		if(selectNode->getData() < itembagvec->size())
		{
			if ((*itembagvec)[selectNode->getData()]!=NULL)
			{
				do 
				{
					if(!m_this)
						break;
					crWidgetNode* pickUI = NULL;
					if (m_ea)
					{
						crVector2 mouse(m_ea->getXnormalized(), m_ea->getYnormalized());
						crWidgetNode *capturer = crFilterRenderManager::getInstance()->getMouseCapturer();
						crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
						crFilterRenderManager::getInstance()->mousePick(mouse,pickUI);
						crFilterRenderManager::getInstance()->setMouseCapturer(capturer);
					}
					//if(!pickUI)
					//{//Drop Item
					//	break;
					//}
					//else if(pickUI != selectNode.get())
					{
						int nameindex = itemtab->getTitleIndex("name");
						int itemid = (*itembagvec)[selectNode->getData()]->getItemID();
						if (itemid>0)
						{
							if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
							{
								for (JXJAppointCardVec::iterator itr = appointcardvec->begin();itr!=appointcardvec->end();++itr)
								{
									if ((*itr)!=NULL)
									{
										if (itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),record2) >= 0 )
										{
											if(record[nameindex] == record2[nameindex])
											{
												ifhavesamecard = true;
												break;
											}
										}
									}
								}
								if (!ifhavesamecard)
								{
									for(int i = 0; i < appointColumns; i++)
									{
										if (i < appointcardvec->size())
										{
											if ((*appointcardvec)[i] == NULL)
											{
												canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
												canvasdata->getParam(WCHDATA_JXJCurSelAppointCardid,param);
												int *curcardid = (int *)param;
												*curcardid = itemid;
												canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
												//dynamic_cast<crImageBoxWidgetNode *>(pickUI)->select(true);
												//if(dynamic_cast<crImageBoxWidgetNode *>(pickUI) && pickUI->getName().compare(m_image[i]) == 0)
												{
													ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
													if (msgCanvas.valid())
													{
														ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
														ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
														ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));

														if (okBtn.valid())
														{
															okBtn->setEnable(true);
														}
														std::vector<float>v_i;
														ItemMap itemMap;
														rcfg::ConfigScript cfg_script(&itemMap);
														cfg_script.Add("Hypertext");
														cfg_script.Push("Hypertext");
														cfg_script.Add("Content");
														cfg_script.Push("Content");
														cfg_script.Add("Text","您确认要派遣足智多谋的");
														cfg_script.Pop();

														cfg_script.Add("Content");
														cfg_script.Push("Content",2);
														v_i.clear();
														v_i.push_back(m_namecolor[0]);
														v_i.push_back(m_namecolor[1]);
														v_i.push_back(m_namecolor[2]);
														v_i.push_back(m_namecolor[3]);
														cfg_script.Add("Color",v_i);
														char tmpText[160]/*,tmpText2[80]*/;
														sprintf(tmpText,"【%s】\0",record[nameindex].c_str());
														cfg_script.Add("Text",tmpText);
														cfg_script.Pop();

														cfg_script.Add("Content");
														cfg_script.Push("Content",3);
														//sprintf(tmpText2,"吗？\0",recruitcountnum,name.c_str());
														cfg_script.Add("Text","来管理内政吗？");
														cfg_script.Pop();

														cfg_script.Pop();
														if(msg.valid())msg->setHypertext(cfg_script);

														if (msgCanvas.valid())
														{
															crData *dlgData = msgCanvas->getDataClass();
															int commandtype = CDP_Widget;
															dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
															dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
															crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
														}
														//ifequip = true;
														//ref_ptr<crStreamBuf> stream = new crStreamBuf;
														//stream->createBuf(5);
														//stream->_writeUChar((unsigned char)selectNode->getData());
														//stream->_writeInt(itemid);
														//crPlayerDataEventPacket packet;
														//crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPutOnEquip,stream.get());
														//netConductor->getNetManager()->sendPacket("all",packet);
													}
												}
											}
										}
									}
								}
								else
								{
									std::string str;
									str = "已经委任了【"+record[nameindex]+"】，请重新委任。";
									ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
									if (tipcanvas.valid())
									{
										ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
										ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
										if (tipcontent.valid())
										{
											tipcontent->setString(str);
										}
										crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
									}
								}
							}
						}
					}
					//crFilterRenderManager::getInstance()->setMouseCapturer(NULL);
				} while (0);
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJAppointOneJiangkaMethod
//
/////////////////////////////////////////
crJXJAppointOneJiangkaMethod::crJXJAppointOneJiangkaMethod():
	m_this(NULL)
{}
crJXJAppointOneJiangkaMethod::crJXJAppointOneJiangkaMethod(const crJXJAppointOneJiangkaMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJAppointOneJiangkaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJAppointOneJiangkaMethod::addParam(int i, const std::string& str)
{
}

void crJXJAppointOneJiangkaMethod::operator()(crHandle &handle)
{
	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	if (playerData && m_this)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid() && canvas->getDataClass())
		{
			void *param;
			crData *canvasdata = canvas->getDataClass();
			canvasdata->getParam(WCHDATA_JXJCurSelAppointCardid,param);
			int curcardid = *(int *)param;
			CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(curcardid);
			CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
			CRNetApp::crPlayerDataEventPacket packet;
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvAppointOneJiangka,stream.get());
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvAppointOneJiangkaMethod
//
/////////////////////////////////////////
crJXJRecvAppointOneJiangkaMethod::crJXJRecvAppointOneJiangkaMethod():
	m_netType(GameClient_Game){}
crJXJRecvAppointOneJiangkaMethod::crJXJRecvAppointOneJiangkaMethod(const crJXJRecvAppointOneJiangkaMethod& handle):
	crMethod(handle),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvAppointOneJiangkaMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvAppointOneJiangkaMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tiptitle = str;
		break;
	case 2:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvAppointOneJiangkaMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			bool success = false;
			bool ifonerowempty = false;
			bool ifsamecard = false;
			unsigned char appointpos = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			if (data)
			{
				//返回信息
				data -> getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				unsigned char secondrowopenlv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSecondRowOpenLevel,viplv).c_str()));
				unsigned char threerowopenlv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJThreeRowOpenLevel,viplv).c_str()));
				float appointcardmaxtime = (float)(atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAppointCardMaxTime,viplv).c_str()));
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
				if(playerData.valid())
				{//验证材料是否充足
					ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					int cardid = m_stream->_readInt();
					crTableIO::StrVec record,record2;
					int typeindex = itemtab->getTitleIndex("将卡类型");
					int nameindex = itemtab->getTitleIndex("name");
					if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),record) >= 0 && atoi(record[typeindex].c_str()) == JiangkaType_zheng) 
					{
						crRole *mainrole = m_this->getMainRole();
						if (mainrole)
						{
							crData *mainroledata = mainrole->getDataClass();
							if (mainroledata)
							{
								mainroledata->getParam(WCHDATA_Level,param);
								unsigned char mylevel = *(unsigned char *)param;
								mainroledata->getParam(WCHDATA_JXJAppointColumnsVec, param);
								unsigned char appointColumns = 3;
								if(param) appointColumns = *(unsigned char *)param;
								data->excHandle(MAKECREPARAM(WCH_LockData,1));
								data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
								JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
								data->getParam(WCHDATA_JXJJiangkaBagVec,param);
								JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
								for (JXJAppointCardVec::iterator itr = appointcardvec->begin();itr!=appointcardvec->end();++itr)
								{
									if ((*itr)!=NULL)
									{
										if (itemtab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getItemID()),record2) >= 0 )
										{
											if(record[nameindex] == record2[nameindex])
											{
												ifsamecard = true;
												break;
											}
										}
									}
								}
								if (!ifsamecard)
								{
									for (int i = 0; i<appointcardvec->size();i++)
									{
										if ((*appointcardvec)[i] == NULL)
										{
											appointpos = (unsigned char)i;
											switch (i)
											{
											case 0:
												ifonerowempty = true;
												break;
											case 1:
												if (mylevel >= secondrowopenlv)
												{
													ifonerowempty = true;
												}
												break;
											case 2:
												//验证VIP等级
												if (viplv >= threerowopenlv)
												{
													ifonerowempty = true;
												}
												break;
											case 3:
												//验证是否已经购买第四个委任栏
												if (appointColumns >= 4)
												{
													ifonerowempty = true;
												}
												break;
											case 4:
												if (appointColumns >= 5)
												{
													ifonerowempty = true;
												}
												break;
											case 5:
												if (appointColumns >= 6)
												{
													ifonerowempty = true;
												}
												break;
											case 6:
												if (appointColumns >= 7)
												{
													ifonerowempty = true;
												}
												break;
											case 7:
												if (appointColumns >= 8)
												{
													ifonerowempty = true;
												}
												break;
											case 8:
												if (appointColumns >= 9)
												{
													ifonerowempty = true;
												}
												break;
											default:
												break;
											}
											if (ifonerowempty)
											{
												break;
											}
										}
									}
									if (ifonerowempty)
									{
										for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
											itr!=jiangkabagvec->end();
											++itr)
										{
											if ((*itr)!=NULL)
											{
												if ((*itr)->getItemID() == cardid)
												{
													success = true;
													(*itr) = NULL;
													break;
												}
											}
										}
										ref_ptr<crAppointCardData> appointcard = new crAppointCardData;
										appointcard->setItemID(cardid);
										appointcard->setValidTime(appointcardmaxtime);
										(*appointcardvec)[appointpos] = appointcard;
									}
								}
								data->excHandle(MAKECREPARAM(WCH_LockData,0));
							}
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(6);
					//stream->_writeUChar(success);
					stream->_writeBool(success);
					stream->_writeUChar(appointpos);
					stream->_writeInt(cardid);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvAppointOneJiangka,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					///游戏日志
					std::string logdata = crArgumentParser::appVectoa(crVector2i(success,cardid));
					GameLogData gamelog(Log_AppointOneJiangka,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			//unsigned char success = m_stream->_readUChar();
			bool  success = m_stream->_readBool();
			unsigned char  appointpos = m_stream->_readUChar();
			int cardid = m_stream->_readInt();
			std::string str= "委任失败！";
			if (success)
			{
				str= "委任成功！";
				crData *data = m_this->getDataClass();
				void *param;
				if (data)
				{
					data -> getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					float appointcardmaxtime = (float)(atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAppointCardMaxTime,viplv).c_str()));
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
					JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
					JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
					for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
						itr!=jiangkabagvec->end();
						++itr)
					{
						if ((*itr)!=NULL)
						{
							if ((*itr)->getItemID() == cardid)
							{
								success = true;
								(*itr) = NULL;
								break;
							}
						}
					}
					ref_ptr<crAppointCardData> appointcard = new crAppointCardData;
					appointcard->setItemID(cardid);
					appointcard->setValidTime(appointcardmaxtime);
					(*appointcardvec)[appointpos] = appointcard;
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}
			ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
			if (tipcanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
				ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
				if (tipcontent.valid())
				{
					tipcontent->setString(str);
				}
				crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
			}
		}
	}
}
//////////////////////////////////
////
////crUIShowTaskMethod
////
/////////////////////////////////////
//crUIShowTaskMethod::crUIShowTaskMethod():
//	m_taskid(0),
//	m_canvas(NULL),
//	m_waitTime(5000)
//{
//}
//crUIShowTaskMethod::crUIShowTaskMethod(const crUIShowTaskMethod& handle):
//	crMethod(handle),
//	m_taskid(0),
//	m_canvas(NULL),
//	m_frameStaticText(handle.m_frameStaticText),
//	m_desTextHypertext(handle.m_desTextHypertext),
//	m_progressHypertext(handle.m_progressHypertext),
//	m_item1ImageBox(handle.m_item1ImageBox),
//	m_item2ImageBox(handle.m_item2ImageBox),
//	m_item3ImageBox(handle.m_item3ImageBox),
//	m_item4ImageBox(handle.m_item4ImageBox),
//	m_expStaticText(handle.m_expStaticText),
//	m_exp2StaticText(handle.m_exp2StaticText),
//	m_goldStaticText(handle.m_goldStaticText),
//	m_waitTime(handle.m_waitTime)
//{
//}
//
//void crUIShowTaskMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_canvas = NULL;
//		}
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_taskid = LOINT64(param64);
//			m_canvas = (std::string *)(HIINT64(param64));
//		}
//		else
//		{
//			m_taskid = 0;
//		}
//		break;
//	}
//}
//
//void crUIShowTaskMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_frameStaticText = str;
//		break;
//	case 1:
//		m_desTextHypertext = str;
//		break;
//	case 2:
//		m_progressHypertext = str;
//		break;
//	case 3:
//		m_item1ImageBox = str;
//		break;
//	case 4:
//		m_item2ImageBox = str;
//		break;
//	case 5:
//		m_item3ImageBox = str;
//		break;
//	case 6:
//		m_item4ImageBox = str;
//		break;
//	case 7:
//		m_expStaticText = str;
//		break;
//	case 8:
//		m_exp2StaticText = str;
//		break;
//	case 9:
//		m_goldStaticText = str;
//		break;
//	case 10:
//		m_waitTime = atoi(str.c_str());
//		break;
//	}
//}
//
//void crUIShowTaskMethod::operator()(crHandle &handle)
//{
//	do 
//	{
//		if(m_taskid == 0)
//			break;
//
//		void *param;
//		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
//		crData *metierData = me->getMetierDataClass();
//		metierData->excHandle(MAKECREPARAM(WCH_LockData,1));
//		metierData->getParam(WCHDATA_GameTaskMap,param);
//		GameTaskMap* gameTaskMap = (GameTaskMap* )param;
//		GameTaskMap::iterator itr = gameTaskMap->find(m_taskid);
//		ref_ptr<crGameTask> gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
//		metierData->excHandle(MAKECREPARAM(WCH_LockData,0));
//		if(!gameTask.valid())
//			break;
//
//		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(*m_canvas);
//		if(!canvas)
//			break;
//		ref_ptr<crStaticTextWidgetNode> frameWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_frameStaticText));
//		if(frameWidget)
//		{
//			frameWidget->setString(gameTask->getTaskName());
//		}
//		ref_ptr<crHypertextWidgetNode> desWidget = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_desTextHypertext));
//		if(desWidget)
//		{
//			std::string file = gameTask->getHyperText();
//			if(!file.empty())
//				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
//			desWidget->setHypertext(file);
//		}
//		ref_ptr<crHypertextWidgetNode> progressWidget = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_progressHypertext));
//		if(progressWidget)
//		{
//			std::string file = gameTask->getHyperText();
//			if(gameTask->isComplete() || file.empty())
//			{
//				progressWidget->clearText();
//			}
//			else if(!gameTask->getActivation())
//			{
//				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
//				std::string ext = crArgumentParser::getFileExtension(file);
//				file = crArgumentParser::getFileNameEliminateExt(file)+"0."+ext;
//				progressWidget->setHypertext(file);
//			}
//			else
//			{
//				file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
//				std::string ext = crArgumentParser::getFileExtension(file);
//
//				unsigned char steptype = gameTask->getTaskStepType();
//				if(steptype == TS_Zero)
//				{
//					int progress = gameTask->getTaskProgress()+1;
//					file = crArgumentParser::getFileNameEliminateExt(file)+crArgumentParser::appItoa(progress)+"."+ext;
//					progressWidget->setHypertext(file);
//				}
//				else if(gameTask->isTaskCanRefer())
//				{
//					file = crArgumentParser::getFileNameEliminateExt(file)+"1."+ext;
//					progressWidget->setHypertext(file);
//				}
//				else
//				{
//					char tmpText[64];
//					std::string relfile;
//					int progress = gameTask->getTaskProgress();
//					_crInt16 A,B;
//					A = LOINT32(progress);
//					B = HIINT32(progress);
//					_crInt16 C,D;
//					int step = gameTask->getTaskSteps()-1;
//					C = LOINT32(step);
//					D = HIINT32(step);
//					_crInt8 a,c;
//					if(steptype >= TS_One)
//					{
//						relfile = crArgumentParser::getFileNameEliminateExt(file)+"One."+ext;
//						progressWidget->setHypertext(relfile);
//
//						a = LOINT16(A);
//						c = LOINT16(C);
//						ItemMap itemMap;
//						rcfg::ConfigScript cfg_script(&itemMap);
//						cfg_script.Add("Hypertext");
//						cfg_script.Push("Hypertext");
//						cfg_script.Add("Content");
//						cfg_script.Push("Content");
//						std::vector<float>v_i;
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						cfg_script.Add("Color",v_i);
//						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//						cfg_script.Add("Text",tmpText);
//						cfg_script.Pop();
//						cfg_script.Pop();
//						progressWidget->setHypertext(cfg_script,true);
//					}
//					if(steptype >= TS_Two)
//					{
//						relfile = crArgumentParser::getFileNameEliminateExt(file)+"Two."+ext;
//						progressWidget->setHypertext(relfile,true);
//
//						a = HIINT16(A);
//						c = HIINT16(C);
//						ItemMap itemMap;
//						rcfg::ConfigScript cfg_script(&itemMap);
//						cfg_script.Add("Hypertext");
//						cfg_script.Push("Hypertext");
//						cfg_script.Add("Content");
//						cfg_script.Push("Content");
//						std::vector<float>v_i;
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						cfg_script.Add("Color",v_i);
//						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//						cfg_script.Add("Text",tmpText);
//						cfg_script.Pop();
//						cfg_script.Pop();
//						progressWidget->setHypertext(cfg_script,true);
//					}
//					if(steptype >= TS_Three)
//					{
//						relfile = crArgumentParser::getFileNameEliminateExt(file)+"Three."+ext;
//						progressWidget->setHypertext(relfile,true);
//
//						a = LOINT16(B);
//						c = LOINT16(D);
//						ItemMap itemMap;
//						rcfg::ConfigScript cfg_script(&itemMap);
//						cfg_script.Add("Hypertext");
//						cfg_script.Push("Hypertext");
//						cfg_script.Add("Content");
//						cfg_script.Push("Content");
//						std::vector<float>v_i;
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						cfg_script.Add("Color",v_i);
//						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//						cfg_script.Add("Text",tmpText);
//						cfg_script.Pop();
//						cfg_script.Pop();
//						progressWidget->setHypertext(cfg_script,true);
//					}
//					if(steptype >= TS_Four)
//					{
//						relfile = crArgumentParser::getFileNameEliminateExt(file)+"Four."+ext;
//						progressWidget->setHypertext(relfile,true);
//
//						a = HIINT16(B);
//						c = HIINT16(D);
//						ItemMap itemMap;
//						rcfg::ConfigScript cfg_script(&itemMap);
//						cfg_script.Add("Hypertext");
//						cfg_script.Push("Hypertext");
//						cfg_script.Add("Content");
//						cfg_script.Push("Content");
//						std::vector<float>v_i;
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						v_i.push_back(0.0f);
//						v_i.push_back(255.0f);
//						cfg_script.Add("Color",v_i);
//						sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//						cfg_script.Add("Text",tmpText);
//						cfg_script.Pop();
//						cfg_script.Pop();
//						progressWidget->setHypertext(cfg_script,true);
//					}
//				}
//			}
//		}
//		ref_ptr<crStaticTextWidgetNode> expWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_expStaticText));
//		if(expWidget)
//		{
//			expWidget->setString(crArgumentParser::appItoa(gameTask->getExp()));
//		}
//		ref_ptr<crStaticTextWidgetNode> exp2Widget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_exp2StaticText));
//		if(exp2Widget)
//		{
//			exp2Widget->setString(crArgumentParser::appItoa(gameTask->getExp2()));
//		}
//		ref_ptr<crStaticTextWidgetNode> goldWidget = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_goldStaticText));
//		if(goldWidget)
//		{
//			goldWidget->setString(crArgumentParser::appItoa(gameTask->getGold()));
//		}
//		///m_item1ImageBox
//		bool request = gameTask->isRequestAwardItem();
//		if(request)
//		{
//			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//			if(netConductor)
//			{
//				crWaitNetReturnStreamLogic::getLock();
//				crRequestTaskAwardInfoPacket packet;
//				crRequestTaskAwardInfoPacket::buildRequestPacket(packet,me->getRoleID(),m_taskid);
//				netConductor->getNetManager()->sendPacket("all",packet);
//				crWaitNetReturnStreamLogic::simpleWait(m_waitTime);
//			}
//		}
//		int i = 0;
//		crImageBoxWidgetNode *imagebox[4];
//		imagebox[0] = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_item1ImageBox));
//		imagebox[1] = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_item2ImageBox));
//		imagebox[2] = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_item3ImageBox));
//		imagebox[3] = dynamic_cast<crImageBoxWidgetNode *>(canvas->getWidget(m_item4ImageBox));
//		if(/*gameTask->getActivation() && */!gameTask->isComplete())
//		{
//			crData *itemData;
//			AwardItemMap &awardItemMap = gameTask->getAwardItemMap();
//			for( AwardItemMap::iterator itr = awardItemMap.begin();
//				itr != awardItemMap.end()&&i<4;
//				++itr,i++ )
//			{
//				if(itr->second.valid())
//				{
//					itemData = itr->second->getDataClass();
//					itemData->getParam(WCHDATA_ItemIcon,param);
//					imagebox[i]->setImageName(*(std::string *)param);
//				}
//				else
//				{
//					imagebox[i]->setImageName(std::string());
//				}
//			}
//		}
//		for(int j = i; j<4; j++)
//		{
//			imagebox[j]->setImageName(std::string());
//		}
//		metierData->inputParam(WCHDATA_CurrentTaskID,&m_taskid);
//		crFilterRenderManager::getInstance()->showCanvas(canvas,true);
//	} while (0);
//}
//////////////////////////////////
////
////crUIAwardItemTipInfoMethod
////
/////////////////////////////////////
//crUIAwardItemTipInfoMethod::crUIAwardItemTipInfoMethod():
//	m_id(1),
//	m_ea(NULL)
//{
//}
//crUIAwardItemTipInfoMethod::crUIAwardItemTipInfoMethod(const crUIAwardItemTipInfoMethod& handle):
//	crMethod(handle),
//	m_id(handle.m_id),
//	m_tipCanvasName(handle.m_tipCanvasName),
//	m_tipWidgetName(handle.m_tipWidgetName),
//	m_ea(NULL)
//{
//}
//
//void crUIAwardItemTipInfoMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_ea = NULL;
//		}
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
//		}
//		else
//		{
//			m_ea = NULL;
//		}
//		break;
//	}
//}
//
//void crUIAwardItemTipInfoMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_id = atoi(str.c_str());
//		break;
//	case 1:
//		m_tipCanvasName = str;
//		break;
//	case 2:
//		m_tipWidgetName = str;
//		break;
//	}
//}
//
//void crUIAwardItemTipInfoMethod::operator()(crHandle &handle)
//{
//	do 
//	{
//		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_tipCanvasName);
//		if(!canvas)
//			break;
//		ref_ptr<crHypertextWidgetNode> widget = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_tipWidgetName));
//		if(!widget)
//			break;
//		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
//		if(me)
//		{
//			void *param;
//			crData *metierData = me->getMetierDataClass();
//			metierData->getParam(WCHDATA_CurrentTaskID,param);
//			int taskid = *(int *)param;
//			ref_ptr<crGameTask> gameTask;
//			metierData->getParam(WCHDATA_GameTaskMap,param);
//			metierData->excHandle(MAKECREPARAM(WCH_LockData,1));
//			GameTaskMap* gameTaskMap = (GameTaskMap* )param;
//			GameTaskMap::iterator itr = gameTaskMap->find(taskid);
//			gameTask = itr!=gameTaskMap->end()?itr->second.get():NULL;
//			metierData->excHandle(MAKECREPARAM(WCH_LockData,0));
//			if(gameTask.valid() && /*gameTask->getActivation() && */!gameTask->isComplete())
//			{
//				AwardItemMap &awardItemMap = gameTask->getAwardItemMap();
//				int i = 1;
//				for( AwardItemMap::iterator itr = awardItemMap.begin();
//					itr != awardItemMap.end()&&i<5;
//					++itr,i++ )
//				{
//					if(i == m_id)
//					{
//						if(itr->second.valid())
//						{
//							crInstanceItem *item = itr->second.get();
//							crData *itemData = item->getDataClass();
//							void *param;
//							itemData->getParam(WCHDATA_ItemInfoText,param);
//							std::string file = *(std::string *)param;
//							if(!file.empty())
//								file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
//							widget->setHypertext(file);
//							itemData->getParam(WCHDATA_ItemPrice,param);
//							int price = *(int*)param;
//							price *= crGlobalHandle::gData()->gSalerate();
//							char tmpText[64];
//							ItemMap itemMap;
//							rcfg::ConfigScript cfg_script(&itemMap);
//							cfg_script.Add("Hypertext");
//							cfg_script.Push("Hypertext");
//							cfg_script.Add("Content");
//							cfg_script.Push("Content");
//							std::vector<float>v_i;
//							v_i.push_back(255.0f);
//							v_i.push_back(255.0f);
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							cfg_script.Add("Color",v_i);
//							sprintf(tmpText,"回收价：%d\0",price);
//							cfg_script.Add("Text",tmpText);
//							cfg_script.Pop();
//							cfg_script.Pop();
//							widget->setHypertext(cfg_script,true);
//							crVector2 mouse(m_ea->getXnormalized(),m_ea->getYnormalized());
//							canvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
//							canvas->setCanFocus(false);
//							crFilterRenderManager::getInstance()->showCanvas(canvas,true);
//						}
//						break;
//					}
//				}
//			}
//		}
//	} while (0);
//}
//////////////////////////////////
////
////crUIShowTask2Method
////
/////////////////////////////////////
//crUIShowTask2Method::crUIShowTask2Method():
//	m_taskid(0)
//{
//}
//crUIShowTask2Method::crUIShowTask2Method(const crUIShowTask2Method& handle):
//	crMethod(handle),
//	m_taskid(handle.m_taskid)
//{
//}
//
//void crUIShowTask2Method::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crListBoxWidgetNode*)param;
//		break;
//	}
//}
//
//void crUIShowTask2Method::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_taskid = atoi(str.c_str());
//		break;
//	case 1:
//		m_canvas = str;
//		break;
//	}
//}
//
//void crUIShowTask2Method::operator()(crHandle &handle)
//{
//	crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
//	if(!me) return;
//	if(m_taskid != 0)
//	{
//		if(m_taskid == -1)
//		{
//			void *param;
//			crData *metierData = me->getMetierDataClass();
//			metierData->getParam(WCHDATA_CurrentTaskID,param);
//			int taskid = *(int *)param;
//			me->doEvent(WCH_UIShowTask,MAKECREPARAM(taskid,&m_canvas));
//		}
//		else
//			me->doEvent(WCH_UIShowTask,MAKECREPARAM(m_taskid,&m_canvas));
//	}
//	else if(m_this)
//	{
//		do 
//		{
//			std::wstring curData;
//			if(!m_this->getData(m_this->getSelect(),curData) || curData.empty())
//				break;
//			int taskid = _wtoi(curData.c_str());
//			if(taskid == 0)
//				break;
//			me->doEvent(WCH_UIShowTask,MAKECREPARAM(taskid,&m_canvas));
//		} while (0);
//	}
//}
///////////////////////////////////////////
////
////crUIUpdateTaskTraceMethod
////
///////////////////////////////////////////
//crUIUpdateTaskTraceMethod::crUIUpdateTaskTraceMethod(){}
//crUIUpdateTaskTraceMethod::crUIUpdateTaskTraceMethod(const crUIUpdateTaskTraceMethod& handle):
//	crMethod(handle),
//	m_traceWidget(handle.m_traceWidget)
//{
//}
//void crUIUpdateTaskTraceMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//void crUIUpdateTaskTraceMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_traceWidget = str;
//		break;
//	}
//}
//void crUIUpdateTaskTraceMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_this->getVisiable())
//	{
//		crRole *me = crMyPlayerData::getInstance()->getCurrentRole();
//		if(!me) return;
//		ref_ptr<crHypertextWidgetNode> traceWidget = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_traceWidget));
//		traceWidget->clearText();
//		crData *myMetierData = me->getMetierDataClass();
//		void *param;
//		myMetierData->excHandle(MAKECREPARAM(WCH_LockData,1));
//		myMetierData->getParam(WCHDATA_GameTaskMap,param);
//		GameTaskMap *gameTaskMap = (GameTaskMap *)param;
//		if(!gameTaskMap||gameTaskMap->empty())
//		{
//			myMetierData->excHandle(MAKECREPARAM(WCH_LockData,0));
//			return;
//		}
//		std::string file,ext;
//		unsigned char steptype;
//		unsigned char i = 0;
//		char tmpText[64];
//		crGameTask* gameTask;
//		for( GameTaskMap::iterator itr = gameTaskMap->begin();
//			i<crGlobalHandle::gData()->gMaxDisplayTaskTrace() && itr != gameTaskMap->end();
//			++itr )
//		{
//			if(itr->second->getActivation() && !itr->second->isComplete())
//			{
//				gameTask = itr->second.get();
//				file = gameTask->getHyperText();
//				if(!file.empty())
//				{
//					ItemMap itemMap;
//					rcfg::ConfigScript cfg_script(&itemMap);
//					cfg_script.Add("Hypertext");
//					cfg_script.Push("Hypertext");
//					cfg_script.Add("Content");
//					cfg_script.Push("Content",1);
//					std::vector<float>v_i;
//					v_i.push_back(255.0f);
//					v_i.push_back(0.0f);
//					v_i.push_back(0.0f);
//					v_i.push_back(255.0f);
//					cfg_script.Add("Color",v_i);
//					cfg_script.Add("Text",itr->second->getTaskName()+"\n");
//					cfg_script.Pop();
//					cfg_script.Pop();
//					traceWidget->setHypertext(cfg_script,true);
//
//					file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
//					ext = crArgumentParser::getFileExtension(file);
//					steptype = itr->second->getTaskStepType();
//					if(steptype == TS_Zero)
//					{
//						int progress = gameTask->getTaskProgress()+1;
//						file = crArgumentParser::getFileNameEliminateExt(file)+crArgumentParser::appItoa(progress)+"."+ext;
//						traceWidget->setHypertext(file,true);
//					}
//					else if(gameTask->isTaskCanRefer())
//					{
//						file = crArgumentParser::getFileNameEliminateExt(file)+"1."+ext;
//						traceWidget->setHypertext(file,true);
//					}
//					else
//					{
//						std::string relfile;
//						int progress = gameTask->getTaskProgress();
//						_crInt16 A,B;
//						A = LOINT32(progress);
//						B = HIINT32(progress);
//						_crInt16 C,D;
//						int step = gameTask->getTaskSteps()-1;
//						C = LOINT32(step);
//						D = HIINT32(step);
//						_crInt8 a,c;
//						if(steptype >= TS_One)
//						{
//							relfile = crArgumentParser::getFileNameEliminateExt(file)+"One."+ext;
//							traceWidget->setHypertext(relfile,true);
//
//							a = LOINT16(A);
//							c = LOINT16(C);
//							ItemMap itemMap;
//							rcfg::ConfigScript cfg_script(&itemMap);
//							cfg_script.Add("Hypertext");
//							cfg_script.Push("Hypertext");
//							cfg_script.Add("Content");
//							cfg_script.Push("Content");
//							std::vector<float>v_i;
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							cfg_script.Add("Color",v_i);
//							sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//							cfg_script.Add("Text",tmpText);
//							cfg_script.Pop();
//							cfg_script.Pop();
//							traceWidget->setHypertext(cfg_script,true);
//						}
//						if(steptype >= TS_Two)
//						{
//							relfile = crArgumentParser::getFileNameEliminateExt(file)+"Two."+ext;
//							traceWidget->setHypertext(relfile,true);
//
//							a = HIINT16(A);
//							c = HIINT16(C);
//							ItemMap itemMap;
//							rcfg::ConfigScript cfg_script(&itemMap);
//							cfg_script.Add("Hypertext");
//							cfg_script.Push("Hypertext");
//							cfg_script.Add("Content");
//							cfg_script.Push("Content");
//							std::vector<float>v_i;
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							cfg_script.Add("Color",v_i);
//							sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//							cfg_script.Add("Text",tmpText);
//							cfg_script.Pop();
//							cfg_script.Pop();
//							traceWidget->setHypertext(cfg_script,true);
//						}
//						if(steptype >= TS_Three)
//						{
//							relfile = crArgumentParser::getFileNameEliminateExt(file)+"Three."+ext;
//							traceWidget->setHypertext(relfile,true);
//
//							a = LOINT16(B);
//							c = LOINT16(D);
//							ItemMap itemMap;
//							rcfg::ConfigScript cfg_script(&itemMap);
//							cfg_script.Add("Hypertext");
//							cfg_script.Push("Hypertext");
//							cfg_script.Add("Content");
//							cfg_script.Push("Content");
//							std::vector<float>v_i;
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							cfg_script.Add("Color",v_i);
//							sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//							cfg_script.Add("Text",tmpText);
//							cfg_script.Pop();
//							cfg_script.Pop();
//							traceWidget->setHypertext(cfg_script,true);
//						}
//						if(steptype >= TS_Four)
//						{
//							relfile = crArgumentParser::getFileNameEliminateExt(file)+"Four."+ext;
//							traceWidget->setHypertext(relfile,true);
//
//							a = HIINT16(B);
//							c = HIINT16(D);
//							ItemMap itemMap;
//							rcfg::ConfigScript cfg_script(&itemMap);
//							cfg_script.Add("Hypertext");
//							cfg_script.Push("Hypertext");
//							cfg_script.Add("Content");
//							cfg_script.Push("Content");
//							std::vector<float>v_i;
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							v_i.push_back(0.0f);
//							v_i.push_back(255.0f);
//							cfg_script.Add("Color",v_i);
//							sprintf(tmpText,"(%d/%d)\0",(int)a,(int)c);
//							cfg_script.Add("Text",tmpText);
//							cfg_script.Pop();
//							cfg_script.Pop();
//							traceWidget->setHypertext(cfg_script,true);
//						}
//					}
//					i++;
//				}
//			}
//		}
//		myMetierData->excHandle(MAKECREPARAM(WCH_LockData,0));
//	}
//}
/////////////////////////////////////////
//
//crJXJServerActiveTaskMethod
//
/////////////////////////////////////////
crJXJServerActiveTaskMethod::crJXJServerActiveTaskMethod()
{
}
crJXJServerActiveTaskMethod::crJXJServerActiveTaskMethod(const crJXJServerActiveTaskMethod& handle):
	crMethod(handle)
{
}
void crJXJServerActiveTaskMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	}
}
void crJXJServerActiveTaskMethod::addParam(int i, const std::string& str)
{
}
void crJXJServerActiveTaskMethod::operator()(crHandle &handle)
{
	void *param;
	crData *myMetierData = m_this->getMetierDataClass();
	if(myMetierData)
	{
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
		crNetDataManager *netDataManager = gameServer->getNetDataManager();
		crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
		int serverid = callback->getServerID();
		crDBSavePacket dbpacket;
		ref_ptr<crJXJInsertTaskrecord> insertTaskrecord = new crJXJInsertTaskrecord;

		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_Level,param);
		unsigned char lv = *(unsigned char *)param;

		unsigned char myShili;
		crNetConductor *netConduc = crNetContainer::getInstance()->getNetConductor(GameServer);
		if (netConduc)
		{
			ref_ptr<crGameServerPlayerData> gsplayerData = dynamic_cast<crGameServerPlayerData *>(netConduc->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
			if (gsplayerData.valid() && gsplayerData->getPlayerGameData())
			{
				crData *dat = gsplayerData->getPlayerGameData()->getDataClass();
				if (dat)
				{
					dat->getParam(WCHDATA_JXJShiliID,param);
					myShili = *(unsigned char *)param;
				}
			}
		}

		int playerid = m_this->getPlayerID();
		crData *serdata = crServerBrainHandle::getInstance()->getDataClass();
		crJXJShili *shili;
		crData *shiliData;
		serdata->getParam(WCHDATA_JXJShiliWei+myShili-c_startShiliID,param);
		shili = (crJXJShili *)param;
		unsigned char winCity = 0;
		unsigned char count = 0;
		int chengxiangid = 0;
		int dasimaid = 0;
		int dajiangjunid = 0;
		if(shili && shili->getDataClass())
		{
			shiliData = shili->getDataClass();
			shiliData->excHandle(MAKECREPARAM(WCH_LockData,1));
			shiliData->getParam(WCHDATA_JXJZhanLingCityCount,param);
			count = *(unsigned char*)param;

			shiliData->getParam(WCHDATA_JXJChengxiang,param);
			chengxiangid = *(int*)param;
			shiliData->getParam(WCHDATA_JXJDasima,param);
			dasimaid = *(int*)param;
			shiliData->getParam(WCHDATA_JXJDajiangjun,param);
			dajiangjunid = *(int*)param;

			shiliData->getParam(WCHDATA_JXJShiliFoundCountryWinCity,param);
			winCity = *(unsigned char *)param;
			shiliData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
		ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
		int taskidindex = tasktitletab->getTitleIndex("taskid");
		crTableIO::StrVec record;

		int cCompleteddailytask = 0;
		crGameTask *task;
		int pretask;
		std::vector<int> GetTaskVec;
		myMetierData->excHandle(MAKECREPARAM(WCH_LockData,1));
		myMetierData->getParam(WCHDATA_GameTaskMap,param);
		GameTaskMap *gameTaskMap = (GameTaskMap *)param;
		if(!gameTaskMap||gameTaskMap->empty())
		{
			myMetierData->excHandle(MAKECREPARAM(WCH_LockData,0));
			return;
		}
		GameTaskMap::iterator preItr;
		for( GameTaskMap::iterator itr = gameTaskMap->begin();
			itr != gameTaskMap->end();
			++itr )
		{
			task = itr->second.get();

			int renwutype = 0;
			if(tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(task->getTaskID()),record) >= 0)
				renwutype = atoi(record[0].c_str());

			if (renwutype == 4)
			{
				if(task->isComplete())
					cCompleteddailytask++;

				if(!task->isComplete() && task->getActivation())
					cCompleteddailytask++;

				if(cCompleteddailytask >= 3)
					continue;
			}

			if (renwutype == 5 && task->getActivation() && playerid!=chengxiangid && playerid!=dasimaid && playerid!=dajiangjunid)
			{
				task->resetTask();
				if(dbConductor)
				{//任务日志
					insertTaskrecord->buildUpdateSql(m_this->getPlayerID(),serverid,m_this->getIName(),task->getTaskID(),TS_Reset,task->getTaskProgress());
					crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
					dbConductor->getNetManager()->sendPacket("all",dbpacket);
				}
			}

			if(!task->getActivation() && !task->isComplete())
			{
				if(task->getTaskID()==21004 && winCity!=(unsigned char)-1)
				{//没有建国的时候不接取这个任务
					continue;
				}
				const CRCore::crVector2ub& lvrange = task->getLvRange();
				if(lv>=lvrange[0] && lv<=lvrange[1])
				{
					pretask = task->getPreTask();
					if(pretask == 0)
					{
						/*int renwutype = 0;
						if(tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(task->getTaskID()),record) >= 0)
						renwutype = atoi(record[0].c_str());*/
						if(renwutype != 5)//查询jxjtasktitle.tab确定任务类型
						{
							task->setActivation(true);
							GetTaskVec.push_back(task->getTaskID());
							if(dbConductor)
							{//任务日志
								insertTaskrecord->buildUpdateSql(m_this->getPlayerID(),serverid,m_this->getIName(),task->getTaskID(),TS_Activation,task->getTaskProgress());
								crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
								dbConductor->getNetManager()->sendPacket("all",dbpacket);
							}
						}
						else
						{
							if (playerid==chengxiangid || playerid==dasimaid || playerid==dajiangjunid)
							{
								task->setActivation(true);
								GetTaskVec.push_back(task->getTaskID());
								if(dbConductor)
								{//任务日志
									insertTaskrecord->buildUpdateSql(m_this->getPlayerID(),serverid,m_this->getIName(),task->getTaskID(),TS_Activation,task->getTaskProgress());
									crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
									dbConductor->getNetManager()->sendPacket("all",dbpacket);
								}
							}
						}
					}
					else
					{
						preItr = gameTaskMap->find(pretask);
						if(preItr != gameTaskMap->end() && preItr->second->isComplete())
						{
							task->setActivation(true);
							GetTaskVec.push_back(task->getTaskID());
							if(dbConductor)
							{//任务日志
								insertTaskrecord->buildUpdateSql(m_this->getPlayerID(),serverid,m_this->getIName(),task->getTaskID(),TS_Activation,task->getTaskProgress());
								crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertTaskrecord.get());
								dbConductor->getNetManager()->sendPacket("all",dbpacket);
							}
						}
					}
				}
				//if(task->getTaskID()==21004 && winCity!=(unsigned char)-1)
				//{
				//	task->setActivation(false);
				//	GetTaskVec.pop_back();
				//}
			}
		}
		myMetierData->excHandle(MAKECREPARAM(WCH_LockData,0));
		ref_ptr<crStreamBuf> stream = new crStreamBuf;
		stream->createBuf(1+GetTaskVec.size()*4);
		stream->_writeUChar(GetTaskVec.size());
		//bool firsttask = false;
		for( std::vector<int>::iterator itr = GetTaskVec.begin();
			itr != GetTaskVec.end();
			++itr )
		{
			//if(*itr == 1)
			//	firsttask = true;
			stream->_writeInt(*itr);
		}
		crNetConductor *netConductor = crNetContainer::getInstance()->getNetConductor(GameServer);
		if(netConductor)
		{//server to client
				
			crJXJPlayerMetierEventPacket packet;
			crJXJPlayerMetierEventPacket::buildReplyPacket(packet,m_this->getPlayerID(),WCH_JXJRecvActiveTaskVec,stream.get());
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
			if(playerData.valid())
			{
				//if(firsttask)
				//{//第一个任务，交还部队
				//	crPlayerGameData *playerGameData = playerData->getPlayerGameData();
				//	crData *pdata = playerGameData->getDataClass();
				//	pdata->excHandle(MAKECREPARAM(WCH_LockData,1));
				//	pdata->getParam(WCHDATA_JXJFormationInfoVec,param);
				//	FormationInfoVec *formationInfoVec = (FormationInfoVec *)param;
				//	formationInfoVec->clear();
				//	pdata->excHandle(MAKECREPARAM(WCH_LockData,0));
				//}
				netConductor->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			if (playerid==chengxiangid || playerid==dasimaid || playerid==dajiangjunid)
			{
				ref_ptr<crStreamBuf> stream1 = new crStreamBuf;
				stream1->createBuf(1);
				stream1->_writeUChar(count);
				crPlayerDataEventPacket packet1;
				crPlayerDataEventPacket::buildReplyPacket(packet1,playerid,WCH_JXJClientRecvZhanLingCityCount,stream1.get());
				ref_ptr<crGameServerPlayerData> playerData1 = dynamic_cast<crGameServerPlayerData *>(netConductor->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
				if(playerData1.valid())
					netConductor->getNetManager()->sendPacket(playerData1->getPlayerConnectServerAddress(),packet1);
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJUIUndoAppointCardMethod
//
/////////////////////////////////////////
crJXJUIUndoAppointCardMethod::crJXJUIUndoAppointCardMethod():
	m_this(NULL),
	m_namecolor(crVector4f(100.0f,190.0f,12.0f,255.0f)),
	m_index(0)
{}
crJXJUIUndoAppointCardMethod::crJXJUIUndoAppointCardMethod(const crJXJUIUndoAppointCardMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_namecolor(handle.m_namecolor),
	m_this(NULL),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent),
	m_appointRadio2(handle.m_appointRadio2)
{
}
void crJXJUIUndoAppointCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIUndoAppointCardMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_namecolor);
		break;
	case 5:
		m_index = atoi(str.c_str());
		break;
	case 6:
		m_tipcanvas = str;
		break;
	case 7:
		m_tiptitle = str;
		break;
	case 8:
		m_tipcontent = str;
		break;
	case 9:
		m_appointRadio2 = str;
		break;
	default:
		break;
	}
}
void crJXJUIUndoAppointCardMethod::operator()(crHandle &handle)
{
	bool ifvalidtimeend = false;
	bool ifhavesamecard = false;
	//ref_ptr<crCanvasNode>canvasNode = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	ref_ptr<crCanvasNode> canvas = m_this->getParentCanvas();
	ref_ptr<crRadioGroupWidgetNode> AppointcurPageNum = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_appointRadio2));
	unsigned int Appointcurpage = 0;
	unsigned char num = 0;
	if (AppointcurPageNum.valid())
	{
		Appointcurpage= AppointcurPageNum->getSelect();
	}
	switch (Appointcurpage)
	{
	case 0:
		num = m_index;
		break;
	case 1:
		num = m_index + 3;
		break;
	case 2:
		num = m_index + 6;
		break;
	default:
		break;
	}
	if(myPlayer && netConductor/* && selectNode->getVisiable()*/)
	{
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		crTableIO::StrVec record;
		crData *data = myPlayer->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		void *param;
		//data->getParam(WCHDATA_JXJJiangkaBagVec,param);
		//JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
		data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
		JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
		data->getParam(WCHDATA_JXJGoldingot,param);
		int mygold = *(int *)param;
		data->getParam(WCHDATA_JXJGiftGold,param);
		int giftgold = *(int*)param;
		mygold += giftgold;
		//braindata
		int nameindex = itemtab->getTitleIndex("name");
		int itemid = 0;
		float validtime = 0;
		crVector2i undocost;
		data -> getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJUndoAppointCardCost,viplv).c_str(),undocost);
		int coststep = undocost[0];
		int costmax = undocost[1];
		if (num < appointcardvec->size())
		{
			if ((*appointcardvec)[num] != NULL)
			{
				itemid = (*appointcardvec)[num]->getItemID();
				validtime = (*appointcardvec)[num]->getValidTime();
				if (itemid>0)
				{
					ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
					if (canvas.valid() && canvas->getDataClass())
					{
						crData *canvasdata = canvas->getDataClass();
						canvasdata->inputParam(WCHDATA_JXJCurSelUndoAppointCardid,&itemid);
					}
					if (validtime > 0)
					{
						if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
						{
							int goldneed = ceil((float)validtime/3600.0f)*coststep;
							if(mygold >= goldneed)
							{
								//dynamic_cast<crImageBoxWidgetNode *>(pickUI)->select(true);
								ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
								if (msgCanvas.valid())
								{
									ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
									ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
									ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));

									if(okBtn.valid())okBtn->setEnable(true);
									std::vector<float>v_i;
									ItemMap itemMap;
									rcfg::ConfigScript cfg_script(&itemMap);
									cfg_script.Add("Hypertext");
									cfg_script.Push("Hypertext");
									cfg_script.Add("Content");
									cfg_script.Push("Content");
									cfg_script.Add("Text","您确认要花费");
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",2);
									v_i.clear();
									v_i.push_back(/*m_namecolor[0]*/140.0);
									v_i.push_back(/*m_namecolor[1]*/40.0);
									v_i.push_back(/*m_namecolor[2]*/40.0);
									v_i.push_back(/*m_namecolor[3]*/255.0);
									cfg_script.Add("Color",v_i);
									char tmpText[160],tmpText2[80];
									sprintf(tmpText,"【%d礼金/元宝】\0",goldneed);
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();

									cfg_script.Add("Content");
									cfg_script.Push("Content",3);
									sprintf(tmpText2,"强制撤销【%s】委任吗？\0",record[nameindex].c_str());
									cfg_script.Add("Text",tmpText2);
									cfg_script.Pop();

									cfg_script.Pop();
									if(msg.valid())msg->setHypertext(cfg_script);

									if (msgCanvas.valid())
									{
										crData *dlgData = msgCanvas->getDataClass();
										int commandtype = CDP_Widget;
										dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
										dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
										crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
									}
								}
							}
							else
							{
								std::string str;
								str = "强制撤销需要"+crArgumentParser::appItoa(goldneed)+"礼金/元宝，元宝不足，请充值！";
								ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
								if (tipcanvas.valid())
								{
									ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
									ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
									if (tipcontent.valid())
									{
										tipcontent->setString(str);
									}
									crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
								}
							}
						}
					}
					else
					{
						ifvalidtimeend = true;
						CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
						stream->createBuf(6);
						stream->_writeBool(ifvalidtimeend);
						stream->_writeUChar((unsigned char)num);
						stream->_writeInt(itemid);
						CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
						CRNetApp::crPlayerDataEventPacket packet;
						CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUndoAppointCard,stream.get());
						net_conductor->getNetManager()->sendPacket("all",packet);
					}
				}
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUndoAppointCardMethod
//
/////////////////////////////////////////
crJXJUndoAppointCardMethod::crJXJUndoAppointCardMethod():
	m_index(0),
	m_this(NULL)
{}
crJXJUndoAppointCardMethod::crJXJUndoAppointCardMethod(const crJXJUndoAppointCardMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_appointRadio2(handle.m_appointRadio2),
	m_this(NULL)
{
}
void crJXJUndoAppointCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUndoAppointCardMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_appointRadio2 = str;
		break;
	default:
		break;
	}
}

void crJXJUndoAppointCardMethod::operator()(crHandle &handle)
{
	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	if (playerData)
	{
		void *param;
		bool ifvalidtimeend = false;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid() && canvas->getDataClass())
		{
			ref_ptr<crRadioGroupWidgetNode> AppointcurPageNum = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_appointRadio2));
			unsigned int Appointcurpage = 0;
			unsigned char num = 0;
			if (AppointcurPageNum.valid())
			{
				Appointcurpage= AppointcurPageNum->getSelect();
			}
			switch (Appointcurpage)
			{
			case 0:
				num = m_index;
				break;
			case 1:
				num = m_index + 3;
				break;
			case 2:
				num = m_index + 6;
				break;
			default:
				break;
			}
			crData *canvasdata = canvas->getDataClass();
			canvasdata->getParam(WCHDATA_JXJCurSelUndoAppointCardid,param);
			int curcardid = *(int *)param;
			CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
			stream->createBuf(6);
			stream->_writeBool(ifvalidtimeend);
			stream->_writeUChar((unsigned char)num);
			stream->_writeInt(curcardid);
			CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
			CRNetApp::crPlayerDataEventPacket packet;
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUndoAppointCard,stream.get());
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUndoAppointCardMethod
//
/////////////////////////////////////////
crJXJRecvUndoAppointCardMethod::crJXJRecvUndoAppointCardMethod():
	m_netType(GameClient_Game){}
crJXJRecvUndoAppointCardMethod::crJXJRecvUndoAppointCardMethod(const crJXJRecvUndoAppointCardMethod& handle):
	crMethod(handle),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvUndoAppointCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvUndoAppointCardMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tiptitle = str;
		break;
	case 2:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvUndoAppointCardMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			bool success = false;
			bool ifbagempty = false;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			if (data)
			{
				//返回信息
				data -> getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				unsigned char secondrowopenlv = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSecondRowOpenLevel,viplv).c_str()));
				unsigned short appointcardmaxtime = (unsigned short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJAppointCardMaxTime,viplv).c_str()));
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
				if(playerData.valid())
				{//验证元宝是否充足
					//ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					crVector2i undocost;
					crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJUndoAppointCardCost,viplv).c_str(),undocost);
					int coststep = undocost[0];
					int costmax = undocost[1];
					bool ifvalidtimeend = m_stream->_readBool();
					unsigned char cardindex = m_stream->_readUChar();
					int cardid = m_stream->_readInt();
					//crTableIO::StrVec record;
					//itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),record);
					//int typeindex = itemtab->getTitleIndex("将卡类型");
					bool needdeductgold = false;
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
					JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
					JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
					//data->getParam(WCHDATA_JXJGoldingot,param);
					//int *mygold = (int *)param;
					int i = 0;
					for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
						itr!=jiangkabagvec->end();
						++itr,i++)
					{
						if ((*itr) == NULL)
						{
							ifbagempty = true;
							break;
						}
					}
					if (ifbagempty)
					{
						if (cardindex<appointcardvec->size())
						{
							if ((*appointcardvec)[cardindex] != NULL)
							{
								if ((*appointcardvec)[cardindex]->getItemID() == cardid)
								{
									float validtime = (*appointcardvec)[cardindex]->getValidTime();
									if (validtime < 0)
									{
										validtime = 0;
									}
									int goldneed = ceil((float)validtime/3600.0f)*coststep;
									if (goldneed > 0)
									{
										if (!ifvalidtimeend)
										{
											MoneyChangeData moneydata(goldneed,"撤销委任");
											m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
											if (moneydata.first == 0)
											{
												success = true;
												//*mygold -= goldneed;
												(*appointcardvec)[cardindex] = NULL;
											}
										}
									}
									else
									{
										success = true;
										(*appointcardvec)[cardindex] = NULL;
									}
								}
								else 
								{
									cardid = (*appointcardvec)[cardindex]->getItemID();
								}
							}
						}
					}
					if (success)
					{
						ref_ptr<crBagItemData> carddata = new crBagItemData;
						carddata->setItemID(cardid);
						carddata->setItemCount(1);
						(*jiangkabagvec)[i] = carddata;
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(6);
					//stream->_writeUChar(success);
					stream->_writeBool(success);
					stream->_writeUChar(cardindex);
					stream->_writeInt(cardid);
					//stream->_writeInt(*mygold);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUndoAppointCard,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					if (needdeductgold)
					{
						crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
						callback->savePlayerData(playerData.get());
					}
					///游戏日志
					std::string logdata = crArgumentParser::appVectoa(crVector2i(success,cardid));
					GameLogData gamelog(Log_DisappointOneJiangka,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			//unsigned char success = m_stream->_readUChar();
			int index = 2074;
			bool success = m_stream->_readBool();
			unsigned char cardindex = m_stream->_readChar();
			int cardid = m_stream->_readInt();
			//int curgold = m_stream->_readInt();
			//std::string str= "撤销委任失败！";
			void*param;
			crData *data = m_this->getDataClass();
			if (data)
			{
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
				JXJAppointCardVec *appointcardvec = (JXJAppointCardVec *)param;
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
				//data->getParam(WCHDATA_JXJGoldingot,param);
				//int *mygold = (int *)param;
				if (success)
				{
					index = 2073;
					//*mygold = curgold;
					if (cardindex < appointcardvec->size())
					{
						(*appointcardvec)[cardindex] = NULL;
					}
					
					for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
						itr!=jiangkabagvec->end();
						++itr)
					{
						if ((*itr)==NULL)
						{
							ref_ptr<crBagItemData> carddata = new crBagItemData;
							carddata->setItemID(cardid);
							carddata->setItemCount(1);
							(*itr) = carddata;
							break;
						}
					}
				}
				else
				{
					//*mygold = curgold;
					if (cardindex < appointcardvec->size())
					{
						if((*appointcardvec)[cardindex] != NULL)
						{
							ref_ptr<crAppointCardData> appointcard = new crAppointCardData;
							appointcard->setItemID(cardid);
							(*appointcardvec)[cardindex] = appointcard;
						}
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));//队伍已解散！
			//ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
			//if (tipcanvas)
			//{
			//	ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
			//	ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
			//	if (tipcontent)
			//	{
			//		tipcontent->setString(str);
			//	}
			//	crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
			//}
		}
	}
}
///////////////////////////////////////////
////
////crJXJUndoAppointCardMethod
////
///////////////////////////////////////////
//crJXJShowNewPlayerTaskCanvasMethod::crJXJShowNewPlayerTaskCanvasMethod():
//	m_index(0)
//{}
//crJXJShowNewPlayerTaskCanvasMethod::crJXJShowNewPlayerTaskCanvasMethod(const crJXJShowNewPlayerTaskCanvasMethod& handle):
//	crMethod(handle),
//	m_index(handle.m_index),
//	m_canvas(handle.m_canvas),
//	m_input(handle.m_input)
//{
//}
//void crJXJShowNewPlayerTaskCanvasMethod::inputParam(int i, void *param)
//{
//}
//void crJXJShowNewPlayerTaskCanvasMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_index = atoi(str.c_str());
//		break;
//	case 1:
//		m_canvas = str;
//		break;
//	case 2:
//		m_input = str;
//		break;
//	}
//}
//
//void crJXJShowNewPlayerTaskCanvasMethod::operator()(crHandle &handle)
//{
//	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
//	if (playerData)
//	{
//		if (m_index == 0)
//		{
//			crInstanceItem *item  = crMyPlayerData::getInstance()->getScene()->findSceneItem(1);//找到府衙模型位置
//
//			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
//			crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
//
//			if(canvas && item)
//			{
//				ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_input));
//				if (input)
//				{
//					input->setVisiable(false);
//				}
//				crVector3 pos = item->getPosition();
//				pos[2]+=item->getRelNode()->getBoundBox().zLength();
//				//if (m_buildingnameposz == 0)
//				//{
//				//	pos[2]+=m_this->getRelNode()->getBoundBox().zLength();
//				//}
//				//else
//				//{
//				//	pos[2] = m_buildingnameposz;
//				//}
//				if(crBrain::getInstance()->getCameraFrustum().contains(pos))
//				{
//					crViewer *bindview = crKeyboardMouseHandle::getInstance()->getBindViewer();
//					crVector3 window;
//					if (bindview)
//					{
//						bindview->getDefaultSceneHandler()->getSceneView()->projectObjectIntoWindow(pos,window);
//						pos = crFilterRenderManager::getInstance()->getIdenticPosition(window);
//						pos[2] = 0.0f;
//						canvas->setPosition(pos);
//						//headCanvas->setVisiable(true);
//						if(!canvas->getVisiable()) 
//						{
//							//canvas->setShowTop(false);
//							crFilterRenderManager::getInstance()->showCanvas(canvas,true);
//						}
//					}
//				}
//				else
//				{
//					if(canvas->getVisiable()) 
//					{
//						crFilterRenderManager::getInstance()->showCanvas(canvas,false);
//					}
//				}
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJUIRollCardsMethod
////
///////////////////////////////////////////
//crJXJUIRollCardsMethod::crJXJUIRollCardsMethod():
//	m_this(NULL),
//	m_namecolor(crVector4f(100.0f,190.0f,12.0f,255.0f))
//{}
//crJXJUIRollCardsMethod::crJXJUIRollCardsMethod(const crJXJUIRollCardsMethod& handle):
//	crMethod(handle),
//	m_msgbox(handle.m_msgbox),
//	m_title(handle.m_title),
//	m_msg(handle.m_msg),
//	m_ok(handle.m_ok),
//	m_namecolor(handle.m_namecolor),
//	m_this(NULL),
//	m_tavernRaido(handle.m_tavernRaido),
//	m_input(handle.m_input),
//	m_tipcanvas(handle.m_tipcanvas),
//	m_tiptitle(handle.m_tiptitle),
//	m_tipcontent(handle.m_tipcontent),
//	m_page1(handle.m_page1)
//{
//}
//void crJXJUIRollCardsMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crJXJUIRollCardsMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_msgbox = str;
//		break;
//	case 1:
//		m_title = str;
//		break;
//	case 2:
//		m_msg = str;
//		break;
//	case 3:
//		m_ok = str;
//		break;
//	case 4:
//		crArgumentParser::appAtoVec(str,m_namecolor);
//		break;
//	case 5:
//		m_tavernRaido = str;
//		break;
//	case 6:
//		m_input = str;
//		break;
//	case 7:
//		m_tipcanvas = str;
//		break;
//	case 8:
//		m_tiptitle = str;
//		break;
//	case 9:
//		m_tipcontent = str;
//		break;
//	case 10:
//		m_page1 = str;
//		break;
//	}
//}
//void crJXJUIRollCardsMethod::operator()(crHandle &handle)
//{
//	bool cancelTask = false;
//	ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
//	if (msgCanvas && m_this)
//	{
//		ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
//		ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
//		ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
//		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
//		if (canvas)
//		{
//			ref_ptr<crNode> page1 = canvas->getChildNode(m_page1);
//			ref_ptr<crRadioGroupWidgetNode> tavernRaido = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_tavernRaido));
//			unsigned char bagnummax = (unsigned char)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiangkaBagSize).c_str()));
//
//			ref_ptr<crTableIO>LuckyCardCostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLuckyCardCostTab);
//			int copperindex = LuckyCardCostTab->getTitleIndex("铜钱");
//			int goldindex = LuckyCardCostTab->getTitleIndex("元宝");
//			crTableIO::StrVec record;
//			void *param;
//			int cardcount = 0;
//			crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
//			if (data)
//			{
//				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
//				JXJItemBagVec *jiangkabagvec = (JXJItemBagVec *)param;
//				for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
//					itr != jiangkabagvec->end();
//					++itr)
//				{
//					if((*itr) != NULL)
//					{
//						cardcount++;
//					}
//				}
//				if (cardcount < bagnummax)
//				{
//					int needmoney = 0;
//					if(tavernRaido)
//					{
//						int select = tavernRaido->getSelect();
//						if (select == 0)
//						{
//							if (page1)
//							{
//								page1->setVisiable(false);
//							}
//							data->getParam(WCHDATA_JXJLuckyCardCopperCost,param);
//							unsigned char coppercost = *(unsigned char *)param;
//							//data->getParam(WCHDATA_JXJCoppercash,param);
//							//int mycopper = *(int *)param;
//							LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(coppercost),record);
//							needmoney = atoi(record[copperindex].c_str());
//						}
//						else
//						{
//							cancelTask = true;
//							data->getParam(WCHDATA_JXJLuckyCardGoldCost,param);
//							unsigned char goldcost = *(unsigned char *)param;
//							//data->getParam(WCHDATA_JXJGoldingot,param);
//							//int mygold = *(int *)param;
//							//data->getParam(WCHDATA_JXJGiftGold,param);
//							//int giftgold = *(int*)param;
//							//mygold += giftgold;
//							LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(goldcost),record);
//							needmoney = atoi(record[goldindex].c_str());
//							if(okBtn)okBtn->setEnable(true);
//							std::vector<float>v_i;
//							ItemMap itemMap;
//							rcfg::ConfigScript cfg_script(&itemMap);
//							cfg_script.Add("Hypertext");
//							cfg_script.Push("Hypertext");
//							cfg_script.Add("Content");
//							cfg_script.Push("Content");
//							cfg_script.Add("Text","您确认要花费");
//							cfg_script.Pop();
//
//							cfg_script.Add("Content");
//							cfg_script.Push("Content",2);
//							v_i.clear();
//							v_i.push_back(m_namecolor[0]);
//							v_i.push_back(m_namecolor[1]);
//							v_i.push_back(m_namecolor[2]);
//							v_i.push_back(m_namecolor[3]);
//							cfg_script.Add("Color",v_i);
//							char tmpText[160]/*,tmpText2[80]*/;
//							if (select == 0)
//							{
//								sprintf(tmpText,"【%d铜钱】\0",needmoney);
//							}
//							else
//							{
//								sprintf(tmpText,"【%d元宝】\0",needmoney);
//							}
//							cfg_script.Add("Text",tmpText);
//							cfg_script.Pop();
//
//							cfg_script.Add("Content");
//							cfg_script.Push("Content",3);
//							cfg_script.Add("Text","抽取将卡吗？");
//							cfg_script.Pop();
//
//							cfg_script.Pop();
//							if(msg)msg->setHypertext(cfg_script);
//
//							if (msgCanvas)
//							{
//								crData *dlgData = msgCanvas->getDataClass();
//								dlgData->inputParam(WCHDATA_CommandDlgWidget,m_this);
//								crFilterRenderManager::getInstance()->doModal(msgCanvas);
//							}
//						}
//					}
//				}
//				else
//				{
//					cancelTask = true;
//					std::string str = "将卡背包已满，请先整理将卡背包！";
//					ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
//					if (tipcanvas)
//					{
//						//	ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
//						ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
//						if (tipcontent)
//						{
//							tipcontent->setString(str);
//						}
//						crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
//					}
//				}
//			}
//		}
//	}
//	handle.outputParam(0,&cancelTask);
//}
///////////////////////////////////////////
////
////crJXJRollCardsMethod
////
///////////////////////////////////////////
//crJXJRollCardsMethod::crJXJRollCardsMethod()
//{}
//crJXJRollCardsMethod::crJXJRollCardsMethod(const crJXJRollCardsMethod& handle):
//	crMethod(handle),
//	m_tavernRaido(handle.m_tavernRaido),
//	m_page1(handle.m_page1)
//{
//}
//void crJXJRollCardsMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crJXJRollCardsMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_tavernRaido = str;
//		break;
//	case 1:
//		m_page1 = str;
//		break;
//	}
//}
//
//void crJXJRollCardsMethod::operator()(crHandle &handle)
//{
//	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
//	if (playerData)
//	{
//		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
//		if (canvas)
//		{
//			ref_ptr<crRadioGroupWidgetNode> tavernRaido = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_tavernRaido));
//			ref_ptr<crNode> page1 = canvas->getChildNode(m_page1);
//			if (tavernRaido)
//			{
//				if (page1)
//				{
//					page1->setVisiable(false);
//				}
//				unsigned char select = tavernRaido->getSelect();
//
//				for (int i = 0; i<2;i++)
//				{
//					tavernRaido->getRadio(i)->setVisiable(false);
//				}
//				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
//				stream->createBuf(1);
//				stream->_writeUChar(select);
//				CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
//				CRNetApp::crPlayerDataEventPacket packet;
//				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvRollCards,stream.get());
//				net_conductor->getNetManager()->sendPacket("all",packet);
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvRollCardsMethod
////
///////////////////////////////////////////
//crJXJRecvRollCardsMethod::crJXJRecvRollCardsMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvRollCardsMethod::crJXJRecvRollCardsMethod(const crJXJRecvRollCardsMethod& handle):
//	crMethod(handle),
//	m_jiusicanvas(handle.m_jiusicanvas),
//	m_cardswitch(handle.m_cardswitch),
//	m_promptinput(handle.m_promptinput),
//	m_tipcanvas(handle.m_tipcanvas),
//	m_tiptitle(handle.m_tiptitle),
//	m_tipcontent(handle.m_tipcontent),
//	m_page1(handle.m_page1)
//{
//}
//void crJXJRecvRollCardsMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvRollCardsMethod::addParam(int i, const std::string& str)
//{
//	switch	(i)
//	{
//	case 0:
//		m_jiusicanvas = str;
//		break;
//	case 1:
//		m_cardswitch = str;
//		break;
//	case 2:
//		m_promptinput = str;
//		break;
//	case 3:
//		m_tipcanvas = str;
//		break;
//	case 4:
//		m_tiptitle = str;
//		break;
//	case 5:
//		m_tipcontent = str;
//		break;
//	case 6:
//		m_page1 = str;
//		break;
//	}
//}
//
//void crJXJRecvRollCardsMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			void *param;
//			bool success = false;
//			bool cardsuccess = false;
//			int playerid = m_this->getPlayerID();
//			crData *data = m_this->getDataClass();
//			if (data)
//			{
//				unsigned char select = m_stream->_readUChar();
//				//返回信息
//				int needmoney = 0;
//				int mymoney = 0;
//				unsigned char cardcost = 0;
//				crTableIO::StrVec record;
//				ref_ptr<crTableIO>LuckyCardCostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLuckyCardCostTab);
//				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//				
//
//				int copperindex = LuckyCardCostTab->getTitleIndex("铜钱");
//				int goldindex = LuckyCardCostTab->getTitleIndex("元宝");
//
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//				ref_ptr<crTableIO>jiusitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJiushiTab);
//				crTableIO::DataVec jiangkaRec;
//				crTableIO::StrVec prorecord;
//				int colorwhite = 0;
//				int colorgreen = 0;
//				int colorblue = 0;
//				int colorpurple = 0;
//				int colororange = 0;
//				int color = 0;
//				int attrid = itemTable->getTitleIndex("类型");
//				int colorindex = itemTable->getTitleIndex("品质");
//				int typeindex = itemTable->getTitleIndex("将卡类型");
//				if (select == 0)
//				{
//					colorwhite = jiusitab->getTitleIndex("大厅白");
//					colorgreen = jiusitab->getTitleIndex("大厅绿");
//					colorblue = jiusitab->getTitleIndex("大厅蓝");
//					colorpurple = jiusitab->getTitleIndex("大厅紫");
//					colororange = jiusitab->getTitleIndex("大厅橙");
//				}
//				else
//				{
//					colorwhite = jiusitab->getTitleIndex("雅间白");
//					colorgreen = jiusitab->getTitleIndex("雅间绿");
//					colorblue = jiusitab->getTitleIndex("雅间蓝");
//					colorpurple = jiusitab->getTitleIndex("雅间紫");
//					colororange = jiusitab->getTitleIndex("雅间橙");
//				}
//				data->getParam(WCHDATA_JXJLuckyCard,param);
//				int *luckycard = (int *)param;
//				data->getParam(WCHDATA_JXJJiusilv,param);
//				if(jiusitab->queryOneRecord(0,crArgumentParser::appItoa(*(unsigned char*)param),prorecord) >= 0 )
//				{
//					//随机抽取
//					for (int i = JiangkaType_ji;i<=JiangkaType_zheng;i++)
//					{
//						std::vector<int> pickcardRnd;
//						pickcardRnd.resize(5);
//						int rndmax = 0;
//						for (int ii = 0; ii<5; ii++)
//						{
//							//获取将卡的属性，
//							//获取该属性的概率
//							switch (ii)
//							{
//							case 0:
//								if (colorwhite >=0)
//								{
//									pickcardRnd[ii] = atoi(prorecord[colorwhite].c_str());
//								}
//								break;
//							case 1:
//								if (colorgreen >=0)
//								{
//									pickcardRnd[ii] = atoi(prorecord[colorgreen].c_str());
//								}
//								break;
//							case 2:
//								if (colorblue >=0)
//								{
//									pickcardRnd[ii] = atoi(prorecord[colorblue].c_str());
//								}
//								break;
//							case 3:
//								if (colorpurple >=0)
//								{
//									pickcardRnd[ii] = atoi(prorecord[colorpurple].c_str());
//								}
//								break;
//							case 4:
//								if (colororange >=0)
//								{
//									pickcardRnd[ii] = atoi(prorecord[colororange].c_str());
//								}
//								break;
//							default:
//								break;
//							}
//							rndmax += pickcardRnd[ii];
//						}
//						CRCore::rangei rr(0,rndmax);
//						int _rr = rr.get_random();
//						int cardi = 0;
//						for (cardi = 0; cardi<5; cardi++)
//						{
//							if(_rr<=pickcardRnd[cardi])
//								break;
//							_rr -= pickcardRnd[cardi];
//						}
//						color = cardi;
//						if (color <= CardColor_Orange)
//						{
//							jiangkaRec.clear();
//							itemTable->queryRecords(attrid,crArgumentParser::appItoa(IT_Jiangka),colorindex,crArgumentParser::appItoa(color),typeindex,crArgumentParser::appItoa(i),jiangkaRec);
//							int jiangkaCount = jiangkaRec.size();
//							int rnd;
//							CRCore::rangei r(0,jiangkaCount);
//							rnd = r.get_random();
//							*(luckycard+i) = atoi(jiangkaRec[rnd][0].c_str());
//							cardsuccess = true;
//						}
//					}
//				}
//				else
//				{
//					cardsuccess = false;
//				}
//				if (cardsuccess)
//				{
//					if(playerData.valid())
//					{
//						if (select == 0)
//						{
//							data->getParam(WCHDATA_JXJLuckyCardCopperCost,param);//第几次购买
//							unsigned char *coppercost = (unsigned char *)param;
//							data->getParam(WCHDATA_JXJCoppercash,param);
//							int *mycopper = (int *)param;
//							if(LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(*coppercost),record) >= 0 )
//							{
//								needmoney = atoi(record[copperindex].c_str());
//								if (*mycopper >= needmoney)
//								{
//									success = true;
//									*mycopper -= needmoney;
//									if (LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(*coppercost + 1),record) >= 0 )
//									{
//										*coppercost += 1;
//									}
//								}
//							}
//							cardcost = *coppercost;
//							mymoney = *mycopper;
//						}
//						else
//						{
//							data->getParam(WCHDATA_JXJLuckyCardGoldCost,param);
//							unsigned char *goldcost = (unsigned char *)param;
//							//data->getParam(WCHDATA_JXJGoldingot,param);
//							//int *mygold = (int *)param;
//							if(LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(*goldcost),record) >= 0 )
//							{
//								needmoney = atoi(record[goldindex].c_str());
//								m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&needmoney,NULL));
//								if (0 == needmoney)
//								{
//									success = true;
//									//*mygold -= needmoney;
//									if (LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(*goldcost + 1),record) >= 0 )
//									{
//										*goldcost += 1;
//									}
//								}
//							}
//							cardcost = *goldcost;
//							//mymoney = *mygold;
//						}
//						//for( int i = 0; i<5; ++i )
//						ref_ptr<crStreamBuf> stream = new crStreamBuf;
//						stream->createBuf(19);
//						//stream->_writeUChar(success);
//						stream->_writeBool(success);
//						stream->_writeUChar(select);
//						stream->_writeUChar(cardcost);
//						if (select == 0)
//						{
//							stream->_writeInt(mymoney);
//						}
//						if (success)
//						{
//							for( int i = 0; i<3; ++i )
//							{
//								stream->_writeInt(*(luckycard+i));
//							}
//						}
//
//						crPlayerDataEventPacket packet;
//						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvRollCards,stream.get());
//						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//					}
//				}
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			//unsigned char success = m_stream->_readUChar();
//			bool success = m_stream->_readBool();
//			unsigned char select = m_stream->_readUChar();
//			unsigned char cardcost = m_stream->_readUChar();
//
//			void*param;
//			crData *data = m_this->getDataClass();
//			if (data)
//			{
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				if (select == 0)
//				{
//					int curmoney = m_stream->_readInt();
//					data->getParam(WCHDATA_JXJLuckyCardCopperCost,param);
//					unsigned char *coppercost = (unsigned char *)param;
//					*coppercost = cardcost;
//
//					data->getParam(WCHDATA_JXJCoppercash,param);
//					int *mycopper = (int *)param;
//					*mycopper = curmoney;
//				}
//				else
//				{
//					data->getParam(WCHDATA_JXJLuckyCardGoldCost,param);
//					unsigned char *goldcost = (unsigned char *)param;
//					*goldcost = cardcost;
//
//					//data->getParam(WCHDATA_JXJGoldingot,param);
//					//int *mygold = (int *)param;
//					//*mygold = curmoney;
//				}
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//				ref_ptr<crCanvasNode>jiusi = crFilterRenderManager::getInstance()->findCanvas(m_jiusicanvas);
//				if (success)
//				{
//					int maxtime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLuckyCardFirstTimeMax).c_str()));
//					data->getParam(WCHDATA_JXJLuckyCard,param);
//					int *luckycard = (int *)param;
//					for( int i = 0; i<3; i++)
//					{
//						*(luckycard+i) = m_stream->_readInt();;
//					}
//
//					if (jiusi)
//					{
//						ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(jiusi->getWidget(m_promptinput));
//						crMultiSwitch *cardswt = dynamic_cast<crMultiSwitch *>(jiusi->getChildNode(m_cardswitch));
//						if (cardswt)
//						{
//							cardswt->setActiveSwitchSet(1);
//						}
//						if (input)
//						{
//							input->setString(std::string("请选择一张将卡"));
//						}
//						crData *jiusidata = jiusi->getDataClass();
//						if (jiusidata)
//						{
//							jiusidata->excHandle(MAKECREPARAM(WCH_LockData,1));
//							jiusidata->getParam(WCHDATA_JXJLuckyCardFirstShowTimer,param);
//							int *firstshowtimer = (int *)param;
//							jiusidata->getParam(WCHDATA_JXJLuckyCardStep,param);
//							int *step = (int *)param;
//							*step = 1;
//							*firstshowtimer = maxtime;
//							jiusidata->excHandle(MAKECREPARAM(WCH_LockData,0));
//						}
//						jiusi->doEvent(WCH_JXJShowluckyCards);
//					}
//				}
//				else
//				{
//					if (jiusi)
//					{
//						ref_ptr<crNode> page1 = jiusi->getChildNode(m_page1);
//						if (page1)
//						{
//							page1->setVisiable(true);
//						}
//					}
//					std::string str = "抽取将卡失败！";
//					ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
//					if (tipcanvas)
//					{
//						ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
//						ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
//						if (tipcontent)
//						{
//							tipcontent->setString(str);
//						}
//						crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
//					}
//				}
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJUIPickCardsMethod
////
///////////////////////////////////////////
//crJXJUIPickCardsMethod::crJXJUIPickCardsMethod():
//	m_index(0)
//{}
//crJXJUIPickCardsMethod::crJXJUIPickCardsMethod(const crJXJUIPickCardsMethod& handle):
//	crMethod(handle),
//	m_index(handle.m_index)
//{
//	for (int i = 0; i < 3; i ++)
//	{
//		m_cardbtn[i] = handle.m_cardbtn[i];
//	}
//}
//void crJXJUIPickCardsMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crJXJUIPickCardsMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_index = atoi(str.c_str());
//		break;
//	case 1:
//		m_cardbtn[0] = str;
//		break;
//	case 2:
//		m_cardbtn[1] = str;
//		break;
//	case 3:
//		m_cardbtn[2] = str;
//		break;
//	}
//}
//void crJXJUIPickCardsMethod::operator()(crHandle &handle)
//{
//	unsigned char index = m_index;
//	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
//	if (playerData)
//	{
//		playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
//		unsigned char success = 0;
//		if (m_index>=0 && m_index<=2)
//		{
//			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
//			if (canvas)
//			{
//				ref_ptr<crButtonWidgetNode> cardbtn[3] = {NULL};
//				for (int i = 0; i < 3; i++)
//				{
//					cardbtn[i] = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_cardbtn[i]));
//					if(cardbtn[i])
//					{
//						cardbtn[i]->setEnable(false);
//					}
//				}
//				crData *canvasdata = canvas->getDataClass();
//				if (canvasdata)
//				{
//					void *param;
//					canvasdata->getParam(WCHDATA_JXJLuckyCardStep,param);
//					int step = *(int *)param;
//					if (step == 0)
//					{
//						playerData->getParam(WCHDATA_JXJJiangkaBagVec,param);
//						JXJItemBagVec *jiangkabagvec  = (JXJItemBagVec *)param;
//						for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
//							itr != jiangkabagvec->end();
//							++itr)
//						{
//							if ((*itr)==NULL)
//							{
//								success = 1;
//								break;
//							}
//						}
//
//						if (success)
//						{
//							int cardid = 0;
//							playerData->getParam(WCHDATA_JXJLuckyCard,param);
//							int *luckycard = (int *)param;
//							canvasdata->getParam(WCHDATA_JXJLuckyCardKnowCard,param);
//							bool ifknowcard = *(bool *)param;
//							canvasdata->getParam(WCHDATA_JXJLuckyCardIndex,param);
//							unsigned char *selcardindex = (unsigned char *)param;
//							*selcardindex = index;
//							if (ifknowcard)
//							{
//								//canvasdata->getParam(WCHDATA_JXJLuckyCardTemp,param);
//								//int *rnd  = (int *)param;
//
//								//index =(unsigned char) (*(rnd + index));
//								cardid = *(luckycard + index);//知天命
//							}
//							else
//							{
//								index = 3;//随机抽取
//							}
//							CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
//							stream->createBuf(5);
//							stream->_writeUChar(index);
//							if (index<3)
//							{
//								stream->_writeInt(cardid);
//							}
//							CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
//							CRNetApp::crPlayerDataEventPacket packet;
//							CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPickCards,stream.get());
//							net_conductor->getNetManager()->sendPacket("all",packet);
//						}
//						else
//						{
//							 crMyPlayerData::getInstance()->getPlayerGameData()->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2034,NULL));
//						}
//					}
//				}
//			}
//		}
//		playerData->excHandle(MAKECREPARAM(WCH_LockData,0));
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvRollCardsMethod
////
///////////////////////////////////////////
//crJXJRecvPickCardsMethod::crJXJRecvPickCardsMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvPickCardsMethod::crJXJRecvPickCardsMethod(const crJXJRecvPickCardsMethod& handle):
//	crMethod(handle),
//	m_jiusicanvas(handle.m_jiusicanvas),
//	m_cardswitch(handle.m_cardswitch),
//	m_tipcanvas(handle.m_tipcanvas),
//	m_tiptitle(handle.m_tiptitle),
//	m_tipcontent(handle.m_tipcontent),
//	m_pickswitch(handle.m_pickswitch)
//{
//}
//void crJXJRecvPickCardsMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvPickCardsMethod::addParam(int i, const std::string& str)
//{
//	switch	(i)
//	{
//	case 0:
//		m_jiusicanvas = str;
//		break;
//	case 1:
//		m_cardswitch = str;
//		break;
//	case 2:
//		m_tipcanvas = str;
//		break;
//	case 3:
//		m_tiptitle = str;
//		break;
//	case 4:
//		m_tipcontent = str;
//		break;
//	case 5:
//		m_pickswitch = str;
//		break;
//	}
//}
//
//void crJXJRecvPickCardsMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			void *param;
//			unsigned char success = 0;
//			int playerid = m_this->getPlayerID();
//			crData *data = m_this->getDataClass();
//			if (data)
//			{
//				unsigned char index = m_stream->_readUChar();
//				int selcardid = 0;
//				if (index < 3)
//				{
//					selcardid = m_stream->_readInt();
//				}
//				//返回信息
//				int needmoney = 0;
//				int mymoney = 0;
//				unsigned char cardcost = 0;
//				crTableIO::StrVec record;
//				//技、谋、政卡概率
//				crVector3i pro;
//				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLuckyCardprobability).c_str(),pro);
//				int jipro = (int)pro[0];
//				int cepro = (int)pro[1];
//				int zhengpro = (int)pro[2];
//				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//
//				if(playerData.valid())
//				{
//					ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//					crTableIO::StrVec record;
//					//int attrid = itemTable->getTitleIndex("类型");
//					data->excHandle(MAKECREPARAM(WCH_LockData,1));
//					data->getParam(WCHDATA_JXJLuckyCard,param);
//					int *luckycard = (int *)param;
//					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
//					JXJItemBagVec *jiangkabagvec  = (JXJItemBagVec *)param;
//
//					int cardid = 0;
//					if (index >= 3)
//					{
//						//随机抽取
//						std::vector<int> pickcardRnd;
//						pickcardRnd.resize(3);
//						int rndmax = 0;
//						for (int i = 0; i<3; i++)
//						{
//							//获取将卡的属性，
//							//获取该属性的概率
//							switch (i)
//							{
//							case 0:
//								pickcardRnd[i] = jipro;
//								break;
//							case 1:
//								pickcardRnd[i] = cepro;
//								break;
//							case 2:
//								pickcardRnd[i] = zhengpro;
//								break;
//							default:
//								break;
//							}
//							rndmax += pickcardRnd[i];
//						}
//						CRCore::rangei rr(0,rndmax);
//						int _rr = rr.get_random();
//						int cardi = 0;
//						for (cardi = 0; cardi<3; cardi++)
//						{
//							if(_rr<pickcardRnd[cardi])
//								break;
//							_rr -= pickcardRnd[cardi];
//						}
//						if(cardi<3)
//						{
//							cardid = *(luckycard + cardi);
//						}
//					}
//					else
//					{
//						for (int i = 0;i<3;i++)
//						{
//							if(selcardid == *(luckycard + i))
//							{
//								cardid = selcardid;
//								break;
//							}
//						}
//					}
//					if (cardid>0)
//					{
//						if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),record) >= 0 )
//						{
//							for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
//								itr != jiangkabagvec->end();
//								++itr)
//							{
//								if ((*itr)==NULL)
//								{
//									success = 1;
//									ref_ptr<crBagItemData> newcard =new crBagItemData;
//									newcard->setItemID(cardid);
//									newcard->setItemCount(1);
//									(*itr) = newcard;
//									for (int i = 0; i <3;i++)
//									{
//										*(luckycard + i) = 0;
//									}
//									break;
//								}
//							}
//							if (!success)
//							{
//								success = 2;//背包已满
//							}
//						}
//					}
//				
//					ref_ptr<crStreamBuf> stream = new crStreamBuf;
//					stream->createBuf(5);
//					stream->_writeUChar(success);
//					stream->_writeInt(cardid);
//					crPlayerDataEventPacket packet;
//					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPickCards,stream.get());
//					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//					data->excHandle(MAKECREPARAM(WCH_LockData,0));
//				}
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			//unsigned char success = m_stream->_readUChar();
//			unsigned char success = m_stream->_readUChar();
//			int cardid = m_stream->_readInt();
//
//			void*param;
//			crData *data = m_this->getDataClass();
//			std::string str;
//			if (data)
//			{
//				unsigned char index = 0;
//				data->excHandle(MAKECREPARAM(WCH_LockData,1));
//				if (success == 1)
//				{
//					int maxtime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLuckyCardLastTimeMax).c_str()));
//					ref_ptr<crCanvasNode>jiusi = crFilterRenderManager::getInstance()->findCanvas(m_jiusicanvas);
//					//int selecttype =0;
//					bool ifknow = false;
//					if (jiusi)
//					{
//						crMultiSwitch *cardswt = dynamic_cast<crMultiSwitch *>(jiusi->getChildNode(m_cardswitch));
//						crMultiSwitch *pickswitch = dynamic_cast<crMultiSwitch *>(jiusi->getChildNode(m_pickswitch));
//						//ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(jiusi->getWidget(m_radio));
//						//if(radio)
//					//	{
//					//		selecttype = radio->getSelect();
//					//	}
//						if (cardswt)
//						{
//							cardswt->setActiveSwitchSet(1);
//						}
//						crData *jiusidata = jiusi->getDataClass();
//						if (jiusidata)
//						{
//							jiusidata->excHandle(MAKECREPARAM(WCH_LockData,1));
//							jiusidata->getParam(WCHDATA_JXJLuckyCardLastShowTimer,param);
//							int *lastshowtimer = (int *)param;
//							jiusidata->getParam(WCHDATA_JXJLuckyCardStep,param);
//							int *step = (int *)param;
//							jiusidata->getParam(WCHDATA_JXJLuckyCardIndex,param);
//							index = *(unsigned char *)param;
//							jiusidata->getParam(WCHDATA_JXJLuckyCardKnowCard,param);
//							ifknow  = *(bool *)param;
//							*step = 2;
//							*lastshowtimer = maxtime;
//							if (pickswitch)
//							{
//								pickswitch->setActiveSwitchSet(index + 1);
//							}
//							jiusidata->excHandle(MAKECREPARAM(WCH_LockData,0));
//						}
//						//////
//						crData *brainData = crBrain::getInstance()->getDataClass();
//						brainData->inputParam(WCHDATA_JXJBrainExtractJiangKa,&success);
//
//					}
//					ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//					crTableIO::StrVec record;
//					data->getParam(WCHDATA_JXJLuckyCard,param);
//					int *luckycard = (int *)param;
//					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
//					JXJItemBagVec *jiangkabagvec  = (JXJItemBagVec *)param;
//					if (cardid>0)
//					{
//						if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),record) >= 0 )
//						{
//							for (JXJItemBagVec::iterator itr = jiangkabagvec->begin();
//								itr != jiangkabagvec->end();
//								++itr)
//							{
//								if ((*itr)==NULL)
//								{
//									ref_ptr<crBagItemData> newcard =new crBagItemData;
//									newcard->setItemID(cardid);
//									newcard->setItemCount(1);
//									(*itr) = newcard;
//									if (!ifknow)
//									{
//										int luckycardid[3] = {0,0,0};
//										for (int i = 0;i<3;i++)
//										{
//											luckycardid[i] = *(luckycard + i);
//										}
//										*(luckycard + index) = cardid;
//										CRCore::rangei rr2(0,3);
//										int _rr2 = 0;
//										for (int i = 0; i<100;i++)
//										{
//											_rr2 = rr2.get_random();
//											if (_rr2!=index)
//											{
//												break;
//											}
//										}
//										for (int ii = 0; ii<3; ii++)
//										{
//											if (luckycardid[ii]!=cardid)
//											{
//												*(luckycard+_rr2) = luckycardid[ii];
//												break;
//											}
//										}
//										for (int i = 0;i<3;i++)
//										{
//											if (i != _rr2 && i!=index)
//											{
//												for (int ii = 0; ii<3; ii++)
//												{
//													if (luckycardid[ii]!=cardid &&luckycardid[ii]!=*(luckycard+_rr2) )
//													{
//														*(luckycard+i) = luckycardid[ii];
//														break;
//													}
//												}
//											}
//										}
//									}
//									if(jiusi)jiusi->doEvent(WCH_JXJShowluckyCards);
//									for (int i = 0; i <3;i++)
//									{
//										*(luckycard + i) = 0;
//									}
//									break;
//								}
//							}
//						}
//					}
//				}
//				else if (success == 2)
//				{
//					str= "将卡背包已满，请先清理背包！";
//				}
//				else if (success == 0)
//				{
//					str= "请勿重复提交！";
//				}
//				data->excHandle(MAKECREPARAM(WCH_LockData,0));
//
//				if(success!=1)
//				{
//					ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
//					if (tipcanvas)
//					{
//						ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
//						ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
//						if (tipcontent)
//						{
//							tipcontent->setString(str);
//						}
//						crFilterRenderManager::getInstance()->showCanvas(tipcanvas,true);
//					}
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJLuckyCardTimerMethod
//
/////////////////////////////////////////
//crJXJLuckyCardTimerMethod::crJXJLuckyCardTimerMethod()
//{}
//crJXJLuckyCardTimerMethod::crJXJLuckyCardTimerMethod(const crJXJLuckyCardTimerMethod& handle):
//	crMethod(handle),
//	m_switch(handle.m_switch),
//	m_tavernradio(handle.m_tavernradio),
//	m_refreshtime(handle.m_refreshtime),
//	m_pushtime(handle.m_pushtime),
//	m_playswitch(handle.m_playswitch),
//	m_zhitianming(handle.m_zhitianming),
//	m_startbtn(handle.m_startbtn),
//	m_pickswitch(handle.m_pickswitch),
//	m_page1(handle.m_page1)
//{
//	for (int i = 0; i < 3;i++)
//	{
//		m_btn[i] = handle.m_btn[i];
//	}
//	for (int i = 0; i < 4;i++)
//	{
//		m_seq[i] = handle.m_seq[i];
//	}
//}
//void crJXJLuckyCardTimerMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//void crJXJLuckyCardTimerMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_switch = str;
//		break;
//	case 1:
//		m_tavernradio = str;
//		break;
//	case 2:
//		m_playswitch = str;
//		break;
//	case 3:
//		m_refreshtime = atoi(str.c_str());
//		break;
//	case 4:
//		m_pushtime = atoi(str.c_str());
//		break;
//	case 5:
//		m_btn[0] = str;
//		break;
//	case 6:
//		m_btn[1] = str;
//		break;
//	case 7:
//		m_btn[2] = str;
//		break;
//	case 8:
//		m_zhitianming = str;
//		break;
//	case 9:
//		m_seq[0] = str;
//		break;
//	case 10:
//		m_seq[1] = str;
//		break;
//	case 11:
//		m_seq[2] = str;
//		break;
//	case 12:
//		m_seq[3] = str;
//		break;
//	case 13:
//		m_startbtn = str;
//		break;
//	case 14:
//		m_pickswitch = str;
//		break;
//	case 15:
//		m_page1 = str;
//		break;
//	default:
//		break;
//	}
//}
//void crJXJLuckyCardTimerMethod::operator()(crHandle &handle)
//{
//	/////////延迟1S执行
//	//crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
//	if (m_this)
//	{
//		crData *canvasdata = m_this->getDataClass();
//		if (canvasdata)
//		{
//			crMultiSwitch *jiusiswitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_switch));
//			crMultiSwitch *playswitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_playswitch));
//			crMultiSwitch *pickswitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_pickswitch));
//			ref_ptr<crRadioGroupWidgetNode> tavernradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_tavernradio));
//			ref_ptr<crButtonWidgetNode> zhitianming = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_zhitianming));
//			ref_ptr<crButtonWidgetNode> startbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_startbtn));
//
//			crSequence *seq[4] = {NULL};
//			ref_ptr<crButtonWidgetNode> btn[3] = {NULL};
//			for (int i = 0 ;i<4; i++)
//			{
//				if (i<3)
//				{
//					btn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_btn[i]));
//				}
//				seq[i] = dynamic_cast<crSequence*>(m_this->getChildNode(m_seq[i]));
//				if(seq[i])seq[i]->setVanishWhenStop(true);
//			}
//			void *param;
//			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
//			canvasdata->getParam(WCHDATA_JXJLuckyCardStep,param);
//			int *step = (int *)param;
//			canvasdata->getParam(WCHDATA_JXJLuckyCardRefreshTimer,param);
//			int *refreshtimer = (int *)param;
//			canvasdata->getParam(WCHDATA_JXJLuckyCardPushTimer,param);
//			int *pushtimer = (int *)param;
//			if (startbtn && startbtn->getVisiable() == true)
//			{
//				startbtn->setVisiable(false);
//			}
//			if (*step == 1)
//			{
//				if (startbtn && startbtn->getVisiable() == false)
//				{
//					startbtn->setVisiable(true);
//				}
//				for (int i = 0; i<3;i++)
//				{
//					if (btn[i])
//					{
//						if (btn[i] ->getEnable())
//						{
//							btn[i]->setEnable(false);
//						}
//					}
//				}
//				canvasdata->getParam(WCHDATA_JXJLuckyCardFirstShowTimer,param);
//				int timer = *(int *)param;
//				//(*timer)-=1;
//				if (timer<=0)
//				{
//					if (startbtn && startbtn->getVisiable() == true)
//					{
//						startbtn->setVisiable(false);
//					}
//					if(seq[0])
//					{
//						seq[0]->setMode(crSequence::START);
//						//seq[0]->setDuration(10,1);
//						//seq[0]->setVanishWhenStop(true);
//					}
//					*refreshtimer = m_refreshtime;
//					*step = 3;
//					if (jiusiswitch)
//					{
//						jiusiswitch->setActiveSwitchSet(3);
//					}
//				}
//			}
//			else if (*step == 2)
//			{
//				canvasdata->getParam(WCHDATA_JXJLuckyCardIndex,param);
//				unsigned char cardindex  = *(unsigned char *)param;
//				for (int i = 0; i<3;i++)
//				{
//					if (btn[i])
//					{
//						if (btn[i] ->getEnable())
//						{
//							btn[i]->setEnable(false);
//						}
//					}
//				}
//				canvasdata->getParam(WCHDATA_JXJLuckyCardLastShowTimer,param);
//				int *timer = (int *)param;
//				*timer-=1;
//				if (*timer<=0)
//				{
//					*step = 4;
//					*pushtimer = m_pushtime;
//					canvasdata->getParam(WCHDATA_JXJLuckyCardKnowCard,param);
//					bool *ifknow  = (bool *)param;
//					*ifknow = false;
//					if (jiusiswitch)
//					{
//						jiusiswitch->setActiveSwitchSet(4);
//					}
//					if(playswitch)
//					{
//						if (cardindex <3 && cardindex >=0)
//						{
//							if(seq[cardindex+1])
//							{
//								seq[cardindex+1]->setMode(crSequence::START);
//								seq[cardindex+1]->setDuration(0.1,1);
//								seq[cardindex+1]->setVanishWhenStop(true);
//							}
//							playswitch->setActiveSwitchSet(cardindex);
//						}
//					}
//				}
//			}
//			else if (*step == 3)
//			{
//				*refreshtimer-=1;
//				if (*refreshtimer<=0)
//				{
//					*step = 0;
//					if (zhitianming)
//					{
//						zhitianming->setEnable(true);
//					}
//					if (jiusiswitch)
//					{
//						jiusiswitch->setActiveSwitchSet(2);
//					}
//				}
//			}
//			else if(*step == 4)
//			{
//				if (pickswitch && pickswitch->getActiveSwitchSet()!=0)
//				{
//					pickswitch->setActiveSwitchSet(0);
//				}
//				for (int i = 0; i<3;i++)
//				{
//					if (btn[i])
//					{
//						if (btn[i] ->getEnable())
//						{
//							btn[i]->setEnable(false);
//						}
//					}
//				}
//				*pushtimer-=1;
//				if (*pushtimer<=0)
//				{
//					*step = 0;
//					if (jiusiswitch)
//					{
//						jiusiswitch->setActiveSwitchSet(0);
//					}
//					if (tavernradio)
//					{
//						for (int i = 0;i<2;i++)
//						{
//							tavernradio->getRadio(i)->setVisiable(true);
//						}
//					}
//					ref_ptr<crNode> page1 = m_this->getChildNode(m_page1);
//					if (page1)
//					{
//						page1->setVisiable(true);
//					}
//					//for (int i = 0; i<3;i++)
//					//{
//					//	if (btn[i])
//					//	{
//					//		if (btn[i] ->getEnable())
//					//		{
//					//			btn[i]->setEnable(true);
//					//		}
//					//	}
//					//}
//				}
//				crFilterRenderManager::getInstance()->showCanvas(m_this,true);
//			}
//			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIKnowLuckyCardsMethod
//
/////////////////////////////////////////
crJXJUIKnowLuckyCardsMethod::crJXJUIKnowLuckyCardsMethod():
	m_this(NULL),
	m_namecolor(crVector4f(100.0f,190.0f,12.0f,255.0f))
{}
crJXJUIKnowLuckyCardsMethod::crJXJUIKnowLuckyCardsMethod(const crJXJUIKnowLuckyCardsMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_namecolor(handle.m_namecolor),
	m_this(NULL),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJUIKnowLuckyCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIKnowLuckyCardsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_namecolor);
		break;
	case 5:
		m_tipcanvas = str;
		break;
	case 6:
		m_tiptitle = str;
		break;
	case 7:
		m_tipcontent = str;
		break;
	}
}
void crJXJUIKnowLuckyCardsMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
	if (msgCanvas.valid())
	{
		ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
		ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
		ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		//ref_ptr<crRadioGroupWidgetNode> tavernRaido = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_tavernRaido));

		crTableIO::StrVec record;
		void *param;
		crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		if (data)
		{
			crVector3i knowcost;
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJKnowLuckyCardCost,viplv).c_str(),knowcost);
			int coststart = knowcost[0];
			int coststep = knowcost[1];
			int costmax = knowcost[2];
			int needmoney = 0;
		//	if(tavernRaido)
			//{
				//int select = tavernRaido->getSelect();
				data->getParam(WCHDATA_JXJKnowLuckyCard,param);
				unsigned char goldcost = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJGoldingot,param);
				int mygold = *(int *)param;
				data->getParam(WCHDATA_JXJGiftGold,param);
				int mygift = *(int *)param;
				mygold += mygift;
				needmoney = goldcost * coststep + coststart;

				if (mygold >= needmoney)
				{
					if(okBtn.valid())
					{
						okBtn->swapEnable(0.1f);
						okBtn->setEnable(true);
					}
					std::vector<float>v_i;
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");
					cfg_script.Add("Content");
					cfg_script.Push("Content");
					cfg_script.Add("Text","您确认要花费");
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",2);
					v_i.clear();
					v_i.push_back(m_namecolor[0]);
					v_i.push_back(m_namecolor[1]);
					v_i.push_back(m_namecolor[2]);
					v_i.push_back(m_namecolor[3]);
					cfg_script.Add("Color",v_i);
					char tmpText[160]/*,tmpText2[80]*/;
					sprintf(tmpText,"【%d礼金/元宝】\0",needmoney);
					cfg_script.Add("Text",tmpText);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",3);
					cfg_script.Add("Text","显示将卡吗？");
					cfg_script.Pop();

					cfg_script.Pop();
					if(msg.valid())msg->setHypertext(cfg_script);

					if (msgCanvas.valid())
					{
						crData *dlgData = msgCanvas->getDataClass();
						int commandtype = CDP_Widget;
						dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
						dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
						crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
					}
				}
				else
				{
					std::string str ="元宝不足!";
					ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
					if (tipcanvas.valid())
					{
						ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
						ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
						if (tipcontent.valid())
						{
							tipcontent->setString(str);
						}
						crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
					}
				}
		//	}
		}
	}
}
/////////////////////////////////////////
//
//crJXJKnowLuckyCardsMethod
//
/////////////////////////////////////////
crJXJKnowLuckyCardsMethod::crJXJKnowLuckyCardsMethod()
{}
crJXJKnowLuckyCardsMethod::crJXJKnowLuckyCardsMethod(const crJXJKnowLuckyCardsMethod& handle):
	crMethod(handle),
	m_tavernRaido(handle.m_tavernRaido)
{
}
void crJXJKnowLuckyCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJKnowLuckyCardsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tavernRaido = str;
		break;
	}
}

void crJXJKnowLuckyCardsMethod::operator()(crHandle &handle)
{
	//crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if (net_conductor)
	{
		m_this->setEnable(false);
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvKnowCards,NULL);
		net_conductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvKnowCardsMethod
//
/////////////////////////////////////////
crJXJRecvKnowCardsMethod::crJXJRecvKnowCardsMethod():
	m_netType(GameClient_Game){}
crJXJRecvKnowCardsMethod::crJXJRecvKnowCardsMethod(const crJXJRecvKnowCardsMethod& handle):
	crMethod(handle),
	m_jiusicanvas(handle.m_jiusicanvas),
	m_knowcardbtn(handle.m_knowcardbtn),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvKnowCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvKnowCardsMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_jiusicanvas = str;
		break;
	case 1:
		m_knowcardbtn = str;
		break;
	case 3:
		m_tipcanvas = str;
		break;
	case 4:
		m_tiptitle = str;
		break;
	case 5:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvKnowCardsMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && data)
			{
				crVector3i knowcost;
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJKnowLuckyCardCost,viplv).c_str(),knowcost);
				int coststart = knowcost[0];
				int coststep = knowcost[1];
				int costmax = knowcost[2];
				int needmoney = 0;
				bool needdeductgold = false;
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJKnowLuckyCard,param);
				unsigned char *goldcost = (unsigned char *)param;
				//data->getParam(WCHDATA_JXJGoldingot,param);
				//int *mygold = (int *)param;
				needmoney = *goldcost * coststep + coststart;

				MoneyChangeData moneydata(needmoney,"知天命");
				m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
				if (0 == moneydata.first)
				{
					//*mygold -= needmoney;
					if (needmoney < costmax) 
					{
						*goldcost += 1;
					}
					success = 1;
				}
				else
				{
					success = 2;
				}
				//curgold = *mygold;


				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(2);
				stream->_writeUChar(success);
				//stream->_writeInt(curgold);
				stream->_writeUChar(*goldcost);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvKnowCards,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				if (needdeductgold)
				{
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					callback->savePlayerData(playerData.get());
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			//unsigned char success = m_stream->_readUChar();
			unsigned char success = m_stream->_readUChar();
			//int curgold = m_stream->_readInt();
			unsigned char curgoldcost = m_stream->_readUChar();
			crData *data = m_this->getDataClass();
			if (data)
			{
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJKnowLuckyCard,param);
				unsigned char *goldcost = (unsigned char *)param;
				//data->getParam(WCHDATA_JXJGoldingot,param);
				//int *mygold = (int *)param;
				*goldcost = curgoldcost;
				//*mygold = curgold;
				if (success == 1)
				{
					ref_ptr<crCanvasNode>jiusi = crFilterRenderManager::getInstance()->findCanvas(m_jiusicanvas);
					if (jiusi.valid())
					{
						ref_ptr<crButtonWidgetNode> btn = dynamic_cast<crButtonWidgetNode *>(jiusi->getWidget(m_knowcardbtn));
						if(btn.valid())btn->doEvent(WCH_JXJUIKnowCards);
					}
				}
				else if (success == 2)
				{
					std::string str ="元宝不足!";
					ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
					if (tipcanvas.valid())
					{
						ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
						ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
						if (tipcontent.valid())
						{
							tipcontent->setString(str);
						}
						crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}

		}
	}
}
/////////////////////////////////////////
//
//crJXJUIKnowCardsMethod
//
/////////////////////////////////////////
crJXJUIKnowCardsMethod::crJXJUIKnowCardsMethod()
{}
crJXJUIKnowCardsMethod::crJXJUIKnowCardsMethod(const crJXJUIKnowCardsMethod& handle):
	crMethod(handle)
{
	for (int i = 0; i <3;i++)
	{
		m_btn[i] = handle.m_btn[i];
	}
}
void crJXJUIKnowCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIKnowCardsMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_switch = str;
		break;
	case 1:
		m_btn[0] = str;
		break;
	case 2:
		m_btn[1] = str;
		break;
	case 3:
		m_btn[2] = str;
		break;
	default:
		break;
	}
}
void crJXJUIKnowCardsMethod::operator()(crHandle &handle)
{
	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	if (m_this && playerData)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			crData *canvasdata = canvas->getDataClass();
			if (canvasdata)
			{
				crMultiSwitch *jiusiswitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_switch));
				if (jiusiswitch)
				{
					jiusiswitch->setActiveSwitchSet(1);
				}
				ref_ptr<crButtonWidgetNode> btn[3] = {NULL};
				for (int i = 0 ;i<3; i++)
				{
					btn[i] = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_btn[i]));
					if (btn[i].valid())
					{
						btn[i]->setEnable(true);
					}
				}
				void *param;
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
				CRCore::rangei r(0,3);
				//canvasdata->getParam(WCHDATA_JXJLuckyCardTemp,param);
				//int *rnd  = (int *)param;
				playerData->getParam(WCHDATA_JXJLuckyCard,param);
				int *luckycard = (int *)param;
				canvasdata->getParam(WCHDATA_JXJLuckyCardKnowCard,param);
				bool *ifknow  = (bool *)param;
				*ifknow = true;
				int index[3];
				index[0] = r.get_random();


				for (int i = 0;i<100;i++)
				{
					index[1] = r.get_random();
					if (index[1] == index[0])
					{
						continue;
					}
					else
					{
						break;
					}
				}
				for (int i = 0; i <3; i++)
				{
					index[2] = i;
					if(index[2] != index[0] && index[2] != index[1])
					{
						break;
					}
				}
				int templuckycard[3] = {*(luckycard + index[0]),*(luckycard + index[1]),*(luckycard + index[2])};
				for (int i = 0; i<3;i++)
				{
					*(luckycard + i) = templuckycard[i];
				}
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
				canvas->doEvent(WCH_JXJShowluckyCards);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJShowLuckyCardMethod
//
/////////////////////////////////////////
crJXJShowLuckyCardMethod::crJXJShowLuckyCardMethod()
{}
crJXJShowLuckyCardMethod::crJXJShowLuckyCardMethod(const crJXJShowLuckyCardMethod& handle):
	crMethod(handle)
{
	for (int i = 0; i<3;i++)
	{
		m_switch[i] = handle.m_switch[i];
		m_cardpic[i] = handle.m_cardpic[i];
		m_cardinfo[i] = handle.m_cardinfo[i];
		m_textinfo[i] = handle.m_textinfo[i];
		m_pickbtn[i] = handle.m_pickbtn[i];
	}
}
void crJXJShowLuckyCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJShowLuckyCardMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_switch[0] = str;
		break;
	case 1:
		m_switch[1] = str;
		break;
	case 2:
		m_switch[2] = str;
		break;
	case 3:
		m_cardpic[0] = str;
		break;
	case 4:
		m_cardpic[1] = str;
		break;
	case 5:
		m_cardpic[2] = str;
		break;
	case 6:
		m_cardinfo[0] = str;
		break;
	case 7:
		m_cardinfo[1] = str;
		break;
	case 8:
		m_cardinfo[2] = str;
		break;
	case 9:
		m_textinfo[0] = str;
		break;
	case 10:
		m_textinfo[1] = str;
		break;
	case 11:
		m_textinfo[2] = str;
		break;
	case 12:
		m_pickbtn[0] = str;
		break;
	case 13:
		m_pickbtn[1] = str;
		break;
	case 14:
		m_pickbtn[2] = str;
		break;
	default:
		break;
	}
}
void crJXJShowLuckyCardMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if (myPlayer)
	{
		crData *playerData = myPlayer->getDataClass();
		void *param;
		crData *canvasdata = m_this->getDataClass();
		if (canvasdata)
		{
			playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			//canvasdata->getParam(WCHDATA_JXJLuckyCardTemp,param);
			//int *rnd  = (int *)param;
			playerData->getParam(WCHDATA_JXJLuckyCard,param);
			int *luckycard  = (int *)param;
			int lukycardcount = 0;
			int cardid;
			for(int i = 0; i<3;i++)
			{
				cardid = *(luckycard+ i);
				if (cardid > 0)
					lukycardcount++;
			}
			crVector3i pickcardopenlv;
			crData *playerData = myPlayer->getDataClass();
			playerData->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPickCardOpenViplv,0).c_str(),pickcardopenlv);
			for(int i = 0; i<3;i++)
			{
				crMultiSwitch *backboard = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_switch[i]));
				ref_ptr<crImageBoxWidgetNode> card = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_cardpic[i]));
				ref_ptr<crImageBoxWidgetNode> nameimage = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_cardinfo[i]));
				ref_ptr<crHypertextWidgetNode> jinengmiaoshu = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_textinfo[i]));
				ref_ptr<crButtonWidgetNode> pickbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_pickbtn[i]));
				if (backboard)
				{
					backboard->setVisiable(false);
				}
				if (card.valid())
				{
					card->setVisiable(false);
				}
				if (nameimage.valid())
				{
					nameimage->setVisiable(false);
				}
				if (jinengmiaoshu.valid())
				{
					jinengmiaoshu->setVisiable(false);
				}
				if (pickbtn.valid())
				{
					pickbtn->setVisiable(false);
				}
				cardid = *(luckycard+ i);

				if (cardid > 0)
				{
					ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					crTableIO::StrVec record;
					//int jinengmiaoshuid = itemTable->getTitleIndex("技能描述");
					int cardindex = itemTable->getTitleIndex("picture");
					int nameimageid = itemTable->getTitleIndex("姓名");
					int backboardid = itemTable->getTitleIndex("品质");
					if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),record) >= 0 )
					{
						//std::string file;
						if(jinengmiaoshu.valid())
						{
							//file = record[jinengmiaoshuid];
							//if(!file.empty())
							//{
							//	jinengmiaoshu->clearText();
							//	file = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + file;
							//	jinengmiaoshu->setHypertext(file);
							//}
							//else
							//{
							//	jinengmiaoshu->clearText();
							//}
							ItemMap itemMap;
							rcfg::ConfigScript outscript(&itemMap);
							crVector2i item(cardid,0);
							myPlayer->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
							jinengmiaoshu->setHypertext(outscript);
							jinengmiaoshu->setVisiable(true);
						}
						if(card.valid())
						{
							card->setImageName(record[cardindex].c_str());
							card->setVisiable(true);
						}
						if(nameimage.valid())
						{
							nameimage->setImageName(record[nameimageid].c_str());
							nameimage->setVisiable(true);
						}
						if(backboard)
						{
							int cardcolor = atoi(record[backboardid].c_str());
							//if (cardcolor <= CardColor_Orange)
							//{
							//	backboard->setActiveSwitchSet(cardcolor);
							//	if (cardlvsw)
							//	{
							//		cardlvsw->setActiveSwitchSet(0);
							//	}
							//}
							//else
							//{
							//	backboard->setActiveSwitchSet(CardColor_Orange);
							//	if (cardlvsw)
							//	{
							//		cardlvsw->setActiveSwitchSet(cardcolor - CardColor_Orange + 1);
							//	}
							//}
							backboard->setActiveSwitchSet(cardcolor);
							backboard->setVisiable(true);
						}
						if (pickbtn.valid())
						{
							if (viplv >= pickcardopenlv[i])
							{
								pickbtn->setVisiable(true);
								if(lukycardcount==1)
									pickbtn->setEnable(false);
								else
									pickbtn->setEnable(true);
							}
						}
					}
				}
			}
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			playerData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvSaleStateChangeMethod
//
/////////////////////////////////////////
crJXJRecvSaleStateChangeMethod::crJXJRecvSaleStateChangeMethod():
	m_netType(GameClient_Game){}
crJXJRecvSaleStateChangeMethod::crJXJRecvSaleStateChangeMethod(const crJXJRecvSaleStateChangeMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvSaleStateChangeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvSaleStateChangeMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvSaleStateChangeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			//unsigned char success = m_stream->_readUChar();
			int saleid = m_stream->_readInt();
			unsigned char state = m_stream->_readUChar();
			crData *data = m_this->getDataClass();
			if (data)
			{ 
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJSaleList,param);
				SaleList *saleList = (SaleList *)param;
				SaleList::iterator sitr;
				for( sitr = saleList->begin();
					sitr != saleList->end();
					++sitr )
				{
					if ((*sitr)->getSaleID() == saleid)
					{
						(*sitr)->setSaleState(state);
						if(state == Sale_Canceled)
						{
							int count = (*sitr)->getCount();
							switch ((*sitr)->getGoodsType())
							{
							case GT_Res:
								{
									data->getParam((*sitr)->getGoodsID(),param);
									int *resource = (int *)param;
									INTLIMITADD(*resource,count,INT_MAX);
								}
								break;
							case GT_TroopsEquip:
								{
									data->getParam(WCHDATA_JXJTroopsEquipMap,param);
									TroopsEquipMap *troopsEquipMap = (TroopsEquipMap *)param;
									INTLIMITADD((*troopsEquipMap)[(*sitr)->getGoodsID()],count,INT_MAX);
								}
								break;
							}
							(*sitr)->saleTimer() = 0;
						}
						break;
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}

		}
	}
}
/////////////////////////////////////////
//
//crJXJBeautyDialogueInitMethod
//
/////////////////////////////////////////
crJXJBeautyDialogueInitMethod::crJXJBeautyDialogueInitMethod():
	m_taskid(0)
{}
crJXJBeautyDialogueInitMethod::crJXJBeautyDialogueInitMethod(const crJXJBeautyDialogueInitMethod& handle):
	crMethod(handle),
	m_thisIsWidget(handle.m_thisIsWidget),
	m_beautydialogue(handle.m_beautydialogue),
	m_taskid(handle.m_taskid)
{
}
void crJXJBeautyDialogueInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		if(!m_thisIsWidget)//0:脚本 1:对话
		{
			m_this = (crWidgetNode*)param;
		}
		else
		{
			m_this2 = (crDataObject*)param;
		}
		break;
	}
}

void crJXJBeautyDialogueInitMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_thisIsWidget = atoi(str.c_str());
		break;
	case 1:
		m_beautydialogue = str;
		break;
	case 2:
		m_taskid = atoi(str.c_str());
		break;

	}
}

void crJXJBeautyDialogueInitMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_beautydialogue);
	if (m_this || m_this2)
	{
		if(canvas.valid())
		{
			crData *data = canvas -> getDataClass();
			if (data)
			{
				if (!m_thisIsWidget)
				{
					data->inputParam(WCHDATA_JXJClickWidget,m_this);
				}
				else
				{
					data->inputParam(WCHDATA_JXJClickWidget2,m_this2);
				}

				data->inputParam(WCHDATA_JXJNewHandTaskID,&m_taskid);
				ref_ptr<crTableIO>dialoguetab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskDialogueTab);
				crTableIO::DataVec dialoguevec;
				if (dialoguetab.valid())
				{
					dialoguetab->queryRecords(0,crArgumentParser::appItoa(m_taskid),dialoguevec);
					int dialognum = dialoguevec.size();
					data->inputParam(WCHDATA_JXJNewHandDialogNum,&dialognum);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBeautyDialogueUpdateMethod
//
/////////////////////////////////////////
crJXJBeautyDialogueUpdateMethod::crJXJBeautyDialogueUpdateMethod():
	m_next(false)
{}
crJXJBeautyDialogueUpdateMethod::crJXJBeautyDialogueUpdateMethod(const crJXJBeautyDialogueUpdateMethod& handle):
	crMethod(handle),
	m_next(handle.m_next),
	m_input(handle.m_input),
	m_newhandcanvas(handle.m_newhandcanvas)
{
}
void crJXJBeautyDialogueUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJBeautyDialogueUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_input = str;
		break;
	case 1:
		m_newhandcanvas = str;
		break;
	case 2:
		m_next = (bool)(atoi(str.c_str()));
		break;
	}
}

void crJXJBeautyDialogueUpdateMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>newhandcanvas = crFilterRenderManager::getInstance()->findCanvas(m_newhandcanvas);
	//ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if(m_this)
	{
		void *param;
		ref_ptr<crHypertextWidgetNode> input = dynamic_cast<crHypertextWidgetNode*>(m_this->getWidget(m_input));
		crData *data = m_this -> getDataClass();
		if (data)
		{
			data->getParam(WCHDATA_JXJNewHandTaskID,param);
			int taskid = *(int *)param;
			data->getParam(WCHDATA_JXJNewHandDialogNum,param);
			int *dialoguenum = (int *)param;
			if(m_next) *dialoguenum -=1;
			if (*dialoguenum > 0)
			{
				ref_ptr<crTableIO>dialoguetab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskDialogueTab);
				crTableIO::DataVec dialoguevec;
				if (dialoguetab.valid())
				{
					int diaindex = dialoguetab->getTitleIndex("对白");
					dialoguetab->queryRecords(0,crArgumentParser::appItoa(taskid),dialoguevec);
					int dialoguevecsize = dialoguevec.size();
					if(dialoguevecsize>0)
					{
						std::string filename = dialoguevec[dialoguevecsize - *dialoguenum][diaindex];
						if(input.valid())
						{
							if(!filename.empty())
							{
								input->clearText();
								filename = crMyPlayerData::getInstance()->getSelectedGame()->getTextDir() + filename;
								input->setHypertext(filename);
							}
							else
							{
								input->clearText();
							}
						}
					}
				}
			}
			//if(m_next) *dialoguenum -=1;
			if(*dialoguenum == 0)
			{
				crFilterRenderManager::getInstance()->closeCanvas(m_this);
				data->excHandle(MAKECREPARAM(WCH_JXJNewHandDialogueClick,NULL));
				//data->getParam(WCHDATA_JXJClickWidget,param);
				//ref_ptr<crWidgetNode> wigetnode = (crWidgetNode *)param;
				//if(wigetnode)
				//{
				//	wigetnode->doEvent(WCH_JXJNewHandDialogueClick);
				//}
				//if(newhandcanvas)crFilterRenderManager::getInstance()->doModal(newhandcanvas);
			}
			//if(m_next) *dialoguenum -=1;
		}
	}
}
///////////////////////////////////////////
////
////crJXJJiusiCostCountTimerMethod
////
///////////////////////////////////////////
//crJXJJiusiCostCountTimerMethod::crJXJJiusiCostCountTimerMethod():
//	m_dt(0),
//	m_sec(0)
//{
//}
//crJXJJiusiCostCountTimerMethod::crJXJJiusiCostCountTimerMethod(const crJXJJiusiCostCountTimerMethod& handle):
//	crMethod(handle),
//	m_dt(handle.m_dt),
//	m_sec(handle.m_sec)
//{
//}
//void crJXJJiusiCostCountTimerMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_dt = *((int*)(LOCREPARAM(param64)));
//			m_sec = HIINT64(param64);
//		}
//		else
//		{
//			m_dt = 0;
//			m_sec = 0;
//		}
//		break;
//	}
//}
//void crJXJJiusiCostCountTimerMethod::addParam(int i, const std::string& str)
//{
//}
//void crJXJJiusiCostCountTimerMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		int playerid = m_this->getPlayerID();
//		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//		if(playerData.valid())
//		{
//		//	int maxtime = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJiusiRefreshCostTimeMax).c_str()));
//			void *param;
//			crData *thisData = m_this->getDataClass();
//			thisData->excHandle(MAKECREPARAM(WCH_LockData,1));
//			thisData->getParam(WCHDATA_JXJJiusiRefreshCostTime,param);
//			int *timer = (int *)param;
//			*timer-=m_dt;
///*
//			time_t t = time(0);
//			int maxtime =(int)(t % 86400);*/
//			time_t t = time(0);
//			if(*timer<=0)
//			{
//				int giftcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOnLineGiftMaxCount).c_str());
//				*timer = m_sec;
//				//*timer = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJunlingRefresh).c_str());
//				thisData->inputParam(WCHDATA_JXJLuckyCardCopperCost,0);
//				thisData->inputParam(WCHDATA_JXJLuckyCardGoldCost,0);
//				thisData->inputParam(WCHDATA_JXJKnowLuckyCard,0);
//				thisData->inputParam(WCHDATA_JXJOnlineRewardCount,&giftcount);
//				thisData->inputParam(WCHDATA_JXJOnlineRewardTimer,&t);
//				//ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				//stream->createBuf(1);
//				//stream->_writeUChar(*count);
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvJiusiCostCountRefresh,NULL);
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//			thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvJiusiCostCountRefreshMethod
////
///////////////////////////////////////////
//crJXJRecvJiusiCostCountRefreshMethod::crJXJRecvJiusiCostCountRefreshMethod()
//{}
//crJXJRecvJiusiCostCountRefreshMethod::crJXJRecvJiusiCostCountRefreshMethod(const crJXJRecvJiusiCostCountRefreshMethod& handle):
//	crMethod(handle),
//	m_input(handle.m_input),
//	m_newhandcanvas(handle.m_newhandcanvas)
//{
//}
//void crJXJRecvJiusiCostCountRefreshMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	}
//}
//
//void crJXJRecvJiusiCostCountRefreshMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_input = str;
//		break;
//	case 1:
//		m_newhandcanvas = str;
//		break;
//	}
//}
//
//void crJXJRecvJiusiCostCountRefreshMethod::operator()(crHandle &handle)
//{
//	if (m_this)
//	{
//		time_t t = time(0);
//		int giftcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJOnLineGiftMaxCount).c_str());
//		crData *thisData = m_this->getDataClass();
//		thisData->inputParam(WCHDATA_JXJLuckyCardCopperCost,0);
//		thisData->inputParam(WCHDATA_JXJLuckyCardGoldCost,0);
//		thisData->inputParam(WCHDATA_JXJKnowLuckyCard,0);
//		/////////////////////////////////////////////////
//		thisData->inputParam(WCHDATA_JXJOnlineRewardCount,&giftcount);
//		thisData->inputParam(WCHDATA_JXJOnlineRewardTimer,&t);
//	}
//}
/////////////////////////////////////////
//
//crJXJRenWuCanvasFoldMethod
//
/////////////////////////////////////////
crJXJRenWuCanvasFoldMethod::crJXJRenWuCanvasFoldMethod()
{}
crJXJRenWuCanvasFoldMethod::crJXJRenWuCanvasFoldMethod(const crJXJRenWuCanvasFoldMethod& handle):
	crMethod(handle)
{
}
void crJXJRenWuCanvasFoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJRenWuCanvasFoldMethod::addParam(int i, const std::string& str)
{
}

void crJXJRenWuCanvasFoldMethod::operator()(crHandle &handle)
{
	if (m_this)
	{
		void *param;
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			crData *thisData = canvas->getDataClass();
			if(thisData)
			{
				thisData->getParam(WCHDATA_JXJRenWuUnFolden,param);
				bool *unfold = (bool *)param;
				bool curfold = !*unfold;
				*unfold = curfold;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetGameCardBuffTimeMethod
//
/////////////////////////////////////////
crJXJSetGameCardBuffTimeMethod::crJXJSetGameCardBuffTimeMethod()
{
}
crJXJSetGameCardBuffTimeMethod::crJXJSetGameCardBuffTimeMethod(const crJXJSetGameCardBuffTimeMethod& handle):
	crMethod(handle),
	m_percentVec(handle.m_percentVec)
{
	for (int i = 0; i <9;i++)
	{
		m_node[i] = handle.m_node[i];
		m_fx[i] = handle.m_fx[i];
	}
}
void crJXJSetGameCardBuffTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJSetGameCardBuffTimeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
		m_node[i] = str;
		break;
	case 9:
	case 10:
	case 11:
	case 12:
	case 13:
	case 14:
	case 15:
	case 16:
	case 17:
		m_fx[i-9] = str;
		break;
	case 18:
		crArgumentParser::appAtoVec(str,m_percentVec);
		break;
	default:
		break;
	}
}

void crJXJSetGameCardBuffTimeMethod::operator()(crHandle &handle)
{
	if (crRunGameHandle::getInstance()->isInManor())
	{
		crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		crNode *node[9] = {NULL};
		crSequence *fx[9] = {NULL};
		for(int i = 0;i<9;i++)
		{
			node[i] = m_this->getChildNode(m_node[i]);
			fx[i] = dynamic_cast<crSequence *>(m_this->getChildNode(m_fx[i]));
			if(node[i]) node[i]->setVisiable(false);
			if(fx[i]) fx[i]->setVisiable(false);
		}
		int timer[9]={0};
		//crVector4s percent;
		void *param;
		unsigned char sourceAddLv[4]={0};
		playerData->getParam(WCHDATA_JXJShuichelv,param);
		sourceAddLv[0] = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJGongshelv,param);
		sourceAddLv[1] = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJRonglulv,param);
		sourceAddLv[2] = *(unsigned char *)param;
		playerData->getParam(WCHDATA_JXJMochuanlv,param);
		sourceAddLv[3] = *(unsigned char *)param;

		playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
		playerData->getParam(WCHDATA_JXJExtraProduceMap,param);
		ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
		for (ExtraProduceMap::iterator itr = extraProduceMap->begin();itr!=extraProduceMap->end();)
		{
			itr->second->timer()--;
			if(itr->second->timer()<=0)
			{
				itr = extraProduceMap->erase(itr);
			}
			else
			{
				if (itr->first == T_Panguo)
				{
					itr++;
					continue;
				}
				if(itr->first>=T_Food && itr->first<=T_Horse)
					timer[itr->first - T_Food] = itr->second->timer();
				else if(itr->first>=T_CopperExtraProduce && itr->first<=T_HorseExtraProduce)
					timer[4+itr->first - T_CopperExtraProduce] = itr->second->timer();
				//percent[itr->first - T_Food] = itr->second->getPercent();
				itr++;
			}
		}
		playerData->excHandle(MAKECREPARAM(WCH_LockData,0));
		//int j;
		for (int i = 0; i < 4; i++)
		{
			if (timer[i] > 0)
			{
				if (fx[i])
				{
					fx[i]->startEffect();
					fx[i]->setVisiable(true);
				}
				if (node[i])
				{
					node[i]->setVisiable(true);
					dynamic_cast<crMultiSwitch *>(node[i])->setActiveSwitchSet(sourceAddLv[i] - 1);
				}
				if(timer[i+5]>0)
				{//奇遇
					if (fx[i+5])
					{
						fx[i+5]->startEffect();
						fx[i+5]->setVisiable(true);
					}
					if (node[i+5])
					{
						node[i+5]->setVisiable(true);
					}
				}
			}
			else if(timer[i+5]>0)
			{//奇遇
				if (fx[i])
				{
					fx[i]->startEffect();
					fx[i]->setVisiable(true);
				}
				if (node[i])
				{
					node[i]->setVisiable(true);
					dynamic_cast<crMultiSwitch *>(node[i])->setActiveSwitchSet(5);
				}
			}
		}
		if(timer[4]>0)
		{//奇遇
			if (fx[4])
			{
				fx[4]->startEffect();
				fx[4]->setVisiable(true);
			}
			if (node[4])
			{
				node[4]->setVisiable(true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJResetCardBagPageMethod
//
/////////////////////////////////////////
crJXJResetCardBagPageMethod::crJXJResetCardBagPageMethod()
{
}

crJXJResetCardBagPageMethod::crJXJResetCardBagPageMethod(const crJXJResetCardBagPageMethod& handle)
{
}

void crJXJResetCardBagPageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJResetCardBagPageMethod::addParam(int i, const std::string& str)
{
}

void crJXJResetCardBagPageMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		crData *braindata = crBrain::getInstance()->getDataClass();
		if (braindata)
		{
			int curpage = 1;
			braindata->inputParam(WCHDATA_JXJCurJiangkaBagPageNum, &curpage);
		}
	}
}


///////////////////////////////////////////
////
////crJXJCheckLordEquipSuitMethod
////
///////////////////////////////////////////
//crJXJCheckLordEquipSuitMethod::crJXJCheckLordEquipSuitMethod()
//{
//}
//
//crJXJCheckLordEquipSuitMethod::crJXJCheckLordEquipSuitMethod(const crJXJCheckLordEquipSuitMethod& handle)
//{
//}
//
//void crJXJCheckLordEquipSuitMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crRole*)param;
//		break;
//	}
//}
//
//void crJXJCheckLordEquipSuitMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJCheckLordEquipSuitMethod::operator()(crHandle &handle)
//{
//	if(m_this)
//	{
//		void *param; // parameter extracting
//		crData *roledata = m_this->getDataClass();
//		if (roledata)
//		{
//			roledata->getParam(WCHDATA_JXJLordEquipVec, param);
//			JXJLordEquipVec *lordequipvec = (JXJLordEquipVec *)param;
//			roledata->getParam(WCHDATA_JXJLordSuitMap, param);
//			JXJLordSuitMap *lordsuitmap = (JXJLordSuitMap *)param;
//			crTableIO::StrVec record;
//			ref_ptr<crTableIO>lordsuittab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipSuitTab);
//			/////////////////////////
//			lordsuitmap->clear();
//			JXJItemBagVec2 templordequipvec;
//			JXJItemBagVec2::iterator itrsuit;
//			for (JXJLordEquipVec::iterator itr = lordequipvec->begin();
//				itr!=lordequipvec->end();
//				++itr)
//			{
//				if (itr->first>0)
//				{
//					templordequipvec.push_back(itr->first);
//				}
//			}
//			//////////////////////////
//			bool findequip[5] = {false};
//			int equipindex[5] = {0};
//			int suititemid[5] = {0};
//
//			int suitid = 0;
//			equipindex[0] = lordsuittab->getTitleIndex("equipid1");
//			equipindex[1] = lordsuittab->getTitleIndex("equipid2");
//			equipindex[2] = lordsuittab->getTitleIndex("equipid3");
//			equipindex[3] = lordsuittab->getTitleIndex("equipid4");
//			equipindex[4] = lordsuittab->getTitleIndex("equipid5");
//			unsigned char equipcount;
//			for(int i = 0;i<lordsuittab->getRowCount();i++)
//			{
//				equipcount = 0;
//				for (int ii = 0; ii < 5; ii++)
//				{
//					suititemid[ii] = atoi(lordsuittab->getData(i,equipindex[ii]).c_str());
//					if (suititemid[ii]>0)
//					{
//						for (int j = 0; j < templordequipvec.size();j++)
//						{
//							if (templordequipvec[j]!=NULL)
//							{
//								if (templordequipvec[j] == suititemid[ii])
//								{
//									equipcount++;
//								}
//							}
//						}
//					}
//				}
//				if (equipcount >= 2)
//				{
//					lordsuitmap->insert(std::make_pair(unsigned char(i+1),equipcount));
//					for (int j = 0; j < equipcount; j++)
//					{
//						for (itrsuit = templordequipvec.begin(); itrsuit != templordequipvec.end();itrsuit++)
//						{
//							if ((*itrsuit)!=NULL)
//							{
//								if ((*itrsuit) == suititemid[j])
//								{
//									templordequipvec.erase(itrsuit);
//									break;
//								}
//							}
//						}
//					}
//				}
//				//int ii = 0;
//				//for (; ii < 5; ii++)
//				//{
//				//	suititemid[ii] = atoi(lordsuittab->getData(i,equipindex[ii]).c_str());
//				//	if (suititemid[ii]>0)
//				//	{
//				//		for (int j = 0; j < templordequipvec.size();j++)
//				//		{
//				//			if (templordequipvec[j]!=NULL)
//				//			{
//				//				if (templordequipvec[j] == suititemid[ii])
//				//				{
//				//					findequip[ii] = true;
//				//					break;
//				//				}
//				//			}
//				//		}
//				//		if (!findequip[ii])
//				//		{
//				//			break;
//				//		}
//				//	}
//				//	else
//				//	{
//				//		break;
//				//	}
//				//}
//				//if (ii>0)
//				//{
//				//	if(findequip[ii-1])
//				//	{
//				//		suitid = i+1;
//				//		lordsuitvec->push_back((unsigned char)suitid);
//				//		for (int k = 0; k < 5; k++)
//				//		{
//				//			suititemid[k] = atoi(lordsuittab->getData(i,equipindex[k]).c_str());
//				//			if (suititemid[k] > 0)
//				//			{
//				//				for (itrsuit = templordequipvec.begin(); itrsuit != templordequipvec.end();itrsuit++)
//				//				{
//				//					if ((*itrsuit)!=NULL)
//				//					{
//				//						if ((*itrsuit) == suititemid[k])
//				//						{
//				//							templordequipvec.erase(itrsuit);
//				//							break;
//				//						}
//				//					}
//				//				}
//				//			}
//				//		}
//				//	}
//				//}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJSetWidgetEnableMethod
//
/////////////////////////////////////////
crJXJSetWidgetEnableMethod::crJXJSetWidgetEnableMethod():
	m_enable(false)
{
}
crJXJSetWidgetEnableMethod::crJXJSetWidgetEnableMethod(const crJXJSetWidgetEnableMethod& handle):
	m_canvas(handle.m_canvas),
	m_button(handle.m_button),
	m_enable(handle.m_enable)
{
}
void crJXJSetWidgetEnableMethod::inputParam(int i, void *param)
{
}
void crJXJSetWidgetEnableMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_button = str;
		break;
	case 2:
		m_enable = (bool)atoi(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJSetWidgetEnableMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if (canvas.valid())
	{
		ref_ptr<crWidgetNode> targetWidget = canvas->getWidget(m_button);
		if (targetWidget.valid())
		{
			targetWidget->setEnable(m_enable);
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetWidgetVisiableMethod
//
/////////////////////////////////////////
crJXJSetWidgetVisiableMethod::crJXJSetWidgetVisiableMethod():
	m_visiable(false)
{
}

crJXJSetWidgetVisiableMethod::crJXJSetWidgetVisiableMethod(const crJXJSetWidgetVisiableMethod& handle):
	m_canvas(handle.m_canvas),
	m_button(handle.m_button),
	m_visiable(handle.m_visiable)
{
}

void crJXJSetWidgetVisiableMethod::inputParam(int i, void *param)
{
}

void crJXJSetWidgetVisiableMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_button = str;
		break;
	case 2:
		m_visiable = (bool)atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJSetWidgetVisiableMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if (canvas.valid())
	{
		ref_ptr<crWidgetNode> targetWidget = canvas->getWidget(m_button);
		if (targetWidget.valid())
		{
			targetWidget->setVisiable(m_visiable);
		}
		else
		{
			ref_ptr<crNode> node = canvas->getChildNode(m_button);
			if(node.valid()) node->setVisiable(m_visiable);
		}
	}
}
/////////////////////////////////////////
//
//crJXJSetShowParamMethod
//
/////////////////////////////////////////
crJXJSetShowParamMethod::crJXJSetShowParamMethod():
	m_index(0)
{
}

crJXJSetShowParamMethod::crJXJSetShowParamMethod(const crJXJSetShowParamMethod& handle)
{
	for (int i = 0; i < 6; i ++)
	{
		m_widget[i] = handle.m_widget[i];
	}
}

void crJXJSetShowParamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJSetShowParamMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_widget[i] = str;
		break;
	case 1:
		m_widget[i] = str;
		break;
	case 2:
		m_widget[i] = str;
		break;
	case 3:
		m_widget[i] = str;
		break;
	case 4:
		m_widget[i] = str;
		break;
	case 5:
		m_widget[i] = str;
		break;
	case 6:
		m_index = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJSetShowParamMethod::operator()(crHandle &handle)
{
	//crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if (m_index < 6)
	{
		if(m_this)
		{
			/*CRCore::ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			if (canvas)
			{
				ref_ptr<crWidgetNode> widget[6] = {NULL};
				for (int i = 0; i < 6; i++)
				{
					widget[i] = canvas->getWidget(m_widget[i]);
				}
				if (widget[m_index])
				{
					if (widget[m_index]->getVisiable())
					{
						widget[m_index]->setVisiable(false);
					}
					else
					{
						for (int ii = 0; ii < 6; ii++)
						{
							if (ii != (int)m_index)
							{
								if (widget[ii])
								{
									if (widget[ii]->getVisiable())
									{
										widget[ii]->setVisiable(false);
									}
								}
							}
						}
						widget[m_index]->setVisiable(true);
					}
				}
			}*/
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISetRadioSelectMethod
//
/////////////////////////////////////////
crJXJUISetRadioSelectMethod::crJXJUISetRadioSelectMethod():
	m_index(0)
{
}

crJXJUISetRadioSelectMethod::crJXJUISetRadioSelectMethod(const crJXJUISetRadioSelectMethod& handle):
	m_canvas(handle.m_canvas),
	m_radiogroup(handle.m_radiogroup),
	m_index(handle.m_index),
	m_radiogroup_2(handle.m_radiogroup_2)
{
}

void crJXJUISetRadioSelectMethod::inputParam(int i, void *param)
{

}

void crJXJUISetRadioSelectMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_radiogroup = str;
		break;
	case 2:
		m_index = atoi(str.c_str());
		break;
	case 3:
		m_radiogroup_2 = str;
		break;
	default:
		break;
	}
}

void crJXJUISetRadioSelectMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if (canvas.valid())
	{
		ref_ptr<crRadioGroupWidgetNode> radio =  dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radiogroup));
		ref_ptr<crRadioGroupWidgetNode> radio_2 = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_radiogroup_2));
		if (radio.valid())
		{
			radio->select(m_index);
			radio->doEvent(WCH_UI_SelectChange);
		}
		if (radio_2.valid())
		{
			radio_2->select(m_index);
			radio_2->doEvent(WCH_UI_SelectChange);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUISetActiveSwitchSetMethod
//
/////////////////////////////////////////
crJXJUISetActiveSwitchSetMethod::crJXJUISetActiveSwitchSetMethod():
	m_value(0),
	m_value2(0)
{
}

crJXJUISetActiveSwitchSetMethod::crJXJUISetActiveSwitchSetMethod(const crJXJUISetActiveSwitchSetMethod& handle):
	m_canvas(handle.m_canvas),
	m_value(handle.m_value),
	m_value2(handle.m_value2),
	m_sw(handle.m_sw),
	m_sw2(handle.m_sw2)
{
}

void crJXJUISetActiveSwitchSetMethod::inputParam(int i, void *param)
{

}

void crJXJUISetActiveSwitchSetMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_sw = str;
		break;
	case 2:
		m_value = atoi(str.c_str());
		break;
	case 3:
		m_sw2 = str;
		break;
	case 4:
		m_value2 = atoi(str.c_str());
		break;
	}
}

void crJXJUISetActiveSwitchSetMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if (canvas.valid())
	{
		ref_ptr<crMultiSwitch> sw =  dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_sw));
		ref_ptr<crMultiSwitch> sw2 = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_sw2));
		if (sw.valid())
		{
			sw->setActiveSwitchSet(m_value);
		}
		if (sw2.valid())
		{
			sw2->setActiveSwitchSet(m_value2);
		}
	}
}
/////////////////////////////////////////
//
//crJXJShowSetImageParamMethod
//
/////////////////////////////////////////
crJXJShowSetImageParamMethod::crJXJShowSetImageParamMethod()
{
}

crJXJShowSetImageParamMethod::crJXJShowSetImageParamMethod(const crJXJShowSetImageParamMethod& handle)
{
	m_brightnessbar = handle.m_brightnessbar;
	m_radio = handle.m_radio;
	m_fullscreencheck = handle.m_fullscreencheck;
	m_windowMaxsizeCheck = handle.m_windowMaxsizeCheck;
	m_hideModelCheck = handle.m_hideModelCheck;
	m_autoBattleSettingCheck = handle.m_autoBattleSettingCheck;
	for (int i = 0; i < 6; i ++)
	{
		m_widget[i] = handle.m_widget[i];
		m_gamelist[i] = handle.m_gamelist[i];
		m_paraminput[i] = handle.m_paraminput[i];
		m_combobox[i] = handle.m_combobox[i];
		if(i < 3)
		{
			m_checkbox[i] = handle.m_checkbox[i];
		}
	}
	m_uiscaleSlider = handle.m_uiscaleSlider;
	//m_uiscaleText = handle.m_uiscaleText;
}

void crJXJShowSetImageParamMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJShowSetImageParamMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_widget[i] = str;
		break;
	case 1:
		m_widget[i] = str;
		break;
	case 2:
		m_widget[i] = str;
		break;
	case 3:
		m_widget[i] = str;
		break;
	case 4:
		m_widget[i] = str;
		break;
	case 5:
		m_widget[i] = str;
		break;
	case 6:
		m_gamelist[i - 6] = str;
		break;
	case 7:
		m_gamelist[i - 6] = str;
		break;
	case 8:
		m_gamelist[i - 6] = str;
		break;
	case 9:
		m_gamelist[i - 6] = str;
		break;
	case 10:
		m_gamelist[i - 6] = str;
		break;
	case 11:
		m_gamelist[i - 6] = str;
		break;
	case 12:
		m_paraminput[i - 12] = str;
		break;
	case 13:
		m_paraminput[i - 12] = str;
		break;
	case 14:
		m_paraminput[i - 12] = str;
		break;
	case 15:
		m_paraminput[i - 12] = str;
		break;
	case 16:
		m_paraminput[i - 12] = str;
		break;
	case 17:
		m_paraminput[i - 12] = str;
		break;
	case 18:
		m_combobox[i - 18] = str;
		break;
	case 19:
		m_combobox[i - 18] = str;
		break;
	case 20:
		m_combobox[i - 18] = str;
		break;
	case 21:
		m_combobox[i - 18] = str;
		break;
	case 22:
		m_combobox[i - 18] = str;
		break;
	case 23:
		m_combobox[i - 18] = str;
		break;
	case 24:
		m_checkbox[0] = str;
		break;
	case 25:
		m_checkbox[1] = str;
		break;
	case 26:
		m_checkbox[2] = str;
		break;
	case 27:
		m_brightnessbar = str;
		break;
	case 28:
		m_radio = str;
		break;
	case 29:
		m_fullscreencheck = str;
		break;
	case 30:
		m_windowMaxsizeCheck = str;
		break;
	case 31:
		m_hideModelCheck = str;
		break;
	case 32:
		m_autoBattleSettingCheck = str;
		break;
	case 33:
		m_uiscaleSlider = str;
		break;
	//case 34:
	//	m_uiscaleText = str;
	//	break;
	default:
		break;
	}
}

void crJXJShowSetImageParamMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCheckBoxWidgetNode >  settingBox = dynamic_cast<crCheckBoxWidgetNode*>(m_this->getWidget("ShowSetting"));
	if(myPlayer && settingBox.valid())
	{
		char filePath[MAX_PATH];
		std::string strPath = crGlobalHandle::getInstance()->getGameDir();
		sprintf(filePath,"%ssystem.ini\0",strPath.c_str());
		bool ischecked = ::GetPrivateProfileInt("frame","frameable",1,filePath);

		settingBox->select(ischecked);
		
	}
	//crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && crDisplaySettings::instance()->getRunMode()>0)
	{
		std::string filename;
		filename = "script/init.cfg";
		if(!crScriptLoadManager::getInstance()->loadConfigScript(m_cfg_script,filename,true))
		{
			CRCore::notify(CRCore::FATAL)<<"loadInitCfg(): file open error,"<<filename<<std::endl;
			return;
		}
		if(!m_cfg_script.Push("DisplaySetting"))
		{
			return;
		}
		ref_ptr<crTableIO>showtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSystemShowTab);
		crTableIO::DataVec record;
		int typeindex = showtab->getTitleIndex("type");
		int nameindex = showtab->getTitleIndex("name");

		ref_ptr<crScrollBarWidgetNode> brightnessbar = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_brightnessbar));
		ref_ptr<crRadioGroupWidgetNode> setradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radio));
		//ref_ptr<crCheckBoxWidgetNode> fullscreencheck = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_fullscreencheck));
		//ref_ptr<crCheckBoxWidgetNode> windowMaxsizeCheck = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_windowMaxsizeCheck));
		//ref_ptr<crCheckBoxWidgetNode> hideModelCheck = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_hideModelCheck));
		//ref_ptr<crCheckBoxWidgetNode> autoBattleSettingCheck = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_autoBattleSettingCheck));
		//ref_ptr<crWidgetNode> widget[8] = {NULL};
		ref_ptr<crTableWidgetNode> gamelist[8] = {NULL};
		ref_ptr<crStaticTextWidgetNode> paraminput[8] = {NULL};
		ref_ptr<crComboBoxWidgetNode> combobox[8] = {NULL};
		//ref_ptr<crCheckBoxWidgetNode> checkbox[3] = {NULL};
		std::string gamelistname = "Gamelist";
		std::string paraminputname = "Input";
		std::string comboboxname = "UI_ComboBox";
		for (int i = 0; i < 8; i++)
		{
			//widget[i] = m_this->getWidget(m_widget[i]);
			gamelist[i] = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(gamelistname + crArgumentParser::appItoa(i + 1)));
			paraminput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(paraminputname + crArgumentParser::appItoa(i + 1)));
			combobox[i] = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(comboboxname + crArgumentParser::appItoa(i + 1)));
			//if (i < 3)
			//{
			//	checkbox[i] = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_checkbox[i]));
			//}
			//if (paraminput[i])
			//{
			//	paraminput[i]->setCanSelectText(true);
			//}
			
			if (gamelist[i].valid())
			{
				gamelist[i]->setMouseMoveSelect(true);
				gamelist[i]->clearData();
				//gamelist[i]->initWindow();
			}
		}
		ref_ptr<crSliderWidgetNode> uiscaleSlider = dynamic_cast<crSliderWidgetNode *>(m_this->getWidget(m_uiscaleSlider));
		//ref_ptr<crStaticTextWidgetNode> uiscaleText = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_uiscaleText));
		//void *param;
		//crData *data = playerData->getDataClass();
		//data->excHandle(MAKECREPARAM(WCH_LockData,1));
		//data->getParam(WCHDATA_JXJTroopsMap,param);
		//TroopsMap *troopsMap = (TroopsMap *)param;
		//troopsList->clearData();
		//int row = 0;
		int uiwidth = (int)crDisplaySettings::instance()->getScreenWidth();
		int uiheight = (int)crDisplaySettings::instance()->getScreenHeight();
		float brightness = crDisplaySettings::instance()->getBrightness();
		int textureDetail = getTextureDetail();//(int)crDisplaySettings::instance()->getTextureDetail();
		int maxanisotropy = getMaxAnisotropy();//(int)crDisplaySettings::instance()->getMaxAnisotropy();
		int ShadowDetail = getShadowDetail();//(int)crDisplaySettings::instance()->getShadowDetail();
		int antialiasing = getNumMultiSamples();//(int)crDisplaySettings::instance()->getNumMultiSamples();
		int hdr = getHDR();//(int)crDisplaySettings::instance()->getHDR();
		bool motionblur = crDisplaySettings::instance()->getMotionBlur();
		bool dof = crDisplaySettings::instance()->getDepthOfField();
		bool alphaShadow = getEnableAlphaShadow();//crDisplaySettings::instance()->getEnableAlphaShadow();
		bool fullScreen = crDisplaySettings::instance()->getFullScreen();
		bool windowMaxsize = crDisplaySettings::instance()->getWindowMaxsize();
		int hidemodel = getHideModel();
		int autobattlesetting = getAutoBattleSetting();
		int fpscontrol = getFPSControl();
		float uiscalefactor = getUIScaleFactor();
		crData *braindata = crBrain::getInstance()->getDataClass();
		braindata->inputParam(WCHDATA_JXJHideModel,&hidemodel);
		braindata->inputParam(WCHDATA_JXJAutoBattleSetting,&autobattlesetting);
		if (brightnessbar.valid())
		{
			brightness = brightness * 10;
			brightnessbar->setValue(brightness);
		}
		int af[8] = {0};
		int fullscreenadd = 0;
		if (windowMaxsize)
		{
			if (fullScreen)
			{
				af[0] = 13;
			}
			else
			{
				af[0] = 12;
			}
		}
		else
		{
			if (fullScreen)
			{
				fullscreenadd = 6;
			}
			switch (uiwidth)
			{
			case 1280:
				if(uiheight > 800)
					af[0] = 1+fullscreenadd;
				else
					af[0] = fullscreenadd;
				break;
			case 1366:
				af[0] = 2 + fullscreenadd;
				break;
			case 1600:
				af[0] = 3 + fullscreenadd;
				break;
			case 1680:
				af[0] = 4 + fullscreenadd;
				break;
			case 1920:
				af[0] = 5 + fullscreenadd;
				break;
			}
		}
		af[1] = textureDetail;//贴图精度
		switch (maxanisotropy)
		{
		case 1:
			af[2] = 0;
			break;
		case 2:
			af[2] = 0;
			break;
		case 4:
			af[2] = 1;
			break;
		case 8:
			af[2] = 2;
			break;
		case 16:
			af[2] = 3;
			break;
		}
		af[3] = ShadowDetail;
		switch (alphaShadow)
		{
		case 0:
			af[4] = 0;
			break;
		case 1:
			af[4] = 1;
			break;
		}
		switch (antialiasing)
		{
		case 1:
			af[5] = 0;
			break;
		case 2:
			af[5] = 1;
			break;
		case 4:
			af[5] = 2;
			break;
		case 8:
			af[5] = 3;
			break;
		case 16:
			af[5] = 4;
			break;
		}
		af[6] = hdr;
		switch (fpscontrol)
		{
		case 0:
			af[7] = 0;
			break;
		case 30:
			af[7] = 1;
			break;
		case 60:
			af[7] = 2;
			break;
		}
		for (int i = 0 ; i < 8 ; i++)
		{
			record.clear();
			showtab->queryRecords(typeindex,crArgumentParser::appItoa(i),record);
			for (int ii = 0; ii < record.size(); ii++)
			{
				gamelist[i]->addData(0,ii,record[ii][nameindex]);
				gamelist[i]->addData(ii,atoi(record[ii][0].c_str()));
			}
			if (combobox[i].valid())
			{

				combobox[i]->select(af[i]);
			}
			//if (i<3 && checkbox[i].valid())
			//{
			//	switch (i)
			//	{
			//	case 0:
			//		checkbox[i]->select(motionblur);
			//		break;
			//	case 1:
			//		checkbox[i]->select(dof);
			//		break;
			//	case 2:
			//		checkbox[i]->select(alphaShadow);
			//		break;
			//	default:
			//		break;
			//	}
			//}
		}
		//if (fullscreencheck.valid())
		//{
		//	fullscreencheck->select(fullScreen);
		//}
		//if (windowMaxsizeCheck.valid())
		//{
		//	windowMaxsizeCheck->select(windowMaxsize);
		//}
		//if (hideModelCheck.valid())
		//{
		//	hideModelCheck->select(hidemodel);
		//}
		//if (autoBattleSettingCheck.valid())
		//{
		//	autoBattleSettingCheck->select(autobattlesetting);
		//}
		//低配，中配，高配
		std::vector<int> paramvector[5];
		for (int i = 0; i < 5; ++i)
		{
			paramvector[i].resize(8);
		}
		ref_ptr<crTableIO>ConfigTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSystemConfigTab);
		crTableIO::StrVec Configrecord;
		int peizhiindex = ConfigTab->getTitleIndex("配置");
		for (int i = 0; i < 5; i++)
		{
			if(ConfigTab->queryOneRecord(0,crArgumentParser::appItoa(i),Configrecord) >= 0)
			{
				crArgumentParser::appAtoVec(Configrecord[peizhiindex].c_str(),paramvector[ConfigType_Low + i]);
			}
		}
		//crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSystemLow, 0),paramvector[ConfigType_Low]);
		//crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSystemMedium, 0),paramvector[ConfigType_Medium]);
		//crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSystemHigh, 0),paramvector[ConfigType_High]);//

		int peizhi = 0;
		bool findpeizhi = true;
		for (int i = 0; i < 5; ++i)
		{
			findpeizhi = true;
			for (int j = 0; j < 7; ++j)
			{
				if(af[j + 1] != paramvector[ConfigType_Low + i][j])
				{
					findpeizhi = false;
					break;
				}
			}
			//if ((int)alphaShadow != paramvector[ConfigType_Low + i][5])
			//{
			//	findpeizhi = false;
			//}
			if (findpeizhi)
			{
				peizhi = i;
				break;
			}
		}
		//if (af[1] == 1 && af[2] == 1 && af[3] == 0 && af[4] == 0 && af[5] == 0 && alphaShadow == false)
		//{
		//	peizhi = 0;
		//}
		//if(af[1] == 1 && af[2] == 2 && af[3] == 2 && af[4] == 2 && af[5] == 0 && alphaShadow == true)
		//{
		//	peizhi = 1;
		//}
		//if(af[1] == 1 && af[2] == 3 && af[3] == 3 && af[4] == 1 && af[5] == 1 && alphaShadow == true)
		//{
		//	peizhi = 2;
		//}
		if (setradio.valid())
		{
			setradio->select(peizhi);
		}
		if (uiscaleSlider.valid())
		{
			float v = (uiscalefactor-0.8f)/(1.2f-0.8f);
			uiscaleSlider->setValue(v);
		}
		//if (uiscaleText.valid())
		//{
		//	char buf[16];
		//	memset(buf,0,16);
		//	sprintf(buf,"%.1f\0",uiscalefactor);
		//	uiscaleText->setString(std::string(buf));
		//}
	}
}
int crJXJShowSetImageParamMethod::getTextureDetail()
{
	int int1 = 0;
	if(m_cfg_script.Get("TextureDetail",int1))
		return int1;
	return 0;
}
int crJXJShowSetImageParamMethod::getMaxAnisotropy()
{
	int int1 = 0;
	if(m_cfg_script.Get("MaxAnisotropy",int1))
		return int1;
	return 0;
}
int crJXJShowSetImageParamMethod::getShadowDetail()
{
	int int1 = 0;
	if(m_cfg_script.Get("ShadowDetail",int1))
		return int1;
	return 0; 
}
int crJXJShowSetImageParamMethod::getNumMultiSamples()
{
	int int1 = 0;
	if(m_cfg_script.Get("numMultiSamples",int1))
		return int1;
	return 0;
}
int crJXJShowSetImageParamMethod::getHDR()
{
	int int1 = 0;
	if(m_cfg_script.Get("HDR",int1))
		return int1;
	return 0;
}
bool crJXJShowSetImageParamMethod::getEnableAlphaShadow()
{
	int int1 = 0;
	if(m_cfg_script.Get("EnableAlphaShadow",int1) && int1 > 0)
		return int1;
	return 0;
}
int crJXJShowSetImageParamMethod::getHideModel()
{
	int int1 = 0;
	m_cfg_script.Get("hidemodel",int1);
	return int1;
}
int crJXJShowSetImageParamMethod::getAutoBattleSetting()
{
	int int1 = 0;
	m_cfg_script.Get("autobattlesetting",int1);
	return int1;
}
int crJXJShowSetImageParamMethod::getFPSControl()
{
	int int1 = 0;
	m_cfg_script.Get("FPSControl", int1);
	return int1;
}
float crJXJShowSetImageParamMethod::getUIScaleFactor()
{
	float flt1 = 1.0f;
	m_cfg_script.Get("UIScaleFactor", flt1);
	return flt1;
}
/////////////////////////////////////////
//
//crJXJUpdateInitCfgMethod
//
/////////////////////////////////////////
crJXJUpdateInitCfgMethod::crJXJUpdateInitCfgMethod(){}
crJXJUpdateInitCfgMethod::crJXJUpdateInitCfgMethod(const crJXJUpdateInitCfgMethod& handle):
	crMethod(handle),
	m_resolutionCombo(handle.m_resolutionCombo),
	m_brightnessSlider(handle.m_brightnessSlider),
	m_textureDetailCombo(handle.m_textureDetailCombo),
	m_textureFilterCombo(handle.m_textureFilterCombo),
	m_shadowDetailCombo(handle.m_shadowDetailCombo),
	m_antialiasingCombo(handle.m_antialiasingCombo),
	m_HDRCombo(handle.m_HDRCombo),
	m_motionBlurCheck(handle.m_motionBlurCheck),
	m_depthOfFieldCheck(handle.m_depthOfFieldCheck),
	m_alphaShadowCheck(handle.m_alphaShadowCheck),
	m_fullScreenCheck(handle.m_fullScreenCheck),
	m_windowMaxsizeCheck(handle.m_windowMaxsizeCheck),
	m_alphaShadowCombo(handle.m_alphaShadowCombo),
	m_FPSCombo(handle.m_FPSCombo),
	m_uiscaleSlider(handle.m_uiscaleSlider)
{
	m_hideModelCheck = handle.m_hideModelCheck;
	m_autoBattleSettingCheck = handle.m_autoBattleSettingCheck;
}
void crJXJUpdateInitCfgMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUpdateInitCfgMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_resolutionCombo = str;
		break;
	case 1:
		m_brightnessSlider = str;
		break;
	case 2:
		m_textureDetailCombo = str;
		break;
	case 3:
		m_textureFilterCombo = str;		
		break;
	case 4:
		m_shadowDetailCombo = str;
		break;	
	case 5:
		m_alphaShadowCombo = str;
		break;
	case 6:
		m_antialiasingCombo = str;
		break;
	case 7:
		m_HDRCombo = str;
		break;
	case 8:
		m_FPSCombo = str;
		break;
	case 9:
		m_uiscaleSlider = str;
		break;
	//case 7:
	//	m_motionBlurCheck = str;
	//	break;
	//case 8:
	//	m_depthOfFieldCheck = str;
	//	break;
	//case 9:
	//	m_alphaShadowCheck = str;
	//	break;
	//case 10:
	//	m_fullScreenCheck = str;
	//	break;
	//case 11:
	//	m_windowMaxsizeCheck = str;
	//	break;
	//case 12:
	//	m_hideModelCheck = str;
	//	break;
	//case 13:
	//	m_autoBattleSettingCheck = str;
	//	break;
	}
}
void crJXJUpdateInitCfgMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		ref_ptr<crComboBoxWidgetNode> resolutionCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_resolutionCombo));
		ref_ptr<crScrollBarWidgetNode> brightnessSlider = dynamic_cast<crScrollBarWidgetNode *>(canvas->getWidget(m_brightnessSlider));
		ref_ptr<crComboBoxWidgetNode> textureDetailCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_textureDetailCombo));
		ref_ptr<crComboBoxWidgetNode> textureFilterCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_textureFilterCombo));
		ref_ptr<crComboBoxWidgetNode> shadowDetailCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_shadowDetailCombo));
		ref_ptr<crComboBoxWidgetNode> antialiasingCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_antialiasingCombo));
		ref_ptr<crComboBoxWidgetNode> HDRCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_HDRCombo));
		ref_ptr<crComboBoxWidgetNode> alphaShadowCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_alphaShadowCombo));
		ref_ptr<crComboBoxWidgetNode> FPSCombo = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_FPSCombo));
		ref_ptr<crSliderWidgetNode> uiscaleSlider = dynamic_cast<crSliderWidgetNode *>(canvas->getWidget(m_uiscaleSlider));
		//ref_ptr<crCheckBoxWidgetNode> motionBlurCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_motionBlurCheck));
		//ref_ptr<crCheckBoxWidgetNode> depthOfFieldCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_depthOfFieldCheck));
		//ref_ptr<crCheckBoxWidgetNode> alphaShadowCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_alphaShadowCheck));
		//ref_ptr<crCheckBoxWidgetNode> fullScreenCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_fullScreenCheck));
		//ref_ptr<crCheckBoxWidgetNode> windowMaxsizeCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_windowMaxsizeCheck));
		//ref_ptr<crCheckBoxWidgetNode> hideModelCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_hideModelCheck));
		//ref_ptr<crCheckBoxWidgetNode> autoBattleSettingCheck = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_autoBattleSettingCheck));

		int resolution = 0;
		float brightness = 0.00001f;
		int textureDetail = 0;
		int textureAnisotropy = 0;
		int shadowDetail = 0;
		int antialiasing = 0;
		int HDR = 0;
		//int motionBlur = 0;
		//int depthOfField = 0;
		int alphaShadow = 0;
		int disableShader = 0;
		bool fullScreen = false;
		int fps = 30;
		bool windowMaxsize = false;
		float uiscalefactor = 1.0f;
		//bool hideModel = false;
		//bool autoBattleSetting = false;
		if (resolutionCombo.valid())
		{
			resolution = resolutionCombo->getSelectIndex();
		}
		if (brightnessSlider.valid())
		{
			brightness = brightnessSlider->getValue();
			brightness = brightness * 0.1;
		}
		if (textureDetailCombo.valid())
		{
			textureDetail = textureDetailCombo->getSelectIndex();
			textureDetail = 1;
		}
		if (textureFilterCombo.valid())
		{
			textureAnisotropy = textureFilterCombo->getSelectIndex();
		}
		switch (textureAnisotropy)
		{
		//case 0:
		//	textureAnisotropy = 1;
		//	break;
		case 0:
			textureAnisotropy = 2;
			break;
		case 1:
			textureAnisotropy = 4;
			break;
		case 2:
			textureAnisotropy = 8;
			break;
		case 3:
			textureAnisotropy = 16;
			break;
		}
		if (shadowDetailCombo.valid())
		{
			shadowDetail = shadowDetailCombo->getSelectIndex();
		}
		if (antialiasingCombo.valid())
		{
			antialiasing = antialiasingCombo->getSelectIndex();
		}
		switch (antialiasing)
		{
		case 0:
			antialiasing = 0;
			break;
		case 1:
			antialiasing = 2;
			break;
		case 2:
			antialiasing = 4;
			break;
		case 3:
			antialiasing = 8;
			break;
		case 4:
			antialiasing = 16;
			break;
		}
		if (HDRCombo.valid())
		{
			HDR = HDRCombo->getSelectIndex();
		}
		if (alphaShadowCombo.valid())
		{
			alphaShadow = alphaShadowCombo->getSelectIndex();
		}
		if (FPSCombo.valid())
		{
			switch (FPSCombo->getSelectIndex())
			{
			case 0:
				fps = 0;
				break;
			case 1:
				fps = 30;
				break;
			case 2:
				fps = 60;
				break;
			default:
				break;
			}
		}
		if (uiscaleSlider.valid())
		{
			float v = uiscaleSlider->getValue();
			uiscalefactor = v*(1.2f-0.8f)+0.8f;
		}
		//if (motionBlurCheck.valid())
		//{
		//	motionBlur = motionBlurCheck->getSelect();
		//}
		//if (depthOfFieldCheck.valid())
		//{
		//	depthOfField = depthOfFieldCheck->getSelect();
		//}
		//if (alphaShadowCheck.valid())
		//{
		//	alphaShadow = alphaShadowCheck->getSelect();
		//}
		//if (fullScreenCheck.valid())
		//{
		//	fullScreen = fullScreenCheck->getSelect();
		//}
		//if (windowMaxsizeCheck.valid())
		//{
		//	windowMaxsize = windowMaxsizeCheck->getSelect();
		//}
		//if (hideModelCheck.valid())
		//{
		//	hideModel = hideModelCheck->getSelect();
		//}
		//if (autoBattleSettingCheck.valid())
		//{
		//	autoBattleSetting = autoBattleSettingCheck->getSelect();
		///}

		rcfg::ConfigScript cfg_script;
		std::string filename = "script/init.cfg";
		if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,filename,true))
		{
			CRCore::notify(CRCore::FATAL)<<"JXJ::crJXJUpdateInitCfgMethod(): file open error "<<filename<<std::endl;
			//sprintf(gDebugInfo->buf(),"crJXJUpdateInitCfgMethod: file open error%s\n\0",filename.c_str());
			//gDebugInfo->debugInfo(CRCore::FATAL);
			return;
		}
		ref_ptr<crTableIO>table = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSystemShowTab);
		crTableIO::StrVec record;
		std::string str;
		int width = crDisplaySettings::instance()->getScreenWidth();
		int height = crDisplaySettings::instance()->getScreenHeight();
		if (resolution >= 6 && resolution < 12 || resolution == 13)
			fullScreen = true;
		if (resolution < 12 && table->queryOneRecord(0, crArgumentParser::appItoa(resolution + 1), 1, "0", record) >= 0)
		{
			windowMaxsize = false;
			str = record[2];
			std::string wstr,hstr;
			std::string::size_type comma = str.find_first_of("×");
			//std::string::size_type spacestr = str.find_first_of(" ");
			wstr = std::string(str.begin(),str.begin()+comma);
			comma += strlen("×");
			hstr = std::string(str.begin() + comma, str.end());
			width = atoi(wstr.c_str());
			height = atoi(hstr.c_str());
		}
		if (resolution >= 12)
		{
			windowMaxsize = true;
		}
		////bool cancelTask = false;
		//crDisplaySettings *ds = crDisplaySettings::instance();
		//int width = ds->getScreenWidth();
		//int height = ds->getScreenHeight();
		//int height2;
		//if(ds->getRunMode() != 3)
		//{//WebGame
		//	if(!ds->getFullScreen())
		//	{
		//		int shellH = 0;
		//		RECT   Rect; 
		//		HWND   hWnd = FindWindow("Shell_TrayWnd", NULL);
		//		if(GetWindowRect(hWnd,&Rect))   
		//		{ 
		//			shellH = Rect.bottom-Rect.top;//   就是任务栏的高度 
		//			if(shellH >= height)
		//				shellH = 0;
		//		}
		//		height2 = height + shellH;
		//	}
		//	if(fullScreen != ds->getFullScreen())
		//	{
		//		//needRestart = true;
		//		ds->setFullScreen(fullScreen);
		//	}
		//	switch (resolution)
		//	{
		//	case 0:
		//		if(width != 1024 || (height != 768 && height2 != 768))
		//			//needRestart = true;
		//		width = 1024;
		//		height = 768;
		//		break;
		//	case 1:
		//		if(width != 1152 || (height != 864 && height2 != 864))
		//			//needRestart = true;
		//		width = 1152;
		//		height = 864;
		//		break;
		//	case 2:
		//		if(width != 1280 || (height != 800 && height2 != 800))
		//			//needRestart = true;
		//		width = 1280;
		//		height = 800;
		//		break;
		//	case 3:
		//		if(width != 1280 || (height != 1024 && height2 != 1024))
		//			//needRestart = true;
		//		width = 1280;
		//		height = 1024;
		//		break;
		//	case 4:
		//		if(width != 1366 || (height != 768 && height2 != 768))
		//			//needRestart = true;
		//		width = 1366;
		//		height = 768;
		//		break;
		//	case 5:
		//		if(width != 1440 || (height != 900 && height2 != 900))
		//			//needRestart = true;
		//		width = 1440;
		//		height = 900;
		//		break;
		//	case 6:
		//		if(width != 1680 || (height != 1050 && height2 != 1050))
		//			//needRestart = true;
		//		width = 1680;
		//		height = 1050;
		//		break;
		//	case 7:
		//		if(width != 1920 || (height != 1080 && height2 != 1080))
		//			//needRestart = true;
		//		width = 1920;
		//		height = 1080;
		//		break;
		//	}
		//	//if(needRestart)
		//	//{
		//	//	CRGUI::cr2DStageManager::getInstance()->doModal(m_noticeDlg);
		//	//}
		//}
		////ds->setVsync(vsync);
		//ds->setBrightness(brightness);
		//ds->setTextureDetail(textureDetail);
		//ds->setMaxAnisotropy(textureAnisotropy);
		//ds->setShadowDetail(shadowDetail);
		//ds->setEnableAlphaShadow(alphaShadow);
		//ds->setMotionBlur(motionBlur);
		//if(motionBlur)
		//{
		//	ds->setMinimumNumAccumBits(8,8,8,8);
		//}
		//else
		//{
		//	ds->setMinimumNumAccumBits(0,0,0,0);
		//}
		//ds->setHDR(HDR);
		//ds->setDepthOfField(depthOfField);
		//if(depthOfField)
		//{
		//	ds->setNeedPixelDepth(true);
		//}
		//else
		//{
		//	ds->setNeedPixelDepth(false);
		//}
		//ds->setNumMultiSamples(antialiasing);
		//ds->setDisableShader(disableShader);
		//ds->setFullScreen(fullScreen);
		//ds->setWindowMaxsize(windowMaxsize);
		////ds->setNPR(npr);
		if(cfg_script.Push("DisplaySetting"))
		{
			//if(!cfg_script.Modify("hidemodel",hideModel?1:0))
			//{
			//	cfg_script.Add("hidemodel",hideModel?1:0);
			//}
			//if(!cfg_script.Modify("autobattlesetting",autoBattleSetting?1:0))
			//{
			//	cfg_script.Add("autobattlesetting",autoBattleSetting?1:0);
			//}
			if(!cfg_script.Modify("FullScreen",fullScreen?1:0))
			{
				cfg_script.Add("FullScreen",fullScreen?1:0);
			}
			if (!cfg_script.Modify("WindowMaxSize", windowMaxsize ? 1 : 0))
			{
				cfg_script.Add("WindowMaxSize", windowMaxsize ? 1 : 0);
			}
			//if(!cfg_script.Modify("Vsync",vsync?1:0))
			//{
			//	cfg_script.Add("Vsync",vsync?1:0);
			//}
			//if(!cfg_script.Modify("FPSControl",60))
			//{
			//	cfg_script.Add("FPSControl",60);
			//}
			if(!cfg_script.Modify("DisableShader",disableShader?1:0))
			{
				cfg_script.Add("DisableShader",disableShader?1:0);
			}
			if(!cfg_script.Modify("screenWidth",width))
			{
				cfg_script.Add("screenWidth",width);
			}
			if(!cfg_script.Modify("screenHeight", height))
			{
				cfg_script.Add("screenHeight",height);
			}
			if(!cfg_script.Modify("Brightness", brightness))
			{
				cfg_script.Add("Brightness",brightness);
			}
			if(!cfg_script.Modify("TextureDetail", textureDetail))
			{
				cfg_script.Add("TextureDetail",textureDetail);
			}
			if(!cfg_script.Modify("MaxAnisotropy", textureAnisotropy))
			{
				cfg_script.Add("MaxAnisotropy",textureAnisotropy);
			}
			if(!cfg_script.Modify("ShadowDetail", shadowDetail))
			{
				cfg_script.Add("ShadowDetail",shadowDetail);
			}
			if(!cfg_script.Modify("EnableAlphaShadow", alphaShadow))
			{
				cfg_script.Add("EnableAlphaShadow",alphaShadow);
			}
			//if(!cfg_script.Modify("MotionBlur", motionBlur))
			//{
			//	cfg_script.Add("MotionBlur",motionBlur);
			//}
			//std::vector<float> v_i;
			//if(motionBlur)
			//{
			//	v_i.push_back(8);
			//	v_i.push_back(8);
			//	v_i.push_back(8);
			//	v_i.push_back(8);
			//}
			//else
			//{
			//	v_i.push_back(0);
			//	v_i.push_back(0);
			//	v_i.push_back(0);
			//	v_i.push_back(0);
			//}
			//if(!cfg_script.Modify("minimumNumberAccumBits", v_i))
			//{
			//	cfg_script.Add("minimumNumberAccumBits",v_i);
			//}
			if(!cfg_script.Modify("HDR", HDR))
			{
				cfg_script.Add("HDR",HDR);
			}
			//if(!cfg_script.Modify("DepthOfField", depthOfField))
			//{
			//	cfg_script.Add("DepthOfField",depthOfField);
			//}
			//if(depthOfField)
			//{
			//	if(!cfg_script.Modify("NeedPixelDepth", 1))
			//	{
			//		cfg_script.Add("NeedPixelDepth",1);
			//	}
			//}
			if(!cfg_script.Modify("numMultiSamples", antialiasing))
			{
				cfg_script.Add("numMultiSamples",antialiasing);
			}
			if (!cfg_script.Modify("FPSControl", fps))
			{
				cfg_script.Add("FPSControl", fps);
			}
			if(!cfg_script.Modify("UIScaleFactor", uiscalefactor))
			{
				cfg_script.Add("UIScaleFactor",uiscalefactor);
			}
			/////声音设置
			//if(!cfg_script.Modify("DisableSound", 1))
			//{
			//	cfg_script.Add("DisableSound",1);
			//}
			//if(!cfg_script.Modify("AmbSoundVolume", 1.0))
			//{
			//	cfg_script.Add("AmbSoundVolume",1.0);
			//}
			//if(!cfg_script.Modify("FxSoundVolume", 1.0))
			//{
			//	cfg_script.Add("FxSoundVolume",1.0);
			//}
			//////////////////
			//if(!cfg_script.Modify("MouseSpeed", mouseSpeed))
			//{
			//	cfg_script.Add("MouseSpeed",mouseSpeed);
			//}
			if (!cfg_script.Pop())
			{
				//CRCore::notify(CRCore::FATAL)<<"crUpdateInitCfgMethod::operator(): "<<cfg_script.GetLastError()<<std::endl;
				char gbuf[256];
				sprintf(gbuf,"crUpdateInitCfgMethod::operator():%s\n\0",cfg_script.GetLastError().c_str());
				gDebugInfo->debugInfo(CRCore::FATAL,gbuf);
			}

			crDisplaySettings::instance()->setFullScreen(fullScreen);
			crDisplaySettings::instance()->setScreenWidth(width);
			crDisplaySettings::instance()->setScreenHeight(height);
			crDisplaySettings::instance()->setBrightness(brightness);
			crDisplaySettings::instance()->setTextureDetail(textureDetail);
			crDisplaySettings::instance()->setMaxAnisotropy(textureAnisotropy);
			crDisplaySettings::instance()->setShadowDetail(shadowDetail);
			crDisplaySettings::instance()->setNumMultiSamples(antialiasing);
			crDisplaySettings::instance()->setHDR(HDR);
			//crDisplaySettings::instance()->setMotionBlur(motionBlur);
			//crDisplaySettings::instance()->setDepthOfField(depthOfField);
			crDisplaySettings::instance()->setEnableAlphaShadow(alphaShadow); 
			crDisplaySettings::initFpsControl(fps);
			crDisplaySettings::instance()->setFpsControl(fps);
			crDisplaySettings::instance()->setUIScaleFactor(uiscalefactor);
			crData *braindata = crBrain::getInstance()->getDataClass();
			//int hidemodelint = hideModel?1:0;
			//int autoBattleSettingint = autoBattleSetting?1:0;
			//braindata->inputParam(WCHDATA_JXJHideModel,&hidemodelint);
			//braindata->inputParam(WCHDATA_JXJAutoBattleSetting,&autoBattleSettingint);
		}
		cfg_script.Write("script/init.cfg");
		cfg_script.Close();

		CRIOManager::crWriteCookFile scopedWrite("script/init.cfg");
		
		//void *param;
		//crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		//if (playerGameData)
		//{
		//	crData *data = playerGameData->getDataClass();
		//	if (data)
		//	{
		//		data->getParam(WCHDATA_JXJBattleRoomID,param);
		//		_crInt64 battleroomid = *(_crInt64 *)param;
		//		int roomid = HIINT64(battleroomid);
		//		data->getParam(WCHDATA_JXJFubenID,param);
		//		int fubenid = *(int *)param;
		//		if(roomid!=0 || fubenid!=0)
		//		{
		//			cancelTask = true;
		//		}
		//	}
		//}
		//handle.outputParam(0,&cancelTask);
	}
}
/////////////////////////////////////////
//
//crJXJUISystemShowUpdateMethod
//
/////////////////////////////////////////
crJXJUISystemShowUpdateMethod::crJXJUISystemShowUpdateMethod()
{
}

crJXJUISystemShowUpdateMethod::crJXJUISystemShowUpdateMethod(const crJXJUISystemShowUpdateMethod& handle):
	m_radiogroup(handle.m_radiogroup)
{
	for (int i = 0; i < 6; i++)
	{
		m_combobox[i] = handle.m_combobox[i];
		if (i<3)
		{
			m_checkbox[i] = handle.m_checkbox[i];
		}
	}
}

void crJXJUISystemShowUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUISystemShowUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_radiogroup = str;
		break;
	case 1:
		m_brightnessbar = str;
		break;
	case 2:
		m_combobox[0] = str;//分辨率
		break;
	case 3:
		m_combobox[1] = str;
		break;
	case 4:
		m_combobox[2] = str;
		break;
	case 5:
		m_combobox[3] = str;
		break;
	case 6:
		m_combobox[4] = str;
		break;
	case 7:
		m_combobox[5] = str;//HDR
		break;
	case 8:
		m_checkbox[0] = str;
		break;
	case 9:
		m_checkbox[1] = str;
		break;
	case 10:
		m_checkbox[2] = str;
		break;
	}
}

void crJXJUISystemShowUpdateMethod::operator()(crHandle &handle)
{

	////////////////////
	//低配 
	//中配 
	//高配 
	/////////////////////
	if (m_this)
	{
		std::string comboboxname = "UI_ComboBox";
		std::vector<int> paramvector[5];
		for(int i = 0; i < 5; ++i)
		{
			paramvector[i].resize(6);
		}
		ref_ptr<crTableIO>ConfigTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSystemConfigTab);
		crTableIO::StrVec Configrecord;
		int peizhiindex = ConfigTab->getTitleIndex("配置");
		for (int i = 0; i < 5; i++)
		{
			if(ConfigTab->queryOneRecord(0,crArgumentParser::appItoa(i),Configrecord) >= 0)
			{
				crArgumentParser::appAtoVec(Configrecord[peizhiindex].c_str(),paramvector[ConfigType_Low + i]);
			}
		}
		ref_ptr<crRadioGroupWidgetNode> radio =  dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radiogroup));
		ref_ptr<crScrollBarWidgetNode> brightnessbar =  dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_brightnessbar));
		ref_ptr<crComboBoxWidgetNode> combobox[8] = {NULL};
	//	ref_ptr<crCheckBoxWidgetNode> checkbox[3] = {NULL};
		int selectindex = 0;
		for (int i = 0; i < 8;i++)
		{
			combobox[i] = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(comboboxname + crArgumentParser::appItoa(i + 1)));
		}
		//for (int i =0; i<3;i++)
		//{
		//	checkbox[i] = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_checkbox[i]));
		//}
		if (radio.valid())
		{
			selectindex = radio->getSelect();
		}
		if (selectindex < 5)
		{
			int i = 0;
		//	if (checkbox[0].valid())
		//	{
		//		checkbox[0] -> select(false);
		//	}
		//	if (checkbox[1].valid())
		//	{
		//		checkbox[1] -> select(false);
		//	}
			for (i = 1; i < 8; i++)
			{
				if (combobox[i].valid())
				{
					combobox[i] -> select(paramvector[selectindex][i - 1]);
				}
			}
		//	if (checkbox[2].valid())
		//	{
		//		checkbox[2] -> select(paramvector[selectindex][5]);
		//	}
		//	crDisplaySettings::initFpsControl()
		//		crDisplaySettings::instance()->setFpsControl()
		}
	}
}
/////////////////////////////////////////
//
//crJXJNewhandSetfubenidMethod
//
/////////////////////////////////////////
crJXJNewhandSetfubenidMethod::crJXJNewhandSetfubenidMethod()
{
	m_taskid = 0;
}
crJXJNewhandSetfubenidMethod::crJXJNewhandSetfubenidMethod(const crJXJNewhandSetfubenidMethod& handle):
	crMethod(handle),
	m_taskid(handle.m_taskid)
{
}
void crJXJNewhandSetfubenidMethod::inputParam(int i, void *param)
{
}

void crJXJNewhandSetfubenidMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_taskid = atoi(str.c_str());
		break;
	}
}

void crJXJNewhandSetfubenidMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
	if(tasktitletab.valid())
	{
		int taskid = 0;
//		void *param;
		crTableIO::StrVec record;
		//ref_ptr<crCanvasNode>taskcanvas = crFilterRenderManager::getInstance()->findCanvas(m_taskcanvas);
		//if(taskcanvas)
		//{
		//	crData *canvasdata = taskcanvas->getDataClass();
		//	if (canvasdata)
		//	{
		//		canvasdata->getParam(WCHDATA_JXJNewHandTaskID,param);
		//		taskid = *(int *)param;
		//	}
		//}
		taskid = m_taskid;
		if (taskid>0)
		{
			unsigned short fubenid = 0;
			int fubenidindex= tasktitletab->getTitleIndex("fubenid");
			int taskidindex= tasktitletab->getTitleIndex("taskid");
			if (tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),record) >= 0 )
			{
				fubenid = (unsigned short)atoi(record[fubenidindex].c_str());
				if (fubenid > 0)
				{
					crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
					unsigned char type = FT_Fuben;
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
					playerData->inputParam(WCHDATA_JXJFubenOrChengchiID,&fubenid);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crCheckRegisterEditBoxMethod
//
/////////////////////////////////////////
crCheckRegisterEditBoxMethod::crCheckRegisterEditBoxMethod()
{
	m_index = 0;
}
crCheckRegisterEditBoxMethod::crCheckRegisterEditBoxMethod(const crCheckRegisterEditBoxMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_resbtn(handle.m_resbtn),
	m_password(handle.m_password),
	m_password2(handle.m_password2)
{
	for (int i = 0; i < 4; i++)
	{
		m_checksw[i] = handle.m_checksw[i];
	}
}
void crCheckRegisterEditBoxMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crEditWidgetNode *)param;
		break;
	}
}

void crCheckRegisterEditBoxMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_checksw[i] = str;
		break;
	case 1:
		m_checksw[i] = str;
		break;
	case 2:
		m_checksw[i] = str;
		break;
	case 3:
		m_checksw[i] = str;
		break;
	case 4:
		m_resbtn = str;
		break;
	case 5:
		m_password = str;
		break;
	case 6:
		m_password2 = str;
		break;
	case 7:
		m_index = atoi(str.c_str());
		break;
	}
}

void crCheckRegisterEditBoxMethod::operator()(crHandle &handle)
{
	if (m_this)
	{
		if (m_index < 4)
		{
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			if (canvas.valid())
			{
				ref_ptr<crEditWidgetNode> password  = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_password));
				ref_ptr<crEditWidgetNode> password2  = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_password2));
				crMultiSwitch *checksw[4] = {NULL};
				for (int i = 0; i < 4; i++)
				{
					checksw[i]  = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_checksw[i]));
				}
				ref_ptr<crButtonWidgetNode> resbtn  = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_resbtn));

				std::string editstring=  crArgumentParser::trim(const_cast<char *>(m_this->getUTF8String().c_str()));
				std::string passwordstr;
				std::string passwordstr2;
				passwordstr = crArgumentParser::trim(const_cast<char *>(password->getUTF8String().c_str()));
				passwordstr2 = crArgumentParser::trim(const_cast<char *>(password2->getUTF8String().c_str()));
				int findindex = 0;
				switch (m_index)
				{
				case 0:
					if (editstring.size()<=16 && editstring.size()>=6)
					{
						checksw[m_index]->setActiveSwitchSet(1);
					}
					else
					{
						checksw[m_index]->setActiveSwitchSet(2);
						crGlobalHandle::getInstance()->doEvent(WCH_UINotify, MAKECREPARAM(44,NULL));
					}
					break;
				case 1://Password1
					if (editstring.size()<=16 && editstring.size()>=6)
					{
						checksw[m_index]->setActiveSwitchSet(2);
					}
					else
					{
						checksw[m_index]->setActiveSwitchSet(1);
						crGlobalHandle::getInstance()->doEvent(WCH_UINotify, MAKECREPARAM(44,NULL));
					}
					if (passwordstr2.size()!=0)
					{
						if (passwordstr.compare(passwordstr2) == 0)
						{
							checksw[2]->setActiveSwitchSet(2);
						}
						else
						{
							checksw[2]->setActiveSwitchSet(1);
							crGlobalHandle::getInstance()->doEvent(WCH_UINotify, MAKECREPARAM(2,NULL));
						}
					}
					break;
				case 2:
					if (passwordstr.compare(passwordstr2) == 0)
					{
						checksw[m_index]->setActiveSwitchSet(2);
					}
					else
					{
						checksw[m_index]->setActiveSwitchSet(1);
						crGlobalHandle::getInstance()->doEvent(WCH_UINotify, MAKECREPARAM(2,NULL));
					}
					break;
				case 3:
					findindex = editstring.find("@");
					if (findindex > 0)
					{
						checksw[m_index]->setActiveSwitchSet(2);
					}
					else
					{
						checksw[m_index]->setActiveSwitchSet(1);
						crGlobalHandle::getInstance()->doEvent(WCH_UINotify, MAKECREPARAM(4,NULL));
					}
					break;
				default:
					break;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crCheckRegisterBtnMethod
//
/////////////////////////////////////////
crCheckRegisterBtnMethod::crCheckRegisterBtnMethod()
{
}
crCheckRegisterBtnMethod::crCheckRegisterBtnMethod(const crCheckRegisterBtnMethod& handle):
	crMethod(handle),
	m_resbtn(handle.m_resbtn)
{
	for (int i = 0; i < 4; i++)
	{
		m_checksw[i] = handle.m_checksw[i];
	}
}
void crCheckRegisterBtnMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode *)param;
		break;
	}
}

void crCheckRegisterBtnMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_checksw[i] = str;
		break;
	case 1:
		m_checksw[i] = str;
		break;
	case 2:
		m_checksw[i] = str;
		break;
	case 3:
		m_checksw[i] = str;
		break;
	case 4:
		m_resbtn = str;
		break;
	}
}

void crCheckRegisterBtnMethod::operator()(crHandle &handle)
{
	crMultiSwitch *checksw[4] = {NULL};
	bool enable = true;
	for (int i = 0; i < 4; i++)
	{
		checksw[i]  = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_checksw[i]));
		if(checksw[i])
		{
			enable &= checksw[i]->getActiveSwitchSet()==(i==0?1:2);
		}
	}
	ref_ptr<crButtonWidgetNode> resbtn  = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_resbtn));
	resbtn->setEnable(enable);
}
/////////////////////////////////////////
//
//crJXJSetRegisterAccountMethod
//
/////////////////////////////////////////
crJXJSetRegisterAccountMethod::crJXJSetRegisterAccountMethod():
	m_this(NULL)
{
}
crJXJSetRegisterAccountMethod::crJXJSetRegisterAccountMethod(const crJXJSetRegisterAccountMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_registeraccount(handle.m_registeraccount),
	m_logincanvas(handle.m_logincanvas),
	m_loginaccount(handle.m_loginaccount)
{
}
void crJXJSetRegisterAccountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJSetRegisterAccountMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_registeraccount = str;
		break;
	case 1:
		m_logincanvas = str;
		break;
	case 2:
		m_loginaccount = str;
		break;
	}
}
void crJXJSetRegisterAccountMethod::operator()(crHandle &handle)
{
	std::string account;
	ref_ptr<crCanvasNode>registercanvas = m_this->getParentCanvas();
	if (registercanvas.valid())
	{
		ref_ptr<crEditWidgetNode> registeraccount = dynamic_cast<crEditWidgetNode *>(registercanvas->getWidget(m_registeraccount));
		if (registeraccount.valid())
		{
			account = registeraccount->getUTF8String();
		}
	}
	ref_ptr<crCanvasNode>logincanvas = crFilterRenderManager::getInstance()->findCanvas(m_logincanvas);
	if (logincanvas.valid())
	{
		ref_ptr<crEditWidgetNode> loginaccount = dynamic_cast<crEditWidgetNode *>(logincanvas->getWidget(m_loginaccount));
		if (loginaccount.valid())
		{
			loginaccount->setString(account);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUpdateFriendDataMethod
//
/////////////////////////////////////////
crJXJRecvUpdateFriendDataMethod::crJXJRecvUpdateFriendDataMethod():
	m_netType(GameClient_Game){}
crJXJRecvUpdateFriendDataMethod::crJXJRecvUpdateFriendDataMethod(const crJXJRecvUpdateFriendDataMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvUpdateFriendDataMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvUpdateFriendDataMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvUpdateFriendDataMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && gsBrainData)
			{
				void *param;
				bool ifonline = false;
				crData *data = m_this->getDataClass();
				if (data)
				{ 
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJShiliID,param);
					unsigned char shiliid = *(unsigned char *)param;

					gsBrainData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
					crJXJShili *shili = (crJXJShili *)param;
					crData * shiliData = shili->getDataClass();

					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					shiliData->excHandle(MAKECREPARAM(WCH_LockData,1));

					data->getParam(WCHDATA_JXJFriendList,param);
					FriendVec *friendVec = (FriendVec *)param;
					if (!friendVec->empty())
					{
						std::list< std::pair<unsigned char,ref_ptr<crFriend> > > DataChangeFriends;
						unsigned char datachange = 0;//0没有改变，1在线 2在线等级，3在线等级icon，4在线等级icon名字，5删除
						ref_ptr<crFriend> changedFriend;
						ref_ptr<crGameServerPlayerData> frienddata;
						shiliData->getParam(WCHDATA_JXJPeopleMap,param);
						PeopleMap *peopleMap = (PeopleMap *)param;
						PeopleMap::iterator pitr;
						for( FriendVec::iterator itr = friendVec->begin();
							itr != friendVec->end();
							)
						{
							if ((*itr)!=NULL)
							{
								datachange = 0;
								pitr = peopleMap->find((*itr)->getPlayerID());
								if(pitr != peopleMap->end())
								{
									frienddata = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData((*itr)->getPlayerID()));
									if(frienddata.valid() && frienddata->getPlayerGameData())
									{
										crData *friendgamedata = frienddata->getPlayerGameData()->getDataClass();
										friendgamedata->getParam(WCHDATA_PlayerIconID,param);
										unsigned char playericonid = *(unsigned char *)param;
										if((*itr)->getIconID() != playericonid)
										{
											datachange = 3;
											(*itr)->setIconID(playericonid);
										}
										else if(!(*itr)->getOnline())
										{
											datachange = 1;
										}
										(*itr)->setOnline(true);
									}
									else
									{
										if((*itr)->getOnline())
										{
											datachange = 1;
										}
										(*itr)->setOnline(false);
									}

									if((*itr)->getLevel() != pitr->second->getLv())
									{
										(*itr)->setLevel(pitr->second->getLv());
										if(datachange != 3)
											datachange = 2;
									}
									if((*itr)->getName() != pitr->second->getName())
									{
										(*itr)->setName(pitr->second->getName());
										datachange = 4;
									}
									if(datachange!=0)
									{
										changedFriend = new crFriend(itr->get());
										DataChangeFriends.push_back(std::make_pair(datachange,changedFriend));
									}
								}
								else
								{
									datachange = 5;
									changedFriend = new crFriend;
									changedFriend->setPlayerID(playerid);
									DataChangeFriends.push_back(std::make_pair(datachange,changedFriend));
									itr = friendVec->erase(itr);
									continue;
								}
							}
							++itr;
						}
						//FriendVec::iterator itr;
						//for( itr = friendVec->begin();
						//	itr != friendVec->end();
						//	++itr )
						//{
						//	if ((*itr)!=NULL)
						//	{
						//		ifonline = false;
						//		int friendid = (*itr)->getPlayerID();
						//		unsigned char lastfriendlv = (*itr)->getLevel();
						//		unsigned char lastfriendiconid = (*itr)->getIconID();
						//		frienddata = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(friendid));
						//		if(frienddata.valid() && frienddata->getPlayerGameData() && frienddata->getPlayerGameData()->getMainRole())
						//		{
						//			ifonline = true;
						//			crData *friendgamedata = frienddata->getPlayerGameData()->getDataClass();
						//			crData *friendroledata = frienddata->getPlayerGameData()->getMainRole()->getDataClass();
						//			if (friendroledata)
						//			{
						//				friendroledata->getParam(WCHDATA_Level,param);
						//				unsigned char friendlv = *(unsigned char *)param;
						//				if (lastfriendlv != friendlv)
						//				{
						//					lastfriendlv = friendlv;
						//					(*itr)->setLevel(friendlv);
						//				}
						//				friendgamedata->getParam(WCHDATA_PlayerIconID,param);
						//				unsigned char playericonid = *(unsigned char *)param;
						//				if (lastfriendiconid != playericonid)
						//				{
						//					lastfriendiconid = playericonid;
						//					(*itr)->setIconID(playericonid);
						//				}
						//			}
						//			else
						//			{
						//				// not online, get level from peopleMap
						//				PeopleMap::iterator pmItr = peopleMap->find(friendid);
						//				if (pmItr != peopleMap->end())
						//				{
						//					(*itr)->setLevel(pmItr->second->getLv());
						//				}
						//			}
						//		}
						//		(*itr)->setOnline(ifonline);
						//	}
						//}
						if(!DataChangeFriends.empty())
						{
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(DataChangeFriends.size() * 28+1);
							stream->_writeUChar(DataChangeFriends.size());
							for( std::list< std::pair<unsigned char,ref_ptr<crFriend> > >::iterator itr = DataChangeFriends.begin();
								itr != DataChangeFriends.end();
								++itr )
							{//0没有改变，1在线 2在线等级，3在线等级icon，4在线等级icon名字，5删除
								stream->_writeUChar(itr->first);
								stream->_writeInt(itr->second->getPlayerID());
								switch (itr->first)
								{
								case 1:
									stream->_writeBool(itr->second->getOnline());
									break;
								case 2:
									stream->_writeBool(itr->second->getOnline());
									stream->_writeUChar(itr->second->getLevel());
									break;
								case 3:
									stream->_writeBool(itr->second->getOnline());
									stream->_writeUChar(itr->second->getLevel());
									stream->_writeUChar(itr->second->getIconID());
									break;
								case 4:
									stream->_writeBool(itr->second->getOnline());
									stream->_writeUChar(itr->second->getLevel());
									stream->_writeUChar(itr->second->getIconID());
									stream->_writeString(itr->second->getName());
									break;
								}
							}
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUpdateFriendData,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
					shiliData->excHandle(MAKECREPARAM(WCH_LockData,0));
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}

		}
		if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			if (data)
			{ 
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJFriendList,param);
				FriendVec *friendVec = (FriendVec *)param;
				FriendVec::iterator itr;
				unsigned char count = m_stream->_readUChar();
				unsigned char datachange = 0;
				int playerid;
				bool online;
				unsigned char lv;
				unsigned char icon;
				std::string name;
				for( int i = 0; i<count; i++)
				{
					datachange = m_stream->_readUChar();
					playerid = m_stream->_readInt();
					switch (datachange)
					{
					case 1:
						online = m_stream->_readBool();
						break;
					case 2:
						online = m_stream->_readBool();
						lv = m_stream->_readUChar();
						break;
					case 3:
						online = m_stream->_readBool();
						lv = m_stream->_readUChar();
						icon = m_stream->_readUChar();
						break;
					case 4:
						online = m_stream->_readBool();
						lv = m_stream->_readUChar();
						icon = m_stream->_readUChar();
						name = m_stream->_readString();
						break;
					}

					for( itr = friendVec->begin();
						itr != friendVec->end();
						++itr )
					{
						if ((*itr)!=NULL && (*itr)->getPlayerID() == playerid)
						{
							switch (datachange)
							{
							case 1:
								(*itr)->setOnline(online);
								break;
							case 2:
								(*itr)->setOnline(online);
								(*itr)->setLevel(lv);
								break;
							case 3:
								(*itr)->setOnline(online);
								(*itr)->setLevel(lv);
								(*itr)->setIconID(icon);
								break;
							case 4:
								(*itr)->setOnline(online);
								(*itr)->setLevel(lv);
								(*itr)->setIconID(icon);
								(*itr)->setName(name);
								break;
							case 5:
								friendVec->erase(itr);
								break;
							}
							break;
						}
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}

		}
	}
}
/////////////////////////////////////////
//
//crJXJShowCityMimiMenuMethod
//
/////////////////////////////////////////
crJXJShowCityMimiMenuMethod::crJXJShowCityMimiMenuMethod():
	m_this(NULL)
{
}
crJXJShowCityMimiMenuMethod::crJXJShowCityMimiMenuMethod(const crJXJShowCityMimiMenuMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_citymenu(handle.m_citymenu),
	m_citylistcanvas(handle.m_citylistcanvas),
	m_entercanvas(handle.m_entercanvas),
	m_nameinput(handle.m_nameinput)
{
}
void crJXJShowCityMimiMenuMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJShowCityMimiMenuMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_citymenu = str;
		break;
	case 1:
		m_citylistcanvas = str;
		break;
	case 2:
		m_entercanvas = str;
		break;
	case 3:
		m_nameinput = str;
		break;
	case 4:
		m_strPingPan = str;
		break;
	case 5:
		m_strEnter = str;
		break;
	}
}
void crJXJShowCityMimiMenuMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if (!myPlayer)
	{
		return;
	}
	crData *data = myPlayer->getDataClass();
	ref_ptr<crTableIO>chengchitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	ref_ptr<crCanvasNode>citymenu = crFilterRenderManager::getInstance()->findCanvas(m_citymenu);
	ref_ptr<crCanvasNode>citylistcanvas = crFilterRenderManager::getInstance()->findCanvas(m_citylistcanvas);
	ref_ptr<crCanvasNode>entercanvas = crFilterRenderManager::getInstance()->findCanvas(m_entercanvas);
	if (citymenu.valid() && m_this && chengchitab.valid() && citylistcanvas.valid() && entercanvas.valid())
	{
		void *param;
		unsigned short chengchiid = 0;
		ref_ptr<crButtonWidgetNode> rebelButton = dynamic_cast<crButtonWidgetNode *>(citymenu->getWidget(m_strPingPan));
		ref_ptr<crButtonWidgetNode> enterButton = dynamic_cast<crButtonWidgetNode *>(citymenu->getWidget(m_strEnter));
		if(rebelButton.valid()) rebelButton->setVisiable(false);//rebelButton->setEnable(false);
		crData *listdata = citylistcanvas->getDataClass();
		if (listdata)
		{
			bool canenter = false;
			
			listdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			listdata->getParam(WCHDATA_JXJBattleCitiesSet, param);
			std::set<unsigned short> *battlecityset = ((std::set<unsigned short> *)param);
			listdata->getParam(WCHDATA_JXJMyBattleCitiesSet, param);
			std::set<unsigned short> *my_cities = ((std::set<unsigned short> *)param);
			listdata->getParam(WCHDATA_JXJCityInBattleSet, param);
			std::set<unsigned short> *cityinbattleset = ((std::set<unsigned short> *)param);
			crTableIO::StrVec record;
			int buttonnameindex = chengchitab->getTitleIndex("buttonname");
			int citynameindex = chengchitab->getTitleIndex("名字");
			if (buttonnameindex >= 0)
			{
				std::string btName = m_this->getName();
				if(chengchitab->queryOneRecord(buttonnameindex,btName,record) >= 0 )
				{
					ref_ptr<crStaticTextWidgetNode> nameinput = dynamic_cast<crStaticTextWidgetNode *>(entercanvas -> getWidget(m_nameinput));
					if (nameinput.valid())
					{
						nameinput->setString(record[citynameindex]);
					}
					chengchiid = atoi(record[0].c_str());
					//crData *menudata = citymenu->getDataClass();
					//if (menudata)
					//{
					//	menudata->inputParam(WCHDATA_JXJCityMenuChengchiid,&chengchiid);
					//}
					if (chengchiid > 0)
					{
						std::set<unsigned short>::iterator itr = battlecityset->find(chengchiid);
						if (itr!=battlecityset->end())
						{
							canenter = true;
						}
						else
						{
							std::set<unsigned short>::iterator itr2 = my_cities->find(chengchiid);
							std::set<unsigned short>::iterator itr3 = cityinbattleset->find(chengchiid);
							if (itr2!=my_cities->end() && itr3!=cityinbattleset->end())
							{
								canenter= true;
							}
						}
						if (canenter)
						{
							//data->inputParam(WCHDATA_JXJBattleChengchiID,&chengchiid);
							unsigned char type = FT_Chengchi;
							data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
							data->inputParam(WCHDATA_JXJFubenOrChengchiID,&chengchiid);
							crVector3 centerCoord = m_this->getBound().center();
							crMatrix mat = m_this->getParentCanvas()->getMatrix();
							citymenu->setPosition(centerCoord * mat);
							///////JXJUIAttachUpdate
							ref_ptr<crData> data = citymenu->getDataClass();
							if(!data.valid())
							{
								data = crDataManager::getInstance()->getData("UI");
								ref_ptr<crHandle> driver = crHandleManager::getInstance()->getHandle("OneSlot");
								ref_ptr<crHandle> method = crHandleManager::getInstance()->getHandle("JXJUIAttachUpdate");
								crVector3 offset;
								method->inputParam(3,m_this);
								driver->inputHandle(0,method.get());
								data->insertHandle(WCH_UI_Frame,driver.get());
								citymenu->setDataClass(data.get());
							}
							else
							{
								data = citymenu->getDataClass();
								ref_ptr<crHandle> method = data->getHandle(WCH_UI_Frame);
								method->inputParam(3,m_this);
							}
							if(enterButton.valid()) enterButton->setEnable(true);
							////////
							//if (!citymenu->getVisiable())
							//{
								crFilterRenderManager::getInstance()->showCanvas(citymenu.get(),true);
							//}
						}
						else
						{
							if (citymenu->getVisiable())
							{
								citymenu->setVisiable(false);
							}
						}
					}
				}
			}
			listdata->excHandle(MAKECREPARAM(WCH_LockData,0));
		}

		ref_ptr<crCanvasNode>parentCanvas = m_this->getParentCanvas();
		crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		if(playerGameData && parentCanvas.valid())
		{
			crData *playerData = playerGameData->getDataClass();
			crData *canvasData = parentCanvas->getDataClass();
			if(canvasData && playerData)
			{
				playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
				playerData->getParam(WCHDATA_JXJRebelCityVec,param);
				RebelCityVec *rebelCityIdVec = (RebelCityVec *)param;
				RebelCityVec::iterator itr_cityid = rebelCityIdVec->begin();
				for (;itr_cityid!=rebelCityIdVec->end();itr_cityid++)
				{
					if(chengchiid > 0 && chengchiid == *itr_cityid)
					{
						crVector3 centerCoord = m_this->getBound().center();
						crMatrix mat = m_this->getParentCanvas()->getMatrix();
						citymenu->setPosition(centerCoord * mat);

						ref_ptr<crData> data = citymenu->getDataClass();
						if(!data.valid())
						{
							data = crDataManager::getInstance()->getData("UI");
							ref_ptr<crHandle> driver = crHandleManager::getInstance()->getHandle("OneSlot");
							ref_ptr<crHandle> method = crHandleManager::getInstance()->getHandle("JXJUIAttachUpdate");
							crVector3 offset;
							method->inputParam(3,m_this);
							driver->inputHandle(0,method.get());
							data->insertHandle(WCH_UI_Frame,driver.get());
							citymenu->setDataClass(data.get());
						}
						else
						{
							data = citymenu->getDataClass();
							ref_ptr<crHandle> method = data->getHandle(WCH_UI_Frame);
							method->inputParam(3,m_this);
						}

						if(rebelButton.valid())
							rebelButton->setVisiable(false);
							//rebelButton->setEnable(true);
						if(enterButton.valid()) enterButton->setEnable(false);
						canvasData->inputParam(WCHDATA_JXJChooseRebelCityID,&chengchiid);

						crFilterRenderManager::getInstance()->showCanvas(citymenu.get(),true);
						break;
					}
				}
				playerData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJBattleRadioAddCityNameMethod
//
/////////////////////////////////////////
crJXJBattleRadioAddCityNameMethod::crJXJBattleRadioAddCityNameMethod():
	m_this(NULL),
	m_scale(1024.0f,1024.0f,1.0f)
{
}
crJXJBattleRadioAddCityNameMethod::crJXJBattleRadioAddCityNameMethod(const crJXJBattleRadioAddCityNameMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_cityradio(handle.m_cityradio),
	m_colormaskgroup(handle.m_colormaskgroup),
	m_scale(handle.m_scale)
{
}
void crJXJBattleRadioAddCityNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJBattleRadioAddCityNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cityradio = str;
		break;
	case 1:
		m_colormaskgroup = str;
		break;
	case 2:
		crArgumentParser::appAtoVec(str.c_str(),m_scale);
		break;
	}
}
void crJXJBattleRadioAddCityNameMethod::operator()(crHandle &handle)
{
	ref_ptr<crTableIO>chengchitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	if (m_this && chengchitab.valid())
	{
		ref_ptr<crRadioGroupWidgetNode> radiogroup = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_cityradio));
		ref_ptr<crStaticTextWidgetNode> nameinput = NULL;
		ref_ptr<crNode> colormaskgroup = m_this->getChildNode(m_colormaskgroup);
		if(colormaskgroup.valid())
		{
			crStateSet *stateset = colormaskgroup->getOrCreateStateSet();										
			crTexMat *tm = new crTexMat;
			stateset->setTextureAttribute(0, tm);
			tm->setMatrix(crMatrix::scale(m_scale));
		}
		if (radiogroup.valid())
		{
			radiogroup->clear();
			std::string buttonname;
			std::string cityname;
			int buttonnameindex = chengchitab->getTitleIndex("buttonname");
			int citynameindex = chengchitab->getTitleIndex("cityname");//test
			if (buttonnameindex >= 0)
			{
				for (int i = 0; i<chengchitab->getRowCount(); i++)
				{
					buttonname = chengchitab->getData(i,buttonnameindex);
					if (buttonname.length()>0)
					{
						radiogroup->addRadioName(buttonname);
					}
					cityname = chengchitab->getData(i,citynameindex);
					nameinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(cityname));
					if (nameinput.valid())
					{
						nameinput -> setColor(crVector4(1.0f,1.0f,0.0f,1.0f));
					}
				}
			}
			int a = 0;
		}
	}
}
/////////////////////////////////////////
//
//crJXJGameShowFormationInfoMethod
//
/////////////////////////////////////////
crJXJGameShowFormationInfoMethod::crJXJGameShowFormationInfoMethod():
	m_this(NULL)
{
}
crJXJGameShowFormationInfoMethod::crJXJGameShowFormationInfoMethod(const crJXJGameShowFormationInfoMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_formationsw(handle.m_formationsw)
{
	for (int i = 0; i <3; i++)
	{
		m_icon[i] = handle.m_icon[i];
		m_input[i] = handle.m_input[i];
		m_progress[i] = handle.m_progress[i];
	}
}
void crJXJGameShowFormationInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJGameShowFormationInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_formationsw = str;
		break;
	case 1:
		m_icon[0] = str;
		break;
	case 2:
		m_icon[1] = str;
		break;
	case 3:
		m_icon[2] = str;
		break;
	case 4:
		m_input[0] = str;
		break;
	case 5:
		m_input[1] = str;
		break;
	case 6:
		m_input[2] = str;
		break;
	case 7:
		m_progress[0] = str;
		break;
	case 8:
		m_progress[1] = str;
		break;
	case 9:
		m_progress[2] = str;
		break;
	}
}
void crJXJGameShowFormationInfoMethod::operator()(crHandle &handle)
{
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crTableIO>troopstab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTroopsTab);
	if(!player || !m_this ||!troopstab) return;
	void *param;
	crData *data = player->getDataClass();
	if(!data) return;

	data->excHandle(MAKECREPARAM(WCH_LockData,1));
	data->getParam(WCHDATA_JXJFormationInfoVec,param);
	FormationInfoVec *formationvec = (FormationInfoVec *)param;
	int size = formationvec->size();
	int armycount = 0;
	if (size>0)
	{
		crMultiSwitch *formationsw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_formationsw));
		crTableIO::StrVec record;
		int iconindex = troopstab->getTitleIndex("icon");
		crImageBoxWidgetNode *icon[3];
		crStaticTextWidgetNode *input[3];
		crProgressWidgetNode *progress[3];
		for (int i = 0 ;i < 3;i++)
		{
			icon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_icon[i]));
			input[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_input[i]));
			progress[i] = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_progress[i]));
			if (icon[i])
			{
				icon[i]->setVisiable(false);
				input[i]->setVisiable(false);
				progress[i]->setVisiable(false);
			}
		}
		for (int i = 0; i < size; i++)
		{
			if ((*formationvec)[i]!=NULL)
			{
				if ((*formationvec)[i]->getAbstractID() > 0)
				{
					armycount++;
					if(troopstab->queryOneRecord(0,crArgumentParser::appItoa((*formationvec)[i]->getAbstractID()),record) >= 0 )
					{
						if (icon[i])
						{
							icon[i]->setVisiable(true);
							icon[i]->setImageName(record[iconindex]);
						}
						if (input[i])
						{
							input[i]->setVisiable(true);
							input[i]->setString(crArgumentParser::appItoa((*formationvec)[i]->getCount()));
						}
						if (progress[i])
						{
							progress[i]->setVisiable(true);
							progress[i]->setProgress(1.0f);
						}
					}
				}
			}
		}
		if (formationsw && armycount > 0)
		{
			formationsw->setActiveSwitchSet(2);
		}
	}
	else
	{
		crFilterRenderManager::getInstance()->closeCanvas(m_this);
	}
	data->excHandle(MAKECREPARAM(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJBattleListCtrlScrollMethod
//
/////////////////////////////////////////
crJXJBattleListCtrlScrollMethod::crJXJBattleListCtrlScrollMethod():
	m_ea(NULL),
	m_this(NULL)
{}
crJXJBattleListCtrlScrollMethod::crJXJBattleListCtrlScrollMethod(const crJXJBattleListCtrlScrollMethod& handle):
	crMethod(handle),
	m_listcontrol1(handle.m_listcontrol1),
	m_listcontrol2(handle.m_listcontrol2),
	m_type(handle.m_type),
	m_ea(NULL),
	m_this(NULL)
{
}
void crJXJBattleListCtrlScrollMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJBattleListCtrlScrollMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_listcontrol1 = str;
		break;
	case 1:
		m_listcontrol2 = str;
		break;
	case 2:
		m_type = atoi(str.c_str());
		break;
	}
}
void crJXJBattleListCtrlScrollMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crScrollBarWidgetNode> vScollbar1 = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_listcontrol1));
		ref_ptr<crScrollBarWidgetNode> vScollbar2 = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_listcontrol2));
		crVector3 centerCoord = m_this->getBound().center();
		crMatrix mat = m_this->getMatrix();
		centerCoord = centerCoord * mat;
		if ( m_ea->getYnormalized() > centerCoord[1])
		{
			if (vScollbar1.valid())
			{
				if (!m_type)
				{
					vScollbar1->setValue(vScollbar1->getValue() - vScollbar1->getLineValue());
				}
				else
				{
					vScollbar1->setValue(vScollbar1->getValue() + vScollbar1->getLineValue());
				}
			}
		}
		else
		{
			if (vScollbar2.valid())
			{
				if (!m_type)
				{
					vScollbar2->setValue(vScollbar2->getValue() - vScollbar2->getLineValue());
				}
				else
				{
					vScollbar2->setValue(vScollbar2->getValue() + vScollbar2->getLineValue());
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJChangeChatTextSizeMethod
//
/////////////////////////////////////////
crJXJChangeChatTextSizeMethod::crJXJChangeChatTextSizeMethod():
	m_this(NULL),
	m_index(0),
	m_nowsize(1)
{
}
crJXJChangeChatTextSizeMethod::crJXJChangeChatTextSizeMethod(const crJXJChangeChatTextSizeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_unfoldbtn(handle.m_unfoldbtn),
	m_packupbtn(handle.m_packupbtn),
	m_sizesw(handle.m_sizesw),
	m_index(handle.m_index),
	m_nowsize(handle.m_nowsize)
{
}
void crJXJChangeChatTextSizeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJChangeChatTextSizeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_unfoldbtn = str;
		break;
	case 1:
		m_packupbtn = str;
		break;
	case 2:
		m_sizesw = str;
		break;
	case 3:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJChangeChatTextSizeMethod::operator()(crHandle &handle)
{
	//crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	//if (!myPlayer)
	//{
	//	return;
	//}
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (!canvas)
	{
		return;
	}
	ref_ptr<crButtonWidgetNode> unfoldbtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_unfoldbtn));
	ref_ptr<crButtonWidgetNode> packupbtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_packupbtn));
	crMultiSwitch *sizesw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_sizesw));
	if (m_index == 0)
	{
		if (sizesw)
		{
			sizesw->setActiveSwitchSet(m_index);
		}
		if (unfoldbtn.valid())
		{
			unfoldbtn->setVisiable(true);
		}
		if (packupbtn.valid())
		{
			packupbtn->setVisiable(false);
		}
	}
	else
	{
		if (m_nowsize == 0)
		{
			if (sizesw)
			{
				sizesw->setActiveSwitchSet(1);
			}
			m_nowsize = 1;
		}
		else
		{
			if (sizesw)
			{
				sizesw->setActiveSwitchSet(2);
			}
			if (unfoldbtn.valid())
			{
				unfoldbtn->setVisiable(false);
			}
			if (packupbtn.valid())
			{
				packupbtn->setVisiable(true);
			}
			m_nowsize = 0;
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckPlayerGameNameNULLMethod
//
/////////////////////////////////////////
crJXJCheckPlayerGameNameNULLMethod::crJXJCheckPlayerGameNameNULLMethod():
	m_this(NULL)
{
}
crJXJCheckPlayerGameNameNULLMethod::crJXJCheckPlayerGameNameNULLMethod(const crJXJCheckPlayerGameNameNULLMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_nameinput(handle.m_nameinput)
{

}
void crJXJCheckPlayerGameNameNULLMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJCheckPlayerGameNameNULLMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_nameinput = str;
		break;
	}
}
void crJXJCheckPlayerGameNameNULLMethod::operator()(crHandle &handle)
{
	bool cancelTask = false;
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (!canvas)
	{
		return;
	}

	ref_ptr<crEditWidgetNode> nameinput = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_nameinput));
	if (!nameinput)
	{
		return;
	}
	std::string name = crArgumentParser::trim(const_cast<char *>(nameinput->getUTF8String().c_str()));
	if(name.empty())
	{
		nameinput->setColor(crVector4f(1.0f,0.0f,0.0f,1.0f));
		nameinput->setString(std::string("名称不能为空"));
		cancelTask = true;
	}
	else if(name.length()>12)
	{
		nameinput->setColor(crVector4f(1.0f,0.0f,0.0f,1.0f));
		nameinput->setString(std::string("名称不能超过12个字符"));
		cancelTask = true;
	}
	else if(name.find_first_of("\'\"") != std::string::npos)
	{
		nameinput->setColor(crVector4f(1.0f,0.0f,0.0f,1.0f));
		nameinput->setString(std::string("请勿使用符号、空格等非法字符"));
		cancelTask = true;
	}
	else
	{
		ref_ptr<crTableIO> InvalidNameTab;
		InvalidNameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJNameLimitTab);
		if (InvalidNameTab.valid())
		{
			std::wstring wtext = CRIOManager::convertUTF8toUTF16(name.c_str());
			std::wstring invalidstring;
			int ipos = 0;
			int invalidwordsize;
			for (int i = 0; i < InvalidNameTab->getRowCount();i++)
			{
				invalidstring = CRIOManager::convertUTF8toUTF16(InvalidNameTab->getData(i,0).c_str());
				invalidwordsize = invalidstring.length();
				if (invalidwordsize <=  wtext.length())
				{
					ipos = wtext.find(invalidstring);
					if(ipos != std::string::npos)
					{
						nameinput->setColor(crVector4f(1.0f,0.0f,0.0f,1.0f));
						nameinput->setString(std::string("请勿使用符号、空格等非法字符"));
						cancelTask = true;
						break;
					}
				}
			}
		}
		if(!cancelTask)
		{
			InvalidNameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInvalidWordTab);
			if (InvalidNameTab.valid())
			{
				std::string invalidstring;
				for (int i = 0; i < InvalidNameTab->getRowCount();i++)
				{
					invalidstring = InvalidNameTab->getData(i,0);
					if(invalidstring.size() > 0 && name.find(invalidstring) != std::string::npos)
					{
						nameinput->setColor(crVector4f(1.0f,0.0f,0.0f,1.0f));
						nameinput->setString(std::string("不能含敏感词"));
						cancelTask = true;
						break;
					}
				}
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJDeductLijinGoldMethod
//
/////////////////////////////////////////
crJXJDeductLijinGoldMethod::crJXJDeductLijinGoldMethod():
	m_this(NULL),
	m_output(false)
{
}

crJXJDeductLijinGoldMethod::crJXJDeductLijinGoldMethod(const crJXJDeductLijinGoldMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_output(false)
{
}

void crJXJDeductLijinGoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_moneydata = (MoneyChangeData *)(LOCREPARAM(param64));
			m_output = (bool *)(HICREPARAM(param64));
		}
		else
		{
			m_moneydata = NULL;
		}
		break;
	}
}

void crJXJDeductLijinGoldMethod::addParam(int i, const std::string& str)
{
}

void crJXJDeductLijinGoldMethod::operator()(crHandle &handle)
{
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	int playerid = m_this->getPlayerID();
	ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
	bool success = false;
	int needdeduct = m_moneydata->first;
	int needdeductgold = 0;
	int deductgiftgold = 0;
	bool goldsuccess = false;
	*m_output = false;
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		if (needdeduct == 0)
		{
			success = true;
		}
		else if (needdeduct < 0)
		{//m_moneydata->first<0表示只扣除元宝
			needdeductgold = needdeduct;
			MoneyChangeData moneyChangeData(needdeductgold,m_moneydata->second);
			m_this->doEvent(WCH_MoneyChange,MAKECREPARAM(&moneyChangeData,&goldsuccess));
			if (goldsuccess)
			{
				success = true;
				*m_output = true;
				char buf[128];
				sprintf(buf,"%s,礼金,%d,元宝,%d\0",m_moneydata->second.c_str(),0,needdeductgold);
				GameLogData gamelog(Log_Money,buf);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				if (m_this->getMainRole())
				{
					crData *data = m_this->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData, 1));
					m_this->getMainRole()->doEvent(WCH_JXJDeductHuodongUpdate, MAKECREPARAM(MAKEINT32(needdeductgold, needdeductgold), NULL));
					data->excHandle(MAKECREPARAM(WCH_LockData, 0));
				}
			}
		}
		else if(needdeduct>0)
		{	
			// 0：扣除成功
			//-1：扣除失败
			crData *data = m_this->getDataClass();
			if(data)
			{
				void *param;
				/*ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));*/
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJGiftGold,param);
				int giftgold = *(int *)param;
				//data->getParam(WCHDATA_JXJGoldingot,param);
				//int *mygold = (int *)param;
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				int goldToVipExpFactor1 = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGiftGoldToVipExpFactor,viplv).c_str());
				//礼金充足
				if (giftgold >= needdeduct)
				{
					deductgiftgold = -needdeduct;
					giftgold -= needdeduct;
					success = true;
					needdeductgold = 0;
					//消耗礼金增加成长值
					//m_this->doEvent(WCH_JXJAddVipExp,MAKECREPARAM(needdeduct * goldToVipExpFactor1,NULL));
				}
				//礼金不足 扣除元宝
				else
				{
					needdeductgold = -(needdeduct - giftgold);
					MoneyChangeData moneyChangeData(needdeductgold,m_moneydata->second);
					m_this->doEvent(WCH_MoneyChange,MAKECREPARAM(&moneyChangeData,&goldsuccess));
					if(goldsuccess)
					{
						success = true;
						*m_output = true;
						//消耗礼金增加成长值
						//m_this->doEvent(WCH_JXJAddVipExp,MAKECREPARAM((giftgold) * goldToVipExpFactor,NULL));
						//消耗元宝增加成长值
						//int goldToVipExpFactor2 = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGoldToVipExpFactor,viplv).c_str());
						//int vipexp = (giftgold) * goldToVipExpFactor1 + (needdeduct - giftgold) * goldToVipExpFactor2;
						//m_this->doEvent(WCH_JXJAddVipExp,MAKECREPARAM(vipexp,NULL));
						////////////////////////////////
						deductgiftgold = -giftgold;
						giftgold = 0;
					}
				}
				data->inputParam(WCHDATA_JXJGiftGold , &giftgold);

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(giftgold);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvDeductLijinGold,stream.get());
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				if (playerData.valid())
				{
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
			if(success)
			{
				char buf[128];
				sprintf(buf,"%s,礼金,%d,元宝,%d\0",m_moneydata->second.c_str(),deductgiftgold,needdeductgold);//-(m_moneydata->first+needdeductgold)
				GameLogData gamelog(Log_Money,buf);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				if(deductgiftgold!=0)
				{
					//记录数据库
					crNetDataManager *netDataManager = gameServer->getNetDataManager();
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(netDataManager->getNetCallback());
					int serverid = callback->getServerID();
					crDBSavePacket dbpacket;
					ref_ptr<crInsertPlayerGiftGold> insertPlayergiftgold = new crInsertPlayerGiftGold;
					insertPlayergiftgold->buildUpdateSql(playerid,serverid,deductgiftgold,m_moneydata->second,m_this->getAdvertid());
					crDBSavePacket::buildRequestPacket(dbpacket,GameGlobalDB,insertPlayergiftgold.get());
					dbConductor->getNetManager()->sendPacket("all",dbpacket);
					//crDataBase *db = crDataBaseManager::getInstance()->getGlobalDB();
					//ref_ptr<crDataBase> globalSession = db->beginSession();
					//ref_ptr<crInsertPlayerGiftGold> insertPlayergiftgold = new crInsertPlayerGiftGold;
					//insertPlayergiftgold->buildUpdateSql(playerid,serverid,deductgiftgold,m_moneydata->second);
					//if(globalSession->executeUpdate(insertPlayergiftgold.get()))
					//{//插入成功
					//	globalSession->commit();
					//}
					//else
					//{
					//	globalSession->rollback();
					//}
					//db->endSession(globalSession.get());
				}
				if(m_this->getMainRole())
				{
					crData *data = m_this->getDataClass();
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					m_this->getMainRole()->doEvent(WCH_JXJDeductHuodongUpdate, MAKECREPARAM(MAKEINT32(deductgiftgold + needdeductgold, needdeductgold), NULL));
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}
		}
	}
	if (success)
	{
		m_moneydata->first = 0;
	}
	else
	{
		m_moneydata->first = -1;
	}
}
/////////////////////////////////////////
//
//crJXJCheckLijinGoldMethod
//
/////////////////////////////////////////
crJXJCheckLijinGoldMethod::crJXJCheckLijinGoldMethod():
	m_this(NULL),
	m_needdeduct(0)
{
}

crJXJCheckLijinGoldMethod::crJXJCheckLijinGoldMethod(const crJXJCheckLijinGoldMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_needdeduct(0)
{
}

void crJXJCheckLijinGoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_needdeduct = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_needdeduct = (int *)(LOCREPARAM(param64));
		}
		else
		{
			m_needdeduct = NULL;
		}
		break;
	}
}

void crJXJCheckLijinGoldMethod::addParam(int i, const std::string& str)
{
}

void crJXJCheckLijinGoldMethod::operator()(crHandle &handle)
{
	bool success = false;
	if (m_needdeduct <= 0)
	{
		success = true;
	}
	if(m_this && m_needdeduct>0)
	{	
		// 0：检测成功
		//-1：检测失败
		crData *data = m_this->getDataClass();
		if(data)
		{
			void *param;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJGiftGold,param);
			int giftgold = *(int *)param;
			data->getParam(WCHDATA_JXJGoldingot,param);
			int mygold = *(int *)param; 
			//检测礼金
			if (giftgold >= *m_needdeduct)
			{
				giftgold -= *m_needdeduct;
				success = true;
			}
			//检测元宝
			else
			{
				if (giftgold + mygold >= *m_needdeduct)
				{
					success = true;
					giftgold = 0;
					mygold -= (*m_needdeduct - giftgold);
				}
			}
		}
	}
	if (success)
	{
		*m_needdeduct = 0;
	}
	else
	{
		*m_needdeduct = -1;
	}
}
/////////////////////////////////////////
//
//crJXJRecvDeductLijinGoldMethod
//
/////////////////////////////////////////
crJXJRecvDeductLijinGoldMethod::crJXJRecvDeductLijinGoldMethod():
	m_netType(GameClient_Game){}
crJXJRecvDeductLijinGoldMethod::crJXJRecvDeductLijinGoldMethod(const crJXJRecvDeductLijinGoldMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvDeductLijinGoldMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvDeductLijinGoldMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvDeductLijinGoldMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameClient_Game)
		{
			int curgiftgold = m_stream->_readInt();
			int extragold = 0;
			crData *data = m_this->getDataClass();
			if (data)
			{
				data->getParam(WCHDATA_JXJGiftGold,param);
				int lastGold = *(int *)param;
				data->inputParam(WCHDATA_JXJGiftGold,&curgiftgold);
				extragold = curgiftgold-lastGold;
			}
			if (extragold!=0)
			{
				crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Giftgold,extragold));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJOnBattleUIMethod
//
/////////////////////////////////////////
crJXJOnBattleUIMethod::crJXJOnBattleUIMethod()
{
}
crJXJOnBattleUIMethod::crJXJOnBattleUIMethod(const crJXJOnBattleUIMethod& handle):
	crMethod(handle)
{
}
void crJXJOnBattleUIMethod::inputParam(int i, void *param)
{
}
void crJXJOnBattleUIMethod::addParam(int i, const std::string& str)
{
}
void crJXJOnBattleUIMethod::operator()(crHandle &handle)
{	
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if (netConductor)
	{
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOnBattleUI,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvOnBattleUIMethod
//
/////////////////////////////////////////
crJXJRecvOnBattleUIMethod::crJXJRecvOnBattleUIMethod():
	m_netType(GameClient_Game){}
crJXJRecvOnBattleUIMethod::crJXJRecvOnBattleUIMethod(const crJXJRecvOnBattleUIMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvOnBattleUIMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvOnBattleUIMethod::addParam(int i, const std::string& str)
{
	//switch (i)
	//{
	//case 0:
	//	m_battlecanvas = str;
	//	break;
	//default:
	//	break;
	//}
}

void crJXJRecvOnBattleUIMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				void *param;
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				//发送战场信息
				//gsBrainData->getParam(WCHDATA_JXJOpenBattle,param);
				//bool openBattle = *(bool *)param;
				//gsBrainData->getParam(WCHDATA_JXJOpenPass,param);
				//bool openPass = *(bool *)param;
				//if(openBattle/* || openPass*/)
				{
					std::set<unsigned short> OnBattleCitySet;
					gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
					OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
					for( OpenBattleMap::iterator itr = openBattleMap->begin();
						itr != openBattleMap->end();
						++itr )
					{
						OnBattleCitySet.insert(HIINT32(itr->first));
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(OnBattleCitySet.size() * 2 + 1);
					stream->_writeUChar(OnBattleCitySet.size());
					for(std::set<unsigned short>::iterator itr = OnBattleCitySet.begin(); itr!=OnBattleCitySet.end();++itr)
					{
						stream->_writeUShort((*itr));
					}
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCityInBattleInfo,stream.get());
					netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

					//加入到查询队列
					gsBrainData->getParam(WCHDATA_JXJOnBattleUIPlayerSet,param);
					OnBattleUIPlayerSet *onBattleUIPlayerSet = (OnBattleUIPlayerSet *)param;
					onBattleUIPlayerSet->insert(playerid);
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		//else if(m_netType == GameClient_Game)
		//{
		//	unsigned char battlecitynum = m_stream->_readUChar();
		//	ref_ptr<crCanvasNode>battlecanvas = crFilterRenderManager::getInstance()->findCanvas(m_battlecanvas);
		//	if (battlecanvas)
		//	{
		//		void *param;
		//		crData *data = battlecanvas->getDataClass();
		//		if (data)
		//		{
		//			data->excHandle(MAKECREPARAM(WCH_LockData,1));
		//			data->getParam(WCHDATA_JXJCityInBattleSet,param);
		//			std::set<unsigned short> *m_cityinbattle = (std::set<unsigned short> *)param;
		//			m_cityinbattle->clear();
		//			for (int i = 0; i<battlecitynum;i++)
		//			{
		//				m_cityinbattle->insert(m_stream->_readUShort());
		//			}
		//			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		//		}
		//	}
		//}
	}
}
/////////////////////////////////////////
//
//crJXJCityInBattleInfoSendDisposeMethod
//
/////////////////////////////////////////
crJXJCityInBattleInfoSendDisposeMethod::crJXJCityInBattleInfoSendDisposeMethod():
	m_this(NULL){}
crJXJCityInBattleInfoSendDisposeMethod::crJXJCityInBattleInfoSendDisposeMethod(const crJXJCityInBattleInfoSendDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJCityInBattleInfoSendDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJCityInBattleInfoSendDisposeMethod::addParam(int i, const std::string& str)
{
}

void crJXJCityInBattleInfoSendDisposeMethod::operator()(crHandle &handle)
{
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKECREPARAM(WCH_LockData,1));
	data->getParam(WCHDATA_JXJOnBattleUIPlayerSet,param);
	OnBattleUIPlayerSet *onBattleUIPlayerSet = (OnBattleUIPlayerSet *)param;
	if(!onBattleUIPlayerSet->empty())
	{
		//data->getParam(WCHDATA_JXJOpenBattle,param);
		//bool openBattle = *(bool *)param;
		//data->getParam(WCHDATA_JXJOpenPass,param);
		//bool openPass = *(bool *)param;
		//if(openBattle/*|| openPass*/)
		{
			std::set<unsigned short> OnBattleCitySet;
			data->getParam(WCHDATA_JXJOpenBattleMap,param);
			OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
			for( OpenBattleMap::iterator itr = openBattleMap->begin();
				 itr != openBattleMap->end();
				 ++itr )
			{
				OnBattleCitySet.insert(HIINT32(itr->first));
			}
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(OnBattleCitySet.size() * 2 + 1);
			stream->_writeUChar(OnBattleCitySet.size());
			for(std::set<unsigned short>::iterator itr = OnBattleCitySet.begin(); itr!=OnBattleCitySet.end();++itr)
			{
				stream->_writeUShort((*itr));
			}
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,0,WCH_JXJRecvCityInBattleInfo,stream.get());
			ref_ptr<crStreamBuf> packetStream = packet.getStreamBuf();
			int bufsize = packetStream->getBufSize();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			for( OnBattleUIPlayerSet::iterator itr = onBattleUIPlayerSet->begin();
				 itr != onBattleUIPlayerSet->end(); )
			{
				playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*itr));
				if(playerData.valid() && playerData->getSceneID()==0)
				{
					packetStream->seekBegin();
					packetStream->_writeInt(*itr);
					packetStream->setBufSize(bufsize);
					netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					++itr;
				}
				else
				{
					itr = onBattleUIPlayerSet->erase(itr);
				}
			}
		}
	}
	data->excHandle(MAKECREPARAM(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRecvCityInBattleInfoMethod
//
/////////////////////////////////////////
crJXJRecvCityInBattleInfoMethod::crJXJRecvCityInBattleInfoMethod():
	m_netType(GameClient_Game){}
crJXJRecvCityInBattleInfoMethod::crJXJRecvCityInBattleInfoMethod(const crJXJRecvCityInBattleInfoMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCityInBattleInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCityInBattleInfoMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_battlecanvas = str;
		break;
	}
}

void crJXJRecvCityInBattleInfoMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			bool canceltask = true;
			unsigned char battlecitynum = m_stream->_readUChar();
			crCanvasNode* battlecanvas = crFilterRenderManager::getInstance()->findCanvas(m_battlecanvas);
			if (battlecanvas)
			{
				void *param;
				crData *data = battlecanvas->getDataClass();
				if (data)
				{
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJCityInBattleSet,param);
					std::set<unsigned short> *cityinbattle = (std::set<unsigned short> *)param;
					std::set<unsigned short> newcityinbattle;
					for (int i = 0; i<battlecitynum;i++)
					{
						newcityinbattle.insert(m_stream->_readUShort());
					}
					if(*cityinbattle != newcityinbattle)
					{
						cityinbattle->swap(newcityinbattle);
						canceltask = false;
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}
			handle.outputParam(0,&canceltask);
		}
	}
}
/////////////////////////////////////////
//
//crJXJLeaveBattleUIMethod
//
/////////////////////////////////////////
crJXJLeaveBattleUIMethod::crJXJLeaveBattleUIMethod()
{
}
crJXJLeaveBattleUIMethod::crJXJLeaveBattleUIMethod(const crJXJLeaveBattleUIMethod& handle):
	crMethod(handle)
{
}
void crJXJLeaveBattleUIMethod::inputParam(int i, void *param)
{
}
void crJXJLeaveBattleUIMethod::addParam(int i, const std::string& str)
{
}
void crJXJLeaveBattleUIMethod::operator()(crHandle &handle)
{	
	crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
	if (netConductor)
	{
		crPlayerDataEventPacket packet;
		crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvLeaveBattleUI,NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvLeaveBattleUIMethod
//
/////////////////////////////////////////
crJXJRecvLeaveBattleUIMethod::crJXJRecvLeaveBattleUIMethod():
	m_netType(GameClient_Game){}
crJXJRecvLeaveBattleUIMethod::crJXJRecvLeaveBattleUIMethod(const crJXJRecvLeaveBattleUIMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvLeaveBattleUIMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvLeaveBattleUIMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvLeaveBattleUIMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			void *param;
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
			gsBrainData->getParam(WCHDATA_JXJOnBattleUIPlayerSet,param);
			OnBattleUIPlayerSet *onBattleUIPlayerSet = (OnBattleUIPlayerSet *)param;
			onBattleUIPlayerSet->erase(playerid);
			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRememberMyAccountMethod
//
/////////////////////////////////////////
crJXJRememberMyAccountMethod::crJXJRememberMyAccountMethod():
	m_this(NULL)
{
}
crJXJRememberMyAccountMethod::crJXJRememberMyAccountMethod(const crJXJRememberMyAccountMethod& handle):
	crMethod(handle),
	m_checkbox(handle.m_checkbox),
	m_account(handle.m_account)
{
}
void crJXJRememberMyAccountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJRememberMyAccountMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_checkbox = str;
		break;
	case 1:
		m_account = str;
		break;
	case 2:
		m_password = str;
		break;
	}
}
void crJXJRememberMyAccountMethod::operator()(crHandle &handle)
{	
	bool cancelTask = false;
	if(m_this)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			ref_ptr<crCheckBoxWidgetNode> rememberbox = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_checkbox));
			ref_ptr<crEditWidgetNode> account = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_account));
			ref_ptr<crEditWidgetNode> password = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_password));
			if (account.valid() && rememberbox.valid() && password.valid())
			{
				//std::string str;
				std::string mypassword = crArgumentParser::trim(const_cast<char *>(password->getUTF8String().c_str()));
				std::string myaccount = crArgumentParser::trim(const_cast<char *>(account->getUTF8String().c_str()));
				if (mypassword.empty())
				{
					cancelTask = true;
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify, MAKECREPARAM(29,NULL));
					//str = "请输入密码";
				}
				if (!myaccount.empty())
				{
					if (rememberbox->getSelect())
					{
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(4+myaccount.length());
						stream->_writeString(myaccount);
						stream->seekBegin();
						stream->saveToFile2("account.cfg");
					}
					else
					{
						DeleteFileA("account.cfg");
					}
				}
				else
				{
					//str = "昵称不能为空";
					crGlobalHandle::getInstance()->doEvent(WCH_UINotify, MAKECREPARAM(30,NULL));
					cancelTask = true;
				}
				//if (cancelTask)
				//{
				//	CRText::crText *noticeText = dynamic_cast<CRText::crText *>(crFilterRenderManager::getInstance()->getDrawable("Notify"));
				//	if(noticeText)
				//	{
				//		noticeText->setText(CRIOManager::convertUTF8toUTF16(str).c_str());
				//		noticeText->setVisiable(true);
				//		CRCore::notify(CRCore::FATAL)<<"JXJNotice:"<<str<<std::endl;
				//	}
				//}
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crSetRememberAccountMethod
//
/////////////////////////////////////////
crSetRememberAccountMethod::crSetRememberAccountMethod():
	m_this(NULL)
{
}
crSetRememberAccountMethod::crSetRememberAccountMethod(const crSetRememberAccountMethod& handle):
	crMethod(handle),
	m_checkbox(handle.m_checkbox),
	m_account(handle.m_account)
{
}
void crSetRememberAccountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crSetRememberAccountMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_checkbox = str;
		break;
	case 1:
		m_account = str;
		break;
	}
}
void crSetRememberAccountMethod::operator()(crHandle &handle)
{	
	bool cancelTask = true;
	if(m_this)
	{
		ref_ptr<crCheckBoxWidgetNode> checkbox = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_checkbox));
		ref_ptr<crEditWidgetNode> account = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_account));
		if (account.valid())
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(16);
			stream->loadFromFile2("account.cfg");
			if(!stream->eof())
			{
				std::string myaccount = stream -> _readString();
				account->setString(myaccount);
				if (checkbox.valid())
				{
					checkbox->select(true);
				}
				cancelTask = false;
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJUILordEquipTipInfoMethod
//
/////////////////////////////////////////
crJXJUILordEquipTipInfoMethod::crJXJUILordEquipTipInfoMethod():
	m_ea(NULL),
	m_this(NULL),
	//m_ifexpand(false),
	//m_expandnum(1.0f),
	m_imageindex(0),
	m_index(-1),
	m_mailIndex(-1),
	m_onlineRewardIndex(-1)
{
}
crJXJUILordEquipTipInfoMethod::crJXJUILordEquipTipInfoMethod(const crJXJUILordEquipTipInfoMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_name(handle.m_name),
	m_info1(handle.m_info1),
	m_info2(handle.m_info2),
	m_itemlv(handle.m_itemlv),
	m_itemicon(handle.m_itemicon),
	m_itemequipon(handle.m_itemequipon),
	m_canvas(handle.m_canvas),
	m_colorred(handle.m_colorred),
	//m_ifexpand(handle.m_ifexpand),
	m_infocanvas(handle.m_infocanvas),
	m_infobk(handle.m_infobk),
	m_infodi(handle.m_infodi),
	m_offsets(handle.m_offsets),
	//m_expandnum(handle.m_expandnum),
	m_imageindex(handle.m_imageindex),
	m_index(handle.m_index),
	m_mailIndex(handle.m_mailIndex),
	m_govshopcanvas(handle.m_govshopcanvas),
	m_GongfangCanvas(handle.m_GongfangCanvas),
	m_GongfangRadio(handle.m_GongfangRadio),
	m_onlineRewardIndex(handle.m_onlineRewardIndex),
	m_ea(NULL),
	m_this(NULL)
{
}
void crJXJUILordEquipTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUILordEquipTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_name = str;
		break;
	case 2:
		m_info1 = str;
		break;
	case 3:
		m_info2 = str;
		break;
	case 4:
		m_itemlv = str;
		break;
	case 5:
		m_itemicon = str;
		break;
	case 6:
		m_itemequipon = str;
		break;
	case 7:
		m_canvas = str;
		break;
	case 8:
		m_infocanvas = str;
		break;
	case 9:
		m_infobk = str;
		break;
	case 10:
		m_infodi = str;
		break;
	case 11:
		crArgumentParser::appAtoVec(str,m_offsets);
		break;
	case 12:
		crArgumentParser::appAtoVec(str,m_colorred);//red
		m_colorred /= 255.0f;
		break;
	//case 11:
	//	m_expandnum = atof(str.c_str());
	//	break;
	case 13:
		m_imageindex = atoi(str.c_str());
		break;
	case 14:
		m_govshopcanvas = str;
		break;
	case 15:
		m_index = atoi(str.c_str());
		break;
	case 16:
		m_mailIndex = atoi(str.c_str());
		break;
	case 17:
		m_mailCanvas = str;
		break;
	case 18:
		m_GongfangCanvas = str;
		break;
	case 19:
		m_GongfangRadio = str;
		break;
	case 20:
		m_onlineRewardIndex = atoi(str.c_str());
		break;
	case 21:
	case 22:
		m_workshopRadio[i-21] = str;
		break;
	}
}
void crJXJUILordEquipTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	ref_ptr<crCanvasNode>infocanvas = crFilterRenderManager::getInstance()->findCanvas(m_infocanvas);
	ref_ptr<crCanvasNode>govshopcanvas = crFilterRenderManager::getInstance()->findCanvas(m_govshopcanvas);
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(tipsCanvas.valid() && playerData && infocanvas.valid())
	{
		void *param;
		crData *data = playerData->getDataClass();
		data->getParam(WCHDATA_JXJVipLv, param);
		unsigned char viplv = *(unsigned char *)param;
		crData *braindata = crBrain::getInstance()->getDataClass();
		bool ifshowcanvas = false;
		ref_ptr<crStaticTextWidgetNode> name = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_name));
		//ref_ptr<crStaticTextWidgetNode> info1 = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_info1));
		ref_ptr<crStaticTextWidgetNode> itemlv = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_itemlv));
		ref_ptr<crImageBoxWidgetNode> itemicon = dynamic_cast<crImageBoxWidgetNode *>(tipsCanvas->getWidget(m_itemicon));
		ref_ptr<crStaticTextWidgetNode> itemequipon = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_itemequipon));
		//
		ref_ptr<crHypertextWidgetNode> info2 = dynamic_cast<crHypertextWidgetNode *>(infocanvas->getWidget(m_info2));
		crMatrixTransform *infobk = dynamic_cast<crMatrixTransform *>(infocanvas->getChildNode(m_infobk));
		crMatrixTransform *infodi = dynamic_cast<crMatrixTransform *>(infocanvas->getChildNode(m_infodi));
		if (name.valid())
		{
			name->clearString();
		}
		//if (info1)
		//{
		//	info1->clearString();
		//}
		if (info2.valid())
		{
			info2->clearText();
		}
		if (itemlv.valid())
		{
			itemlv->clearString();
		}
		if (itemicon.valid())
		{
			itemicon->clearImage();
		}
		if (itemequipon.valid())
		{
			itemequipon->clearString();
		}
		crRole *mainRole = playerData->getMainRole();
		crData *roleData = mainRole->getDataClass();
		roleData->getParam(WCHDATA_Level,param);
		unsigned char rolelv = *(unsigned char *)param;
		int itemid = 0;
		_crInt32 equipmagic = 0;
		crVector4f colormode;//white,green,blue,purple,orange
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		ref_ptr<crTableIO>qualitytab = crGlobalHandle::gData()->gGlobalTable( WCHDATA_JXJQualityTab);
		crTableIO::StrVec colorrecord;
		int qualityindex = qualitytab->getTitleIndex("color");
		if(canvas.valid())
		{
			if (m_mailIndex > 0 && m_mailIndex < 6)
			{
				ref_ptr<crCanvasNode>mailCanvas = crFilterRenderManager::getInstance()->findCanvas(m_mailCanvas);
				if(mailCanvas.valid())
				{
					mailCanvas->doEvent(WCH_JXJUIMailTip,MAKECREPARAM(&itemid,m_mailIndex-1));
				}
			}
			else if(m_onlineRewardIndex >= 1 && m_onlineRewardIndex < 5)//m_onlineRewardIndex = 1时是礼金，不需要装备tips
			{
				crTableIO::StrVec record,itemrecord;
				ref_ptr<crTableIO>olRewardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJOnlineRewardTab);
				int giftGoldIndex = olRewardTab->getTitleIndex("礼金");
				int item1index = olRewardTab->getTitleIndex("道具1");
				int item2index = olRewardTab->getTitleIndex("道具2");
				int item3index = olRewardTab->getTitleIndex("道具3");
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				int typeindex = itemtab->getTitleIndex("类型");
				void *param;
				crMyPlayerData *myPalyer = crMyPlayerData::getInstance();
				myPalyer->getPlayerGameData()->getDataClass()->getParam(WCHDATA_JXJOnlineRewardCount,param);
				unsigned char count = *(unsigned char *)param;
				if(olRewardTab->queryOneRecord(0,crArgumentParser::appItoa(count),record) >= 0 && giftGoldIndex>=0)
				{
					int count = atoi(record[giftGoldIndex].c_str());
					crVector3i vec3;
					int currIndex = 0;
					if(m_onlineRewardIndex == 1)
					{
						if(count == 0)
						{
							currIndex = item1index;
						}
					}
					if(m_onlineRewardIndex == 2 && currIndex!=item1index)
					{
						if (count == 0)
						{
							currIndex = item2index;
						}
						else
						{
							currIndex = item1index;
						}
					}
					else if(m_onlineRewardIndex == 3)
					{
						if (count == 0)
						{
							currIndex = item3index;
						}
						else
						{
							currIndex = item2index;
						}
					}
					else if(m_onlineRewardIndex == 4)
					{
						if (count != 0)
						{
							currIndex = item3index;
						}
					}
					crArgumentParser::appAtoVec(record[currIndex], vec3);
					if(itemtab->queryOneRecord(0, crArgumentParser::appItoa(vec3[0]), itemrecord) >= 0 )
					{
						int itemTypeId = atoi(itemrecord[typeindex].c_str());
						itemid = vec3[0];
					}
				}
			}
			else
			{
				if(m_index < 0)
					//if (!canvas->getVisiable())
				{
					void *param;
					ref_ptr<crCanvasNode> parentCanvas = m_this->getParentCanvas();
					std::string myName = playerData->getCharacterName();
					std::wstring text;
					std::string newName;
					ref_ptr<crStaticTextWidgetNode> playerName = dynamic_cast<crStaticTextWidgetNode *>(parentCanvas->getWidget("Name"));
					if (playerName.valid())
					{
						text = playerName->getString();
						newName = CRIOManager::convertUTF16toUTF8(text.c_str());
					}
					JXJLordEquipVec equipinfo;
					if (m_workshopRadio[0].empty())
					{
						if (newName != myName)
						{
							//如果当前显示的装备框是好友的，取好友的装备信息
							//data->excHandle(MAKECREPARAM(WCH_LockData, 1));
							data->getParam(WCHDATA_JXJMyFriendLordEquipVec, param);
							equipinfo = *(JXJLordEquipVec *)param;
							//data->excHandle(MAKECREPARAM(WCH_LockData, 0));	
						}
						else
						{
							//roleData->excHandle(MAKECREPARAM(WCH_LockData,1));
							roleData->getParam(WCHDATA_JXJLordEquipVec,param);
							equipinfo = *(JXJLordEquipVec *)param;
							//roleData->excHandle(MAKECREPARAM(WCH_LockData,0));
						}
					}
					else
					{
						crRadioGroupWidgetNode* pRadio = NULL;
						if(!m_GongfangCanvas.empty())
						{
							ref_ptr<crCanvasNode>GongfangCanvas = crFilterRenderManager::getInstance()->findCanvas(m_GongfangCanvas);
							if (GongfangCanvas.valid() && parentCanvas.valid())
							{
								ref_ptr<crRadioGroupWidgetNode> GongfangRadio = dynamic_cast<crRadioGroupWidgetNode *>(GongfangCanvas->getWidget(m_GongfangRadio));
								if (GongfangRadio.valid())
								{
									int gongfangselect = GongfangRadio->getSelect();
									if (gongfangselect == GongfangType_JingLian)
									{
										pRadio = dynamic_cast<crRadioGroupWidgetNode *>(parentCanvas->getWidget(m_workshopRadio[0]));
									}
									if (gongfangselect == GongfangType_FuLian)
									{
										pRadio = dynamic_cast<crRadioGroupWidgetNode *>(parentCanvas->getWidget(m_workshopRadio[1]));
									}
								}
							}
						}
						else if(parentCanvas.valid())
						{
							pRadio = dynamic_cast<crRadioGroupWidgetNode *>(parentCanvas->getWidget(m_workshopRadio[0]));
						}
						if (pRadio)
						{
							int index = pRadio->getSelect();
							roleData->getParam(WCHDATA_JXJLordEquipVecs, param);
							std::vector<JXJLordEquipVec> openedEquipVec = *(std::vector<JXJLordEquipVec> *)param;
							if (index < openedEquipVec.size())
							{
								equipinfo = openedEquipVec[index];
							}
						}
					}
					if (m_imageindex < equipinfo.size() && equipinfo[m_imageindex].first>0)
					{
						itemid = equipinfo[m_imageindex].first;
						equipmagic = equipinfo[m_imageindex].second;
					}
				}
				//else if(m_index < 10)
				//{//官职商店 
				//	if(govshopcanvas.valid())
				//	{
				//		crData *shopcanvasdata = govshopcanvas->getDataClass();
				//		if (shopcanvasdata)
				//		{
				//			shopcanvasdata->getParam(WCHDATA_JXJGovPostShopItemDeq,param);
				//			GovPostShopItemIDDeq *itemdeq = (GovPostShopItemIDDeq *)param;
				//			if (m_index < itemdeq->size() && (*itemdeq)[m_index]!=NULL)
				//			{
				//				itemid = (*itemdeq)[m_index];
				//			}
				//		}
				//	}
				//}
				else if (m_index == 20 || m_index == 21)
				{//工坊
					int gongfangselect = 0;
					crBagItemData *gongfangitemdata = NULL;
					ref_ptr<crCanvasNode>GongfangCanvas = crFilterRenderManager::getInstance()->findCanvas(m_GongfangCanvas);
					if (GongfangCanvas.valid())
					{
						ref_ptr<crRadioGroupWidgetNode> GongfangRadio = dynamic_cast<crRadioGroupWidgetNode *>(GongfangCanvas->getWidget(m_GongfangRadio));
						crData *canvasdata = GongfangCanvas->getDataClass();
						if (GongfangRadio.valid() && canvasdata)
						{
							gongfangselect = GongfangRadio->getSelect();
							if (gongfangselect == GongfangType_JingLian)
							{
								canvasdata->getParam(WCHDATA_JXJRefineEquipBagitemdata,param);
								gongfangitemdata = (crBagItemData *)param;
							}
							if (gongfangselect == GongfangType_FuLian)
							{
								if (m_index == 20)
								{

									canvasdata->getParam(WCHDATA_JXJAttachEquipBagitemdata,param);
									gongfangitemdata = (crBagItemData *)param;
								}
								else
								{

									canvasdata->getParam(WCHDATA_JXJAttachMateBagitemdata,param);
									gongfangitemdata = (crBagItemData *)param;
								}
							}
							if (gongfangselect == GongfangType_RongLian)
							{
								canvasdata->getParam(WCHDATA_JXJSmelterItemData,param);
								gongfangitemdata = (crBagItemData *)param;
							}
							if (gongfangitemdata)
							{
								itemid = gongfangitemdata->getItemID();
								equipmagic = gongfangitemdata->getEquipMagic();
							}
						}
					}
				}
				else if(m_index >= 30 && m_index <= 32)
				{
					crTableIO::StrVec cardrecord;
					crVector3i matevec;
					int cardid = 0;
					int needmateindex = itemtab->getTitleIndex("升级材料");
					braindata->getParam(WCHDATA_JXJUpgradeJiangkaIndex,param);
					short upgradejiangkaindex = *(short *)param;
					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
					JXJItemBagVec *cardbagvec = (JXJItemBagVec *)param;
					if (cardbagvec && upgradejiangkaindex>=0 && upgradejiangkaindex < cardbagvec->size())
					{
						if ( (*cardbagvec)[upgradejiangkaindex]!=NULL)
						{
							cardid = (*cardbagvec)[upgradejiangkaindex]->getItemID();
							if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),cardrecord) >= 0 )
							{
								crArgumentParser::appAtoVec(cardrecord[needmateindex],matevec);
								itemid = matevec[m_index - 30];
							}
						}
					}
				}
				else if (m_index == 40 || m_index == 41)
				{
					int index_ = m_index - 40;
					ref_ptr<crCanvasNode>pricecanvas = crFilterRenderManager::getInstance()->findCanvas(m_govshopcanvas);
					if (pricecanvas.valid() && pricecanvas->getDataClass())
					{
						crData *pricedata = pricecanvas->getDataClass();
						pricedata->getParam(WCHDATA_JXJRenwuRewardVec, param);
						RenWuRewardVec* renwurewardvec = (RenWuRewardVec *)param;
						if (index_ < renwurewardvec->size())
						{
							itemid = (*renwurewardvec)[index_][0];
							equipmagic = (*renwurewardvec)[index_][1];
						}
					}
				}
				else if (m_index == 50)
				{
					int rewarditemcount = 0;
					data->getParam(WCHDATA_JXJPlayerCycleCount, param);
					short cycleCount = *(short *)param;
					if (m_this->getParentCanvas())
					{
						crData *xgjcanvasdata = m_this->getParentCanvas()->getDataClass();
						if (xgjcanvasdata)
						{
							CRCore::ScopedLock<crData> lock(*xgjcanvasdata);
							xgjcanvasdata->getParam(WCHDATA_JXJHuoyueduRewardItemVec, param);
							HuoyueduRewardItemVec *rewardidvec = (HuoyueduRewardItemVec *)param;
							xgjcanvasdata->getParam(WCHDATA_JXJHuoyueduRewardItemCountVec, param);
							HuoyueduRewardItemVec *huoyueduitemcountvec = (HuoyueduRewardItemVec *)param;
							int xgj_index = 0;
							std::string namepr = "XGJ_Icon";
							std::string iconname;
							std::string thisname = m_this->getName();
							for (int i = 0; i < 18; ++i)
							{
								iconname = namepr + crArgumentParser::appItoa(i + 1);
								if (iconname.compare(thisname) == 0)
								{
									xgj_index = i;
									break;
								}
							}
							if (xgj_index < rewardidvec->size())
							{
								itemid = (*rewardidvec)[xgj_index];
								rewarditemcount = (*huoyueduitemcountvec)[xgj_index];
							}
							//if (itemid == T_Copper || itemid == T_Exploit || itemid == T_Exp || itemid == T_VIPExp)
							//{
								std::string tipsstring;
								switch (itemid)
								{
								case T_Food:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "粮食";
									break;
								case T_Wood:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "木材";
									break;
								case T_Iron:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "铁矿";
									break;
								case T_Horse:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "马匹";
									break;
								case T_Copper:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "铜钱";
									break;
								case T_Exploit:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "功勋";
									break;
								case T_Exp:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "经验";
									break;
								case T_Giftgold:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "礼金";
									break;
								case T_VIPExp:
									{
										int maxvalue = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxCycleVipExpReward, viplv).c_str());
										tipsstring = crArgumentParser::appItoa(CRCore::minimum(rewarditemcount * (cycleCount + 1),maxvalue)) + "VIP经验" + "(轮回次数:" + crArgumentParser::appItoa(cycleCount) + "次)";
									}
									break;
								case T_Achievement:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "战功";
									break;
								case T_Contribute:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "国家贡献";
									break;
								case T_JiangHun:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "将魂";
									break;
								case T_Zhanquan:
									tipsstring = crArgumentParser::appItoa(rewarditemcount) + "征战券";
									break;
								default:
									break;
								}
								ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas("Tips1");
								if (tips.valid() && !tipsstring.empty())
								{
									ref_ptr<crStaticTextWidgetNode> tipsText = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget("TipsText1"));
									if (tipsText.valid())
									{
										tipsText->setString(tipsstring);
										const crBoundingBox &btnbox = m_this->getBoundBox();
										//
										const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
										float posx = btnbox.m_min[0];
										float posy = (btnbox.m_min[1] + 1.5f*(btnbox.m_max[1] - btnbox.m_min[1]));
										//
										crVector2 mouse(crVector2(posx, posy));
										tips->setMatrix(crMatrix::translate(mouse[0], mouse[1], 0.0f) * mat);
										crFilterRenderManager::getInstance()->showCanvas(tips.get(), true);
									}
								}
							//}
						}
					}
				}
				else if (m_index>=60 && m_index < 70)
				{
					int index_ = m_index - 60;
					crVector3i vec3;			
					ref_ptr<crTableIO> shouchongAwardTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJShouchongAwardTab);
					if(crArgumentParser::appAtoVec((*shouchongAwardTab)(index_,1),vec3))
					{
						itemid = vec3[0];
						equipmagic = vec3[1];
					}
				}
				else if (m_index>=70 && m_index < 79)	//任务界面奖励物品tips
				{
				
					/*					int index_ = m_index - 70;
					ref_ptr<crTableIO>tasktitletab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTaskTitleTab);
					ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);

					int taskidindex = tasktitletab->getTitleIndex("taskid");

					crTableIO::StrVec recordtask,recorditem;
					int itemaward1index = tasktitletab->getTitleIndex("奖励1");
					int awardtype1index = tasktitletab->getTitleIndex("类型1");
					crVector3i vec3;

					crData *brainData = crBrain::getInstance()->getDataClass();
					brainData->getParam(WCHDATA_JXJCurChooseTaskID,param);
					int taskid = *(int *)param;

					if (taskidindex > 0 && tasktitletab->queryOneRecord(taskidindex,crArgumentParser::appItoa(taskid),recordtask)>=0)
					{
					if (T_Item == atoi(recordtask[awardtype1index+(index_-1)*2].c_str()))
					{
					crArgumentParser::appAtoVec(recordtask[itemaward1index+(index_-1)*2],vec3);
					if (vec3[0]>0 && itemtab->queryOneRecord(0,crArgumentParser::appItoa(vec3[0]),recorditem)>=0)
					{
					itemid = vec3[0];
					equipmagic = vec3[1];
					}
					}
					}	*/			
				}
				else if ( m_index == 80)	//月卡界面提示tips
				{
					std::string tipsstring = "不足五天时才可进行续费(包括五天)";
					ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas("Tips1");
					if (tips.valid() && !tipsstring.empty())
					{
						ref_ptr<crStaticTextWidgetNode> tipsText = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget("TipsText1"));
						if (tipsText.valid())
						{
							tipsText->setString(tipsstring);
							const crBoundingBox &btnbox = m_this->getBoundBox();
							//
							const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
							float posx = btnbox.m_min[0];
							float posy = (btnbox.m_min[1] + 1.5f*(btnbox.m_max[1] - btnbox.m_min[1]));
							//
							crVector2 mouse(crVector2(posx, posy));
							tips->setMatrix(crMatrix::translate(mouse[0], mouse[1], 0.0f) * mat);
							crFilterRenderManager::getInstance()->showCanvas(tips.get(), true);
						}
					}

				}
				//else if (m_index > 80 && m_index < 100)		//自选礼包界面tips
				//{
				//	do 
				//	{
				//		int zixuanhuodongID = 0;
				//		int _index = m_index - 80;
				//		ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
				//		if (false == huodongTab.valid()) break;
				//		ref_ptr<crTableIO> itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				//		if (false == itemtab.valid()) break;
				//		crTableIO::StrVec recordhuodong,recorditem;
				//		int huodongidindex = huodongTab->getTitleIndex("id");
				//		int itemaward1index = huodongTab->getTitleIndex("奖励1");
				//		int titleIdx = huodongTab->getTitleIndex("标题");
				//		std::vector<int> awardVec;

				//		crTableIO::DataVec huodongIDVec;
				//		std::string titletext("自选礼包");
				//		huodongTab->queryRecords(titleIdx,titletext,huodongIDVec);
				//		if (!huodongIDVec.empty()) 
				//		{
				//			crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
				//			crRole *mainRole = playerGameData->getMainRole();
				//			if (mainRole && mainRole->getDataClass())
				//			{
				//				crData *data = mainRole->getDataClass();	
				//				data->getParam(WCHDATA_JXJNewHuodongMap	,param);
				//				NewHuodongMap *huodongMap= (NewHuodongMap *)param;
				//				NewHuodongMap ::iterator itr;
				//				int huodongid = 0;
				//				for(crTableIO::DataVec::iterator siter = huodongIDVec.begin(); siter!=huodongIDVec.end();++siter)
				//				{
				//					huodongid = atoi((*siter)[huodongidindex].c_str());
				//					itr = huodongMap->find(huodongid);	
				//					if(itr != huodongMap->end())
				//					{
				//						if(itr->second->isActivation())
				//						{
				//							zixuanhuodongID = huodongid;
				//							break;
				//						}
				//					}
				//				}
				//			}
				//		}
				//		if(zixuanhuodongID > 0)
				//		{
				//			if (huodongidindex >=0 && huodongTab->queryOneRecord(huodongidindex,crArgumentParser::appItoa(zixuanhuodongID),recordhuodong)>=0)
				//			{
				//				crArgumentParser::appAtoVec(recordhuodong[itemaward1index+(_index-1)/4],awardVec);
				//				if (awardVec.empty()) break;
				//				int _id = (_index%4-1)*3;
				//				if (_id+1 < awardVec.size())
				//				{
				//					if (awardVec[_id]>0 && itemtab->queryOneRecord(0,crArgumentParser::appItoa(awardVec[_id]),recorditem)>=0)
				//					{
				//						itemid = awardVec[_id];
				//						equipmagic = awardVec[_id+1];
				//					}
				//				}
				//			}
				//		}
				//	} while (0);	
				//}
				//else if (m_index > 100 && m_index < 120)	//累计充值回馈活动tips  累计消费回馈tips
				//{
				//	do 
				//	{
				//		ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
				//		if (!huodongTab.valid()) break;
				//		crTableIO::DataVec leijihuodongVec;
				//		crTableIO::StrVec huoRecord;
				//		int idIdx = huodongTab->getTitleIndex("id");
				//		int titleIdx = huodongTab->getTitleIndex("标题");
				//		int awardIdx[5] ;
				//		for (unsigned char i = 0; i < 5; ++ i)
				//		{
				//			awardIdx[i] = -1;
				//		}
				//		awardIdx[0] = huodongTab->getTitleIndex("奖励1");
				//		awardIdx[1] = huodongTab->getTitleIndex("奖励2");
				//		awardIdx[2] = huodongTab->getTitleIndex("奖励3");
				//		awardIdx[3] = huodongTab->getTitleIndex("奖励4");
				//		awardIdx[4] = huodongTab->getTitleIndex("奖励5");
				//		std::string titletext("累计充值回馈");
				//		if (m_imageindex == 1)
				//		{
				//			titletext = "累计消费回馈";
				//		}
				//		huodongTab->queryRecords(titleIdx,titletext,leijihuodongVec);	
				//		int Vecsize = leijihuodongVec.size()<=5?leijihuodongVec.size():5;
				//		int selectid = -1;
				//		ref_ptr<crCanvasNode>leijichongzhiCanvas = crFilterRenderManager::getInstance()->findCanvas(m_GongfangCanvas);
				//		ref_ptr<crRadioGroupWidgetNode> huodongRadio = dynamic_cast<crRadioGroupWidgetNode *>(leijichongzhiCanvas->getWidget(m_GongfangRadio));
				//		if (huodongRadio.valid())
				//		{
				//			selectid = huodongRadio->getSelect();
				//		}
				//		if(selectid < 0 || selectid >= Vecsize) break;

				//		int _value = m_index - 101;
				//		int _index = 0;
				//		if (_value >=0 && _value < 4)
				//		{
				//			_index = _value;

				//		}
				//		else if(_value >=4 && _value <5)
				//		{
				//			_index = _value - 4;
				//		}
				//		else if (_value >=5 && _value < 7)
				//		{
				//			_index = _value - 5;
				//		}
				//		else if(_value >=7 && _value <10)
				//		{
				//			_index = _value - 7;
				//		}
				//		else if (_value >= 10 && _value < 15)
				//		{
				//			_index = _value - 10;
				//		}
				//		if(_index < 0 || _index > 4) break;
				//		crVector3i awardVec;
				//		if(awardIdx[_index] < 0 || awardIdx[_index] >= leijihuodongVec[selectid].size()) break;
				//		//crArgumentParser::appAtoVec(leijihuodongVec[selectid][awardIdx[_index]].c_str(),awardVec);
				//		int huodongID =0;
				//		roleData->getParam(WCHDATA_JXJNewHuodongMap	,param);
				//		NewHuodongMap *huodongMap= (NewHuodongMap *)param;
				//		NewHuodongMap::iterator tmpitr;
				//		int ii = 0; 
				//		for(crTableIO::DataVec::iterator siter = leijihuodongVec.begin(); siter!=leijihuodongVec.end();++siter)
				//		{
				//			huodongID = atoi((*siter)[idIdx].c_str());
				//			tmpitr = huodongMap->find(huodongID);
				//			if(tmpitr != huodongMap->end())
				//			{
				//				if(tmpitr->second->getActivation() > 0)
				//				{
				//					if (huodongTab->queryOneRecord(idIdx,crArgumentParser::appItoa(huodongID),huoRecord) < 0) continue;
				//					if (selectid == ii)
				//					{
				//						crArgumentParser::appAtoVec(huoRecord[awardIdx[_index]],awardVec);
				//					}
				//					++ii;
				//				}
				//			}
				//		}
				//		itemid = awardVec[0];
				//		equipmagic = awardVec[1];
				//	} while (0);
				//}
				//else if (m_index >120 && m_index < 140)  //单笔充值回馈 tips
				//{
				//	do 
				//	{
				//		int _value = (int)((m_index - 121)/4);
				//		int _index = (m_index -121)%4;
				//		ref_ptr<crTableIO> huodongTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJHuodongTab);
				//		if (!huodongTab.valid()) break;
				//		crTableIO::DataVec _huodongVec;
				//		int idIdx = huodongTab->getTitleIndex("id");
				//		int titleIdx = huodongTab->getTitleIndex("标题");
				//		int awardIdx[4] ;
				//		for (unsigned char i = 0; i < 4; ++ i)
				//		{
				//			awardIdx[i] = -1;
				//		}
				//		awardIdx[0] = huodongTab->getTitleIndex("奖励1");
				//		awardIdx[1] = huodongTab->getTitleIndex("奖励2");
				//		awardIdx[2] = huodongTab->getTitleIndex("奖励3");
				//		awardIdx[3] = huodongTab->getTitleIndex("奖励4");
				//		std::string titletext("单笔充值回馈");
				//		huodongTab->queryRecords(titleIdx,titletext,_huodongVec);
				//		if(_value >= _huodongVec.size()) break;
				//		crVector3i awardVec;
				//		if(awardIdx[_index] < 0 || awardIdx[_index] >= _huodongVec[_value].size()) break;
				//		crArgumentParser::appAtoVec(_huodongVec[_value][awardIdx[_index]].c_str(),awardVec);
				//		itemid = awardVec[0];
				//		equipmagic = awardVec[1];

				//	} while (0);
				//}
				else if (m_index == 200)
				{
					crData *uiData = m_this->getDataClass();
					if (uiData)
					{
						CRCore::ScopedLock<crData> lock(*uiData);
						uiData->getParam(0, param);
						itemid = *(int *)param;
						uiData->getParam(1, param);
						int count = *(int *)param;
						std::string tipsstring;
						switch (itemid)
						{
						case T_Food:
							tipsstring = crArgumentParser::appItoa(count) + "粮食";
							break;
						case T_Wood:
							tipsstring = crArgumentParser::appItoa(count) + "木材";
							break;
						case T_Iron:
							tipsstring = crArgumentParser::appItoa(count) + "铁矿";
							break;
						case T_Horse:
							tipsstring = crArgumentParser::appItoa(count) + "马匹";
							break;
						case T_Copper:
							tipsstring = crArgumentParser::appItoa(count) + "铜钱";
							break;
						case T_Exploit:
							tipsstring = crArgumentParser::appItoa(count) + "功勋";
							break;
						case T_Exp:
							tipsstring = crArgumentParser::appItoa(count) + "经验";
							break;
						case T_Giftgold:
							tipsstring = crArgumentParser::appItoa(count) + "礼金";
							break;
						case T_VIPExp:
							tipsstring = crArgumentParser::appItoa(count) + "VIP经验";
							break;
						case T_Achievement:
							tipsstring = crArgumentParser::appItoa(count) + "战功";
							break;
						case T_Contribute:
							tipsstring = crArgumentParser::appItoa(count) + "国家贡献";
							break;
						case T_JiangHun:
							tipsstring = crArgumentParser::appItoa(count) + "将魂";
							break;
						case T_Zhanquan:
							tipsstring = crArgumentParser::appItoa(count) + "征战券";
							break;
						case T_CopperExtraProduce:
							tipsstring = crArgumentParser::appItoa(count) + "%征收加成";
							break;
						case T_FoodExtraProduce:
							tipsstring = crArgumentParser::appItoa(count) + "%粮食加成";
							break;
						case T_WoodExtraProduce:
							tipsstring = crArgumentParser::appItoa(count) + "%木材加成";
							break;
						case T_IronExtraProduce:
							tipsstring = crArgumentParser::appItoa(count) + "%铁矿加成";
							break;
						case T_HorseExtraProduce:
							tipsstring = crArgumentParser::appItoa(count) + "%马匹加成";
							break;
						case T_Troops:
							tipsstring = crArgumentParser::appItoa(count) + "士兵";
							break;
						default:
							break;
						}
						ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas("Tips1");
						if (tips.valid() && !tipsstring.empty())
						{
							ref_ptr<crStaticTextWidgetNode> tipsText = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget("TipsText1"));
							if (tipsText.valid())
							{
								tipsText->setString(tipsstring);
								tipsText->setColor(FCOLOR_BLACK);
								const crBoundingBox &btnbox = m_this->getBoundBox();
								//
								const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
								float posx = btnbox.m_min[0];
								float posy = (btnbox.m_min[1] + 1.5f*(btnbox.m_max[1] - btnbox.m_min[1]));
								//
								crVector2 mouse(crVector2(posx, posy));
								tips->setMatrix(crMatrix::translate(mouse[0], mouse[1], 0.0f) * mat);
								crFilterRenderManager::getInstance()->showCanvas(tips.get(), true);
							}
						}
					}
				}
				else if (m_index == 201)
				{//轮回界面装备tips
					std::string boxname = m_this->getName();
					ref_ptr<crCanvasNode>  Canvas = m_this->getParentCanvas();
					if (boxname.find("XLunhui_Icon") != std::string::npos && Canvas.valid())
					{
						std::string strindex = boxname.substr(boxname.find('o') + 2, boxname.size() - boxname.find('o') - 2);
						int index = atoi(strindex.c_str()) - 1;

						ref_ptr<crRadioGroupWidgetNode> cardPage = dynamic_cast<crRadioGroupWidgetNode *>(Canvas->getWidget("XLunhui_zhuangbei_qieye"));
						int page = cardPage->getSelect();
						int offset = page*CycleItemOnePageCount;
						index += offset;

						crData *canvasData = Canvas->getDataClass();
						canvasData->getParam(WCHDATA_JXJLunHuiItemMap, param);
						ItemOrCardMap *cardoritemMap = (ItemOrCardMap *)param;

						if (index < CycleItemCount)
						{
							if (cardoritemMap)
							{
								ItemOrCardMap::iterator iter = cardoritemMap->find((char)index);
								if (iter != cardoritemMap->end() && iter->second.valid())
								{
									itemid = iter->second->getItemID();
									equipmagic = iter->second->getEquipMagic();
								}
							}
							if (itemid == 0)
							{
								data->getParam(WCHDATA_JXJPlayerStore, param);
								ref_ptr<crJXJPlayerStore> playerStore = (crJXJPlayerStore *)param;
								if (playerStore.valid())
								{
									crData *playerStoreData = playerStore->getDataClass();
									if (playerStoreData)
									{
										playerStoreData->excHandle(MAKECREPARAM(WCH_LockData, 1));
										playerStoreData->getParam(WCHDATA_JXJItemBagVec, param);
										JXJStoreItemBagVec *itemVec = (JXJStoreItemBagVec *)param;
										if (index < itemVec->size() && (*itemVec)[index].valid())
										{
											itemid = (*itemVec)[index]->getItemID();
											equipmagic = (*itemVec)[index]->getEquipMagic();
										}
										playerStoreData->excHandle(MAKECREPARAM(WCH_LockData, 0));
									}
								}
							}
						}
					}
				}
			}
		}				
		if(itemid>0)
		{
			ref_ptr<crTableIO>lordequiptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLordEquipTab);
			//int tnameindex = lordequiptab->getTitleIndex("称号");
			//int shuxingindex = lordequiptab->getTitleIndex("属性");

			int iconindex = itemtab->getTitleIndex("icon");
			//int info2index = itemtab->getTitleIndex("物品描述");
			int nameindex = itemtab->getTitleIndex("name");
			int typeindex = itemtab->getTitleIndex("类型");
			int colorindex = itemtab->getTitleIndex("品质");
			int needlvindex = itemtab->getTitleIndex("人物等级");
			crTableIO::StrVec record,lordrecord;

			if (itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0 )
			{
				int colormodeid = atoi(record[colorindex].c_str());
				if (qualitytab->queryOneRecord(0,crArgumentParser::appItoa(colormodeid),colorrecord) >= 0 )
				{
					crArgumentParser::appAtoVec(colorrecord[qualityindex],colormode);
				}
				if(name.valid())
				{
					name->setColor(colormode/255.0f);
					//name->setColor(crVector4f(88.0f,200.0f,200.0f,255.0f));
					name->setString(record[nameindex]);
				}
				std::string file;
				if (itemlv.valid())
				{
					if (rolelv < atoi(record[needlvindex].c_str()))//人物等级不足时显示红字
					{
						itemlv->setColor(FCOLOR_RED);
						if (itemequipon.valid())
						{
							itemequipon->setColor(FCOLOR_RED);
						}
					}
					else
					{
						itemlv->setColor(FCOLOR_BLACK);
						if (itemequipon.valid())
						{
							itemequipon->setColor(FCOLOR_GREEN);
						}
					}
					itemlv->setString(record[needlvindex]);
				}
				if (itemicon.valid())
				{
					itemicon->setImageName(record[iconindex]);
				}
				if (itemequipon.valid())
				{
					std::string str;// = "未使用";
					if (atoi(record[typeindex].c_str()) == IT_Equip)
					{
						if (m_index == 0)
						{
							str = "未装备";
						}
						else
						{
							str = "已装备";
						}
						//if (lordequiptab->queryOneRecord(0,crArgumentParser::appItoa(itemid),lordrecord) >= 0 )
						//{
						//if(info1)
						//{
						//	info1->setColor(colormode[colormodeid]);
						//	info1->setString(lordrecord[tnameindex]);
						//}
						//}
					}
					itemequipon->setString(str);
				}
				if(info2.valid())
				{
					ItemMap itemMap;
					rcfg::ConfigScript outscript(&itemMap);
					crVector2i item(itemid,equipmagic);
					playerData->doEvent(WCH_JXJCreateItemTips,MAKECREPARAM(&item,&outscript));
					info2->setHypertext(outscript);
				}

				///////////计算缩放
				float boxYlength = infobk->getChild(0)->getBoundBox().yLength()/**crDisplaySettings::instance()->getUIViewScale()[1]*/;
				info2->updateData();
				const crBoundingBox &bbox = info2->getTextObject()->getBoundBox();
				const crBoundingBox &bbox2 = info2->getBoundBox();
				float texheight = 0.0f;
				float needmove = 0.0f;
				if(bbox.valid())
				{
					texheight = bbox.yLength();
					texheight *= crDisplaySettings::instance()->getUIPixelMeter() * crDisplaySettings::instance()->getUIHeightScale()/crDisplaySettings::instance()->getUIScaleFactor();
					if(texheight<boxYlength) texheight = boxYlength;
					float scale = texheight/boxYlength;

					float needmove ;
					const crBoundingBox &tipsbb = tipsCanvas->getBoundBox();
					crVector3 centerTansTar = info2->getBound().center();

					float tmpLength = bbox2.yLength();
					if(infodi)
					{
						float diYlength = infodi->getChild(0)->getBoundBox().yLength();
						centerTansTar[1] += 0.5f * (tmpLength - texheight) + 0.25f * diYlength;
						//centerTansTar[1] += 0.5f * (tmpLength - texheight) ;
					}
					else
						centerTansTar[1] += 0.5f * (tmpLength - texheight);
					// 源中心点
					crVector3 centerTansSrc = infobk->getChild(0)->getBoundBox().center();
					// 将源中心点平移到原点
					crMatrix put_mat = crMatrix::translate(centerTansSrc);
					crMatrix inv_put = crMatrix::inverse(put_mat);
					crMatrix rotmat;
					rotmat.postMult(inv_put);
					rotmat.postMult(crMatrix::scale(1.0f,scale,1.0f));
					rotmat.postMult(crMatrix::translate(centerTansTar));
					if(infobk)infobk->setMatrix(rotmat);

					if(infodi)
					{
						float diYlength = infodi->getChild(0)->getBoundBox().yLength();
						//needmove = diYlength*0.5f*(scale-1.0f) - needmove;
						needmove = boxYlength - texheight + diYlength * 0.25f;
						//needmove = boxYlength - texheight;
						infodi->setMatrix(crMatrix::translate(0.0f,needmove/*+c_tipsoffsets[2]*scale*/,0.0f));
					}
				}
				else
				{
					infobk->setMatrix(crMatrix::scale(1.0f,1.0f/*m_expandnum*/,1.0f) * crMatrix::translate(0.0f,0.0f,0.0f));
					if(infodi) infodi->setMatrix(crMatrix::translate(0.0f,0.0f,0.0f));
				}
				///////////////////////////////////////
				const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
				const crBoundingBox &iconbox = m_this->getBoundBox();
				const crBoundingBox &tips = tipsCanvas->getBoundBox();
				float posx = (tips.m_max[0]-tips.m_min[0])*0.5;
				float posy = (tips.m_max[1]-tips.m_min[1])*0.5;
				crVector3 pos(iconbox.m_max[0],iconbox.m_max[1],0.0f);
				/////////////////////////////////////////
				crVector3 pos2(iconbox.m_min[0] ,iconbox.m_min[1],0.0f);
				pos = pos * mat;
				pos2 = pos2 * mat;
				float posx2,posy2;
				/////////////////////////////////////////                             
				if (pos2[0] >= 0)
				{
					posx2 = pos2[0] - posx;
				}
				else
				{
					posx2 = pos[0] + posx;
				}
				if (pos2[1] >= 0)
				{
					posy2 = pos[1] - posy;
				}
				else
				{
					posy2 = pos2[1] + 2.0f * posy - needmove;
				}
				if((abs(posy2)+posy)>1.0f)
				{
					if (posy2 >= 0)
					{
						posy2 -= posy;
					}
					else
					{
						posy2 += posy;
					}
				}
				crVector2 mouse(crVector2(posx2,posy2));
				//infobk->setMatrix(crMatrix::scale(1.0f,m_expandnum,1.0f) * crMatrix::translate(0,(infobk->getChild(0)->getBoundBox().yLength()*0.5f),0.0f));
				infocanvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));//(crMatrix::translate(mouse[0],mouse[1]-posy*2.0f-tipsCanvas->getBoundBox().yLength()*0.5f,0.0f));

				/////////////////////////////////////////
				tipsCanvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f));
				tipsCanvas->setCanFocus(false);
				infocanvas->setCanFocus(false);

				crFilterRenderManager::getInstance()->showCanvas(infocanvas.get(),true);
				crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
				ifshowcanvas = true;
			}
		}
		if (!ifshowcanvas)
		{
			crFilterRenderManager::getInstance()->closeCanvas(tipsCanvas.get());
			crFilterRenderManager::getInstance()->closeCanvas(infocanvas.get());
		}
	}
}	

/////////////////////////////////////////
//
//crJXJTakeOffLordEquipMethod
//
/////////////////////////////////////////
crJXJTakeOffLordEquipMethod::crJXJTakeOffLordEquipMethod():
	m_this(NULL),m_index(0)
{
}
crJXJTakeOffLordEquipMethod::crJXJTakeOffLordEquipMethod(const crJXJTakeOffLordEquipMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent),
	m_name(handle.m_name)
{
}
void crJXJTakeOffLordEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJTakeOffLordEquipMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_tipcanvas = str;
		break;
	case 2:
		m_tiptitle = str;
		break;
	case 3:
		m_tipcontent = str;
		break;
	case 4:
		m_name = str;
		break;
	default:
		break;
	}
}
void crJXJTakeOffLordEquipMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();

	if(m_this && myPlayer)
	{
		void *param;
		bool cantakeoff = false;
		crData *data = myPlayer ->getDataClass();
		std::string myName = myPlayer->getCharacterName();
		ref_ptr<crStaticTextWidgetNode> playerName = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_name));
		if (playerName.valid())
		{
			std::wstring text = playerName->getString();
			std::string name = CRIOManager::convertUTF16toUTF8(text.c_str());
			if (name != myName)
			{
				//如果当前显示的装备框不是自己的，就不能完成右键取下装备的操作
				return;
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		data->getParam(WCHDATA_JXJItemBagVec,param);
		JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
		data->getParam(WCHDATA_JXJOpenBagNum,param);
		unsigned char openbagnum = *(unsigned char *)param;
		int i = 0;
		for (JXJItemBagVec::iterator itr = itembagvec->begin();itr!=itembagvec->end() && i < openbagnum;++itr,++i)
		{
			if((*itr) == NULL)
			{
				cantakeoff = true;
				break;
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
		if (cantakeoff)
		{
			crRole *mainRole = myPlayer->getMainRole();
			crData *roleData = mainRole->getDataClass();
			if (roleData)
			{
				roleData->excHandle(MAKECREPARAM(WCH_LockData,1));
				roleData->getParam(WCHDATA_JXJLordEquipVec,param);
				JXJLordEquipVec *lordequipvec = (JXJLordEquipVec *)param;
				if (m_index < lordequipvec->size())
				{
					if((*lordequipvec)[m_index].first>0)
					{
						crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
						if (netConductor)
						{
							int itemid = 0;
							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(8);
							stream->_writeInt((*lordequipvec)[m_index].first);
							stream->_writeInt((*lordequipvec)[m_index].second);
							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvTakeOffLordEquip,stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
						}
					}
				}
				roleData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else
		{
			std::string str ="背包已满。请先整理背包！";
			ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
			if (tipcanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
				ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
				if (tipcontent.valid())
				{
					tipcontent->setString(str);
				}
				crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvPutOnEquipMethod
//
/////////////////////////////////////////
crJXJRecvTakeOffLordEquipMethod::crJXJRecvTakeOffLordEquipMethod():
	m_netType(GameClient_Game){}
crJXJRecvTakeOffLordEquipMethod::crJXJRecvTakeOffLordEquipMethod(const crJXJRecvTakeOffLordEquipMethod& handle):
	crMethod(handle),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvTakeOffLordEquipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTakeOffLordEquipMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tiptitle = str;
		break;
	case 2:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvTakeOffLordEquipMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				bool cantakeoff = false;
				int itemid = m_stream->_readInt();
				_crInt32 equipmagic = m_stream->_readInt();
				void *param;
				unsigned char openbagnum;
				int equipindex = 0;
				JXJItemBagVec *itembagvec;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJItemBagVec,param);
				itembagvec = (JXJItemBagVec *)param;
				data->getParam(WCHDATA_JXJOpenBagNum,param);
				openbagnum = *(unsigned char *)param;
				crRole *mainRole = m_this->getMainRole();
				crData *mainroledata = mainRole->getDataClass();
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,1));
				//mainroledata->getParam(WCHDATA_JXJLordSuitMap,param);
				//JXJLordSuitMap *lordequipsuitmap = (JXJLordSuitMap *)param;;
				mainroledata->getParam(WCHDATA_JXJLordEquipVec,param);
				JXJLordEquipVec *lordequipvec = (JXJLordEquipVec *)param;
				int bagindex = 0;
				for (JXJItemBagVec::iterator itr = itembagvec->begin();itr!=itembagvec->end() && bagindex < openbagnum;++itr,++bagindex)
				{
					if((*itr) == NULL)
					{
						cantakeoff = true;
						break;
					}
				}
				if (cantakeoff)
				{
					for (JXJLordEquipVec::iterator itr2 = lordequipvec->begin();itr2!=lordequipvec->end();++itr2,equipindex++)
					{
						if (itr2->first==itemid && itr2->second == equipmagic)
						{
							success  = 1;
							ref_ptr<crBagItemData> baginfo = new crBagItemData;
							baginfo->setItemID(itemid);
							baginfo->setEquipMagic(equipmagic);
							baginfo->setItemCount(1);
							(*itembagvec)[bagindex] = baginfo;
							itr2->first = 0;
							itr2->second = 0;
							break;
						}
					}
				}
				else
				{
					success = 2;
				}
				//mainRole->doEvent(WCH_JXJCheckLordEquipSuit);
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				if(success)
				{
					stream->createBuf(11/* + lordequipsuitmap->size()*2*/);
					stream->_writeUChar(success);
					stream->_writeInt(itemid);
					stream->_writeInt(equipmagic);
					stream->_writeUChar(equipindex);
					stream->_writeUChar(bagindex);
					//stream->_writeUChar((unsigned char)lordequipsuitmap->size());
					//if (lordequipsuitmap->size() > 0)
					//{
					//	for (JXJLordSuitMap::iterator itr = lordequipsuitmap->begin();
					//		itr!=lordequipsuitmap->end();
					//		++itr)
					//	{
					//		if (itr->first > 0)
					//		{
					//			stream->_writeUChar(itr->first);
					//			stream->_writeUChar(itr->second);
					//		}
					//	}
					//}
				}
				else
				{
					stream->createBuf(1);
					stream->_writeUChar(success);
				}
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,0));
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvTakeOffLordEquip,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = crArgumentParser::appVectoa(crVector2i(success,itemid));
				GameLogData gamelog(Log_TakeoffLordEquip,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			//ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
			//ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_input));
			if(success == 1)
			{
				void *param;
				crData *data = m_this->getDataClass();
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				crData *mainroledata = crMyPlayerData::getInstance()->getPlayerGameData()->getMainRole()->getDataClass();
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,1));
				//mainroledata->getParam(WCHDATA_JXJLordSuitMap,param);
				//JXJLordSuitMap *lordequipsuitmap = (JXJLordSuitMap *)param;
				//lordequipsuitmap->clear();
				int itemid = m_stream -> _readInt();
				_crInt32 equipmagic = m_stream->_readInt();
				unsigned char selectid = m_stream->_readUChar();
				unsigned char bagindex = m_stream->_readUChar();
				//unsigned char suitsize = m_stream->_readUChar();
				//for (int i = 0; i < suitsize;i++)
				//{
				//	lordequipsuitmap->insert(std::make_pair(m_stream->_readUChar(),m_stream->_readUChar()));
				//}
				data->getParam(WCHDATA_JXJItemBagVec,param);
				JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
				mainroledata->getParam(WCHDATA_JXJLordEquipVec,param);
				JXJLordEquipVec *lordequipvec = (JXJLordEquipVec *)param;
				if (selectid < lordequipvec->size())
				{
					(*lordequipvec)[selectid].first = 0;
					(*lordequipvec)[selectid].second = 0;
				}
				if (bagindex<itembagvec->size())
				{
					ref_ptr<crBagItemData> baginfo = new crBagItemData;
					baginfo->setItemID(itemid);
					baginfo->setEquipMagic(equipmagic);
					baginfo->setItemCount(1);
					(*itembagvec)[bagindex] = baginfo;
				}
				//m_this->getMainRole()->doEvent(WCH_JXJCheckLordEquipSuit);
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,0));
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			else
			{
				std::string str ="装备信息错误";//0
				if (success == 2)
				{
					str ="背包已满。请先整理背包！";
				}
				ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
				if (tipcanvas.valid())
				{
					ref_ptr<crStaticTextWidgetNode> tiptitle = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tiptitle));
					ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
					if (tipcontent.valid())
					{
						tipcontent->setString(str);
					}
					crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJOnChengfangUIMethod
//
/////////////////////////////////////////
crJXJOnChengfangUIMethod::crJXJOnChengfangUIMethod()
{
}
crJXJOnChengfangUIMethod::crJXJOnChengfangUIMethod(const crJXJOnChengfangUIMethod& handle):
	crMethod(handle)
{
}
void crJXJOnChengfangUIMethod::inputParam(int i, void *param)
{
}
void crJXJOnChengfangUIMethod::addParam(int i, const std::string& str)
{
}
void crJXJOnChengfangUIMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if (netConductor)
		{
			void *param;
			crData *data = myPlayer->getDataClass();
			data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
			unsigned char type = *(unsigned char *)param;
			data->getParam(WCHDATA_JXJFubenOrChengchiID, param);
			unsigned short chengchiid = *(unsigned short *)param;
			if(type == FT_Chengchi && chengchiid>0)
			{
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJChengChiMap,param);
				ChengchiMap *chengchimap = (ChengchiMap *)param;
				if(chengchimap->find(chengchiid)!=chengchimap->end())
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(2);
					stream->_writeUShort(chengchiid);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvOnChengfangUI,stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvOnChengfangUIMethod
//
/////////////////////////////////////////
crJXJRecvOnChengfangUIMethod::crJXJRecvOnChengfangUIMethod():
	m_netType(GameClient_Game){}
crJXJRecvOnChengfangUIMethod::crJXJRecvOnChengfangUIMethod(const crJXJRecvOnChengfangUIMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvOnChengfangUIMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvOnChengfangUIMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvOnChengfangUIMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned short chengchiid = m_stream->_readUShort();
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid())
			{
				void *param;
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));

				gsBrainData->getParam(WCHDATA_JXJOnChengfangUIPlayerMap,param);
				//发送战场信息
				//gsBrainData->getParam(WCHDATA_JXJOpenBattle,param);
				//bool openBattle = *(bool *)param;
				//gsBrainData->getParam(WCHDATA_JXJOpenPass,param);
				//bool openPass = *(bool *)param;
				//if(openBattle/* || openPass*/)
				{
					//gsBrainData->getParam(WCHDATA_JXJCloseBattleSet,param);
					//ClosedBattleSet *closeBattleSet = (ClosedBattleSet *)param;
					ref_ptr<crStreamBuf> stream;
					gsBrainData->getParam(WCHDATA_JXJChengChiMap,param);
					ChengchiMap *chengchimap = (ChengchiMap *)param;
					ChengchiMap::iterator ccItr;
					gsBrainData->getParam(WCHDATA_JXJOpenBattleMap,param);
					OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
					gsBrainData->getParam(WCHDATA_JXJBattleScoreMap,param);
					BattleScoreMap *battleScoreMap = (BattleScoreMap *)param;
					BattleScoreMap::iterator bsItr;
					ShiliScoreMap::iterator ssItr;
					ChengfangInfovec BattleRoom;
					ClosedBattleSet::iterator closeitr;
					//unsigned char ifopen;
					float remaintime;
					//unsigned char startShiliID = 10;//atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());

					ccItr = chengchimap->find(chengchiid);
					if(ccItr!=chengchimap->end())
					{
						BattleRoom.resize(0);
						for( OpenBattleMap::iterator oitr = openBattleMap->begin();
							oitr != openBattleMap->end();
							++oitr )
						{
							if( HIINT32(oitr->first) == chengchiid )
							{
								remaintime = oitr->second.second.second;
								//ifopen = 1;
								//closeitr = closeBattleSet->find(MAKEINT64(oitr->first,oitr->second.second.first));
								//if (closeitr != closeBattleSet->end())
								//{
								//	ifopen = 0;
								//}
								BattleRoom.push_back(std::make_pair(crVector4ub(LOINT16(LOINT32(oitr->first)),HIINT16(LOINT32(oitr->first)),(unsigned char)(oitr->second.first.first.size()),
									(unsigned char)(oitr->second.first.second.size())),remaintime));
							}
						}
						stream = new crStreamBuf;
						stream->createBuf(3+BattleRoom.size()*8);
						stream->_writeUShort(ccItr->first);//城池id，
						//ccItr->second->buildStream(stream);//12
						//stream->_writeUChar(ccItr->second.first);//势力id
						//stream->_writeUShort(ccItr->second.second);//城防值
						//bsItr = battleScoreMap->find(chengchiid);
						//if(bsItr != battleScoreMap->end())
						//{//2*3
						//	ssItr = bsItr->second.find(c_startShiliID);
						//	if(ssItr != bsItr->second.end())
						//	{//势力1胜利次数
						//		stream->_writeShort(ssItr->second.first);
						//	}
						//	else
						//	{
						//		stream->_writeShort(0);
						//	}
						//	ssItr = bsItr->second.find(c_startShiliID+1);
						//	if(ssItr != bsItr->second.end())
						//	{//势力2胜利次数
						//		stream->_writeShort(ssItr->second.first);
						//	}
						//	else
						//	{
						//		stream->_writeShort(0);
						//	}
						//	ssItr = bsItr->second.find(c_startShiliID+2);
						//	if(ssItr != bsItr->second.end())
						//	{//势力3胜利次数
						//		stream->_writeShort(ssItr->second.first);
						//	}
						//	else
						//	{
						//		stream->_writeShort(0);
						//	}
						//}
						//else
						//{
						//	stream->_writeShort(0);
						//	stream->_writeShort(0);
						//	stream->_writeShort(0);
						//}
						stream->_writeUChar(BattleRoom.size());//已经开启的房间数量
						for( ChengfangInfovec::iterator brItr = BattleRoom.begin();
							brItr != BattleRoom.end();
							++brItr )
						{////已经开启的房间信息
							stream->_writeVec4ub(brItr->first);//攻防势力ID，攻方人数，守方人数
							stream->_writeFloat(brItr->second);//剩余时间
							//stream->_writeBool(brItr->second.second);//是否开启
						}
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvChengfangInfo,stream.get());
						netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
				//加入到查询队列
				gsBrainData->getParam(WCHDATA_JXJChengChiMap,param);
				ChengchiMap *chengchimap = (ChengchiMap *)param;
				if(chengchimap->find(chengchiid)!=chengchimap->end())
				{
					gsBrainData->getParam(WCHDATA_JXJOnChengfangUIPlayerMap,param);
					OnChengfangUIPlayerMap *onChengfangUIPlayerMap = (OnChengfangUIPlayerMap *)param;
					(*onChengfangUIPlayerMap)[chengchiid].insert(playerid);
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJChengfangInfoSendDisposeMethod
//
/////////////////////////////////////////
crJXJChengfangInfoSendDisposeMethod::crJXJChengfangInfoSendDisposeMethod():
	m_this(NULL){}
crJXJChengfangInfoSendDisposeMethod::crJXJChengfangInfoSendDisposeMethod(const crJXJChengfangInfoSendDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJChengfangInfoSendDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJChengfangInfoSendDisposeMethod::addParam(int i, const std::string& str)
{
}

void crJXJChengfangInfoSendDisposeMethod::operator()(crHandle &handle)
{
	//////////////////////////
	//返回					//
	//  1.城防值（房间数）	//
	//	2.每个房间状态		//
	//	3.每个房间攻方人数	//
	//	4.每个房间守方人数	//
	//////////////////////////
	void *param;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKECREPARAM(WCH_LockData,1));
	data->getParam(WCHDATA_JXJOnChengfangUIPlayerMap,param);
	OnChengfangUIPlayerMap *onChengfangUIPlayerMap = (OnChengfangUIPlayerMap *)param;
	if(!onChengfangUIPlayerMap->empty())
	{
		//data->getParam(WCHDATA_JXJOpenBattle,param);
		//bool openBattle = *(bool *)param;
		//data->getParam(WCHDATA_JXJOpenPass,param);
		//bool openPass = *(bool *)param;
		//if(openBattle/* || openPass*/)
		{
			//data->getParam(WCHDATA_JXJCloseBattleSet,param);
			//ClosedBattleSet *closeBattleSet = (ClosedBattleSet *)param;
			ref_ptr<crStreamBuf> stream;
			data->getParam(WCHDATA_JXJChengChiMap,param);
			ChengchiMap *chengchimap = (ChengchiMap *)param;
			ChengchiMap::iterator ccItr;
			data->getParam(WCHDATA_JXJOpenBattleMap,param);
			OpenBattleMap *openBattleMap = (OpenBattleMap *)param;
			data->getParam(WCHDATA_JXJBattleScoreMap,param);
			BattleScoreMap *battleScoreMap = (BattleScoreMap *)param;
			BattleScoreMap::iterator bsItr;
			ShiliScoreMap::iterator ssItr;
			ChengfangInfovec BattleRoom;
			//unsigned char startShiliID = 10;//atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
			crPlayerDataEventPacket packet;
			ref_ptr<crStreamBuf> packetStream;
			int bufsize;
			ClosedBattleSet::iterator closeitr;
			//unsigned char ifopen;
			float remaintime;
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetManager *netManager = gameServer->getNetManager();
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			for( OnChengfangUIPlayerMap::iterator itr = onChengfangUIPlayerMap->begin();
				 itr != onChengfangUIPlayerMap->end(); )
			{
				if(itr->second.empty())
				{
					itr = onChengfangUIPlayerMap->erase(itr);
				}
				else
				{
					ccItr = chengchimap->find(itr->first);
					if(ccItr!=chengchimap->end())
					{
						BattleRoom.resize(0);
						for( OpenBattleMap::iterator oitr = openBattleMap->begin();
							oitr != openBattleMap->end();
							++oitr )
						{
							if( HIINT32(oitr->first) == itr->first )
							{
								remaintime = oitr->second.second.second;
								//ifopen = 1;
								//closeitr = closeBattleSet->find(MAKEINT64(oitr->first,oitr->second.second.first));
								//if (closeitr != closeBattleSet->end())
								//{
								//	ifopen = 0;
								//}
								BattleRoom.push_back(std::make_pair(crVector4ub(LOINT16(LOINT32(oitr->first)),HIINT16(LOINT32(oitr->first)),(unsigned char)(oitr->second.first.first.size()),
									(unsigned char)(oitr->second.first.second.size())),remaintime));
							}
						}
						stream = new crStreamBuf;
						stream->createBuf(3+BattleRoom.size()*8);
						stream->_writeUShort(ccItr->first);//城池id，
						//ccItr->second->buildStream(stream);//12
						//stream->_writeUChar(ccItr->second.first);//势力id
						//stream->_writeUShort(ccItr->second.second);//城防值
						//bsItr = battleScoreMap->find(itr->first);
						//if(bsItr != battleScoreMap->end())
						//{//2*3
						//	ssItr = bsItr->second.find(c_startShiliID);
						//	if(ssItr != bsItr->second.end())
						//	{//势力1胜利次数
						//		stream->_writeShort(ssItr->second.first);
						//	}
						//	else
						//	{
						//		stream->_writeShort(0);
						//	}
						//	ssItr = bsItr->second.find(c_startShiliID+1);
						//	if(ssItr != bsItr->second.end())
						//	{//势力2胜利次数
						//		stream->_writeShort(ssItr->second.first);
						//	}
						//	else
						//	{
						//		stream->_writeShort(0);
						//	}
						//	ssItr = bsItr->second.find(c_startShiliID+2);
						//	if(ssItr != bsItr->second.end())
						//	{//势力3胜利次数
						//		stream->_writeShort(ssItr->second.first);
						//	}
						//	else
						//	{
						//		stream->_writeShort(0);
						//	}
						//}
						//else
						//{
						//	stream->_writeShort(0);
						//	stream->_writeShort(0);
						//	stream->_writeShort(0);
						//}
						stream->_writeUChar(BattleRoom.size());//已经开启的房间数量
						for( ChengfangInfovec::iterator brItr = BattleRoom.begin();
							brItr != BattleRoom.end();
							++brItr )
						{////已经开启的房间信息
							stream->_writeVec4ub(brItr->first);//攻防势力ID，攻方人数，守方人数
							stream->_writeFloat(brItr->second);//剩余时间
							//stream->_writeBool(brItr->second.second);//是否开启
						}
						crPlayerDataEventPacket::buildReplyPacket(packet,0,WCH_JXJRecvChengfangInfo,stream.get());
						packetStream = packet.getStreamBuf();
						bufsize = packetStream->getBufSize();
						for( OnChengfangUIPlayerSet::iterator cfItr = itr->second.begin();
							cfItr != itr->second.end();
							/*++cfItr*/ )
						{
							playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(*cfItr));
							if(playerData.valid() && playerData->getSceneID()==0)
							{
								packetStream->seekBegin();
								packetStream->_writeInt(*cfItr);
								packetStream->setBufSize(bufsize);
								netManager->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
								++cfItr;
							}
							else
							{
								cfItr = itr->second.erase(cfItr);
							}
						}
					}
					++itr;
				}
			}
		}
	}
	data->excHandle(MAKECREPARAM(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRecvChengfangInfoMethod
//
/////////////////////////////////////////
crJXJRecvChengfangInfoMethod::crJXJRecvChengfangInfoMethod():
	m_netType(GameClient_Game){}
crJXJRecvChengfangInfoMethod::crJXJRecvChengfangInfoMethod(const crJXJRecvChengfangInfoMethod& handle):
	crMethod(handle),
	m_battlecanvas(handle.m_battlecanvas)
{
}
void crJXJRecvChengfangInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvChengfangInfoMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_battlecanvas = str;
		break;
	}
}

void crJXJRecvChengfangInfoMethod::operator()(crHandle &handle)
{
	if(m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			unsigned short chengchiid = m_stream -> _readUShort();//城池ID
			//unsigned char shiliid = m_stream -> _readUChar(); // 守方势力ID
			//unsigned short chengfang = m_stream -> _readUShort();//城防值
			//unsigned short shiliwin1 = m_stream -> _readUShort();//势力1胜利次数
			//unsigned short shiliwin2 = m_stream -> _readUShort();//势力2胜利次数
			//unsigned short shiliwin3 = m_stream -> _readUShort();//势力3胜利次数
			unsigned char roomnum = m_stream -> _readUChar();//已开启的房间数

			void *param;
			crVector4ub v4ub;
			float remaintime = 0.0f;
			crCanvasNode* battlecanvas = crFilterRenderManager::getInstance()->findCanvas(m_battlecanvas);
			if (battlecanvas)
			{
				crData *canvasdata = battlecanvas->getDataClass();
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
				canvasdata -> inputParam(WCHDATA_JXJChengfangChengchiid,&chengchiid);
				//canvasdata -> inputParam(WCHDATA_JXJChengfangDefendShiliid,&shiliid);
				//canvasdata -> inputParam(WCHDATA_JXJChengfangNum,&chengfang);
				//canvasdata -> inputParam(WCHDATA_JXJChengfangWin1,&shiliwin1);
				//canvasdata -> inputParam(WCHDATA_JXJChengfangWin2,&shiliwin2);
				//canvasdata -> inputParam(WCHDATA_JXJChengfangWin3,&shiliwin3);
				//canvasdata -> inputParam(WCHDATA_JXJChengfangOpenRoomNum,&roomnum);
				canvasdata -> getParam(WCHDATA_JXJChengfanginfovec,param);
				ChengfangInfovec *chengfanginfovec = (ChengfangInfovec *)param;
				chengfanginfovec->clear();
				crVector4ub v4ub;
				for (int i = 0 ; i < roomnum; i++)
				{
					v4ub = m_stream -> _readVec4ub();//攻方势力ID，守方势力ID,攻方人数，守方人数
					remaintime = m_stream -> _readFloat();
					chengfanginfovec->push_back(std::make_pair(v4ub,remaintime));
					//v4ub = m_stream -> _readVec4ub();//攻方势力ID，攻方人数，守方人数,是否可进入
					//chengfanginfovec->push_back(v4ub);
				}
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			}

		}
	}
}
/////////////////////////////////////////
//
//crJXJLeaveChengfangUIMethod
//
/////////////////////////////////////////
crJXJLeaveChengfangUIMethod::crJXJLeaveChengfangUIMethod()
{
}
crJXJLeaveChengfangUIMethod::crJXJLeaveChengfangUIMethod(const crJXJLeaveChengfangUIMethod& handle):
	crMethod(handle)
{
}
void crJXJLeaveChengfangUIMethod::inputParam(int i, void *param)
{
}
void crJXJLeaveChengfangUIMethod::addParam(int i, const std::string& str)
{
}
void crJXJLeaveChengfangUIMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if (netConductor)
		{
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvLeaveChengfangUI,NULL);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvLeaveChengfangUIMethod
//
/////////////////////////////////////////
crJXJRecvLeaveChengfangUIMethod::crJXJRecvLeaveChengfangUIMethod():
	m_netType(GameClient_Game){}
crJXJRecvLeaveChengfangUIMethod::crJXJRecvLeaveChengfangUIMethod(const crJXJRecvLeaveChengfangUIMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvLeaveChengfangUIMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvLeaveChengfangUIMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvLeaveChengfangUIMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			void *param;
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
			gsBrainData->getParam(WCHDATA_JXJOnChengfangUIPlayerMap,param);
			OnChengfangUIPlayerMap *onChengfangUIPlayerMap = (OnChengfangUIPlayerMap *)param;
			OnChengfangUIPlayerSet::iterator cfItr;
			for( OnChengfangUIPlayerMap::iterator itr = onChengfangUIPlayerMap->begin();
				 itr != onChengfangUIPlayerMap->end();
				 ++itr )
			{
				cfItr = itr->second.find(playerid);
				if(cfItr != itr->second.end())
				{
					itr->second.erase(cfItr);
					break;
				}
			}
			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJBattleLineUpCanvasUpdateMethod
//
/////////////////////////////////////////
crJXJBattleLineUpCanvasUpdateMethod::crJXJBattleLineUpCanvasUpdateMethod():
	m_this(NULL)
{
}
crJXJBattleLineUpCanvasUpdateMethod::crJXJBattleLineUpCanvasUpdateMethod(const crJXJBattleLineUpCanvasUpdateMethod& handle):
	crMethod(handle),
	m_nameinput(handle.m_nameinput),
	m_gongtotal(handle.m_gongtotal),
	m_shoutotal(handle.m_shoutotal),
	m_chengfanginput(handle.m_chengfanginput),
	m_lineupbtn(handle.m_lineupbtn),
	m_lineupsw(handle.m_lineupsw),
	m_defendshilisw(handle.m_defendshilisw)
{
	for(int i = 0; i < 12; i++)
	{
		m_playerinput[i] = handle.m_playerinput[i];
		m_battlenameinput[i] = handle.m_battlenameinput[i];
		m_battleinfo[i] = handle.m_battleinfo[i];
		m_battlingsw[i] = handle.m_battlingsw[i];
		m_battlewinsw[i] = handle.m_battlewinsw[i];
		if (i < 3)
		{
			m_shilichengfangsw[i] = handle.m_shilichengfangsw[i];
			m_shilichengfanginput[i] = handle.m_shilichengfanginput[i];
		}
	}
}
void crJXJBattleLineUpCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJBattleLineUpCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_nameinput = str;
		break;
	case 1:
		m_gongtotal = str;
		break;
	case 2:
		m_shoutotal = str;
		break;
	case 3:
		m_chengfanginput = str;
		break;
	case 4:
		m_playerinput[i - 4] = str;
		break;
	case 5:
		m_playerinput[i - 4] = str;
		break;
	case 6:
		m_playerinput[i - 4] = str;
		break;
	case 7:
		m_playerinput[i - 4] = str;
		break;
	case 8:
		m_playerinput[i - 4] = str;
		break;
	case 9:
		m_playerinput[i - 4] = str;
		break;
	case 10:
		m_playerinput[i - 4] = str;
		break;
	case 11:
		m_playerinput[i - 4] = str;
		break;
	case 12:
		m_playerinput[i - 4] = str;
		break;
	case 13:
		m_playerinput[i - 4] = str;
		break;
	case 14:
		m_playerinput[i - 4] = str;
		break;
	case 15:
		m_playerinput[i - 4] = str;
		break;
	case 16:
		m_battlenameinput[i - 16] = str;
		break;
	case 17:
		m_battlenameinput[i - 16] = str;
		break;
	case 18:
		m_battlenameinput[i - 16] = str;
		break;
	case 19:
		m_battlenameinput[i - 16] = str;
		break;
	case 20:
		m_battlenameinput[i - 16] = str;
		break;
	case 21:
		m_battlenameinput[i - 16] = str;
		break;
	case 22:
		m_battlenameinput[i - 16] = str;
		break;
	case 23:
		m_battlenameinput[i - 16] = str;
		break;
	case 24:
		m_battlenameinput[i - 16] = str;
		break;
	case 25:
		m_battlenameinput[i - 16] = str;
		break;
	case 26:
		m_battlenameinput[i - 16] = str;
		break;
	case 27:
		m_battlenameinput[i - 16] = str;
		break;
	case 28:
		m_battleinfo[i - 28] = str;
		break;
	case 29:
		m_battleinfo[i - 28] = str;
		break;
	case 30:
		m_battleinfo[i - 28] = str;
		break;
	case 31:
		m_battleinfo[i - 28] = str;
		break;
	case 32:
		m_battleinfo[i - 28] = str;
		break;
	case 33:
		m_battleinfo[i - 28] = str;
		break;
	case 34:
		m_battleinfo[i - 28] = str;
		break;
	case 35:
		m_battleinfo[i - 28] = str;
		break;
	case 36:
		m_battleinfo[i - 28] = str;
		break;
	case 37:
		m_battleinfo[i - 28] = str;
		break;
	case 38:
		m_battleinfo[i - 28] = str;
		break;
	case 39:
		m_battleinfo[i - 28] = str;
		break;
	case 40:
		m_lineupbtn = str;
		break;
	case 41:
		m_battlingsw[i - 41] = str;
		break;
	case 42:
		m_battlingsw[i - 41] = str;
		break;
	case 43:
		m_battlingsw[i - 41] = str;
		break;
	case 44:
		m_battlingsw[i - 41] = str;
		break;
	case 45:
		m_battlingsw[i - 41] = str;
		break;
	case 46:
		m_battlingsw[i - 41] = str;
		break;
	case 47:
		m_battlingsw[i - 41] = str;
		break;
	case 48:
		m_battlingsw[i - 41] = str;
		break;
	case 49:
		m_battlingsw[i - 41] = str;
		break;
	case 50:
		m_battlingsw[i - 41] = str;
		break;
	case 51:
		m_battlingsw[i - 41] = str;
		break;
	case 52:
		m_battlingsw[i - 41] = str;
		break;
	case 53:
		m_battlewinsw[i - 53] = str;
		break;
	case 54:
		m_battlewinsw[i - 53] = str;
		break;
	case 55:
		m_battlewinsw[i - 53] = str;
		break;
	case 56:
		m_battlewinsw[i - 53] = str;
		break;
	case 57:
		m_battlewinsw[i - 53] = str;
		break;
	case 58:
		m_battlewinsw[i - 53] = str;
		break;
	case 59:
		m_battlewinsw[i - 53] = str;
		break;
	case 60:
		m_battlewinsw[i - 53] = str;
		break;
	case 61:
		m_battlewinsw[i - 53] = str;
		break;
	case 62:
		m_battlewinsw[i - 53] = str;
		break;
	case 63:
		m_battlewinsw[i - 53] = str;
		break;
	case 64:
		m_battlewinsw[i - 53] = str;
		break;
	case 65:
		m_shilichengfangsw[i - 65] = str;
		break;
	case 66:
		m_shilichengfangsw[i - 65] = str;
		break;
	case 67:
		m_shilichengfangsw[i - 65] = str;
		break;
	case 68:
		m_shilichengfanginput[i - 68] = str;
		break;
	case 69:
		m_shilichengfanginput[i - 68] = str;
		break;
	case 70:
		m_shilichengfanginput[i - 68] = str;
		break;
	case 71:
		m_lineupsw = str;
		break;
	case 72:
		m_defendshilisw = str;
		break;
	case 73:
		m_defendshu1 = str;
		break;
	case 74:
		m_defendwu1 = str;
		break;
	case 75:
		m_defendwei1 = str;
		break;
	case 76:
		m_defendshu2 = str;
		break;
	}
}
void crJXJBattleLineUpCanvasUpdateMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		void *param;
		crData *data = myPlayer->getDataClass();
		crData *canvasdata = m_this->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
		canvasdata -> getParam(WCHDATA_JXJChengfangChengchiid,param);
		unsigned short chengchiid = *(unsigned short *)param;//城池ID
		data->getParam(WCHDATA_JXJChengChiMap,param);
		ChengchiMap *chengchiMap = (ChengchiMap *)param;
		ChengchiMap::iterator ccItr = chengchiMap->find(chengchiid);
		if(ccItr != chengchiMap->end())
		{
			unsigned char chengzhu = ccItr->second->getChengzhuShili();
			unsigned short chengfang = ccItr->second->getChengzhuChengfang();
			crJXJChengfangInfo::ShiliChengfangMap shiliChengfangMap = ccItr->second->getShiliChengfangMap();
			//canvasdata -> getParam(WCHDATA_JXJChengfangDefendShiliid,param);
			//unsigned char shiliid = *(unsigned char *)param; // 守方势力ID
			//canvasdata -> getParam(WCHDATA_JXJChengfangNum,param);
			//unsigned short chengfang = *(unsigned short *)param;//城防值
			//canvasdata -> getParam(WCHDATA_JXJChengfangWin1,param);
			//unsigned short shiliwin1 = *(unsigned short *)param;//势力1胜利次数
			//canvasdata -> getParam(WCHDATA_JXJChengfangWin2,param);
			//unsigned short shiliwin2 = *(unsigned short *)param;//势力2胜利次数
			//canvasdata -> getParam(WCHDATA_JXJChengfangWin3,param);
			//unsigned short shiliwin3 = *(unsigned short *)param;//势力3胜利次数
			//canvasdata -> getParam(WCHDATA_JXJChengfangOpenRoomNum,param);
			//unsigned char roomnum = *(unsigned char *)param;//已开启的房间数
			canvasdata -> getParam(WCHDATA_JXJChengfanginfovec,param);
			ChengfangInfovec chengfanginfovec = *(ChengfangInfovec *)param;//攻方势力ID，攻方人数，守方人数，是否可进入
			canvasdata -> getParam(WCHDATA_JXJRoomStateVec,param);
			RoomStateVec *roomstatevec = (RoomStateVec *)param;//房间开启状态
			//unsigned char lastwin = 0;//今天之前被摧毁的城池
			data -> getParam(WCHDATA_JXJShiliID,param);
			unsigned char myshili = *(unsigned char *)param;//我的势力

			ref_ptr<crButtonWidgetNode> lineupbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_lineupbtn));
			ref_ptr<crStaticTextWidgetNode> nameinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nameinput));
			ref_ptr<crStaticTextWidgetNode> gongtotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_gongtotal));
			ref_ptr<crStaticTextWidgetNode> shoutotal = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_shoutotal));
			ref_ptr<crStaticTextWidgetNode> chengfanginput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_chengfanginput));
			ref_ptr<crMultiSwitch> lineupsw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_lineupsw));
			ref_ptr<crMultiSwitch> defendshilisw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_defendshilisw));
			ref_ptr<crStaticTextWidgetNode> playerinput[12] = {NULL};
			ref_ptr<crStaticTextWidgetNode> battlenameinput[12] = {NULL};
			ref_ptr<crStaticTextWidgetNode> battleinfo[12] = {NULL};
			ref_ptr<crMultiSwitch> battlingsw[12] = { NULL };
			ref_ptr<crMultiSwitch> battlewinsw[12] = { NULL };
			ref_ptr<crMultiSwitch> shilichengfangsw[3] = { NULL };
			ref_ptr<crStaticTextWidgetNode> shilichengfanginput[3] = { NULL };

			ref_ptr<crButtonWidgetNode> defendshu1 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_defendshu1));
			ref_ptr<crButtonWidgetNode> defendwu1 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_defendwu1));
			ref_ptr<crButtonWidgetNode> defendwei1 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_defendwei1));
			ref_ptr<crButtonWidgetNode> deffendshu2 = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_defendshu2));

			roomstatevec->clear();
			if (lineupbtn.valid())
			{
				if (chengfang > 0)
				{
					lineupbtn->setEnable(true);
				}
				else
				{
					lineupbtn->setEnable(false);
				}
			}
			for (int i = 0; i < 12; i++)
			{
				playerinput[i]  = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_playerinput[i]));
				battlenameinput[i]  = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_battlenameinput[i]));
				battleinfo[i]  = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_battleinfo[i]));
				battlingsw[i]  = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_battlingsw[i]));
				battlewinsw[i]  = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_battlewinsw[i]));
				if (playerinput[i].valid())playerinput[i]->clearString();
				if (battlenameinput[i].valid())battlenameinput[i]->clearString();
				if (battleinfo[i].valid())battleinfo[i]->clearString();
				if (battlingsw[i].valid())battlingsw[i]->setActiveSwitchSet(0);
				if (battlewinsw[i].valid())battlewinsw[i]->setActiveSwitchSet(0);
				if (i < 3)
				{
					shilichengfangsw[i] = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_shilichengfangsw[i]));
					shilichengfanginput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_shilichengfanginput[i]));
				}
			}

			ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
			crTableIO::StrVec record;
			//int startShiliID = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJStartShiliID).c_str());
			int maxchengfang = 0;
			int nameindex = chengchiTab->getTitleIndex("名字");
			int chengfindex = chengchiTab->getTitleIndex("城防值");
			if (chengchiTab->queryOneRecord(0,crArgumentParser::appItoa((int)chengchiid),record) >= 0 )
			{
				if (nameinput.valid())
				{
					nameinput -> setString(record[nameindex] + "之战");
				}
				maxchengfang = atoi(record[chengfindex].c_str());
				if (chengfanginput.valid())
				{
					chengfanginput->setString(crArgumentParser::appItoa((int)chengfang)+"/"+record[chengfindex]);
				}
			}
			std::string gongstr = "魏,蜀,吴";
			std::string shoustr = "群";
			unsigned char shili;
			int shilivisible[3] = { 0, 0, 0 };
			if(chengzhu >= c_startShiliID)
			{
				shili = chengzhu - c_startShiliID;
				switch(shili)
				{
				case 0:
					gongstr = "蜀,吴";
					shoustr = "魏";
					//shiliwin1 = 0;
					break;
				case 1:
					gongstr = "魏,吴";
					shoustr = "蜀";
					//shiliwin2 = 0;
					break;
				case 2:
					gongstr = "魏,蜀";
					shoustr = "吴";
					//shiliwin3 = 0;
					break;
				}
			}
			if (gongtotal.valid())
			{
				gongtotal->setString(gongstr);
			}
			if (shoutotal.valid())
			{
				shoutotal->setString(shoustr);
			}
			int cfshiliindex = 0;
			for (crJXJChengfangInfo::ShiliChengfangMap::iterator itr = shiliChengfangMap.begin();
				itr != shiliChengfangMap.end();
				++itr)
			{
				if (itr->second >= c_startShiliID)
				{
					shili = itr->second - c_startShiliID;
					if (shili >= 0 && shili < 3)
					{
						shilivisible[shili] = 1;
						if (shilichengfangsw[cfshiliindex].valid())
						{
							shilichengfangsw[cfshiliindex]->setActiveSwitchSet(shili);
						}
						if (shilichengfanginput[cfshiliindex].valid())
						{
							shilichengfanginput[cfshiliindex]->setString(crArgumentParser::appItoa(itr->first));
						}
					}
					++cfshiliindex;
				}
			}
			//cfshiliindex -= 1;
			for (int i = 0; i < 3; ++i)
			{
				if (shilivisible[i] == 0)
				{
					if (shilichengfangsw[cfshiliindex].valid())
					{
						shilichengfangsw[cfshiliindex]->setActiveSwitchSet(i);
					}
					if (shilichengfanginput[cfshiliindex].valid())
					{
						shilichengfanginput[cfshiliindex]->setString(crArgumentParser::appItoa(0));
					}
					++cfshiliindex;
				}
			}
			//lastwin = (maxchengfang - chengfang)/100 - (shiliwin1 + shiliwin2 +shiliwin3);

			int times = 0;
			int hour = 0;
			int t = 0;
			int minute = 0;
			int s = 0;
			crVector4ub v4ub;
			std::string roominfo;
			crVector4f color;
			int maxcount = maxchengfang/100;
			int chengzhucount = chengfang/100;
			int shilicount;
			int j = 0;
			unsigned char roomstate;
			int i = 0;
			std::vector< std::pair<crVector4ub,float> > RoomInfoVec;//攻势力,守势力,攻人数,守人数,剩余时间
			crVector4ub info;
			float remaintime;
			bool found = false;
			if(chengzhu<c_startShiliID)
			{
				for( ;i<chengzhucount;i++)
				{
					found = false;
					for( ChengfangInfovec::iterator itr = chengfanginfovec.begin();
						 itr != chengfanginfovec.end();
						 ++itr )
					{
						v4ub = itr->first;
						if(v4ub[1] == chengzhu)
						{
							info = v4ub;
							remaintime = itr->second;
							RoomInfoVec.push_back(std::make_pair(info,remaintime));
							chengfanginfovec.erase(itr);
							found = true;
							break;
						}
					}
					if(!found)
					{
						info.set(0,chengzhu,0,0);
						remaintime = 0;
						RoomInfoVec.push_back(std::make_pair(info,remaintime));
					}
				}
				for( crJXJChengfangInfo::ShiliChengfangMap::iterator itr = shiliChengfangMap.begin();
					 itr != shiliChengfangMap.end();
					 ++itr )
				{
					shilicount = itr->first / 100;
					for(j=0;j<shilicount;j++)
					{
						info.set(0,itr->second,0,0);
						remaintime = 0;
						RoomInfoVec.push_back(std::make_pair(info,remaintime));
					}
				}
			}
			else
			{
				for( crJXJChengfangInfo::ShiliChengfangMap::iterator itr = shiliChengfangMap.begin();
					itr != shiliChengfangMap.end();
					++itr )
				{
					shilicount = itr->first / 100;
					for(j=0;j<shilicount;j++)
					{
						found = false;
						for( ChengfangInfovec::iterator citr = chengfanginfovec.begin();
							citr != chengfanginfovec.end();
							++citr )
						{
							v4ub = citr->first;
							if(v4ub[1] == itr->second)
							{
								info = v4ub;
								remaintime = citr->second;
								RoomInfoVec.push_back(std::make_pair(info,remaintime));
								chengfanginfovec.erase(citr);
								found = true;
								break;
							}
						}
						if(!found)
						{
							info.set(0,itr->second,0,0);
							remaintime = 0;
							RoomInfoVec.push_back(std::make_pair(info,remaintime));
						}
					}
				}
			}
			i = 0;
			for( std::vector< std::pair<crVector4ub,float> >::iterator itr = RoomInfoVec.begin();
				 itr != RoomInfoVec.end() && i<12;
				 ++itr,++i )
			{
				color = (crVector4f(1.0f,1.0f,1.0f,1.0f));
				roomstate = RoomStateType_Accessible;
				info = itr->first;
				shili = info[1] - c_startShiliID;
				switch(shili)
				{
				case 0:
					color = (crVector4f(0.0f,0.0f,1.0f,1.0f));
					shoustr = "魏";
					if (battlewinsw[i].valid())battlewinsw[i]->setActiveSwitchSet(1);
					break;
				case 1:
					color = (crVector4f(0.0f,1.0f,0.0f,1.0f));
					shoustr = "蜀";
					if (battlewinsw[i].valid())battlewinsw[i]->setActiveSwitchSet(2);
					break;
				case 2:
					color = (crVector4f(1.0f,0.0f,0.0f,1.0f));
					shoustr = "吴";
					if (battlewinsw[i].valid())battlewinsw[i]->setActiveSwitchSet(3);
					break;
				default:
					shoustr = "群";
					if (battlewinsw[i].valid())battlewinsw[i]->setActiveSwitchSet(0);
					break;
				}
				if(info[0] == 0)
				{//未开启
					//roominfo = "未开启";
					roominfo = shoustr;
					if (battlingsw[i].valid())battlingsw[i]->setActiveSwitchSet(1);
				}
				else
				{
					//roominfo = "进行中…";
					shili = info[0] - c_startShiliID;
					switch(shili)
					{
					case 0:
						gongstr = "魏";
						break;
					case 1:
						gongstr = "蜀";
						break;
					case 2:
						gongstr = "吴";
						break;
					default:
						gongstr = "群";
						break;
					}
					if (battlingsw[i].valid())battlingsw[i]->setActiveSwitchSet(2);
				}
				if (info[0] > 0)
				{
					if (playerinput[i].valid())
					{
						std::string str;
						int code = 1137;
						if (info[0] == myshili)
						{
							if (info[3] == 0)
							{
								code = 1134;
							}
							else if (info[3] <= 5)
							{
								code = 1135;
							}
							else if (info[3] <= 10)
							{
								code = 1136;
							}
							ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
							crTableIO::StrVec record;
							if (textTab->queryOneRecord(0, crArgumentParser::appItoa(code), record) >= 0)
							{
								str = gongstr + ":" + crArgumentParser::appItoa(info[2]) + " " + shoustr + ":" + record[1];
							}
						}
						else if (info[1] == myshili)
						{
							if (info[2] == 0)
							{
								code = 1134;
							}
							else if (info[2] <= 5)
							{
								code = 1135;
							}
							else if (info[2] <= 10)
							{
								code = 1136;
							}
							ref_ptr<crTableIO> textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
							crTableIO::StrVec record;
							if (textTab->queryOneRecord(0, crArgumentParser::appItoa(code), record) >= 0)
							{
								str = gongstr + ":" + record[1] + " " + shoustr + ":" + crArgumentParser::appItoa(info[3]);
							}
						}
						else
						{
							str = gongstr + ":" + crArgumentParser::appItoa(info[2]) + " " + shoustr + ":" + crArgumentParser::appItoa(info[3]);
						}
						playerinput[i]->setString(str);
					}
					//显示战场剩余时间
					times = (int)(itr->second);
					hour = times/3600;
					t = times%3600;
					minute = t/60;
					s = t%60;
					roominfo = crArgumentParser::appItoa(hour) + ":" + crArgumentParser::appItoa(minute);
					if(info[0]!=myshili && info[1]!=myshili)
					{//进攻方不是我方
						roomstate = RoomStateType_NotOur;
						color = (crVector4f(1.0f,0.1f,0.2f,1.0f));//进攻方和守方都不是我方
					}
					else if(minute < 5)
					{//剩余时间小于5分钟不可进入
						roomstate = RoomStateType_NotEnoughTime;
						color = (crVector4f(1.0f,0.1f,0.2f,1.0f));//剩余时间小于5分钟不可进入
					}
					else
					{
						color = (crVector4f(0.0f,1.0f,1.0f,1.0f));
					}
				}

				if(battlenameinput[i].valid())battlenameinput[i]->setString(record[nameindex] + "之战"+crArgumentParser::appItoa(i+1));
				if(battleinfo[i].valid())
				{	
					battleinfo[i]->setColor(color);
					battleinfo[i]->setString(roominfo);
				}
				roomstatevec->push_back(roomstate);
			}
			if (lineupsw.valid() && defendshilisw.valid())
			{
				if (chengzhu == myshili)
				{
					lineupsw->setActiveSwitchSet(1);
					switch (myshili - c_startShiliID)
					{
					case 0:
						{
							defendshilisw->setActiveSwitchSet(0);
							if(gongstr=="蜀" && defendwu1.valid())
								defendwu1->setEnable(false);
							else if(gongstr=="吴" && defendshu1.valid())
								defendshu1->setEnable(false);
						}
						break;
					case 1:
						{
							defendshilisw->setActiveSwitchSet(1);
							if(gongstr=="吴" && defendwei1.valid())
								defendwei1->setEnable(false);
							else if(gongstr=="魏" && defendwu1.valid())
								defendwu1->setEnable(false);
						}
						break;
					case 2:
						{
							defendshilisw->setActiveSwitchSet(2);
							if(gongstr=="魏" && deffendshu2.valid())
								deffendshu2->setEnable(false);
							else if(gongstr=="蜀" && defendwei1.valid())
								defendwei1->setEnable(false);
						}
						break;
					}
				}
				else
				{
					lineupsw->setActiveSwitchSet(0);
				}
			}
			//for (int i = 0;i<maxcount && i < 12;i++)
			//{
			//	roomstate = RoomStateType_Accessible;
			//	color = (crVector4f(1.0f,1.0f,1.0f,1.0f));
			//	roominfo = "未开启";
			//	if (i < lastwin)
			//	{
			//		roominfo = "已摧毁";
			//		color = (crVector4f(0.0f,0.0f,0.0f,1.0f));
			//		if (battlingsw[i])battlingsw[i]->setActiveSwitchSet(2);
			//		if (battlewinsw[i])battlewinsw[i]->setActiveSwitchSet(4);
			//	}
			//	else if (i < lastwin + shiliwin1)
			//	{
			//		roominfo = "魏国胜利";
			//		color = (crVector4f(0.0f,0.0f,1.0f,1.0f));
			//		if (battlingsw[i])battlingsw[i]->setActiveSwitchSet(2);
			//		if (battlewinsw[i])battlewinsw[i]->setActiveSwitchSet(1);
			//	}
			//	else if (i < lastwin + shiliwin1 + shiliwin2)
			//	{
			//		roominfo = "蜀国胜利";
			//		color = (crVector4f(0.0f,1.0f,0.0f,1.0f));
			//		if (battlingsw[i])battlingsw[i]->setActiveSwitchSet(2);
			//		if (battlewinsw[i])battlewinsw[i]->setActiveSwitchSet(2);
			//	}
			//	else if (i < lastwin + shiliwin1 + shiliwin2 + shiliwin3)
			//	{
			//		roominfo = "吴国胜利";
			//		color = (crVector4f(1.0f,0.0f,0.0f,1.0f));
			//		if (battlingsw[i])battlingsw[i]->setActiveSwitchSet(2);
			//		if (battlewinsw[i])battlewinsw[i]->setActiveSwitchSet(3);
			//	}
			//	else if(i < lastwin + shiliwin1 + shiliwin2 + shiliwin3 + roomnum)
			//	{

			//		roomstatevec->push_back(roomstate);
			//		j++;
			//	}
			//	if(battlenameinput[i].valid())battlenameinput[i]->setString(record[nameindex] + "之战"+crArgumentParser::appItoa(i+1));
			//	if(battleinfo[i].valid())
			//	{	
			//		battleinfo[i]->setColor(color);
			//		battleinfo[i]->setString(roominfo);
			//	}
			//}
			//if (gongtotal.valid())
			//{
			//	gongtotal->setString(gongstr);
			//}
			//if (shoutotal.valid())
			//{
			//	shoutotal->setString(shoustr);
			//}
		}
		canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJBattleTimerUpdateMethod
//
/////////////////////////////////////////
crJXJBattleTimerUpdateMethod::crJXJBattleTimerUpdateMethod():
	m_this(NULL),
	m_mintime(0)
{
}
crJXJBattleTimerUpdateMethod::crJXJBattleTimerUpdateMethod(const crJXJBattleTimerUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_battleTimer(handle.m_battleTimer),
	m_battlecanvas(handle.m_battlecanvas)
{
}
void crJXJBattleTimerUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJBattleTimerUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_battleTimer = str;
		break;
	case 1:
		m_battlecanvas = str;
		break;
	case 2:
		m_mintime = atoi(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJBattleTimerUpdateMethod::operator()(crHandle &handle)
{
	if (!m_this)
	{
		return;
	}
	ref_ptr<crStaticTextWidgetNode> battleTimer = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_battleTimer));
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!playerData) return;
	crData *data = playerData->getDataClass();
	ref_ptr<crCanvasNode>battlecanvas = crFilterRenderManager::getInstance()->findCanvas(m_battlecanvas);

	if (!battlecanvas)
	{
		return;
	}
	//crData *canvasdata = battlecanvas->getDataClass();

	void *param;
	//canvasdata->getParam(WCHDATA_JXJBattleUIType, param);
	//int select = *(int *)param;
	int time = 0;
	bool isopened = false;
	//if(select == BT_CityBattle)
	//{
		data->getParam(WCHDATA_JXJOpenBattle,param);
		isopened = *(bool *)param;
		data->getParam(WCHDATA_JXJBattleTimer,param);
		time = *(int *)param;
	//}
	//else if(select == BT_GateBattle)
	//{
	//	data->getParam(WCHDATA_JXJOpenPass,param);
	//	isopened = *(bool *)param;
	//	data->getParam(WCHDATA_JXJPassTimer,param);
	//	time = *(short *)param;
	//}

	if(isopened)
	{
		int t;
		int hour,minute,s;
		hour = time/3600;
		t = time%3600;
		minute = t/60;
		s = t%60;
		if(time<=m_mintime)
		{
			if(battleTimer.valid())battleTimer->setColor(crVector4(1,0,0,1));
		}
		else
		{
			if(battleTimer.valid())battleTimer->setColor(crVector4(0,0,0,1));
		}
		if (battleTimer.valid())battleTimer->setString(crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s));
	}
	else
	{
		if(battleTimer.valid())
		{
			battleTimer->setColor(crVector4(0,0,0,1));
			//battleTimer->setString(L"00:00:00");
			battleTimer->setString(L"全天");
		}
	}
}
/////////////////////////////////////////
//
//crJXJCloseAllSelectCanvasMethod
//
/////////////////////////////////////////
crJXJCloseAllSelectCanvasMethod::crJXJCloseAllSelectCanvasMethod()
{
}
crJXJCloseAllSelectCanvasMethod::crJXJCloseAllSelectCanvasMethod(const crJXJCloseAllSelectCanvasMethod& handle):
	crMethod(handle)
{
	m_canvasVec = handle.m_canvasVec;
}
void crJXJCloseAllSelectCanvasMethod::inputParam(int i, void *param)
{
}
void crJXJCloseAllSelectCanvasMethod::addParam(int i, const std::string& str)
{
	m_canvasVec.push_back(str);
}
void crJXJCloseAllSelectCanvasMethod::operator()(crHandle &handle)
{
	for (int i = 0; i < m_canvasVec.size();i++)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasVec[i]);
		if (canvas.valid() && canvas->getVisiable())
		{
			crFilterRenderManager::getInstance()->closeCanvas(canvas.get());
		}
	}
}
/////////////////////////////////////////
//
//crJXJBattleCanvasUpdateMethod
//
/////////////////////////////////////////
crJXJBattleCanvasUpdateMethod::crJXJBattleCanvasUpdateMethod()
{
}
crJXJBattleCanvasUpdateMethod::crJXJBattleCanvasUpdateMethod(const crJXJBattleCanvasUpdateMethod& handle):
	crMethod(handle)
{
}
void crJXJBattleCanvasUpdateMethod::inputParam(int i, void *param)
{
}
void crJXJBattleCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas[i] = str;
		break;
	case 1:
		m_canvas[i] = str;
		break;
	default:
		break;
	}
}
void crJXJBattleCanvasUpdateMethod::operator()(crHandle &handle)
{
	for (int i = 0; i < 2; i++)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas[i]);
		if (canvas.valid() && canvas -> getVisiable())
		{
			crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
		}
	}
	//canvas->doEvent(WCH_UI_UpdateData);
}

/////////////////////////////////////////
//
//crJXJUIClearPunishTimeMethod
//
/////////////////////////////////////////
crJXJUIClearPunishTimeMethod::crJXJUIClearPunishTimeMethod()
{
}
crJXJUIClearPunishTimeMethod::crJXJUIClearPunishTimeMethod(const crJXJUIClearPunishTimeMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok)
{
}
void crJXJUIClearPunishTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIClearPunishTimeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_tipcanvas = str;
		break;
	case 2:
		m_tipcontent = str;
		break;
	case 3:
		m_msgbox = str;
		break;
	case 4:
		m_title = str;
		break;
	case 5:
		m_msg = str;
		break;
	case 6:
		m_ok = str;
		break;
	default:
		break;
	}
}
void crJXJUIClearPunishTimeMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && myPlayer->getDataClass())
	{
		void *param;
		bool canbuy = false;
		int needgold= 0;
		//ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		crData *playerData = myPlayer->getDataClass();
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if(canvas.valid() && canvas->getDataClass())
		{
			playerData->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int curgoldmin = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCurPunishMinCostGold,viplv).c_str());
			crData *canvasdata = canvas->getDataClass();
			canvasdata->getParam(WCHDATA_JXJBattlePunishTime,param);
			short punishtime = *(short *)param;
			needgold = (1 + punishtime/60) * curgoldmin;
			canvasdata->inputParam(WCHDATA_JXJClearPunishTimeNeedGold,&needgold);

			playerData->getParam(WCHDATA_JXJGoldingot,param);
			int goldingot = *(int*)param;
			playerData->getParam(WCHDATA_JXJGiftGold,param);
			int giftgold = *(int*)param;
			goldingot += giftgold;
			if (goldingot >= needgold)
			{
				canbuy = true;
			}
		}
		if (canbuy)
		{
			playerData->getParam(WCHDATA_JXJGoldCostHintInt,param);
			unsigned int ifhint = *(unsigned int *)param & JXJGoldCostType_DeserterCDHint;
			ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
			ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
			ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
			ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
			if (ifhint)
			{
				int hinttype = JXJGoldCostType_DeserterCDHint;
				crData *braindata = crBrain::getInstance()->getDataClass();
				braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);
				std::vector<float>v_i;
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content");
				cfg_script.Add("Text","您确认要花费");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",2);
				v_i.clear();
				v_i.push_back(140.0);
				v_i.push_back(40.0);
				v_i.push_back(40.0);
				v_i.push_back(255.0);
				cfg_script.Add("Color",v_i);
				char tmpText[20];
				sprintf(tmpText,"%d礼金/元宝\0",needgold);
				cfg_script.Add("Text",tmpText);
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",3);
				cfg_script.Add("Text","去除惩罚时间吗？");
				cfg_script.Pop();

				cfg_script.Pop();
				if(msg.valid())msg->setHypertext(cfg_script);
			}
			if(okBtn.valid())okBtn->setEnable(true);
			if (msgCanvas.valid())
			{
				crData *dlgData = msgCanvas->getDataClass();
				int commandtype = CDP_Widget;
				dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
				dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
				if (ifhint)
				{
					crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
				}
				else
				{
					if(okBtn.valid())okBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
				}
			}
		}
		else
		{
			std::string tipstr = "元宝不足,请充值!";
			if (needgold == 0)
			{
				tipstr = "惩罚时间已结束，可以进入战场了！";
			}
			ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
			if (tipcanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
				if (tipcontent.valid())
				{
					tipcontent->setString(tipstr);
				}
				crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJClearPunishTimeMethod
//
/////////////////////////////////////////
crJXJClearPunishTimeMethod::crJXJClearPunishTimeMethod():
	m_this(NULL)
{
}
crJXJClearPunishTimeMethod::crJXJClearPunishTimeMethod(const crJXJClearPunishTimeMethod& handle):
	crMethod(handle)
{
}
void crJXJClearPunishTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJClearPunishTimeMethod::addParam(int i, const std::string& str)
{
}
void crJXJClearPunishTimeMethod::operator()(crHandle &handle)
{	
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (canvas.valid() && canvas->getDataClass())
	{
		//ref_ptr<crTableIO> itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		//std::vector<std::string> record;
		//itemtab->queryOneRecord(2,"召集令",record);
		//int id = atoi(record[0].c_str());

		void *param;
		crData *canvasdata = canvas->getDataClass();
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);

		crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
		playerData->getParam(WCHDATA_JXJItemBagVec,param);
		JXJItemBagVec *itemBagVec = (JXJItemBagVec *)param;
		int count = 0;
		for (int i=0;i<itemBagVec->size();i++)
		{
			if((*itemBagVec)[i].valid())
			{
				if ((*itemBagVec)[i]->getItemID() == DuZhanLing/*7522*/)
				{
					count += (*itemBagVec)[i]->getItemCount();
				}
			}
		}

		if(netConductor && count==0)
		{
			canvasdata->getParam(WCHDATA_JXJClearPunishTimeNeedGold,param);
			int goldneed = *(int *)param;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(goldneed);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvClearPunishTime,stream.get());
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		else
		{
			int timesid = WCHDATA_JXJRecruitTime3+1;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(timesid);

			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUseJianZhuLing,stream.get());
			if(netConductor)
				netConductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvClearPunishTimeMethod
//
/////////////////////////////////////////
crJXJRecvClearPunishTimeMethod::crJXJRecvClearPunishTimeMethod():
	m_netType(GameClient_Game),
	m_delayHideWidgetTime(0)
{}
crJXJRecvClearPunishTimeMethod::crJXJRecvClearPunishTimeMethod(const crJXJRecvClearPunishTimeMethod& handle):
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent),
	m_punishcanvas(handle.m_punishcanvas),
	m_delayHideWidgetTime(handle.m_delayHideWidgetTime),
	m_manorTaskBar_cavas(handle.m_manorTaskBar_cavas)
{
}
void crJXJRecvClearPunishTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvClearPunishTimeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tipcontent = str;
		break;
	case 2:
		m_punishcanvas = str;
		break;
	case 3:
		m_delayHideWidgetTime = atoi(str.c_str());
		break;
	case 4:
		m_manorTaskBar_cavas = str;
		break;
	default:
		break;
	}
}

void crJXJRecvClearPunishTimeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned char success = 0;
				void *param;
				int goldneed = m_stream->_readInt();
				int goldneedsever = 0;
				bool needdeductgold = false;
				m_this->getDataClass()->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				int curgoldmin = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCurPunishMinCostGold,viplv).c_str());
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJBattleDropPlayerMap,param);
				BattleDropPlayerMap *battleDropPlayerMap = (BattleDropPlayerMap *)param;
				BattleDropPlayerMap::iterator itr;
				itr = battleDropPlayerMap->find(playerid);
				if (itr!=battleDropPlayerMap->end())
				{
					goldneedsever = (itr->second.second/60 + 1) * curgoldmin;
					if (goldneed >= goldneedsever - curgoldmin)
					{
						MoneyChangeData moneydata(goldneed,"秒逃兵时间");
						m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
						if (moneydata.first == 0)
						{
							battleDropPlayerMap->erase(itr);
							success = 1;//秒时间成功
						}
					}
				}
				else
				{
				//	MoneyChangeData moneydata(goldneed,"秒逃兵时间");
				//	m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
				//	if (moneydata.first == 0)
				//	{
						success = 1;
				//	}
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
				if (success == 1)
				{
					if (needdeductgold)
					{
						crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
						callback->savePlayerData(playerData.get());
					}
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1);
				stream->_writeUChar(success);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvClearPunishTime,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = crArgumentParser::appItoa(success);
				GameLogData gamelog(Log_ClearPunishTime,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream -> _readUChar();
			std::string tipstr = "元宝不足,请充值!";
			if (success)
			{
				tipstr = "清除惩罚时间成功！您可以再次进入战场了！";
				ref_ptr<crCanvasNode>punishcanvas = crFilterRenderManager::getInstance()->findCanvas(m_punishcanvas);
				if (punishcanvas.valid())
				{
					crFilterRenderManager::getInstance()->closeCanvas(punishcanvas.get());
					crData *canvasdata = punishcanvas->getDataClass();
					canvasdata->inputParam(WCHDATA_JXJBattlePunishTime,0);
				}
			}
			ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
			ref_ptr<crCanvasNode> manorTaskBar_cavas = crFilterRenderManager::getInstance()->findCanvas(m_manorTaskBar_cavas);
			if (tipcanvas.valid() && manorTaskBar_cavas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
				if (tipcontent.valid())
				{
					tipcontent->setString(tipstr);
					tipcontent->setVisiable(true);
				}
				const crBoundingBox &tipsbox = tipcanvas->getBoundBox();
				const crBoundingBox &taskCavasbox = manorTaskBar_cavas->getBoundBox();
				tipcanvas->setMatrix(crMatrix::translate(taskCavasbox.xMin() + tipsbox.xLength()*0.5f, taskCavasbox.yMax() - tipsbox.yLength()*0.5f, 0.0f));
				crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
				crData *braindata = crBrain::getInstance()->getDataClass();
				braindata->inputParam(WCHDATA_JXJDelayHideWidgetTime, &m_delayHideWidgetTime);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGameDeleteFriendMethod
//
/////////////////////////////////////////
crJXJUIGameDeleteFriendMethod::crJXJUIGameDeleteFriendMethod():
	m_index(0)
{
}

crJXJUIGameDeleteFriendMethod::crJXJUIGameDeleteFriendMethod(const crJXJUIGameDeleteFriendMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_friendlist(handle.m_friendlist),
	m_index(handle.m_index),
	m_groupcanvas(handle.m_groupcanvas)
{
}

void crJXJUIGameDeleteFriendMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIGameDeleteFriendMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		m_friendlist = str;
		break;
	case 5:
		m_index = atoi(str.c_str());
		break;
	case 6:
		m_groupcanvas = str;
		break;
	}
}

void crJXJUIGameDeleteFriendMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerData)
	{
		ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
		if (msgCanvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
			ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
			ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));

			std::string name;
			if (m_index == 0)
			{
				ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
				ref_ptr<crTableWidgetNode> friendList = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_friendlist));
				if (friendList.valid())
				{
					crFriend *myfriend = (crFriend *)(friendList->getSelectData());
					if (myfriend)
					{
						name = myfriend->getName();
					}
				}
			}
			else if(m_index == 1)
			{
				ref_ptr<crCanvasNode>groupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_groupcanvas);
				if (groupcanvas.valid())
				{
					crData *canvasdata = groupcanvas->getDataClass();
					canvasdata->getParam(WCHDATA_JXJMyGroupSelPlayData,param);
					crJXJConsortiaMember *memberplayerData = (crJXJConsortiaMember *)param;
					name = memberplayerData->getName();
				}
			}
			std::vector<float>v_i;
			ItemMap itemMap;
			rcfg::ConfigScript cfg_script(&itemMap);
			if (name.size())
			{
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				cfg_script.Add("Content");
				cfg_script.Push("Content");
				cfg_script.Add("Text","您确认要删除");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",2);
				v_i.clear();
				v_i.push_back(0.0);
				v_i.push_back(255.0);
				v_i.push_back(255.0);
				v_i.push_back(255.0);
				cfg_script.Add("Color",v_i);
				char tmpText[20];
				sprintf(tmpText,"【%s】\0",name.c_str());
				cfg_script.Add("Text",tmpText);
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",3);
				cfg_script.Add("Text","吗？");
				cfg_script.Pop();

				cfg_script.Pop();
				if(msg.valid())msg->setHypertext(cfg_script);
				if(okBtn.valid())okBtn->setEnable(true);
				if (msgCanvas.valid())
				{
					crData *dlgData = msgCanvas->getDataClass();
					int commandtype = CDP_Widget;
					dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
					dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
					crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
				}
			}
		}
		
	}
}
/////////////////////////////////////////
//
//crJXJBattleSetMultiSwitchActiveMethod
//
/////////////////////////////////////////
crJXJBattleSetMultiSwitchActiveMethod::crJXJBattleSetMultiSwitchActiveMethod()
{
}

crJXJBattleSetMultiSwitchActiveMethod::crJXJBattleSetMultiSwitchActiveMethod(const crJXJBattleSetMultiSwitchActiveMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_switch(handle.m_switch),
	m_zoom(handle.m_zoom),
	m_enlarge(handle.m_enlarge)
{
}

void crJXJBattleSetMultiSwitchActiveMethod::inputParam(int i, void *param)
{
}

void crJXJBattleSetMultiSwitchActiveMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_switch = str;
		break;
	case 2:
		m_zoom = str;
		break;
	case 3:
		m_enlarge = str;
		break;
	}
}

void crJXJBattleSetMultiSwitchActiveMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerData)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			crMultiSwitch *multiswitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_switch));
			ref_ptr<crButtonWidgetNode> zoom = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_zoom));
			ref_ptr<crButtonWidgetNode> enlarge = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_enlarge));
			if (zoom.valid() && enlarge.valid())
			{
				if (zoom -> getVisiable())
				{
					zoom -> setVisiable(false);
					enlarge -> setVisiable(true);
					if(multiswitch) multiswitch->setActiveSwitchSet(1);
				}
				else
				{
					zoom -> setVisiable(true);
					enlarge -> setVisiable(false);
					if(multiswitch) multiswitch->setActiveSwitchSet(0);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIDisableSoundMethod
//
/////////////////////////////////////////
crJXJUISystemUpdateMethod::crJXJUISystemUpdateMethod()
{
}

crJXJUISystemUpdateMethod::crJXJUISystemUpdateMethod(const crJXJUISystemUpdateMethod& handle):
	crMethod(handle),
	m_checkbox(handle.m_checkbox),
	m_bkscroll(handle.m_bkscroll),
	m_efxscroll(handle.m_efxscroll)
{
}

void crJXJUISystemUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUISystemUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_checkbox = str;
		break;
	case 1:
		m_bkscroll = str;
		break;
	case 2:
		m_efxscroll = str;
		break;
	}
}

void crJXJUISystemUpdateMethod::operator()(crHandle &handle)
{
	if(!m_this)return;
	crDisplaySettings *ds = crDisplaySettings::instance();
	ref_ptr<crCheckBoxWidgetNode> checkbox = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_checkbox));
	ref_ptr<crScrollBarWidgetNode> bkscroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_bkscroll));
	ref_ptr<crScrollBarWidgetNode> efxscroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_efxscroll));
	bool disablesound = false; 
	if(checkbox.valid())disablesound = checkbox->getSelect();
	float bksound = 0.0f;
	if(bkscroll.valid())bksound = bkscroll->getValue();
	float efxsound = 0.0f;
	if(efxscroll.valid())efxsound = efxscroll->getValue();
	bool issame = true;
	if(disablesound != ds->getDisableSound())
	{
		ds->setDisableSound(disablesound);
		issame = false;
	}
	if(bksound != ds->getAmbSoundVolume())
	{
		ds->setAmbSoundVolume(bksound);
		issame = false;
	}
	if(efxsound != ds->getFxSoundVolume())
	{
		ds->setFxSoundVolume(efxsound);
		issame = false;
	}
	if(!issame)
	{
		rcfg::ConfigScript cfg_script;
		std::string filename = "script/init.cfg";
		if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,filename,true))
		{
			//CRCore::notify(CRCore::FATAL)<<"JXJ::crJXJUpdateInitCfgMethod(): file open error "<<filename<<std::endl;
			char gbuf[256];
			sprintf(gbuf,"crJXJUpdateInitCfgMethod(): file open error %s\n\0",filename.c_str());
			gDebugInfo->debugInfo(CRCore::FATAL,gbuf);
			return;
		}
		//声音设置
		if(cfg_script.Push("DisplaySetting"))
		{
			//声音设置
			if(!cfg_script.Modify("DisableSound", disablesound))
			{
				cfg_script.Add("DisableSound",disablesound);
			}
			if(!cfg_script.Modify("AmbSoundVolume", bksound))
			{
				cfg_script.Add("AmbSoundVolume",bksound);
			}
			if(!cfg_script.Modify("FxSoundVolume", efxsound))
			{
				cfg_script.Add("FxSoundVolume",efxsound);
			}
			//////////////////
			//if(!cfg_script.Modify("MouseSpeed", mouseSpeed))
			//{
			//	cfg_script.Add("MouseSpeed",mouseSpeed);
			//}
			if (!cfg_script.Pop())
			{
				//CRCore::notify(CRCore::FATAL)<<"crUpdateInitCfgMethod::operator(): "<<cfg_script.GetLastError()<<std::endl;
				char gbuf[256];
				sprintf(gbuf,"crJXJUISystemUpdateMethod::operator():%s\n\0",cfg_script.GetLastError().c_str());
				gDebugInfo->debugInfo(CRCore::FATAL,gbuf);
			}

		}
		cfg_script.Write("script/init.cfg");
		cfg_script.Close();

		CRIOManager::crWriteCookFile scopedWrite("script/init.cfg");
	}
}
/////////////////////////////////////////
//
//crJXJUISystemOnShowMethod
//
/////////////////////////////////////////
crJXJUISystemOnShowMethod::crJXJUISystemOnShowMethod()
{
}

crJXJUISystemOnShowMethod::crJXJUISystemOnShowMethod(const crJXJUISystemOnShowMethod& handle):
	crMethod(handle),
	m_checkbox(handle.m_checkbox),
	m_bkscroll(handle.m_bkscroll),
	m_efxscroll(handle.m_efxscroll)
{
}

void crJXJUISystemOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUISystemOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_checkbox = str;
		break;
	case 1:
		m_bkscroll = str;
		break;
	case 2:
		m_efxscroll = str;
		break;
	}
}

void crJXJUISystemOnShowMethod::operator()(crHandle &handle)
{
	//if(!m_this)return;
	crDisplaySettings *ds = crDisplaySettings::instance();
	//ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_strCanvas);
	//if(!canvas.valid()) return;
	ref_ptr<crCheckBoxWidgetNode> checkbox = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_checkbox));
	ref_ptr<crScrollBarWidgetNode> bkscroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_bkscroll));
	ref_ptr<crScrollBarWidgetNode> efxscroll = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_efxscroll));
	int disablesound = ds->getDisableSound();
	float bksound = ds->getAmbSoundVolume(); 
	float efxsound = ds->getFxSoundVolume();
	if(checkbox.valid())checkbox->select(disablesound);
	if(bkscroll.valid())bkscroll->setValue(bksound);
	if(efxscroll.valid())efxscroll->setValue(efxsound);
}
/////////////////////////////////////////
//
//crJXJSetBattleNameMethod
//
/////////////////////////////////////////
crJXJSetBattleNameMethod::crJXJSetBattleNameMethod()
{
}

crJXJSetBattleNameMethod::crJXJSetBattleNameMethod(const crJXJSetBattleNameMethod& handle):
	crMethod(handle),
	m_canvasname(handle.m_canvasname),
	m_battlename(handle.m_battlename)
{
}

void crJXJSetBattleNameMethod::inputParam(int i, void *param)
{
}

void crJXJSetBattleNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasname = str;
		break;
	case 1:
		m_battlename = str;
		break;
	}
}

void crJXJSetBattleNameMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!myPlayer)return;
	crData *data = myPlayer->getDataClass();
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasname);
	if(!canvas)return;
	ref_ptr<crStaticTextWidgetNode> battlename = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_battlename));
	ref_ptr<crTableIO>chengchiTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);
	crTableIO::StrVec record;
	void *param;
	data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
	unsigned char type = *(unsigned char *)param;
	data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
	unsigned short id = *(unsigned short *)param;
	if(type == FT_Chengchi && id>0 && chengchiTab->queryOneRecord(0,crArgumentParser::appItoa(id),record) >= 0 )
	{
		int nameid = chengchiTab->getTitleIndex("名字");
		std::string name = record[nameid].c_str();
		if(battlename.valid())battlename->setString(name);
	}
}
/////////////////////////////////////////
//
//crJXJUIPunishtimerMethod
//
/////////////////////////////////////////
crJXJUIPunishtimerMethod::crJXJUIPunishtimerMethod()
{
}

crJXJUIPunishtimerMethod::crJXJUIPunishtimerMethod(const crJXJUIPunishtimerMethod& handle):
	crMethod(handle),
	m_inputtime(handle.m_inputtime),
	m_serverpunishtime(handle.m_serverpunishtime),
	m_lastpunishtime(handle.m_lastpunishtime)
{
}

void crJXJUIPunishtimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIPunishtimerMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_inputtime = str;
		break;
	default:
		break;
	}
}

void crJXJUIPunishtimerMethod::operator()(crHandle &handle)
{
	if (!m_this)
	{
		return;
	}
	crData *canvasdata = m_this->getDataClass();
	if (canvasdata)
	{
		void *param;
		canvasdata->getParam(WCHDATA_JXJBattlePunishTime,param);
		short time = *(short *)param;
		if (m_serverpunishtime != time)
		{
			m_serverpunishtime = time;
			m_lastpunishtime = time;
		}
		else
		{
			m_lastpunishtime -= 1;
		}
		int punish = m_lastpunishtime;
		ref_ptr<crStaticTextWidgetNode> textWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_inputtime));
		if(textWidget.valid())
		{
			int t;
			int hour,minute,s;
			hour = punish/3600;
			t = punish%3600;
			minute = t/60;
			s = t%60;
			textWidget->setString(/*"您提前从战场退出，还需要再等待"+*//*"惩罚时间:"+*/crArgumentParser::appItoa(hour)+":"+crArgumentParser::appItoa(minute)+":"+crArgumentParser::appItoa(s)/*+"秒，才能进入排队系统,请等待！"*/);
		}
		if(punish > 0)
		{
			if(!m_this->getVisiable())
				crFilterRenderManager::getInstance()->showCanvas(m_this,true);
		}
		else
		{
			canvasdata->inputParam(WCHDATA_JXJBattlePunishTime,0);
			if(m_this->getVisiable())
				crFilterRenderManager::getInstance()->closeCanvas(m_this);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIReleaseRecruitInfoMethod
//
/////////////////////////////////////////
crJXJUIReleaseRecruitInfoMethod::crJXJUIReleaseRecruitInfoMethod()
{
}

crJXJUIReleaseRecruitInfoMethod::crJXJUIReleaseRecruitInfoMethod(const crJXJUIReleaseRecruitInfoMethod& handle):
	crMethod(handle),
	m_canvasname(handle.m_canvasname),
	m_chatmodesw(handle.m_chatmodesw),
	m_chatinput(handle.m_chatinput),
	m_sendbtn(handle.m_sendbtn)
{
}

void crJXJUIReleaseRecruitInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIReleaseRecruitInfoMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvasname = str;
		break;
	case 1:
		m_chatmodesw = str;
		break;
	case 2:
		m_chatinput = str;
		break;
	case 3:
		m_sendbtn = str;
		break;
	case 4:
		m_switch = str;
		break;
	default:
		break;
	}
}

void crJXJUIReleaseRecruitInfoMethod::operator()(crHandle &handle)
{
	if (!m_this)return;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(!myPlayer)return;
	crData *data = myPlayer->getDataClass();
	int playerid = myPlayer->getPlayerID();
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasname);
	ref_ptr<crCanvasNode>canvas_1 = crFilterRenderManager::getInstance()->findCanvas("UI_Country1");
	if(!canvas || !canvas_1)return;
	ref_ptr<crRadioGroupWidgetNode> chatmodesw = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_chatmodesw));
	ref_ptr<crStaticTextWidgetNode> chatinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_chatinput));
	ref_ptr<crButtonWidgetNode> sendbtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_sendbtn));
	crMultiSwitch *mulitSwitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_switch));
	if(!chatmodesw || !chatinput ||!sendbtn || !mulitSwitch)return;
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	ref_ptr<crTableIO>chengchitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJChengChiTab);

	void *param;
	bool smallacc = false;
	data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
	unsigned char type = *(unsigned char *)param;
	data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
	unsigned short id = *(unsigned short *)param;
	crData * canvasData = canvas_1->getDataClass();
	canvasData->excHandle(MAKECREPARAM(WCH_LockData,1));

	canvasData->getParam(WCHDATA_JXJShiliDataTempPeopleVec,param);
	PeopleVec  & peopleVec = *(PeopleVec *)param;
	int vecSize = peopleVec.size();
	for (int i = 0; i < 9 && i < vecSize; ++ i)
	{
		if (playerid == peopleVec[i]->getID() && peopleVec[i]->getSmallAcc())
		{
			//检查玩家是否被标记为小号
			smallacc = true;
		}
	}
	if(type>0 && id>0 && !smallacc)
	{
		chatmodesw->select(ChatInCountry);
		chatmodesw->doEvent(WCH_UI_SelectChange);
		mulitSwitch->setActiveSwitchSet(ChatInCountry-1);
		int nameid;
		crTableIO::StrVec record;
		std::string name;
		std::string strMessage;
		int textid = 0;
		int myplayerID = crMyPlayerData::getInstance()->getPlayerID();
		if(type == FT_Fuben)
		{
			if(fubentab.valid() && fubentab->queryOneRecord(0,crArgumentParser::appItoa(id),record) >= 0 )
			{
				nameid = fubentab->getTitleIndex("name");
				name = record[nameid];

				strMessage += std::string("^4^")+std::string("[")+name+std::string("]副本招募队员，请各路英豪尽快加入队伍吧！")+std::string("{(")+ \
					crArgumentParser::appItoa(FT_Fuben)+std::string(")(")+crArgumentParser::appItoa(myplayerID)+std::string(")(")+crArgumentParser::appItoa(id)+std::string(")}");//{(type)(playerid)(fubenid)}
			}
		}
		else if(type == FT_Chengchi)
		{
			if(chengchitab.valid() && chengchitab->queryOneRecord(0,crArgumentParser::appItoa(id),record) >= 0 )
			{
				nameid = chengchitab->getTitleIndex("名字");
				name = record[nameid];

				strMessage += std::string("^4^")+std::string("[")+name+std::string("]城战招募队员，请各路英豪尽快加入队伍吧！")+std::string("{(")+ \
					crArgumentParser::appItoa(FT_Chengchi)+std::string(")(")+crArgumentParser::appItoa(myplayerID)+std::string(")(")+crArgumentParser::appItoa(id)+std::string(")}");
			}
		}

		if(!strMessage.empty())
		{
			chatinput->setString(strMessage);
			sendbtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
		}
	}
	canvasData->excHandle(MAKECREPARAM(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJGetFukuLimitAddMethod
//
/////////////////////////////////////////
crJXJGetFukuLimitAddMethod::crJXJGetFukuLimitAddMethod():
	m_output(NULL){}
crJXJGetFukuLimitAddMethod::crJXJGetFukuLimitAddMethod(const crJXJGetFukuLimitAddMethod& handle):
	crMethod(handle),
	m_output(NULL)
{
}
void crJXJGetFukuLimitAddMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_output = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_output = (float *)(LOCREPARAM(param64));
		}
		else
		{
			m_output = NULL;
		}
		break;
	}
}
void crJXJGetFukuLimitAddMethod::addParam(int i, const std::string& str)
{
}
void crJXJGetFukuLimitAddMethod::operator()(crHandle &handle)
{
	if(m_this && m_output)
	{
		void *param;
		float percent = 0.0f;
		crData *data = m_this->getDataClass();
		//crTableIO::StrVec techrecord;
		//ref_ptr<crTableIO>techlvtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
		//int shuxingindex = techlvtab->getTitleIndex("属性加成");
		//int lvindex = techlvtab->getTitleIndex("lv");
		//科技增加府库上限
		//data->getParam(WCHDATA_JXJTechZhaoMulv,param);
		//unsigned char techlv = *(unsigned char *)param;
		//if (techlv > 0)
		//{
		//	if(techlvtab->queryOneRecord(0,crArgumentParser::appItoa(WCHDATA_JXJTechZhaoMulv),lvindex,crArgumentParser::appItoa(techlv),techrecord) >= 0 )
		//	{
		//		percent += atof(techrecord[shuxingindex].c_str());
		//	}
		//}
		//委任增加府库上限
		crTableIO::StrVec cardrecord;
		ref_ptr<crTableIO>cardtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJZhengCardTab);
		int zhengkatypeindex = cardtab->getTitleIndex("政卡类型");
		int addpercentindex = cardtab->getTitleIndex("政卡加成");
		data->getParam(WCHDATA_JXJAppointJiangkaBagVec,param);
		JXJAppointCardVec *appjiangkavec = (JXJAppointCardVec *)param;

		for (JXJAppointCardVec::iterator carditr = appjiangkavec->begin();
			carditr!=appjiangkavec->end();
			++carditr)
		{
			if ((*carditr)!=NULL)
			{
				if(cardtab->queryOneRecord(0,crArgumentParser::appItoa((*carditr)->getItemID()),cardrecord) >= 0 )
				{
					if(atoi(cardrecord[zhengkatypeindex].c_str()) == ZhengAdd_AddFukuLimit)
					{
						percent +=atof(cardrecord[addpercentindex].c_str());
						break;
					}
				}
			}
		}

		unsigned char fukumaxtechlv[3] = {0};
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		crVector3 limitadd;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFukuLimitTech,viplv).c_str(),limitadd);
		data->getParam(WCHDATA_JXJFuKuMaxTechLv,param);
		fukumaxtechlv[0] = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFuKuMaxTech2Lv,param);
		fukumaxtechlv[1] = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFuKuMaxTech3Lv,param);
		fukumaxtechlv[2] = *(unsigned char *)param;
		for (int i = 0; i < 3; ++i)
		{
			if (fukumaxtechlv[i] > 0)
			{
				percent += limitadd[i];
			}
		}
		
		*m_output = percent * 0.01f;//*0.01f
	}
}
/////////////////////////////////////////
//
//crJXJUIUndoAddJiangKaDragMethod
//
/////////////////////////////////////////
crJXJUIUndoAddJiangKaDragMethod::crJXJUIUndoAddJiangKaDragMethod()
{
}
crJXJUIUndoAddJiangKaDragMethod::crJXJUIUndoAddJiangKaDragMethod(const crJXJUIUndoAddJiangKaDragMethod& handle):
	crMethod(handle),
	m_cardcanvas(handle.m_cardcanvas),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent),
	m_jiicon(handle.m_jiicon),
	m_mouicon(handle.m_mouicon)
{
	for( int i = 0; i<6; i++)
	{
		m_btn[i] = handle.m_btn[i];
		m_colorbox[i] = handle.m_colorbox[i];
	}
}
void crJXJUIUndoAddJiangKaDragMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIUndoAddJiangKaDragMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_cardcanvas = str;
		break;
	case 1:
		m_btn[0] = str;
		break;
	case 2:
		m_btn[1] = str;
		break;
	case 3:
		m_btn[2] = str;
		break;
	case 4:
		m_btn[3] = str;
		break;
	case 5:
		m_btn[4] = str;
		break;
	case 6:
		m_btn[5] = str;
		break;
	case 7:
		m_colorbox[0] = str;
		break;
	case 8:
		m_colorbox[1] = str;
		break;
	case 9:
		m_colorbox[2] = str;
		break;
	case 10:
		m_colorbox[3] = str;
		break;
	case 11:
		m_colorbox[4] = str;
		break;
	case 12:
		m_colorbox[5] = str;
		break;
	case 13:
		m_tipcanvas = str;
		break;
	case 14:
		m_tipcontent = str;
		break;
	case 15:
		m_jiicon = str;
		break;
	case 16:
		m_mouicon = str;
		break;
	}
}
void crJXJUIUndoAddJiangKaDragMethod::operator()(crHandle &handle)
{
	void *param;
	if(!m_this) return;
	ref_ptr<crCanvasNode>formationcanvas = m_this->getParentCanvas();
	ref_ptr<crCanvasNode>cardcanvas = crFilterRenderManager::getInstance()->findCanvas(m_cardcanvas);//编队界面
	if(!formationcanvas || !cardcanvas) return;

	crData *formationdata = formationcanvas->getDataClass();
	crData *formcarddata = cardcanvas->getDataClass();

	formationdata->excHandle(MAKECREPARAM(WCH_LockData,1));
	formcarddata->excHandle(MAKECREPARAM(WCH_LockData,1));
	formationdata->getParam(WCHDATA_JXJTempFormationVec, param);
	FormationInfoVec *tempformationvec = (FormationInfoVec *)param;
	formcarddata->getParam(WCHDATA_JXJForJKVec, param);
	JXJItemBagVec *tempcardvec = (JXJItemBagVec *)param;

	bool ifcanundo = false;
	for (JXJItemBagVec::iterator itr = tempcardvec->begin(); itr!=tempcardvec->end(); ++itr)
	{
		if ((*itr) == NULL)
		{
			ifcanundo = true;
			break;
		}
	}
	if (ifcanundo)
	{
		std::string btnname = m_this->getName();
		ref_ptr<crWidgetNode> btn = NULL;
		int row = 0;
		int col = 0;
		int cardid = 0;
		for (int i = 0;i < 6;i++)
		{
			if (btnname == m_btn[i])
			{
				row = i/2;
				col = i%2;
				if (col == 0)
				{
					formationdata->inputParam(WCHDATA_JXJCurFormation1stCardIndex, &row);
				}
				else
				{
					formationdata->inputParam(WCHDATA_JXJCurFormation2ndCardIndex, &row);
				}
				btn = formationcanvas->getWidget(m_btn[i]);
				if (btn.valid())
				{
					//btn -> setVisiable(false);
					crMultiSwitch *multiswitch =dynamic_cast<crMultiSwitch *>(formationcanvas->getChildNode(m_colorbox[i]));
					if (multiswitch)
					{
						//multiswitch->setVisiable(false);
						multiswitch->setActiveSwitchSet(0);
					}
					CRCore::crStateSet *state_set =
						dynamic_cast<CRCore::crObject *>(( dynamic_cast<CRCore::crGroup *>(btn->getChild(0)))->getChild(0))->getDrawable(0)->getStateSet();
					if (state_set)
					{
						CRCore::crTexture2D *texture_2d = 
							dynamic_cast<CRCore::crTexture2D *>(state_set->getTextureAttribute(0,CRCore::crStateAttribute::TEXTURE));
						btn->setVisiable(true);
						if (col == 0)
						{
							texture_2d->setImage(0, texture_2d->getImageDataRequestHandler()->requestImageFile(m_jiicon,texture_2d));
						}
						else
						{
							texture_2d->setImage(0, texture_2d->getImageDataRequestHandler()->requestImageFile(m_mouicon,texture_2d));
						}
					}
				}
				break;
			}
		}
		if (row < tempformationvec->size())
		{
			crVector2i equips = (*tempformationvec)[row]->getEquips();
			cardid = equips[col];

			equips[col] = -1;
			(*tempformationvec)[row]->setEquips(equips);
		}
		if (cardid > 0)
		{
			for (JXJItemBagVec::iterator itr = tempcardvec->begin(); itr!=tempcardvec->end(); ++itr)
			{
				if ((*itr) == NULL)
				{
					ref_ptr<crBagItemData> undocard = new crBagItemData;
					undocard->setItemID(cardid);
					undocard->setItemCount(1);
					(*itr) = undocard;
					break;
				}
			}
		}
	}
	else
	{
		std::string tipstr = "将卡背包已满，请先整理将卡背包!";
		ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
		if (tipcanvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
			if (tipcontent.valid())
			{
				tipcontent->setString(tipstr);
			}
			crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
		}
	}
	formcarddata->excHandle(MAKECREPARAM(WCH_LockData,0));
	formationdata->excHandle(MAKECREPARAM(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJWidgetDoEventMethod
//
/////////////////////////////////////////
crJXJWidgetDoEventMethod::crJXJWidgetDoEventMethod():
	m_buttonindex(0),
	m_eventindex(0)
{
}

crJXJWidgetDoEventMethod::crJXJWidgetDoEventMethod(const crJXJWidgetDoEventMethod& handle):
	crMethod(handle),
	m_canvasname(handle.m_canvasname),
	m_widgetname(handle.m_widgetname),
	m_buttonindex(handle.m_buttonindex),
	m_eventindex(handle.m_eventindex)
{
}

void crJXJWidgetDoEventMethod::inputParam(int i, void *param)
{
// 	switch(i) 
// 	{
// 	case 0:
// 		if(param == 0)
// 		{//释放
// 			m_this = NULL;
// 		}
// 		break;
// 	case 1:
// 		m_this = (crWidgetNode*)param;
// 		break;
// 	}
}

void crJXJWidgetDoEventMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvasname = str;
		break;
	case 1:
		m_widgetname = str;
		break;
	case 2:
		m_buttonindex = atoi(str.c_str());
		break;
	case 3:
		m_eventindex = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJWidgetDoEventMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasname);
	if (canvas.valid())
	{
		ref_ptr<crWidgetNode> widget = canvas->getWidget(m_widgetname);
		if(widget.valid() && widget->getEnable())
		{
			widget->doEvent(MAKEINT32(m_buttonindex,m_eventindex));
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckLordLevelMethod
//
/////////////////////////////////////////
crJXJCheckLordLevelMethod::crJXJCheckLordLevelMethod():
	m_this(NULL)
{
}

crJXJCheckLordLevelMethod::crJXJCheckLordLevelMethod(const crJXJCheckLordLevelMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_tips(handle.m_tips),
	m_tipstext(handle.m_tipstext),
	m_this(handle.m_this)
{
}

void crJXJCheckLordLevelMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJCheckLordLevelMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_tips = str;
		break;
	case 2:
		m_tipstext = str;
		break;
	default:
		break;
	}
}

void crJXJCheckLordLevelMethod::operator()(crHandle &handle)
{
	bool cancelTask = false;
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	if(player)
	{
		void *param;
		int tianshu = 0;
		crRole *mainrole = player->getMainRole();
		if(!mainrole)return;
		crData *mainroledata = mainrole->getDataClass();
		if(!mainroledata)return;
		crData *data = player->getDataClass();
		if(!data)return;

		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int openlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevel,viplv).c_str());
		int maxBattlelv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenMaxLimitLevel,viplv).c_str());
		int IncreaseDate = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBattleOpenLevelIncreaseDate,viplv).c_str());
		//int formationopenlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFormationOpenLv,viplv).c_str());
		int fubenopenlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFuBenOpenLv,viplv).c_str());
		mainroledata->getParam(WCHDATA_Level,param);
		unsigned char mylv = *(unsigned char *)param;
		ref_ptr<crStaticTextWidgetNode> tipstext = NULL;
		ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tips);
		if (tips.valid())
		{
			 tipstext = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_tipstext));
			 if (tipstext.valid() && m_this)
			 {
				 tipstext->setColor(COLOR_YELLOW);
				 const crBoundingBox &btnbox = m_this->getBoundBox();
				 const crBoundingBox &tipsbox = tips->getBoundBox();
				 const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
				 float posx = btnbox.m_min[0] - tipsbox.xLength()/2;
				 float posy =  btnbox.m_max[1] + tipsbox.yLength()/2;
				 ////////////
				 crVector2 mouse(crVector2(posx,posy));
				 tips->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f) * mat);
			 }
		}
		switch (m_index)
		{
		case 1:
			if (crGlobalHandle::isClient())
			{
				crGlobalHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKECREPARAM(&tianshu, NULL));
			}
			else
			{
				crServerBrainHandle::getInstance()->doEvent(WCH_JXJGetStartedDays, MAKECREPARAM(&tianshu, NULL));
			}
			if (tianshu >= 0 && tianshu < IncreaseDate)
			{
				if (mylv < openlv)
				{
					cancelTask = true;
				}
			}
			else if (tianshu >= IncreaseDate && tianshu < maxBattlelv-IncreaseDate)
			{
				int battlelv_1 = openlv + tianshu - IncreaseDate + 1;
				if (mylv < battlelv_1)
				{
					cancelTask = true;
				}
			}
			else
			{
				if (mylv < maxBattlelv)
				{
					cancelTask = true;
				}
			}

			//if (mylv < openlv)
			//{
			//	cancelTask = true;
			//}
			break;
		case 2:
			//if (mylv < formationopenlv)
			//{
			//	cancelTask = true;
			//}
			break;
		case 3:
			if (mylv < fubenopenlv)
			{
				cancelTask = true;
			}
			break;
		case 4:
			//if (mylv < formationopenlv)
			//{
			//	cancelTask = true;
			//	if (tipstext.valid())
			//	{
			//		tipstext->setString("Lv." + crArgumentParser::appItoa(formationopenlv) + "开放");
			//		crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);
			//	}
			//}
			break;
		case 5:
			if (mylv < fubenopenlv)
			{
				cancelTask = true;
				if (tipstext.valid())
				{
					tipstext->setString("Lv." + crArgumentParser::appItoa(fubenopenlv) + "开放");
					crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);
				}
			}
			break;
		default:
			break;
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJShowVersionInfoMethod
//
/////////////////////////////////////////
crJXJShowVersionInfoMethod::crJXJShowVersionInfoMethod()
{
}

crJXJShowVersionInfoMethod::crJXJShowVersionInfoMethod(const crJXJShowVersionInfoMethod& handle):
	crMethod(handle),
	m_hypertext(handle.m_hypertext),
	m_filename(handle.m_filename)
{
}

void crJXJShowVersionInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJShowVersionInfoMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_hypertext = str;
		break;
	case 1:
		m_filename = str;
		break;
	default:
		break;
	}
}

void crJXJShowVersionInfoMethod::operator()(crHandle &handle)
{
	if (m_this)
	{
		ref_ptr<crHypertextWidgetNode> input = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_hypertext));
		if (input.valid() && !m_filename.empty())
		{
			m_filename = crGlobalHandle::getInstance()->getGameDir() + m_filename;
			input->setHypertext(m_filename);
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushReturnTimerMethod
//
/////////////////////////////////////////
crJXJFubenRushReturnTimerMethod::crJXJFubenRushReturnTimerMethod():
	m_lastpunishtime(0)
{
}

crJXJFubenRushReturnTimerMethod::crJXJFubenRushReturnTimerMethod(const crJXJFubenRushReturnTimerMethod& handle):
	crMethod(handle),
	m_inputtime(handle.m_inputtime),
	m_lastpunishtime(handle.m_lastpunishtime),
	m_rushcanvas(handle.m_rushcanvas),
	m_fubencanvas(handle.m_fubencanvas),
	m_sequence(handle.m_sequence)
{
}

void crJXJFubenRushReturnTimerMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJFubenRushReturnTimerMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_inputtime = str;
		break;
	case 1:
		m_rushcanvas = str;
		break;
	case 2:
		m_fubencanvas = str;
		break;
	case 3:
		m_sequence = str;
		break;
	default:
		break;
	}
}

void crJXJFubenRushReturnTimerMethod::operator()(crHandle &handle)
{
	if (!m_this)
	{
		return;
	}
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = myPlayer->getDataClass();
	data->getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	int time = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFubenRushRerurnTime,viplv).c_str());
	ref_ptr<crCanvasNode>rushcanvas = crFilterRenderManager::getInstance()->findCanvas(m_rushcanvas);
	ref_ptr<crCanvasNode>fubencanvas = crFilterRenderManager::getInstance()->findCanvas(m_fubencanvas);
	if (m_lastpunishtime <= 0)
	{
		crSequence *sequence = dynamic_cast<crSequence *>(m_this->getChildNode(m_sequence));
		if(sequence)
		{
			sequence->setVanishWhenStop(true);
			sequence->setDuration(0.1f, 1);
			sequence->startEffect();
			m_lastpunishtime = 2;
		}
		else
		{
			m_lastpunishtime = time;
		}
	}
	else
	{
		m_lastpunishtime -= 1;
	}
	int punish = m_lastpunishtime;
	ref_ptr<crStaticTextWidgetNode> textWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_inputtime));
	if(textWidget.valid())
	{
		textWidget->setString(crArgumentParser::appItoa(punish));
	}
	if(punish <= 0)
	{
		if(m_this->getVisiable())
		{
			crFilterRenderManager::getInstance()->closeCanvas(m_this);
			if(textWidget.valid())
			{
				textWidget->clearString();
			}
		}
		if(rushcanvas.valid() && rushcanvas->getVisiable())
		{
			crFilterRenderManager::getInstance()->closeCanvas(rushcanvas.get());
		}
		if(fubencanvas.valid() && !fubencanvas->getVisiable())
		{
			crFilterRenderManager::getInstance()->showCanvas(fubencanvas.get(),true);
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushEditCheckMethod
//
/////////////////////////////////////////
crJXJFubenRushEditCheckMethod::crJXJFubenRushEditCheckMethod():
	m_this(NULL)
{
}
crJXJFubenRushEditCheckMethod::crJXJFubenRushEditCheckMethod(const crJXJFubenRushEditCheckMethod& handle):
	crMethod(handle),
	m_inputcount(handle.m_inputcount),
	m_rushradio(handle.m_rushradio)
{
}
void crJXJFubenRushEditCheckMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crEditWidgetNode*)param;
		break;
	}
}
void crJXJFubenRushEditCheckMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_inputcount = str;
		break;
	case 1:
		m_rushradio = str;
		break;
	default:
		break;
	}
}
void crJXJFubenRushEditCheckMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	if(m_this && playerGameData && fubentab.valid())
	{
		int editcount = atoi(m_this->getUTF8String().c_str());
		int canrushcount = 0;
		int needjunling = 0;
		void *param;
		crTableIO::StrVec record;

		int junlingindex = fubentab -> getTitleIndex("军令");
		crData *data = playerGameData->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short id = *(unsigned short *)param;
		data->getParam(WCHDATA_JXJJunling,param);
		unsigned short junling = *(unsigned short *)param;
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int maxRushCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str());
		if (type == FT_Fuben && fubentab->queryOneRecord(0,crArgumentParser::appItoa(id),record) && junlingindex >= 0)
		{
			int perrushcount = atoi(record[junlingindex].c_str());
			if (perrushcount > 0)
			{
				canrushcount = (int)(junling/100) / perrushcount;
				if (editcount > canrushcount)
				{
					editcount = canrushcount;
				}
				if (editcount > maxRushCount)
				{
					editcount = maxRushCount;
				}
				if (editcount < 0)
				{
					editcount = 0;
				}
				needjunling = perrushcount * editcount;
			}
			if (!m_this->getUTF8String().empty())
			{
				m_this->setString(crArgumentParser::appItoa(editcount));
			}
		}

		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			ref_ptr<crStaticTextWidgetNode> input = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_inputcount));
			ref_ptr<crRadioGroupWidgetNode> radio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_rushradio));
			if(input.valid())input -> setString(crArgumentParser::appItoa(needjunling));
			if(radio.valid() && radio->getSelect()!=1)radio ->select(1);
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushOnShowMethod
//
/////////////////////////////////////////
crJXJFubenRushOnShowMethod::crJXJFubenRushOnShowMethod()
{
}

crJXJFubenRushOnShowMethod::crJXJFubenRushOnShowMethod(const crJXJFubenRushOnShowMethod& handle):
	crMethod(handle),
	m_fubeninput(handle.m_fubeninput),
	m_rushradio(handle.m_rushradio),
	m_rushcountedit(handle.m_rushcountedit),
	m_junlingcountinput(handle.m_junlingcountinput),
	m_startrushbtn(handle.m_startrushbtn),
	m_junlingtips(handle.m_junlingtips),
	m_scrollbar(handle.m_scrollbar),
	m_hyperText(handle.m_hyperText)
{
	for( int i=0; i<7; i++)
	{
		m_checkkbox[i]=handle.m_checkkbox[i];
		m_strText[i]=handle.m_strText[i];
	}
}

void crJXJFubenRushOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJFubenRushOnShowMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_fubeninput = str;
		break;
	case 1:
		m_rushradio = str;
		break;
	case 2:
		m_rushcountedit = str;
		break;
	case 3:
		m_junlingcountinput = str;
		break;
	case 4:
		m_startrushbtn = str;
		break;
	case 5:
		m_junlingtips = str;
		break;
	case 6:
		m_checkkbox[0] = str;
		break;
	case 7:
		m_checkkbox[1] = str;
		break;
	case 8:
		m_checkkbox[2] = str;
		break;
	case 9:
		m_checkkbox[3] = str;
		break;
	case 10:
		m_checkkbox[4] = str;
		break;
	case 11:
		m_checkkbox[5] = str;
		break;
	case 12:
		m_checkkbox[6] = str;
		break;
	case 13:
		m_strText[0] = str;
		break;
	case 14:
		m_strText[1] = str;
		break;
	case 15:
		m_strText[2] = str;
		break;
	case 16:
		m_strText[3] = str;
		break;
	case 17:
		m_strText[4] = str;
		break;
	case 18:
		m_strText[5] = str;
		break;
	case 19:
		m_strText[6] = str;
		break;
	case 20:
		m_scrollbar = str;
		break;
	case 21:
		m_hyperText = str;
		break;
	default:
		break;
	}
}

void crJXJFubenRushOnShowMethod::operator()(crHandle &handle)
{

	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	if(m_this && playerGameData && fubentab.valid())
	{
		void *param;
		crTableIO::StrVec record;
		ref_ptr<crStaticTextWidgetNode> numInput;
		ref_ptr<crStaticTextWidgetNode> textInput;
		ref_ptr<crHypertextWidgetNode> hytextInput;
		int junlingindex = fubentab -> getTitleIndex("军令");
		int nameindex = fubentab -> getTitleIndex("name");
		ref_ptr<crCanvasNode>junlingtips = crFilterRenderManager::getInstance()->findCanvas(m_junlingtips);
		ref_ptr<crStaticTextWidgetNode> fubeninput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_fubeninput));
		ref_ptr<crRadioGroupWidgetNode> rushradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_rushradio));
		ref_ptr<crEditWidgetNode> rushcountedit = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_rushcountedit));
		ref_ptr<crStaticTextWidgetNode> junlingcountinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_junlingcountinput));
		ref_ptr<crButtonWidgetNode> startbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_startrushbtn));

		for(int i = 0;i<7;i++)
		{
			numInput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_checkkbox[i]));
			textInput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_strText[i]));
			if(numInput.valid())
			{
				//checkBox->setVisiable(false);
				numInput->clearString();
			}
			if(textInput.valid())
				textInput->clearString();
		}
		hytextInput = dynamic_cast<crHypertextWidgetNode *>(m_this->getWidget(m_hyperText));
		if(hytextInput.valid())
			hytextInput->clearText();
		ref_ptr<crScrollBarWidgetNode> barInput;
		barInput = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbar));
		if(barInput.valid())
		{
			barInput->setValue(0);
			barInput->setRange(0,0);
			barInput->setLineValue(1);
			barInput->setPageValue(7);
		}

		unsigned short junling = 0;
		crData *data = playerGameData->getDataClass();
		data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
		unsigned char type = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
		unsigned short fubenid = *(unsigned short *)param;
		data->getParam(WCHDATA_JXJJunling,param);
		junling = *(unsigned short *)param;
		if (junlingcountinput.valid())
		{
			junlingcountinput->setString(std::string("0"));
		}
		if (rushcountedit.valid())
		{
			rushcountedit->setString(std::string("0"));
		}
		if (rushradio.valid())
		{
			rushradio->select(FubenRushCountType_All);
		}
		if (type==FT_Fuben && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) && nameindex >= 0)
		{
			if (fubeninput.valid())
			{
				fubeninput->setString(record[nameindex]);
			}
			if (junlingtips.valid())
			{
				if (junling < atoi(record[junlingindex].c_str()) * 100)
				{
					if (startbtn.valid()) startbtn->setEnable(false);
					crFilterRenderManager::getInstance()->doModal(junlingtips.get());
					//crFilterRenderManager::getInstance()->showCanvas(junlingtips,true);
				}
				else
				{
					if (startbtn.valid()) startbtn->setEnable(true);
				}
			}
		}
		else
		{
			if (startbtn.valid()) startbtn->setEnable(false);
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushUpdateMethod
//
/////////////////////////////////////////
crJXJFubenRushUpdateMethod::crJXJFubenRushUpdateMethod()
{
}

crJXJFubenRushUpdateMethod::crJXJFubenRushUpdateMethod(const crJXJFubenRushUpdateMethod& handle):
	crMethod(handle),
	m_rushradio(handle.m_rushradio),
	m_rushcountedit(handle.m_rushcountedit),
	m_junlingcountinput(handle.m_junlingcountinput),
	m_startrushbtn(handle.m_startrushbtn),
	m_junlingtips(handle.m_junlingtips)
{
}

void crJXJFubenRushUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJFubenRushUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_rushradio = str;
		break;
	case 1:
		m_rushcountedit = str;
		break;
	case 2:
		m_junlingcountinput = str;
		break;
	case 3:
		m_startrushbtn = str;
		break;
	case 4:
		m_junlingtips = str;
		break;
	default:
		break;
	}
}

void crJXJFubenRushUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	if(m_this && playerGameData && fubentab.valid())
	{
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushStartMethod
//
/////////////////////////////////////////
crJXJFubenRushStartMethod::crJXJFubenRushStartMethod()
{
}

crJXJFubenRushStartMethod::crJXJFubenRushStartMethod(const crJXJFubenRushStartMethod& handle):
	crMethod(handle),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch),
	m_rushradio(handle.m_rushradio),
	m_rushcountedit(handle.m_rushcountedit),
	m_check_sw(handle.m_check_sw)
{
}

void crJXJFubenRushStartMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJFubenRushStartMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_leftswitch = str;
		break;
	case 1:
		m_rightswitch = str;
		break;
	case 2:
		m_rushradio = str;
		break;
	case 3:
		m_rushcountedit = str;
		break;
	case 4:
		m_hyperText = str;
		break;
	case 5:
		m_cfg = str;
		break;
	case 6:
		m_table = str;
		break;
	case 7:
		m_itemCheckBox[0] = str;
		break;
	case 8:
		m_itemCheckBox[1] = str;
		break;
	case 9:
		m_itemCheckBox[2] = str;
		break;
	case 10:
		m_itemCheckBox[3] = str;
		break;
	case 11:
		m_itemCheckBox[4] = str;
		break;
	case 12:
		m_itemCheckBox[5] = str;
		break;
	case 13:
		m_itemCheckBox[6] = str;
		break;
	case 14:
		m_inputStr[0] = str;
		break;
	case 15:
		m_inputStr[1] = str;
		break;
	case 16:
		m_inputStr[2] = str;
		break;
	case 17:
		m_inputStr[3] = str;
		break;
	case 18:
		m_inputStr[4] = str;
		break;
	case 19:
		m_inputStr[5] = str;
		break;
	case 20:
		m_inputStr[6] = str;
		break;
	case 21:
		m_check = str;
		break;
	case 22:
		m_check_sw = str;
		break;
	default:
		break;
	}
}

void crJXJFubenRushStartMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	if(m_this && playerGameData && fubentab.valid() && netConductor)
	{
		void *param;
		bool use_up = false;
		crData *data = playerGameData->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		int needbagcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFubenRushNeedBagNum,viplv).c_str());
		playerGameData->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
		int maxRushCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str());
		if (needbagcount == 0)
		{
			unsigned char rushcount = 0;
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			if (canvas.valid())
			{
				ref_ptr<crRadioGroupWidgetNode> rushradio = dynamic_cast<crRadioGroupWidgetNode *>(canvas -> getWidget(m_rushradio));
				ref_ptr<crEditWidgetNode> rushedit = dynamic_cast<crEditWidgetNode *>(canvas -> getWidget(m_rushcountedit));
				crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
				crMultiSwitch *rightsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
				ref_ptr<crHypertextWidgetNode> hyperText = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_hyperText));
				ref_ptr<crRadioWidgetNode> sweep_check = dynamic_cast<crRadioWidgetNode *>(canvas->getWidget(m_check));
				ref_ptr<crMultiSwitch> sweep_check_sw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_check_sw));
				if (sweep_check.valid() && sweep_check->getSelect())
				{
					use_up = true;
				}
				if (rushedit.valid() && rushradio.valid() && rushradio->getSelect() == FubenRushCountType_Edit)
				{
					rushcount = atoi(rushedit->getUTF8String().c_str());
					if (rushcount > maxRushCount)
					{
						rushcount = maxRushCount;
					}
				}
				if (leftsw)
				{
					leftsw->setActiveSwitchSet(FubenRushType_Rushing);
				}
				if (rightsw)
				{
					rightsw->setActiveSwitchSet(FubenRushType_Rushing);
				}
				if(hyperText.valid())
				{
					rcfg::ConfigScript cfg_script;
					if(!crScriptLoadManager::getInstance()->loadConfigScript(cfg_script,m_cfg,true,""))
					{
						//CRCore::notify(CRCore::FATAL)<<"JXJ::crJXJChatReshowMethod(): file open error "<<m_cfg<<std::endl;
						char gbuf[256];
						sprintf(gbuf,"crJXJChatReshowMethod file open error:%s\n\0",m_cfg.c_str());
						gDebugInfo->debugInfo(CRCore::FATAL,gbuf);
						return;
					}
					cfg_script.Push("Hypertext");
					int index = 1;
					cfg_script.Add("Content");
					cfg_script.Push("Content",index++);
					cfg_script.Add("DrawMode","TEXT");
					cfg_script.Add("Text",std::string("扫荡进行中......\n"));
					cfg_script.Pop();
					cfg_script.Pop();
					hyperText->setHypertext(cfg_script,false);
				}
				crData *canvasData = m_this->getDataClass();
				if(canvasData)
				{
					canvasData->inputParam(WCHDATA_JXJFubenRushCount,NULL);
					canvasData->excHandle(MAKECREPARAM(WCH_LockData,1));
					canvasData->getParam(WCHDATA_JXJFubenRushRewardItemMap,param);
					//需要修改equipmagic
					FubenRushItemMap *itemmap = (FubenRushItemMap *)param;
					if(itemmap)
						itemmap->clear();
					canvasData->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				crCheckBoxWidgetNode *itemCheckBox[7]; 
				crStaticTextWidgetNode *inputText; 
				for (int i = 0;i<7;i++)
				{
					itemCheckBox[i] = dynamic_cast<crCheckBoxWidgetNode *>(canvas->getWidget(m_itemCheckBox[i]));
					if(itemCheckBox[i])
						itemCheckBox[i]->setVisiable(false);
					inputText = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_inputStr[i]));
					if(inputText) inputText->clearString();
				}
			}
			data->getParam(WCHDATA_JXJJunling,param);
			unsigned short junling = *(unsigned short *)param /100;
			if(junling==0)
			{
				playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2009,NULL));
			}
			else if(rushcount==0 && !use_up)
			{
				playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(7010,NULL));
			}
			else
			{
				data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
				unsigned char type = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJFubenOrChengchiID,param);
				unsigned short fubenid = *(unsigned short *)param;
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(4);
				stream->_writeUShort(fubenid);
				stream->_writeUChar(rushcount);
				stream->_writeBool(use_up);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvFubenRushStart, stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
		else
		{
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvFubenRushStartMethod
//
/////////////////////////////////////////
crJXJRecvFubenRushStartMethod::crJXJRecvFubenRushStartMethod():
	m_netType(GameClient_Game){}
crJXJRecvFubenRushStartMethod::crJXJRecvFubenRushStartMethod(const crJXJRecvFubenRushStartMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent)
{
	for (int i = 0;i < 3;i++)
	{
		m_numbersw1[i] = handle.m_numbersw1[i];
		m_numbersw2[i] = handle.m_numbersw2[i];
	}
}
void crJXJRecvFubenRushStartMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenRushStartMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_leftswitch = str;
		break;
	case 2:
		m_rightswitch = str;
		break;
	case 3:
		m_numbersw1[0] = str;
		break;
	case 4:
		m_numbersw1[1] = str;
		break;
	case 5:
		m_numbersw1[2] = str;
		break;
	case 6:
		m_numbersw2[0] = str;
		break;
	case 7:
		m_numbersw2[1] = str;
		break;
	case 8:
		m_numbersw2[2] = str;
		break;
	case 9:
		m_tipcanvas = str;
		break;
	case 10:
		m_tipcontent = str;
		break;
	default:
		break;
	}
}

void crJXJRecvFubenRushStartMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		//////////////////////////
		//	返回success			//
		//	0.军令不足			//
		//	1.开始扫荡成功		//
		//	2.在副本或战场中	//
		//	3.已经在扫荡了		//
		//	4.副本ID错误		//
		//	5.背包空间不足		//
		//////////////////////////
		if(m_netType == GameServer)
		{
			//void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			unsigned short fubenid = m_stream->_readUShort();
			unsigned char rushcount = m_stream->_readUChar();
			bool use_up = m_stream->_readBool();
			if (data)
			{
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
				if(playerData.valid())
				{
					void *param;
					data->getParam(WCHDATA_JXJJunling,param);
					unsigned short junling = *(unsigned short *)param /100;
					//检测背包
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					int needbagcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFubenRushNeedBagNum,viplv).c_str());
					m_this->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
					int maxRushCount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMaxJunling,viplv).c_str());
					if (needbagcount == 0)
					{
						//检测是否在副本中
						data->getParam(WCHDATA_JXJFubenOrChengchiType,param);
						unsigned char type = *(unsigned char *)param;
						if (0 == rushcount && !use_up)
						{
							success = 6;
						}
						else 
						{
							if (type == FT_None)
							{
								//检测军令是否足够
								ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
								crTableIO::StrVec record;
								int junlingindex = fubentab->getTitleIndex("军令");
								if (fubentab.valid() && junlingindex && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) >= 0 )
								{
									unsigned char perrushjunling = atoi(record[junlingindex].c_str());
									if (rushcount == 0 && perrushjunling > 0)
									{
										if (junling >= 256)
										{
											rushcount = maxRushCount;
										}
										else
										{
											rushcount = (unsigned short)(junling / perrushjunling);
											if (rushcount > maxRushCount)
											{
												rushcount = maxRushCount;
											}
										}
									}
									if (rushcount > 0)
									{
										if (rushcount > maxRushCount)
										{
											rushcount = maxRushCount;
										}
										unsigned char needjunling = rushcount * perrushjunling;
										if (needjunling <= junling)
										{
											success = 1;
										}//0军令不足
									}
								}
								else
								{
									success = 4;
								}
							}
							else
							{
								success = 2;//在副本或战场中
							}
						}
						///
						if (success == 1)
						{
							type = FT_Fuben;
							data->inputParam(WCHDATA_JXJFubenOrChengchiType,&type);
							data->inputParam(WCHDATA_JXJFubenOrChengchiID,&fubenid);

							crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
							gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
							gsBrainData->getParam(WCHDATA_JXJFubenRushMap,param);
							JXJFubenRushMap *rushplayermap = (JXJFubenRushMap *)param;
							for(JXJFubenRushMap::iterator itr = rushplayermap->begin();
								itr != rushplayermap->end();
								++itr)
							{
								for (JXJFubenRushVec::iterator vitr = itr->second.begin();
									vitr != itr->second.end();
									++vitr)
								{
									if (playerid == (*vitr)->getPlayerID())
									{
										(*vitr)->setState(FubenRushType_Rushing);
										rushcount = (*vitr)->getRushCount();
										success = 3;
									}
								}
							}
							if (success == 1)
							{
								ref_ptr<crRushPlayerInfo> playerinfo = new crRushPlayerInfo;
								playerinfo->setFubenID(fubenid);
								playerinfo->setRushCount(rushcount);
								playerinfo->setAllRushCount(rushcount);
								playerinfo->setState(FubenRushType_Rushing);
								playerinfo->setPlayerID(playerid);
								(*rushplayermap)[5].push_back(playerinfo);
							}
							gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
						}
					}
					else
					{
						success = 5;
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					
					stream->createBuf(2);
					if(success==6 && junling == 0)
						success = 0;//军令不足
					stream->_writeUChar(success);
					stream->_writeUChar(rushcount);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvFubenRushStart,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					///游戏日志
					std::string logdata = crArgumentParser::appVectoa(crVector2i(success,fubenid));
					GameLogData gamelog(Log_FubenRushStart,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			unsigned char rushcount = m_stream->_readUChar();
			crData *brainData = crBrain::getInstance()->getDataClass();
			brainData->inputParam(WCHDATA_JXJRemainFubenRushCount,&rushcount);
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);

			if(canvas.valid())
			{
				crMultiSwitch *numbersw1[3] = {NULL};
				crMultiSwitch *numbersw2[3] = {NULL};
				for (int i = 0; i < 3; i++)
				{
					numbersw1[i] = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_numbersw1[i]));
					numbersw2[i] = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_numbersw2[i]));
					if(numbersw1[i])
						numbersw1[i]->setActiveSwitchSet(0);
					if(numbersw2[i])
						numbersw2[i]->setActiveSwitchSet(0);
				}
				if (success == 1 ||success == 3)
				{
					if (rushcount >= 100)
					{
						crVector3i num;
						int baiwei = rushcount/100;
						int shiwei = (rushcount - baiwei * 100) / 10;
						int gewei = rushcount - baiwei * 100 - shiwei * 10;
						num[0] = baiwei;
						num[1] = gewei;
						num[2] = shiwei;
						for (int i = 0;i<3;i++)
						{
							if (numbersw1[i])
							{
								if (i == 0)
								{
									numbersw1[i]->setActiveSwitchSet(num[i]);
								}
								else
								{
									numbersw1[i]->setActiveSwitchSet(num[i] + 1);
								}
							}
							if (numbersw2[i])
							{
								if (i == 0)
								{
									numbersw2[i]->setActiveSwitchSet(num[i]);
								}
								else
								{
									numbersw2[i]->setActiveSwitchSet(num[i] + 1);
								}
							}
						}
					}
					else if (rushcount >= 10)
					{
						crVector2i num;
						num[0] = rushcount/10;
						num[1] = rushcount%10;
						for (int i = 0;i<2;i++)
						{
							if (numbersw1[i])
							{
								if (i == 0)
								{
									numbersw1[2]->setActiveSwitchSet(num[i] + 1);
								}
								else
								{
									numbersw1[1]->setActiveSwitchSet(num[i] + 1);
								}
							}
							if (numbersw2[i])
							{
								if (i == 0)
								{
									numbersw2[2]->setActiveSwitchSet(num[i] + 1);
								}
								else
								{
									numbersw2[1]->setActiveSwitchSet(num[i] + 1);
								}
							}
						}
					}
					else
					{
						if (numbersw1[2])
						{
							numbersw1[2]->setActiveSwitchSet(rushcount + 1);
						}
						if (numbersw2[2])
						{
							numbersw2[2]->setActiveSwitchSet(rushcount + 1);
						}
					}
				}
				else
				{
					crData *data = m_this->getDataClass();
					//data->inputParam(WCHDATA_JXJFubenID,0);

					crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
					crMultiSwitch *rightswitch = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
					if (leftsw)
					{
						leftsw->setActiveSwitchSet(0);
					}
					if (rightswitch)
					{
						rightswitch->setActiveSwitchSet(0);
					}
					int index = 2013;
					switch (success)
					{
					case 0:
						index = 2009;
						break;
					case 2:
						index = 2010;
						break;
					case 4:
						index = 2011;
						break;
					case 5:
						index = 2008;
						break;
					case 6:
						index = 7010;
						break;
					default:
						break;
					}
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushPauseMethod
//
/////////////////////////////////////////
crJXJFubenRushPauseMethod::crJXJFubenRushPauseMethod()
{
}

crJXJFubenRushPauseMethod::crJXJFubenRushPauseMethod(const crJXJFubenRushPauseMethod& handle):
	crMethod(handle),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch)
{
}

void crJXJFubenRushPauseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJFubenRushPauseMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_leftswitch = str;
		break;
	case 1:
		m_rightswitch = str;
		break;
	default:
		break;
	}
}

void crJXJFubenRushPauseMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (canvas.valid())
	{
		crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
		crMultiSwitch *rightsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
		if (leftsw)
		{
			leftsw->setActiveSwitchSet(FubenRushType_Rushing);
		}
		if(rightsw)
		{
			rightsw->setActiveSwitchSet(FubenRushType_Pause);
		}
	}
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvFubenRushPause, NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvFubenRushPauseMethod
//
/////////////////////////////////////////
crJXJRecvFubenRushPauseMethod::crJXJRecvFubenRushPauseMethod():
	m_netType(GameClient_Game){}
crJXJRecvFubenRushPauseMethod::crJXJRecvFubenRushPauseMethod(const crJXJRecvFubenRushPauseMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvFubenRushPauseMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenRushPauseMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_leftswitch = str;
		break;
	case 2:
		m_rightswitch = str;
		break;
	case 3:
		m_tipcanvas = str;
		break;
	case 4:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvFubenRushPauseMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;//1.成功暂停 2.扫荡已结束
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			if (data)
			{
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJFubenRushMap,param);
				JXJFubenRushMap *rushplayermap = (JXJFubenRushMap *)param;
				for(JXJFubenRushMap::iterator itr = rushplayermap->begin();
					itr != rushplayermap->end();
					++itr)
				{
					for (JXJFubenRushVec::iterator vitr = itr->second.begin();
						vitr != itr->second.end();
						++vitr)
					{
						if (playerid == (*vitr)->getPlayerID())
						{
							(*vitr)->setState(FubenRushType_Pause);
							success = 1;
						}
					}
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
				if(playerData.valid())
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1);
					stream->_writeUChar(success);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvFubenRushPause,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			if (!success)
			{
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if (canvas.valid())
				{
					crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
					crMultiSwitch *rightsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
// 					if (leftsw)
// 					{
// 						//leftsw->setActiveSwitchSet(FubenRushType_Ready);
// 					}
					if(rightsw)
					{
						rightsw->setActiveSwitchSet(FubenRushType_Ready);
					}
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
				std::string tipstr = "扫荡已结束或不存在";
				ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
				if (tipcanvas.valid())
				{
					ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
					if (tipcontent.valid())
					{
						tipcontent->setString(tipstr);
					}
					crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushContinueMethod
//
/////////////////////////////////////////
crJXJFubenRushContinueMethod::crJXJFubenRushContinueMethod()
{
}

crJXJFubenRushContinueMethod::crJXJFubenRushContinueMethod(const crJXJFubenRushContinueMethod& handle):
	crMethod(handle),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch)
{
}

void crJXJFubenRushContinueMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJFubenRushContinueMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_leftswitch = str;
		break;
	case 1:
		m_rightswitch = str;
		break;
	default:
		break;
	}
}

void crJXJFubenRushContinueMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (canvas.valid())
	{
		crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
		crMultiSwitch *rightsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
		if (leftsw)
		{
			leftsw->setActiveSwitchSet(FubenRushType_Rushing);
		}
		if(rightsw)
		{
			rightsw->setActiveSwitchSet(FubenRushType_Rushing);
		}
	}
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvFubenRushContinue, NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvFubenRushContinueMethod
//
/////////////////////////////////////////
crJXJRecvFubenRushContinueMethod::crJXJRecvFubenRushContinueMethod():
	m_netType(GameClient_Game){}
crJXJRecvFubenRushContinueMethod::crJXJRecvFubenRushContinueMethod(const crJXJRecvFubenRushContinueMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch),
	m_tipcanvas(handle.m_tipcanvas),
	m_tipcontent(handle.m_tipcontent)
{
}
void crJXJRecvFubenRushContinueMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenRushContinueMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_leftswitch = str;
		break;
	case 2:
		m_rightswitch = str;
		break;
	case 3:
		m_tipcanvas = str;
		break;
	case 4:
		m_tipcontent = str;
		break;
	}
}

void crJXJRecvFubenRushContinueMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			if (data)
			{
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJFubenRushMap,param);
				JXJFubenRushMap *rushplayermap = (JXJFubenRushMap *)param;
				for(JXJFubenRushMap::iterator itr = rushplayermap->begin();
					itr != rushplayermap->end();
					++itr)
				{
					for (JXJFubenRushVec::iterator vitr = itr->second.begin();
						vitr != itr->second.end();
						++vitr)
					{
						if (playerid == (*vitr)->getPlayerID())
						{
							(*vitr)->setState(FubenRushType_Rushing);
							success = 1;
						}
					}
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
				if(playerData.valid())
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(1);
					stream->_writeUChar(success);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvFubenRushContinue,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			if (!success)
			{
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if (canvas.valid())
				{
					crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
					crMultiSwitch *rightsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
// 					if (leftsw)
// 					{
// 						//leftsw->setActiveSwitchSet(FubenRushType_Ready);
// 					}
					if(rightsw)
					{
						rightsw->setActiveSwitchSet(FubenRushType_Ready);
					}
					crFilterRenderManager::getInstance()->showCanvas(canvas.get(),true);
				}
				std::string tipstr = "扫荡已结束或不存在";
				ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
				if (tipcanvas.valid())
				{
					ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
					if (tipcontent.valid())
					{
						tipcontent->setString(tipstr);
					}
					crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushEndMethod
//
/////////////////////////////////////////
crJXJFubenRushEndMethod::crJXJFubenRushEndMethod()
{
}

crJXJFubenRushEndMethod::crJXJFubenRushEndMethod(const crJXJFubenRushEndMethod& handle):
	crMethod(handle),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch),
	m_rushradio(handle.m_rushradio),
	m_rushcountedit(handle.m_rushcountedit),
	m_rushjunlinginput(handle.m_rushjunlinginput)
{
}

void crJXJFubenRushEndMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJFubenRushEndMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_leftswitch = str;
		break;
	case 1:
		m_rightswitch = str;
		break;
	case 2:
		m_rushradio = str;
		break;
	case 3:
		m_rushcountedit = str;
		break;
	case 4:
		m_rushjunlinginput = str;
		break;
	case 5:
		m_list = str;
		break;
	default:
		break;
	}
}

void crJXJFubenRushEndMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		crData *data = playerGameData->getDataClass();
		data->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
		data->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid() && canvas->getVisiable())
		{
			crData *canvasData = canvas->getDataClass();
			if(canvasData)
				canvasData->inputParam(WCHDATA_JXJFubenRushRewardItemMap,NULL);
			ref_ptr<crTableWidgetNode> settleList= dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_list));
			if(settleList.valid())
				settleList->clearData();
			crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
			crMultiSwitch *rightsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
			if (leftsw)
			{
				leftsw->setActiveSwitchSet(FubenRushType_Ready);
			}
			if(rightsw)
			{
				rightsw->setActiveSwitchSet(FubenRushType_Ready);
			}
		}
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvFubenRushEnd, NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvFubenRushEndMethod
//
/////////////////////////////////////////
crJXJRecvFubenRushEndMethod::crJXJRecvFubenRushEndMethod():
	m_netType(GameClient_Game){}
crJXJRecvFubenRushEndMethod::crJXJRecvFubenRushEndMethod(const crJXJRecvFubenRushEndMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvFubenRushEndMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenRushEndMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvFubenRushEndMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			if (data)
			{
				//crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				//ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));

				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJFubenRushMap,param);
				JXJFubenRushMap *rushplayermap = (JXJFubenRushMap *)param;
				for(JXJFubenRushMap::iterator itr = rushplayermap->begin();
					itr != rushplayermap->end();
					++itr)
				{
					for (JXJFubenRushVec::iterator vitr = itr->second.begin();
					vitr != itr->second.end();
					++vitr)
					{
						if (playerid == (*vitr)->getPlayerID())
						{
							if(itr->first != 0)
							{
								ref_ptr<crRushPlayerInfo> playerinfo = new crRushPlayerInfo;
								playerinfo->setPlayerID((*vitr)->getPlayerID());
								playerinfo->setAllRushCount((*vitr)->getAllRushCount());
								playerinfo->setFubenID((*vitr)->getFubenID());
								playerinfo->setRushCount(0);
								playerinfo->setState(FubenRushType_Rushing);
								vitr = itr->second.erase(vitr);
								(*rushplayermap)[0].push_back(playerinfo);
								break;
							}
							else
							{
								(*vitr)->setState(FubenRushType_Rushing);
								(*vitr)->setRushCount(0);
							}
						}
					}
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

				//ref_ptr<crStreamBuf> stream = new crStreamBuf;
				//stream->createBuf(1);
				//stream->_writeUChar(success);
				//crPlayerDataEventPacket packet;
				//crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvFubenRushEnd,stream.get());
				//gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
		//else if(m_netType == GameClient_Game)
		//{
		//	unsigned char success = m_stream->_readUChar();
		//	if (success)
		//	{
		//		crData *data = m_this->getDataClass();
		//		if(data)
		//		{
		//			data->inputParam(WCHDATA_JXJFubenID,NULL);
		//		}
		//	}
		//}
	}
}
/////////////////////////////////////////
//
//crJXJFubenRushDisposeMethod
//
/////////////////////////////////////////
crJXJFubenRushDisposeMethod::crJXJFubenRushDisposeMethod():
	m_this(NULL){}
crJXJFubenRushDisposeMethod::crJXJFubenRushDisposeMethod(const crJXJFubenRushDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}
void crJXJFubenRushDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJFubenRushDisposeMethod::addParam(int i, const std::string& str)
{
}

void crJXJFubenRushDisposeMethod::operator()(crHandle &handle)
{
	//////////////////////////
	//返回					//
	//  1.扫荡剩余轮数		//	
	//	2.剩余军令			//
	//	3.战斗信息			//
	//////////////////////////
	bool success = false;
	void *param;
	int playerid = 0;
	crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
	crNetManager *netManager = gameServer->getNetManager();
	crNetDataManager *netDataManager = gameServer->getNetDataManager();
	ref_ptr<crGameServerPlayerData> playerData;

	ref_ptr<crPlayerGameData> playerGameData;
	crData *pgData;
	unsigned char currushcount = 0;
	int needbagcount;
	unsigned short* junling = 0;
	int fubenRushNeedBagNum = 0;
	ref_ptr<crTableIO> fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	crTableIO::StrVec record;
	unsigned short fubenid;
	unsigned char needjunling;
	unsigned char viplv;
	int junlingindex = fubentab->getTitleIndex("军令");
	crPlayerDataEventPacket packet;
	ref_ptr<crStreamBuf> stream = new crStreamBuf;
	stream->createBuf(3);

	JXJFubenRushVec *rushVec = NULL;
	crData *data = m_this->getDataClass();
	data->excHandle(MAKECREPARAM(WCH_LockData,1));
	data->getParam(WCHDATA_JXJFubenRushMap,param);
	JXJFubenRushMap *fubenrushmap = (JXJFubenRushMap *)param;
	if(!fubenrushmap->empty())
	{
		rushVec = &((*fubenrushmap)[0]);
	}
	data->excHandle(MAKECREPARAM(WCH_LockData,0));

	if(rushVec)
	{
		for( JXJFubenRushVec::iterator vitr = rushVec->begin();
			vitr!=rushVec->end();)
		{
			success = false;
			playerid = (*vitr)->getPlayerID();
			playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(playerData.valid() && playerData->getPlayerGameData() && playerData->getPlayerGameData()->getDataClass() && (*vitr)->getRushCount() > 0)
			{
				if ((*vitr) -> getState() == FubenRushType_Rushing)
				{
					playerGameData = playerData->getPlayerGameData();
					pgData = playerGameData->getDataClass();
					pgData->getParam(WCHDATA_JXJVipLv,param);
					viplv = *(unsigned char *)param;
					fubenRushNeedBagNum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFubenRushNeedBagNum,viplv).c_str());
					currushcount = 0;
					needbagcount = fubenRushNeedBagNum;
					pgData->excHandle(MAKECREPARAM(WCH_LockData,1));
					playerGameData->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
					pgData->getParam(WCHDATA_JXJJunling,param);
					junling = (unsigned short *)param;
					if (needbagcount == 0)
					{
						currushcount = (*vitr)->getRushCount();
						fubenid = (*vitr)->getFubenID();
						pgData->getParam(WCHDATA_JXJFubenProgressMap,param);
						FubenProgressMap *fubenProgressMap = (FubenProgressMap *)param;
						FubenProgressMap::iterator fbitr = fubenProgressMap->find(fubenid);
						if(fbitr != fubenProgressMap->end() && fbitr->second->getComplete() && junlingindex && fubentab->queryOneRecord(0,crArgumentParser::appItoa(fubenid),record) >= 0 )
						{
							needjunling = atoi(record[junlingindex].c_str())*100;
							if(needjunling>0 && *junling >= needjunling)
							{
								success = true;
								*junling -= needjunling;
								currushcount--;
								playerGameData->doEvent(WCH_JXJFubenRushReward,MAKECREPARAM(&fubenid,NULL));	
							}
							else
							{
								currushcount = 0;
							}
						}
						else
						{
							currushcount = 0;
						}
					}
					else
					{
						currushcount = 0;
					}
					/////////////////////////////////////
					stream->seekBegin();
					stream->_writeUChar(currushcount);
					stream->_writeUShort(*junling);
					if(currushcount == 0)
					{
						vitr = rushVec->erase(vitr);
						pgData->inputParam(WCHDATA_JXJFubenOrChengchiType,NULL);
						pgData->inputParam(WCHDATA_JXJFubenOrChengchiID,NULL);
					}
					else
					{
						(*vitr)->setRushCount(currushcount);
						++vitr;
					}
					pgData->excHandle(MAKECREPARAM(WCH_LockData,0));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvFubenRushInfo,stream.get());
					netManager->sendPacket(playerData->getPlayerConnectServerAddress(), packet);
					//增加活跃度/////////////////////////////////
					if (success && playerData.valid())
					{
						playerData->getPlayerGameData()->doEvent(WCH_JXJRecvHuoyuedu, MAKECREPARAM(HYD_FubenRush, 1));
					}
					///////////////////////////////////////////////
				}
				else
				{
					++vitr;
				}
			}
			else
			{
				vitr = rushVec->erase(vitr);
			}
		}
	}

	data->excHandle(MAKECREPARAM(WCH_LockData,1));
	if(!fubenrushmap->empty())
	{
		for (int i = 0; i < 5; i++)
		{
			(*fubenrushmap)[i].swap((*fubenrushmap)[i + 1]);
		}
	}
	data->excHandle(MAKECREPARAM(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJRecvFubenRushInfoMethod
//
/////////////////////////////////////////
crJXJRecvFubenRushInfoMethod::crJXJRecvFubenRushInfoMethod():
	m_netType(GameClient_Game){}
crJXJRecvFubenRushInfoMethod::crJXJRecvFubenRushInfoMethod(const crJXJRecvFubenRushInfoMethod& handle):
	crMethod(handle),
	m_leftswitch(handle.m_leftswitch),
	m_rightswitch(handle.m_rightswitch),
	m_rushradio(handle.m_rushradio),
	m_rushcountedit(handle.m_rushcountedit),
	m_rushjunlinginput(handle.m_rushjunlinginput)
{
}
void crJXJRecvFubenRushInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvFubenRushInfoMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_leftswitch = str;
		break;
	case 2:
		m_rightswitch = str;
		break;
	case 3:
		m_rushradio = str;
		break;
	case 4:
		m_rushcountedit = str;
		break;
	case 5:
		m_rushjunlinginput = str;
		break;
	case 6:
		m_numbersw1[0] = str;
		break;
	case 7:
		m_numbersw1[1] = str;
		break;
	case 8:
		m_numbersw1[2] = str;
		break;
	case 9:
		m_numbersw2[0] = str;
		break;
	case 10:
		m_numbersw2[1] = str;
		break;
	case 11:
		m_numbersw2[2] = str;
		break;
	}
}

void crJXJRecvFubenRushInfoMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			unsigned char rushcount = m_stream->_readUChar();
			unsigned short junling = m_stream->_readUShort();
			crData *data = m_this->getDataClass();
			data->inputParam(WCHDATA_JXJJunling,&junling);
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvas.valid())
			{
				crData *brainData = crBrain::getInstance()->getDataClass();
				brainData->inputParam(WCHDATA_JXJRemainFubenRushCount,&rushcount);
				if (rushcount == 0)
				{
					if (canvas.valid() && canvas->getVisiable())
					{
						crFilterRenderManager::getInstance()->closeCanvas(canvas.get());
					}
					//crData *data = m_this->getDataClass();
					//if(data)
					//{
					//	//data->inputParam(WCHDATA_JXJFubenID,NULL);
					//}
					crMultiSwitch *leftsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_leftswitch));
					crMultiSwitch *rightsw = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_rightswitch));
					ref_ptr<crRadioGroupWidgetNode> rushradio = dynamic_cast<crRadioGroupWidgetNode *>(canvas->getWidget(m_rushradio));
					ref_ptr<crEditWidgetNode> rushedit = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_rushcountedit));
					ref_ptr<crStaticTextWidgetNode> rushinput = dynamic_cast<crStaticTextWidgetNode *>(canvas->getWidget(m_rushjunlinginput));
// 					if (leftsw)
// 					{
// 						//leftsw->setActiveSwitchSet(FubenRushType_Ready);
// 					}
					if(rightsw)
					{
						rightsw->setActiveSwitchSet(FubenRushType_Ready);
					}
					if (rushradio.valid())
					{
						rushradio->select(0);
					}
					if (rushedit.valid())
					{
						rushedit->setString(std::string("0"));
					}
					if (rushinput.valid())
					{
						rushinput->setString(std::string("0"));
					}
				}
				else
				{
					crMultiSwitch *numbersw1[3] = {NULL};
					crMultiSwitch *numbersw2[3] = {NULL};
					for (int i = 0; i < 3; i++)
					{
						numbersw1[i] = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_numbersw1[i]));
						numbersw2[i] = dynamic_cast<crMultiSwitch *>(canvas->getChildNode(m_numbersw2[i]));
						if (numbersw1[i])
						{
							numbersw1[i]->setActiveSwitchSet(0);
						}
						if (numbersw2[i])
						{
							numbersw2[i]->setActiveSwitchSet(0);
						}
					}
					if (rushcount >= 100)
					{
						crVector3i num;
						int baiwei = rushcount / 100;
						int shiwei = (rushcount - baiwei * 100) / 10;
						int gewei = rushcount - baiwei * 100 - shiwei * 10;
						num[0] = baiwei;
						num[1] = gewei;
						num[2] = shiwei;
						for (int i = 0;i<3;i++)
						{
							if (numbersw1[i])
							{
								if (i == 0)
								{
									numbersw1[i]->setActiveSwitchSet(num[i]);
								}
								else
								{
									numbersw1[i]->setActiveSwitchSet(num[i] + 1);
								}
							}
							if (numbersw2[i])
							{
								if (i == 0)
								{
									numbersw2[i]->setActiveSwitchSet(num[i]);
								}
								else
								{
									numbersw2[i]->setActiveSwitchSet(num[i] + 1);
								}
							}
						}
					}
					else if (rushcount >= 10)
					{
						crVector2i num;
						num[0] = rushcount/10;
						num[1] = rushcount%10;
						for (int i = 0;i<2;i++)
						{
							if (numbersw1[i])
							{
								if (i == 0)
								{
									numbersw1[2]->setActiveSwitchSet(num[i] + 1);
								}
								else
								{
									numbersw1[1]->setActiveSwitchSet(num[i] + 1);
								}
							}
							if (numbersw2[i])
							{
								if (i == 0)
								{
									numbersw2[2]->setActiveSwitchSet(num[i] + 1);
								}
								else
								{
									numbersw2[1]->setActiveSwitchSet(num[i] + 1);
								}
							}
						}
					}
					else
					{
						if (numbersw1[2])
						{
							numbersw1[2]->setActiveSwitchSet(rushcount + 1);
						}
						if (numbersw2[2])
						{
							numbersw2[2]->setActiveSwitchSet(rushcount + 1);
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJChapterRadioAddNameMethod
//
/////////////////////////////////////////
crJXJChapterRadioAddNameMethod::crJXJChapterRadioAddNameMethod():
	m_this(NULL)
{
}
crJXJChapterRadioAddNameMethod::crJXJChapterRadioAddNameMethod(const crJXJChapterRadioAddNameMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_chapterradio(handle.m_chapterradio)
{
	for(int i = 0; i < 11; i++)
	{
		m_statename[i] = handle.m_statename[i];
	}
}
void crJXJChapterRadioAddNameMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJChapterRadioAddNameMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_chapterradio = str;
		break;
	case 1:
		m_statename[0] = str;
		break;
	case 2:
		m_statename[1] = str;
		break;
	case 3:
		m_statename[2] = str;
		break;
	case 4:
		m_statename[3] = str;
		break;
	case 5:
		m_statename[4] = str;
		break;
	case 6:
		m_statename[5] = str;
		break;
	case 7:
		m_statename[6] = str;
		break;
	case 8:
		m_statename[7] = str;
		break;
	case 9:
		m_statename[8] = str;
		break;
	case 10:
		m_statename[9] = str;
		break;
	case 11:
		m_statename[10] = str;
		break;
	}
}
void crJXJChapterRadioAddNameMethod::operator()(crHandle &handle)
{
	if (m_this)
	{
		ref_ptr<crRadioGroupWidgetNode> chapterradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_chapterradio));
		if (chapterradio.valid())
		{
			chapterradio->addRadioName(m_statename[0]);
			//chapterradio->clear();
			//for (int i = 0; i<11; i++)
			//{
			//	if (m_statename[i].length()>0)
			//	{
			//		chapterradio->addRadioName(m_statename[i]);
			//	}
			//}
			//int a = 0;
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIWidgetChangePageMethod
//
/////////////////////////////////////////
crJXJUIWidgetChangePageMethod::crJXJUIWidgetChangePageMethod():
	m_this(NULL),
	m_curpageid(0),
	m_totalpageid(0),
	m_extraPageId(0)
{
}
crJXJUIWidgetChangePageMethod::crJXJUIWidgetChangePageMethod(const crJXJUIWidgetChangePageMethod& handle):
	crMethod(handle),
	m_step(handle.m_step),
	m_needCanvas(handle.m_needCanvas),
	m_curpageid(handle.m_curpageid),
	m_totalpageid(handle.m_totalpageid),
	m_extraPageId(handle.m_extraPageId)
{
}
void crJXJUIWidgetChangePageMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIWidgetChangePageMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = str;
		break;
	case 1:
		m_curpageid = atoi(str.c_str());
		break;
	case 2:
		m_totalpageid = atoi(str.c_str());
		break;
	case 3:
		m_needCanvas = str;
		break;
	case 4:
		m_extraPageId = atoi(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJUIWidgetChangePageMethod::operator()(crHandle &handle)
{	
	//crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (m_needCanvas != "")
	{
		canvas = crFilterRenderManager::getInstance()->findCanvas(m_needCanvas);
	}
	if(m_this &&  m_curpageid > 0 && m_totalpageid > 0 && canvas.valid())
	{
		void *param;
		int curpagenum,totalpage;
		crData *canvasdata = canvas->getDataClass();
		if (canvasdata)
		{
			canvasdata->getParam(m_curpageid,param);
			curpagenum = *(int *)param;
			canvasdata->getParam(m_totalpageid,param);
			totalpage = *(int *)param;
			if (m_step == "L")
			{
				curpagenum = 1;
			}
			else if (m_step == "R")
			{
				curpagenum = totalpage;
			}
			else
			{
				curpagenum += atoi(m_step.c_str());
				if (curpagenum <= 0 || curpagenum>totalpage)
				{
					if (curpagenum <= 0 && m_extraPageId == m_curpageid)
					{//部分窗口的页数最小值为0,通过脚本传入对象m_extraPageId来验证
						curpagenum = 0;
					}
					else
					{
						curpagenum -=atoi(m_step.c_str());
					}
				}
			}
			canvasdata->inputParam(m_curpageid,&curpagenum);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIShowTipsCanvasMethod
//
/////////////////////////////////////////
crJXJUIShowTipsCanvasMethod::crJXJUIShowTipsCanvasMethod():
	m_this(NULL),
	m_noticeindex(0),
	m_isModal(false)
{
}
crJXJUIShowTipsCanvasMethod::crJXJUIShowTipsCanvasMethod(const crJXJUIShowTipsCanvasMethod& handle):
	crMethod(handle),
	m_noticeindex(handle.m_noticeindex),
	m_isModal(handle.m_isModal)
{
}
void crJXJUIShowTipsCanvasMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_noticeindex = LOCREPARAM(param64);
			m_isModal = HICREPARAM(param64);
		}
		else
		{
			m_noticeindex = 0;
			m_isModal = false;
		}
		break;
	}
}
void crJXJUIShowTipsCanvasMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tipcanvas = str;
		break;
	case 1:
		m_tipcontent = str;
		break;
	}
}
void crJXJUIShowTipsCanvasMethod::operator()(crHandle &handle)
{	
	if (m_noticeindex > 0)
	{
		ref_ptr<crTableIO>textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
		crTableIO::StrVec record;
		std::string tipstr;
		if(textTab->queryOneRecord(0,crArgumentParser::appItoa(m_noticeindex),record) >= 0 )
		{
			tipstr = record[1];		
		}
		if (!tipstr.empty())
		{
			ref_ptr<crCanvasNode>tipcanvas = crFilterRenderManager::getInstance()->findCanvas(m_tipcanvas);
			if (tipcanvas.valid())
			{
				ref_ptr<crStaticTextWidgetNode> tipcontent = dynamic_cast<crStaticTextWidgetNode *>(tipcanvas->getWidget(m_tipcontent));
				if (tipcontent.valid())
				{
					tipcontent->setString(tipstr);
				}
				//if (m_isModal)
				//{
					crFilterRenderManager::getInstance()->doModal(tipcanvas.get());
				//}
				//else
				//{
					//if (!tipcanvas -> getVisiable())
					//{
				//	crFilterRenderManager::getInstance()->showCanvas(tipcanvas.get(),true);
					//}
				//}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUICreateGroupMethod
//
/////////////////////////////////////////
crJXJUICreateGroupMethod::crJXJUICreateGroupMethod()
{
}

crJXJUICreateGroupMethod::crJXJUICreateGroupMethod(const crJXJUICreateGroupMethod& handle):
	crMethod(handle),
	m_inputname(handle.m_inputname),
	m_index(handle.m_index)
{
}

void crJXJUICreateGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUICreateGroupMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_inputname = str;
		break;
	case 1:
		m_index = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJUICreateGroupMethod::operator()(crHandle &handle)
{
	void *param;
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (canvas.valid())
	{
		crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
		CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
		crData *data = playerGameData->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;

		int needCopperlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedCopperLv,viplv).c_str());
		int needGoldlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedGoldLv,viplv).c_str());
		int needcopper = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedCopper,viplv).c_str());
		int needgold = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedGold,viplv).c_str());
		int maxsize = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGroupNameMaxSize,viplv).c_str());
		std::string juntuanname;
		ref_ptr<crEditWidgetNode> inputname = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_inputname));
		if (inputname.valid())
		{
			juntuanname = inputname->getUTF8String();
		}
		std::string groupName;
		if(!juntuanname.empty())
		{
			if (juntuanname.length() <=  maxsize)
			{
				int success = 0;
				playerGameData->doEvent(WCH_JXJCheckInvalidWords,MAKECREPARAM(&success,&juntuanname));
			
				if (success > 0)
				{
					playerGameData->doEvent(WCH_JXJCheckNameLimit,MAKECREPARAM(&success,&juntuanname));
					if (success > 0)
					{
						groupName  = crArgumentParser::trim(const_cast<char *>(juntuanname.c_str()));
						if (groupName.empty())
						{
							playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2021,NULL));
							return;
						}
						bool enoughmoney = false;
						crData *mainRoleData = playerGameData->getMainRole()->getDataClass();
						if (data && mainRoleData)
						{
							mainRoleData->getParam(WCHDATA_Level,param);
							unsigned char lv = *(unsigned char *)param;
							data->getParam(WCHDATA_JXJConsortiaID,param);
							short juntuanid = *(short *)param;
							if (juntuanid == 0)
							{
								if (m_index == CreatGruopCostType_Copper)
								{
									if (lv >= needCopperlv )
									{
										data->getParam(WCHDATA_JXJCoppercash,param);
										int copper = *(int *)param;
										if (copper >= needcopper)
										{
											enoughmoney = true;
										}
										else
										{
											enoughmoney = false;
											playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2001,NULL));//铜钱不足
										}
									}
									else
									{
										playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3079,NULL));//等级不足
									}
								}
								else if (m_index == CreatGruopCostType_Gold)
								{
									if (lv >= needGoldlv)
									{
										playerGameData->doEvent(WCH_JXJCheckLijinGold,MAKECREPARAM(&needgold,NULL));
										if(needgold == 0)
										{
											enoughmoney = true;
										}
										else
										{
											enoughmoney = false;
											playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2002,NULL));//元宝不足
										}
									}
									else
									{
										playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3080,NULL));//等级不足
									}
								}
								if(playerGameData && netConductor && enoughmoney)
								{
									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(5 + groupName.size());
									stream->_writeUChar(m_index);
									stream->_writeString(groupName);
									CRNetApp::crPlayerDataEventPacket packet;
									CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCreateGroup, stream.get());
									netConductor->getNetManager()->sendPacket("all",packet);
								}
							}
							else
							{
								playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2006,NULL));//已加入军团
							}
						}
					}
				}
			}
			else
			{
				playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2023,NULL));//名称过长
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCreateGroupMethod
//
/////////////////////////////////////////
crJXJRecvCreateGroupMethod::crJXJRecvCreateGroupMethod():
	m_netType(GameClient_Game){}
crJXJRecvCreateGroupMethod::crJXJRecvCreateGroupMethod(const crJXJRecvCreateGroupMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvCreateGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCreateGroupMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvCreateGroupMethod::operator()(crHandle &handle)
{
	//////////////////////////////
	//			返回			//
	//		   success			//
	//	0.创建军团失败。		//
	//	1.创建军团成功。		//
	//	2.军团名称被占用。		//
	//	3.领主等级不足。		//
	//	4.铜钱不足。			//
	//	5.元宝不足。			//
	//	6.已在军团中。			//
	//	7.已经申请过了。		//
	//	8.正在申请加入别的军团。//
	//////////////////////////////
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			bool needdeductgold = false;
			unsigned char success = JXJCreateGroupRet_suc;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			unsigned char costtype = m_stream->_readUChar();
			std::string juntuanname = m_stream->_readString();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				int needCopperlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedCopperLv,viplv).c_str());
				int needGoldlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedGoldLv,viplv).c_str());
				int needcopper = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedCopper,viplv).c_str());
				int needgold = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedGold,viplv).c_str());
				////////////////////////////////////////////
				crData *mainRoleData = m_this->getMainRole()->getDataClass();
				mainRoleData->getParam(WCHDATA_Level,param);
				unsigned char lv = *(unsigned char *)param;

				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJConsortiaID,param);
				int juntuanid = *(int *)param;
				if(juntuanid > 0)
				{
					success = JXJCreateGroupRet_failed_hasGroup ;
				}
				else
				{
					std::string groupName;
					gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
					ConsortiaMap *consortiaMap = (ConsortiaMap *)param;
					for(ConsortiaMap::iterator itr = consortiaMap->begin(); 
						itr != consortiaMap->end(); ++itr)
					{
						itr->second->getName(groupName);
						if (juntuanname == groupName)
						{
							success = JXJCreateGroupRet_failed_nameRepeat ;//名称重复
							break;
						}
					}
					if (success == JXJCreateGroupRet_suc)
					{
						if (costtype == CreatGruopCostType_Copper)
						{
							if (lv >= needCopperlv)
							{
								bool needdeductgold = false;
								m_this->doEvent(WCH_JXJDeductCopperCash,MAKECREPARAM(&needcopper,NULL));
								if (-1 == needcopper)
								{
									success = JXJCreateGroupRet_failed_noCopper ;
								}
							}
							else success = JXJCreateGroupRet_failed_noLevel;
						}
						else
						{
							if (lv >= needGoldlv)
							{
								MoneyChangeData moneydata(needgold,"元宝创建军团");
								m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
								if(moneydata.first != 0)
								{
									success = JXJCreateGroupRet_failed_noGold ;//元宝不足
								}
							}
							else success = JXJCreateGroupRet_failed_noLevel;
						}
					}
				}

				if(success == JXJCreateGroupRet_suc)
				{
					gsBrainData->getParam(WCHDATA_JXJCreateGroupDisposeDeq,param);
					CreateGroupDeq *creategroupdeq = (CreateGroupDeq *)param;
					for (CreateGroupDeq::iterator citr = creategroupdeq->begin();
						citr != creategroupdeq->end();
						++citr)
					{
						if (citr->first == playerid)
						{
							success = JXJCreateGroupRet_failed_willCreate ;//已经申请创建了
							break;
						}
					}
					if (success == JXJCreateGroupRet_suc)
					{
						creategroupdeq->push_back(std::make_pair(playerid,juntuanname));
					}
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(1);
				stream->_writeUChar(success);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCreateGroup,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = crArgumentParser::appItoa(success);
				GameLogData gamelog(Log_CreateGroup,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
			if (!m_this || !playerGameData || playerGameData->getDataClass() == NULL) return;
			if (m_this->getDataClass() == NULL) return;
			void *param;
			crData *data = playerGameData->getDataClass();
			data->getParam(WCHDATA_JXJShiliID,param);
			unsigned char shiliid = *(unsigned char *)param;

			std::string playerName = playerGameData->getCharacterName();
			unsigned char success = m_stream->_readUChar();
			if (success > 0)
			{
				int index = 0;
				switch (success)
				{
				case JXJCreateGroupRet_failed_noCopper:
					index = 2001;
					break;
				case JXJCreateGroupRet_failed_noGold:
					index = 2002;
					break;
				case JXJCreateGroupRet_failed_nameRepeat:
					index = 2005;
					break;
				case JXJCreateGroupRet_failed_noLevel:
					index = 2003;
					break;
				case JXJCreateGroupRet_failed_hasGroup:
					index = 2006;
					break;
				case JXJCreateGroupRet_failed_willCreate:
					index = 2007;
					break;
				case JXJCreateGroupRet_suc:
					break;
				default:
					break;
				}
				if (index > 0)
				{
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCreateGroupDisposeMethod
//
/////////////////////////////////////////
crJXJCreateGroupDisposeMethod::crJXJCreateGroupDisposeMethod():
	m_this(NULL),
	m_taskcount(5)
{
}
crJXJCreateGroupDisposeMethod::crJXJCreateGroupDisposeMethod(const crJXJCreateGroupDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_taskcount(handle.m_taskcount)
{
}
void crJXJCreateGroupDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	}
}

void crJXJCreateGroupDisposeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_taskcount = atoi(str.c_str());
		break;
	}
}

void crJXJCreateGroupDisposeMethod::operator()(crHandle &handle)
{
	crNetConductor *dbConductor = crNetContainer::getInstance()->getNetConductor(GameServerClient_DB);
	if(dbConductor)
	{
		m_taskVec.resize(0);
		m_taskVec.reserve(m_taskcount);
		void *param;
		crData *gameData = m_this->getDataClass();
		gameData ->excHandle(MAKECREPARAM(WCH_LockData,1));
		gameData ->getParam(WCHDATA_JXJCreateGroupDisposeDeq,param);
		CreateGroupDeq *disposeDeq = (CreateGroupDeq *)param;
		gameData ->getParam(WCHDATA_JXJConsortiaMap,param);
		ConsortiaMap *consortiamap = ( ConsortiaMap *)param;
		//typedef std::vector<std::pair<int ,std::string >> PlayerIDVec;
		//PlayerIDVec playerIDVec;
		//playerIDVec.reserve(disposeDeq->size());
		if(!disposeDeq->empty())
		{
			int playerid = 0;
			std::string juntuanname;
			int i = 0;
			while(!disposeDeq->empty() && i<m_taskcount)
			{
				playerid = disposeDeq->front().first;
				juntuanname = disposeDeq->front().second;
				disposeDeq->pop_front();
				m_taskVec.push_back(std::make_pair(playerid,juntuanname));
				i++;
			}
		}
		gameData->excHandle(MAKECREPARAM(WCH_LockData,0));

		if(!m_taskVec.empty())
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			crPlayerGameData *playerGameData;

			ref_ptr<crInsertConsortia> insertCreate = new crInsertConsortia;
			crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
			int insertid = 0;
			std::string createname;
			crDBSavePacket packet;
			char tmp[64]; 

			int playerid;
			std::string juntuanname ;
			for (std::vector< std::pair<int ,std::string> >::iterator itr = m_taskVec.begin(); itr != m_taskVec.end(); ++ itr)
			{
				playerid = itr->first;
				juntuanname = itr->second;
				playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(playerData.valid())
				{
					playerGameData = playerData->getPlayerGameData();
					if(playerGameData && playerGameData->getMainRole())
					{
						crData *mainRoleData = playerGameData->getMainRole()->getDataClass();
						crData *data = playerGameData->getDataClass();
						if(data && mainRoleData)
						{
							data ->getParam(WCHDATA_JXJShiliID,param);
							unsigned char shiliid = *(unsigned char *)param;
							ref_ptr<crJXJConsortia> consortiainfo = new crJXJConsortia;
							consortiainfo->loadData();
							crData *consortiadata = consortiainfo->getDataClass();
							if(consortiadata)
							{
								time_t t = time(0); 
								strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S",localtime(&t) ); 
								///////////////////添加到membermap
								mainRoleData->getParam(WCHDATA_Level,param);
								unsigned char mylv = *(unsigned char *)param;
								mainRoleData->getParam(WCHDATA_JXJGovPost,param);
								unsigned char govPost = *(unsigned char *)param;
								consortiadata->inputParam(WCHDATA_JXJConsortiaShiliID, &shiliid);
								unsigned char groupLevel = 1;
								consortiadata->inputParam(WCHDATA_JXJConsortialv, &groupLevel);
								consortiadata->inputParam(WCHDATA_JXJConsortiaName, &juntuanname);
								int groupExp = 0;
								consortiadata->inputParam(WCHDATA_JXJConsortiaFunds, &groupExp);
								int dismissTime = 48 * 60 * 60;
								consortiadata->inputParam(WCHDATA_JXJConsortiaDismissTime, &dismissTime);
								std::string notice = "欢迎加入军团！";
								consortiadata->inputParam(WCHDATA_JXJConsortiaNormalNotice, &notice);
								unsigned char conquest = 1;
								consortiadata->inputParam(WCHDATA_JXJConquest,&conquest);

								consortiadata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
								ConsortiaMemberMap *consortiamembermap = ( ConsortiaMemberMap *)param;
								ref_ptr<crJXJConsortiaMember> consortiamemberinfo = new crJXJConsortiaMember(playerid);
								consortiamemberinfo->setLevel(mylv);
								consortiamemberinfo->setName(playerData->getCharacterName());
								consortiamemberinfo->setPos(govPost);
								consortiamemberinfo->setGroupPos(JXJGroup_FirstLeader);
								consortiamemberinfo->setActiveValue(0);
								consortiamemberinfo->setTime(t);
								consortiamembermap->insert(std::make_pair(playerid,consortiamemberinfo));

								ref_ptr<CRCore::crStreamBuf> dataStream = new crStreamBuf;
								consortiadata->excHandle(MAKECREPARAM(WCH_BuildSaveStream,dataStream.get()));
								consortiainfo->updateLeaderVec();
								//往数据库里添加
								ref_ptr<crDataBase> dbSession = gameglobaldb->beginSession();
								insertid = 0;
								insertCreate->buildUpdateSql(/*juntuanname,playerid,*/dataStream.get());
								if(dbSession->executeUpdate(insertCreate.get()))
								{
									insertid = dbSession->getInsertID();
									consortiainfo->setID(insertid);
									consortiainfo->setCreateDate(tmp);
									dbSession->commit();
								}
								gameglobaldb->endSession(dbSession.get());

								if (insertid > 0)
								{
									////////////////////向客户端发送数据
									data->inputParam(WCHDATA_JXJConsortiaID,&insertid);

									data ->excHandle(MAKECREPARAM(WCH_LockData,1));
									data->getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
									MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *) param;
									myGroupApplySet->clear();
									data ->excHandle(MAKECREPARAM(WCH_LockData,0));

									gameData->excHandle(MAKECREPARAM(WCH_LockData,1));
									consortiamap->insert(std::make_pair(insertid,consortiainfo));
									consortiainfo->updateToRank(gameData);
									gameData->excHandle(MAKECREPARAM(WCH_LockData,0));

									ref_ptr<crStreamBuf> stream = new crStreamBuf;
									stream->createBuf(20);
									stream->_writeInt(insertid);
									stream->_writeString(juntuanname);


									// 插入一条国家频道消息
									crHandle *noticeHandle = crServerBrainHandle::getInstance()->getDataClass()->getHandle(WCH_JXJServerNotice);
									std::string shiliName[] = {"魏国","蜀国","吴国"};
									std::string outString ;
									std::string playerName = playerData->getCharacterName();
									//int mode = 2;
									int texid = 2000;
									noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
									//noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
									noticeHandle->inputParam(WCHDATA_NoticeParam1,&shiliName[shiliid - c_startShiliID]);
									noticeHandle->inputParam(WCHDATA_NoticeParam2,&playerName);
									noticeHandle->inputParam(WCHDATA_NoticeParam3,&juntuanname);
									noticeHandle->inputParam(WCHDATA_NoticeOutPut,&outString);
									crServerBrainHandle::getInstance()->doEvent(WCH_JXJServerNotice);

									ref_ptr<crJXJChatMessageInfo> chatInfo = new crJXJChatMessageInfo(playerData->getCharacterName(),outString,shiliid,shiliid);
									chatInfo->setSenderID(playerid);

									gameData->excHandle(MAKECREPARAM(WCH_LockData,1));
									crServerBrainHandle::getInstance()->doEvent(WCH_JXJSystermNoticeCreate,MAKECREPARAM(chatInfo.get(),NULL));
									gameData->excHandle(MAKECREPARAM(WCH_LockData,0));

									crPlayerDataEventPacket packet2;
									crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJClientRecvCreateGroup,stream.get());
									gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
								}
								else
								{
									crPlayerDataEventPacket packet2;
									crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJClientLeaveGroup,NULL);
									gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
								}
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGroupListOnShowMethod
//
/////////////////////////////////////////
crJXJUIGroupListOnShowMethod::crJXJUIGroupListOnShowMethod():
	m_this(NULL),
	m_curpageid(0),
	m_totalpageid(0)
{
}
crJXJUIGroupListOnShowMethod::crJXJUIGroupListOnShowMethod(const crJXJUIGroupListOnShowMethod& handle):
	crMethod(handle),
	m_step(handle.m_step),
	m_curpageid(handle.m_curpageid),
	m_totalpageid(handle.m_totalpageid)
{
}
void crJXJUIGroupListOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIGroupListOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_step = str;
		break;
	case 1:
		m_curpageid = atoi(str.c_str());
		break;
	case 2:
		m_totalpageid = atoi(str.c_str());
		break;
	}
}
void crJXJUIGroupListOnShowMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if(m_this && playerGameData && m_curpageid > 0 && m_totalpageid > 0)
	{
	}
}
/////////////////////////////////////////
//
//crJXJUIGroupListUpdateMethod
//
/////////////////////////////////////////
crJXJUIGroupListUpdateMethod::crJXJUIGroupListUpdateMethod():
	m_this(NULL)
{
}
crJXJUIGroupListUpdateMethod::crJXJUIGroupListUpdateMethod(const crJXJUIGroupListUpdateMethod& handle):
	crMethod(handle),
	m_grouplist(handle.m_grouplist),
	m_pageinput(handle.m_pageinput),
	m_leftbtn(handle.m_leftbtn),
	m_rightbtn(handle.m_rightbtn)
{
	for (int i = 0; i < 10; i++)
	{
		m_disapplybtn[i] = handle.m_disapplybtn[i];
		m_checkinfobtn[i] = handle.m_checkinfobtn[i];
	}
}
void crJXJUIGroupListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIGroupListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_disapplybtn[i] = str;
		break;
	case 1:
		m_disapplybtn[i] = str;
		break;
	case 2:
		m_disapplybtn[i] = str;
		break;
	case 3:
		m_disapplybtn[i] = str;
		break;
	case 4:
		m_disapplybtn[i] = str;
		break;
	case 5:
		m_disapplybtn[i] = str;
		break;
	case 6:
		m_disapplybtn[i] = str;
		break;
	case 7:
		m_disapplybtn[i] = str;
		break;
	case 8:
		m_disapplybtn[i] = str;
		break;
	case 9:
		m_disapplybtn[i] = str;
		break;
	case 10:
		m_checkinfobtn[i - 10] = str;
		break;
	case 11:
		m_checkinfobtn[i - 10] = str;
		break;
	case 12:
		m_checkinfobtn[i - 10] = str;
		break;
	case 13:
		m_checkinfobtn[i - 10] = str;
		break;
	case 14:
		m_checkinfobtn[i - 10] = str;
		break;
	case 15:
		m_checkinfobtn[i - 10] = str;
		break;
	case 16:
		m_checkinfobtn[i - 10] = str;
		break;
	case 17:
		m_checkinfobtn[i - 10] = str;
		break;
	case 18:
		m_checkinfobtn[i - 10] = str;
		break;
	case 19:
		m_checkinfobtn[i - 10] = str;
		break;
	case 20:
		m_grouplist = str;
		break;
	case 21:
		m_pageinput = str;
		break;
	case 22:
		m_leftbtn = str;
		break;
	case 23:
		m_rightbtn = str;
		break;
	case 24:
		m_recuitNotice = str;
		break;
	case 25:
		m_info = str;
		break;
	}
}

void crJXJUIGroupListUpdateMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if (playerGameData && m_this)
	{
		void *param;
		crData *data = playerGameData->getDataClass();
		crData *mainroledata = playerGameData->getMainRole()->getDataClass();
		if (data && mainroledata)
		{
			mainroledata->excHandle(MAKECREPARAM(WCH_LockData,1));
			/*data-> getParam(WCHDATA_JXJConsortiaID,param);
			int mygroupid = *( int *)param;*/
			ref_ptr<crTableWidgetNode> grouplist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_grouplist));
			ref_ptr<crStaticTextWidgetNode> pageinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pageinput));
			ref_ptr<crStaticTextWidgetNode> recuitNotice = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_recuitNotice));
			ref_ptr<crStaticTextWidgetNode> info = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_info));
			ref_ptr<crButtonWidgetNode> leftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_leftbtn));
			ref_ptr<crButtonWidgetNode> rightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_rightbtn));
			ref_ptr<crButtonWidgetNode> disapplybtn[10] = {NULL};
			ref_ptr<crButtonWidgetNode> checkinfobtn[10] = {NULL};
			for (int i = 0;i < 10;i++)
			{
				disapplybtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_disapplybtn[i]));
				checkinfobtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_checkinfobtn[i]));
				if (disapplybtn[i].valid())disapplybtn[i]->setVisiable(false);
				if (checkinfobtn[i].valid())checkinfobtn[i]->setVisiable(false);
			}

			ref_ptr<crStaticTextWidgetNode> textWidget = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_info));
			if(textWidget.valid())
			{
				int texid = 3016;
				crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
				noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
				int mode = 2;
				noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
				std::string output;
				noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
				crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
				textWidget->setString(output);
			}
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			unsigned char perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGroupPerPageNum,viplv).c_str());
			crData *canvasdata = m_this->getDataClass();
			if (canvasdata && grouplist.valid())
			{
				canvasdata->getParam(WCHDATA_JXJCurSelectGroupID,param);
				int curselectgroupid = *( int *)param;
				canvasdata->getParam(WCHDATA_JXJGroupCurPage,param);
				int curpage = *( int *)param;
				canvasdata->getParam(WCHDATA_JXJGroupTotalPage,param);
				int totalpage = *( int *)param;
				canvasdata->getParam(WCHDATA_JXJGroupInfoVec,param);
				GroupInfoVec *groupinfovec = (GroupInfoVec *)param;
				canvasdata->getParam(WCHDATA_JXJMyApplyGroupInfoSet,param);
				MyGroupApplySet * myGroupApplySet = ( MyGroupApplySet *)param;

				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;
				int sel = grouplist->getSelect();
				grouplist->clearData();
				int row = 0;
				if (!groupinfovec->empty())
				{
					if (recuitNotice.valid())
					{
						recuitNotice->clearString();
					}
					ref_ptr<crTableIO> groupUpgradeTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJMyGroupUpgradeTab);
					crTableIO::StrVec record;
					int memeberNumIdx = groupUpgradeTab->getTitleIndex("成员上限");
					
					std::string maxGroupNum;
					std::string creatorname;
					for( GroupInfoVec::iterator itr = groupinfovec->begin();
						itr != groupinfovec->end()&&row<perpagenum;
						++itr,row++ )
					{
						creatorname = (*itr)->getCreatorName();
						grouplist->addData(0,row,crArgumentParser::appItoa((*itr)->getRank()));
						grouplist->addData(1,row,(*itr)->getName());
						grouplist->addData(2,row,creatorname);
						grouplist->addData(3,row,crArgumentParser::appItoa((*itr)->getLv()));
						maxGroupNum.clear();
						if (groupUpgradeTab.valid() && groupUpgradeTab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getLv()),record) >= 0 ) 
						{
							maxGroupNum = record[memeberNumIdx];
						}
						grouplist->addData(4,row,crArgumentParser::appItoa((*itr)->getMemberCount()) + "/" + maxGroupNum);
						grouplist->addData(row,(*itr)->getID());

						if (myGroupApplySet && myGroupApplySet->find((*itr)->getID()) !=  myGroupApplySet->end())
						{
							// 显示已申请
							if (disapplybtn[row].valid())disapplybtn[row]->setVisiable(true);
						}
						else
						{
							// 显示查看
							if (checkinfobtn[row].valid())checkinfobtn[row]->setVisiable(true);
						}
						if (row == sel)
						{
							if (recuitNotice.valid())
							{
								recuitNotice->setString((*itr)->getNotice());
							}
						}
					}
				}
				if (pageinput.valid())
				{
					pageinput->setString(crArgumentParser::appItoa(curpage) + "/" + crArgumentParser::appItoa(totalpage));
				}
				grouplist->selectRow(sel);
			}
			mainroledata->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryGroupListMethod
//
/////////////////////////////////////////
crJXJQueryGroupListMethod::crJXJQueryGroupListMethod()
{
}

crJXJQueryGroupListMethod::crJXJQueryGroupListMethod(const crJXJQueryGroupListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_checkbox(handle.m_checkbox)
{
}

void crJXJQueryGroupListMethod::inputParam(int i, void *param)
{
}

void crJXJQueryGroupListMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_checkbox = str;
		break;
	default:
		break;
	}
}

void crJXJQueryGroupListMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		void *param;
		unsigned char rushcount = 0;
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			crData *canvasdata = canvas->getDataClass();
			if (canvasdata)
			{
				canvasdata->getParam(WCHDATA_JXJGroupCurPage,param);
				int startpage = *(int *)param;
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(1);
				stream->_writeUChar((unsigned char)startpage);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryGroupList, stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryGroupListMethod
//
/////////////////////////////////////////
crJXJRecvQueryGroupListMethod::crJXJRecvQueryGroupListMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryGroupListMethod::crJXJRecvQueryGroupListMethod(const crJXJRecvQueryGroupListMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvQueryGroupListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryGroupListMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvQueryGroupListMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			unsigned char startpage = m_stream->_readUChar();
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			unsigned char perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGroupPerPageNum,viplv).c_str());
			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
			gsBrainData->getParam(WCHDATA_JXJQueryGroupDisposeDeq,param);
			QueryGroupDeq *querygroupdeq = (QueryGroupDeq *)param;
			QueryGroupDeq::iterator itr;
			for(itr = querygroupdeq->begin(); itr != querygroupdeq->end(); ++itr)
			{
				if (itr->valid())
				{
					if ( (*itr)->playerid == playerid )
						break;
				}
			}
			if (itr == querygroupdeq->end())
			{
				CRCore::ref_ptr<QueryGroupDeqItem > newItem = new QueryGroupDeqItem;
				newItem->playerid = playerid;
				newItem->startPage = startpage;
				newItem->pageNum = perpagenum;
				querygroupdeq->push_back(newItem);
				//querygroupdeq->push_back(std::make_pair(playerid,std::make_pair(startpage,perpagenum)));
			}

			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryGroupDisposeMethod
//
/////////////////////////////////////////
crJXJQueryGroupDisposeMethod::crJXJQueryGroupDisposeMethod():
	m_this(NULL),
	m_dt(NULL),
	m_validterm(60){}
crJXJQueryGroupDisposeMethod::crJXJQueryGroupDisposeMethod(const crJXJQueryGroupDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_dt(NULL),
	m_validterm(handle.m_validterm)
{
}
void crJXJQueryGroupDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = (float*)LOCREPARAM(param64);
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJQueryGroupDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_validterm = atof(str.c_str());
		break;
	}
}

void crJXJQueryGroupDisposeMethod::operator()(crHandle &handle)
{
	crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
	if(m_this && gameglobaldb)
	{
		//GoodsCountMap Update;
		for( GroupRecordMap::iterator itr = m_groupRecordMap.begin();
			itr != m_groupRecordMap.end(); )
		{
			itr->second.second -= *m_dt;
			if(itr->second.second<=0)
			{
				itr = m_groupRecordMap.erase(itr);
				continue;
			}
			++itr;
		}

		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));

		data->getParam(WCHDATA_JXJConsortiaLvRank,param);
		ConsortialvRank *groupLvRank = (ConsortialvRank *)param;
		ConsortialvRank::RankSet & rankSet = groupLvRank->getRankSet();

		data->getParam(WCHDATA_JXJConsortiaMap,param);
		ConsortiaMap *consortiamap = ( ConsortiaMap *)param;
		data->getParam(WCHDATA_JXJQueryGroupDisposeDeq,param);
		QueryGroupDeq *querygroupdeq = (QueryGroupDeq *)param;
		if(!querygroupdeq->empty())
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			crPlayerGameData *playerGameData;

			crVector2i groupR;
			//std::pair<int,std::pair<unsigned char,unsigned char>> query;
			
			GroupRecordMap::iterator groupRecordItr;
			int count,bufsize,playerid,endline;
			ref_ptr<crStreamBuf> stream;
			crPlayerDataEventPacket packet;
			while(!querygroupdeq->empty())
			{
				CRCore::ref_ptr<QueryGroupDeqItem> query = querygroupdeq->front();
				querygroupdeq->pop_front();
				if (query.valid() == false) continue;

				playerid = query->playerid;
				playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(playerData.valid())
				{
					playerGameData = playerData->getPlayerGameData();
					if(playerGameData && playerGameData->getDataClass())
					{
						crData * player = playerGameData->getDataClass();
						player->getParam(WCHDATA_JXJShiliID,param);
						unsigned char playerShiLiid = *( unsigned char *)param;
						
						//查询记录
						int firstline = (query->startPage - 1) * query->pageNum;
						groupR.set(firstline,query->pageNum);
						groupRecordItr = m_groupRecordMap.find(groupR);
						if(groupRecordItr == m_groupRecordMap.end())
						{
							stream = new crStreamBuf;
							crData *condata;
							std::string bossname;
							ConsortialvRank::RankSet::iterator rsItr;
							ConsortiaMap::iterator mapitr;
							if(groupR[0]< rankSet.size())
							{
								unsigned char consortiamapsize = 0;
								stream->createBuf(512);
								stream->_writeInt(0);
								stream->_writeUChar(0);
								std::string groupName ;
								endline = groupR[0]+groupR[1];
								count = -1;
								for (rsItr = rankSet.begin(); rsItr != rankSet.end(); ++ rsItr )
								{
									if (rsItr->valid())
									{
										if (playerShiLiid != (*rsItr)->m_shili) 
											continue;
										mapitr = consortiamap->find((*rsItr)->m_id);
										if (mapitr == consortiamap->end())
											continue;
										++ count;
										if(count < groupR[0] || count >= endline) 
										{
											continue;
										}
										std::string  *notice = NULL;
										condata = mapitr->second->getDataClass();
										condata->getParam(WCHDATA_JXJConsortiaNormalNotice,param);
										notice = (std::string *)param;
										mapitr->second->getLeaderName(0,bossname);
										mapitr->second->getName(groupName);
										consortiamapsize++;
										stream->_writeInt(mapitr->second->getID());//军团ID
										stream->_writeString(groupName);//军团名称20
										stream->_writeString(bossname);//团长名称20
										stream->_writeUChar(mapitr->second->getLevel());//军团等级
										stream->_writeUShort(mapitr->second->getMemberCount());//成员人数
										stream->_writeUChar(playerShiLiid);//军团势力
										stream->_writeString(*notice);//军团公告132
										stream->_writeInt(count + 1);
									}
								}

								m_groupRecordMap[groupR] = std::make_pair(stream.get(),m_validterm);
								bufsize = stream->getBufSize();
								stream->seekBegin();
								stream->_writeInt(count);
								stream->_writeUChar(consortiamapsize);
								stream->setBufSize(bufsize);
								//向客户端发送数据
								crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvGroupList,stream.get());
								gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							}
						}
						//else
						//{
						//	stream = groupRecordItr->second.first.get();
						//	count = consortiamap->size();
						//	bufsize = stream->getBufSize();
						//	stream->seekBegin();
						//	stream->_writeInt(count);
						//	stream->setBufSize(bufsize);
						//	//向客户端发送数据
						//	crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvGroupList,stream.get());
						//	gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						//}
					}
				}
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvGroupListMethod
//
/////////////////////////////////////////
crJXJClientRecvGroupListMethod::crJXJClientRecvGroupListMethod():
	m_netType(GameClient_Game){}
crJXJClientRecvGroupListMethod::crJXJClientRecvGroupListMethod(const crJXJClientRecvGroupListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}
void crJXJClientRecvGroupListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvGroupListMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvas = str;
		break;
	}
}

void crJXJClientRecvGroupListMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvas.valid() && data)
			{
				crData *canvasdata = canvas->getDataClass();
				if (canvasdata)
				{
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					unsigned char perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGroupPerPageNum,viplv).c_str());
					canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
					canvasdata ->getParam(WCHDATA_JXJGroupInfoVec,param);
					GroupInfoVec *groupinfovec = (GroupInfoVec *)param;
					groupinfovec->clear();
					int groupcount = m_stream->_readInt();
					unsigned char  size = m_stream->_readUChar();
					for (int i = 0; i < size; i++)
					{
						ref_ptr<crJXJGroupInfo> groupinfo = new crJXJGroupInfo;
						groupinfo->setID(m_stream -> _readInt());
						groupinfo->setName(m_stream -> _readString());
						groupinfo->setCreatorName(m_stream -> _readString());
						groupinfo->setLv(m_stream -> _readUChar());
						groupinfo->setMemberCount(m_stream -> _readUShort());
						groupinfo->setShiliID(m_stream -> _readUChar());
						groupinfo->setNotice(m_stream -> _readString());
						groupinfo->setRank(m_stream->_readInt());
						groupinfovec->push_back(groupinfo);
					}
					int totalpage = ceil((float)groupcount/(float)perpagenum) ;
					if (totalpage < 1)
					{
						totalpage = 1;
					}
					canvasdata ->inputParam(WCHDATA_JXJGroupTotalPage,&totalpage);
					canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
					canvas->doEvent(WCH_UI_UpdateData);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckBagEmptyBagMethod
//
/////////////////////////////////////////
crJXJCheckBagEmptyBagMethod::crJXJCheckBagEmptyBagMethod():
	m_this(NULL),
	m_count(0)
{
}
crJXJCheckBagEmptyBagMethod::crJXJCheckBagEmptyBagMethod(const crJXJCheckBagEmptyBagMethod& handle):
	crMethod(handle),
	m_count(handle.m_count)
{
}
void crJXJCheckBagEmptyBagMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_count = (int *)LOCREPARAM(param64);
		}
		else
		{
			m_count = 0;
		}
		break;
	}
}
void crJXJCheckBagEmptyBagMethod::addParam(int i, const std::string& str)
{
}
void crJXJCheckBagEmptyBagMethod::operator()(crHandle &handle)
{	
	//返回0代表格子足够
	if (*m_count > 0)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		data->getParam(WCHDATA_JXJItemBagVec,param);
		JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
		if (*m_count <= itembagvec->size())
		{
			for(JXJItemBagVec::iterator itr = itembagvec->begin();
				itr!=itembagvec->end();
				++itr)
			{
				if (!itr->get())
				{
					(*m_count)--;
					if (*m_count == 0)
					{
						break;
					}
				}
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJSetCurSelectGroupIDMethod
//
/////////////////////////////////////////
crJXJSetCurSelectGroupIDMethod::crJXJSetCurSelectGroupIDMethod():
	m_index(0)
{
}

crJXJSetCurSelectGroupIDMethod::crJXJSetCurSelectGroupIDMethod(const crJXJSetCurSelectGroupIDMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_index(handle.m_index),
	m_gamelist(handle.m_gamelist)
{
}

void crJXJSetCurSelectGroupIDMethod::inputParam(int i, void *param)
{
}

void crJXJSetCurSelectGroupIDMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_index = atoi(str.c_str());
		break;
	case 2:
		m_gamelist = str;
		break;
	default:
		break;
	}
}

void crJXJSetCurSelectGroupIDMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if (canvas.valid())
	{
		int curselectid = 0;
		crData *canvasdata = canvas->getDataClass();
		if (canvasdata)
		{
			void *param;
			ref_ptr<crTableWidgetNode> grouplist = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_gamelist));
			canvasdata->getParam(WCHDATA_JXJGroupInfoVec,param);
			GroupInfoVec *groupinfovec = (GroupInfoVec *)param;
			if (m_index < groupinfovec->size())
			{
				curselectid = (*groupinfovec)[m_index]->getID();
				if (grouplist.valid())
				{
					grouplist->selectRow(m_index);

				}
			}
			canvasdata->inputParam(WCHDATA_JXJCurSelectGroupID,&curselectid);
		}
	}
}
/////////////////////////////////////////
//
//crJXJApplyJionGroupMethod
//
/////////////////////////////////////////
crJXJApplyJionGroupMethod::crJXJApplyJionGroupMethod()
{
}

crJXJApplyJionGroupMethod::crJXJApplyJionGroupMethod(const crJXJApplyJionGroupMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}

void crJXJApplyJionGroupMethod::inputParam(int i, void *param)
{
}

void crJXJApplyJionGroupMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJApplyJionGroupMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		void *param;
		crData *mainroledata = playerGameData->getMainRole()->getDataClass();
		crData * data = playerGameData->getDataClass();
		if (mainroledata && data)
		{
			data->getParam(WCHDATA_JXJConsortiaID,param);
			int groupid = *(int *)param;
			if (groupid == 0)
			{
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if (canvas.valid())
				{
					crData *canvasdata = canvas->getDataClass();
					if (canvasdata)
					{
						canvasdata->getParam(WCHDATA_JXJMyApplyGroupInfoSet,param);
						MyGroupApplySet * myGroupApplySet = ( MyGroupApplySet *)param;
						mainroledata->getParam(WCHDATA_Level,param);
						unsigned char lv = *(unsigned char *)param;

						data->getParam(WCHDATA_JXJVipLv,param);
						unsigned char viplv = *(unsigned char *)param;

						int needGoldlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJJoinGroupNeedLv,viplv).c_str());

						if (lv >= needGoldlv)
						{
							unsigned char maxMember = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJConsortiaApplyMaxNum	).c_str());
							if ( myGroupApplySet->size() < maxMember)
							{
								bool ifapply = false;
								canvasdata->getParam(WCHDATA_JXJCurSelectGroupID,param);
								int selectid = *(int *)param;

								MyGroupApplySet::iterator itr = myGroupApplySet->find(selectid);
								if (itr == myGroupApplySet->end())
								{
									CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
									stream->createBuf(4);
									stream->_writeInt(selectid);
									CRNetApp::crPlayerDataEventPacket packet;
									CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvApplyJionGroup, stream.get());
									netConductor->getNetManager()->sendPacket("all",packet);
								}
								else
								{
									playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2016,NULL));
								}
							}
							else
							{
								playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2022,NULL));
							}
						}
						else
						{
							playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3081,NULL));//等级不足
						}
					}
				}
			}
			else
			{
				playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2017,NULL));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvApplyJionGroupMethod
//
/////////////////////////////////////////
crJXJRecvApplyJionGroupMethod::crJXJRecvApplyJionGroupMethod():
	m_netType(GameClient_Game){}
crJXJRecvApplyJionGroupMethod::crJXJRecvApplyJionGroupMethod(const crJXJRecvApplyJionGroupMethod& handle):
	crMethod(handle),
	m_groupcanvas(handle.m_groupcanvas),
	m_myGroupcanvas(handle.m_myGroupcanvas)
{
}
void crJXJRecvApplyJionGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvApplyJionGroupMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_groupcanvas = str;
		break;
	case 1:
		m_myGroupcanvas = str;
		break;
	}
}

void crJXJRecvApplyJionGroupMethod::operator()(crHandle &handle)
{
	//////////////////////////////
	//返回success
	//0.军团不存在或数据错误
	//1.申请成功
	//2.已经申请过了
	//3.已经在军团中了
	//4.申请数过多
	///////////////////////////////
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = JXJApplyJoinInGroupRet_failed_unkwon;
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && m_this->getMainRole())
			{
				crData *data = m_this->getDataClass();
				crData *mainroledata = m_this->getMainRole()->getDataClass();
				if (data && mainroledata)
				{
					int leaderId = 0;
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					int selectid = m_stream->_readInt();
					data->getParam(WCHDATA_JXJConsortiaID,param);
					int groupid = *(int *)param;
					if (groupid == 0)
					{
						data->getParam(WCHDATA_JXJVipLv,param);
						unsigned char viplv = *(unsigned char *)param;
						crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
						ref_ptr<crData> groupdata;
						gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
						gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
						ConsortiaMap *consortiaMap = (ConsortiaMap *)param;
						ConsortiaMap::iterator itr = consortiaMap->find(selectid);
						if (itr != consortiaMap->end())
						{
							groupdata = itr->second->getDataClass(); 
						}
						if(groupdata.valid())
						{
							data->getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
							MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *) param;
							do 
							{
								bool modify = false;
								ref_ptr<crTableIO> groupUpgradeTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJMyGroupUpgradeTab);
								crTableIO::StrVec record;

								groupdata->getParam(WCHDATA_JXJConsortiaLeaderVec,param);
								GroupLeaderVec *groupLeaderVec = (GroupLeaderVec *)param;
								if (groupLeaderVec->size())
								{
									leaderId = (*groupLeaderVec)[0];
								}
								groupdata->getParam(WCHDATA_JXJConsortialv,param);
								unsigned char groupLv = *(unsigned char *)param;
								groupdata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
								ConsortiaMemberMap * consortiaMemberMap = (ConsortiaMemberMap *) param;
								groupdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
								ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
								ConsortiaApplyVec::iterator citr;
								for (citr = applyvec->begin(); citr != applyvec->end(); ++citr)
								{
									if ((*citr)->getPlayerID() == playerid)
									{
										applyvec->erase(citr);
										modify = true;
										break;
									}
								}
								int memeberNumIdx = groupUpgradeTab->getTitleIndex("成员上限");
								if (groupUpgradeTab->queryOneRecord(0,crArgumentParser::appItoa(groupLv),record) >= 0 ) 
								{
									if (consortiaMemberMap->size() >= atoi(record[memeberNumIdx].c_str()))
									{
										success = JXJApplyJoinInGroupRet_failed_groupFull;
										break;
									}
								}
								unsigned char maxMember = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJConsortiaApplyMaxNum	).c_str());
								MyGroupApplySet::iterator setIt = myGroupApplySet->find(selectid);
								if (myGroupApplySet->end() != setIt)
								{
									success = JXJApplyJoinInGroupRet_failed_hadApply;
								}
								else if (myGroupApplySet->size() > maxMember )
								{
									success = JXJApplyJoinInGroupRet_failed_numLimit;
								}
								else
								{
									success = JXJApplyJoinInGroupRet_suc;
									mainroledata->getParam(WCHDATA_Level,param);
									unsigned char lv = *(unsigned char *)param;
									mainroledata->getParam(WCHDATA_JXJGovPost,param);
									unsigned char post = *(unsigned char*)param;
									time_t t = time(0); 
									ref_ptr<crJXJConsortiaApplyMember> applymember = new crJXJConsortiaApplyMember(playerid);
									applymember->setName(playerData->getCharacterName());
									applymember->setLevel(lv);
									applymember->setPos(post);
									applymember->setTime((int)t);
									applyvec->push_back(applymember);
									myGroupApplySet->insert(selectid);
									modify = true;
								}
								if (modify)
								{
									groupdata->inputParam(WCHDATA_JXJConsortiaModify,&modify);
								}
							} while (0);
						}
						gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
					else
					{
						success = JXJApplyJoinInGroupRet_failed_inGroup;
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));

					crPlayerDataEventPacket packet;
					ref_ptr<crStreamBuf> streamBuf = new crStreamBuf;
					streamBuf->createBuf(5);
					streamBuf->_writeUChar(success);
					streamBuf->_writeInt(playerid);
					streamBuf->_writeInt(selectid);
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvApplyJionGroup,streamBuf.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

					if (success == JXJApplyJoinInGroupRet_suc)
					{
						ref_ptr<crGameServerPlayerData> leaderData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(leaderId));
						if (leaderData.valid())
						{
							crPlayerDataEventPacket::buildReplyPacket(packet,leaderId,WCH_JXJRecvApplyJionGroup,streamBuf.get());
							gameServer->getNetManager()->sendPacket(leaderData->getPlayerConnectServerAddress(),packet);
						}
					}
					///游戏日志
					std::string logdata = crArgumentParser::appVectoa(crVector2i(success,selectid));
					GameLogData gamelog(Log_ApplyJionGroup,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			int playerid = m_stream->_readInt();
			int selectid = m_stream->_readInt();
			int index = 0;
			switch (success)
			{
			case JXJApplyJoinInGroupRet_failed_groupFull:
				{
					index = 2014;
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
				}
				break;
			case JXJApplyJoinInGroupRet_failed_numLimit:
				{
					index = 2022;
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
				}
				break;
			case JXJApplyJoinInGroupRet_failed_hadApply:
				{
					index = 2016;
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
				}
				break;
			case JXJApplyJoinInGroupRet_failed_inGroup:
				{
					index = 2017;
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
				}
				break;
			case JXJApplyJoinInGroupRet_suc:
				{
					crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
					if (playerData->getPlayerID() == playerid)
					{
						ref_ptr<crCanvasNode>groupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_groupcanvas);
						if (groupcanvas.valid())
						{
							crData *canvasdata = groupcanvas->getDataClass();
							if (canvasdata)
							{
								void *param;
								canvasdata->getParam(WCHDATA_JXJMyApplyGroupInfoSet,param);
								MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *)param;
								myGroupApplySet->insert(selectid);
								index = 2015;
								m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
							}
						}
					}
					else
					{
						ref_ptr<crCanvasNode>groupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_myGroupcanvas);
						if (groupcanvas.valid())
						{
							crData *canvasdata = groupcanvas->getDataClass();
							if (canvasdata)
							{
								bool hasNew = true;
								canvasdata->inputParam(WCHDATA_JXJConsortiaHasNewApplyer,&hasNew);
								hasNew = false;
								canvasdata->inputParam(WCHDATA_JXJConsortiaHadOpenShenHe,&hasNew);
							}
						}
					}
				}
				break;
			default:
				break;
			}
			
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIApplyListUpdateMethod
//
/////////////////////////////////////////
crJXJUIApplyListUpdateMethod::crJXJUIApplyListUpdateMethod():
	m_this(NULL)
{
}
crJXJUIApplyListUpdateMethod::crJXJUIApplyListUpdateMethod(const crJXJUIApplyListUpdateMethod& handle):
	crMethod(handle),
	m_grouplist(handle.m_grouplist),
	m_groupignoreall(handle.m_groupignoreall),
	m_pageinput(handle.m_pageinput),
	m_farleftbtn(handle.m_farleftbtn),
	m_leftbtn(handle.m_leftbtn),
	m_rightbtn(handle.m_rightbtn),
	m_farrightbtn(handle.m_farrightbtn)
{
	for (int i = 0; i < 10; i++)
	{
		m_applybtn[i] = handle.m_applybtn[i];
		m_disapplybtn[i] = handle.m_disapplybtn[i];
	}
}
void crJXJUIApplyListUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIApplyListUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_applybtn[i] = str;
		break;
	case 1:
		m_applybtn[i] = str;
		break;
	case 2:
		m_applybtn[i] = str;
		break;
	case 3:
		m_applybtn[i] = str;
		break;
	case 4:
		m_applybtn[i] = str;
		break;
	case 5:
		m_applybtn[i] = str;
		break;
	case 6:
		m_applybtn[i] = str;
		break;
	case 7:
		m_applybtn[i] = str;
		break;
	case 8:
		m_applybtn[i] = str;
		break;
	case 9:
		m_applybtn[i] = str;
		break;
	case 10:
		m_disapplybtn[i - 10] = str;
		break;
	case 11:
		m_disapplybtn[i - 10] = str;
		break;
	case 12:
		m_disapplybtn[i - 10] = str;
		break;
	case 13:
		m_disapplybtn[i - 10] = str;
		break;
	case 14:
		m_disapplybtn[i - 10] = str;
		break;
	case 15:
		m_disapplybtn[i - 10] = str;
		break;
	case 16:
		m_disapplybtn[i - 10] = str;
		break;
	case 17:
		m_disapplybtn[i - 10] = str;
		break;
	case 18:
		m_disapplybtn[i - 10] = str;
		break;
	case 19:
		m_disapplybtn[i - 10] = str;
		break;
	case 20:
		m_grouplist = str;
		break;
	case 21:
		m_groupignoreall = str;
		break;
	case 22:
		m_pageinput = str;
		break;
	case 23:
		m_farleftbtn = str;
		break;
	case 24:
		m_leftbtn = str;
		break;
	case 25:
		m_rightbtn = str;
		break;
	case 26:
		m_farrightbtn = str;
		break;
	}
}
void crJXJUIApplyListUpdateMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if (playerGameData && m_this)
	{
		void *param;
		crData *data = playerGameData->getDataClass();
		//crData *mainroledata = playerGameData->getMainRole()->getDataClass();
		if (data /*&& mainroledata*/)
		{
			data-> getParam(WCHDATA_JXJConsortiaID,param);
			int mygroupid = *( int *)param;
			ref_ptr<crTableWidgetNode> grouplist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_grouplist));
			ref_ptr<crButtonWidgetNode> groupignoreall = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_groupignoreall));
			ref_ptr<crStaticTextWidgetNode> pageinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pageinput));
			ref_ptr<crButtonWidgetNode> farleftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_farleftbtn));
			ref_ptr<crButtonWidgetNode> leftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_leftbtn));
			ref_ptr<crButtonWidgetNode> rightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_rightbtn));
			ref_ptr<crButtonWidgetNode> farrightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_farrightbtn));
			ref_ptr<crButtonWidgetNode> applybtn[10] = {NULL};
			ref_ptr<crButtonWidgetNode> disapplybtn[10] = {NULL};
			for (int i = 0;i < 10;i++)
			{
				applybtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_applybtn[i]));
				disapplybtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_disapplybtn[i]));
				if (applybtn[i].valid())applybtn[i]->setVisiable(false);
				if (disapplybtn[i].valid())disapplybtn[i]->setVisiable(false);
			}
			if (groupignoreall.valid())
			{
				groupignoreall->setEnable(false);
			}

			crData *canvasdata = m_this->getDataClass();
			if (canvasdata)
			{
				ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
				crTableIO::StrVec record;
				int govpostindex = postTab->getTitleIndex("govpost");
				canvasdata->getParam(WCHDATA_JXJGroupApplyCurPage,param);
				int curpage = *( int *)param;
				canvasdata->getParam(WCHDATA_JXJGroupApplyTotalPage,param);
				int totalpage = *( int *)param;
				if (pageinput.valid())
				{
					pageinput->setString(crArgumentParser::appItoa(curpage) + "/" + crArgumentParser::appItoa(totalpage));
				}
				canvasdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
				ConsortiaApplyVec *groupapplyvec = (ConsortiaApplyVec *)param;

				grouplist->clearData();
				int row = 0;
				char tmp[64];
				time_t t;
				if (!groupapplyvec->empty())
				{
					if(groupignoreall.valid())groupignoreall->setEnable(true);
					for( ConsortiaApplyVec::iterator itr = groupapplyvec->begin();
						itr != groupapplyvec->end();
						++itr,row++ )
					{
						t = (*itr)->getTime();
						strftime( tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S",localtime(&t) ); 
						grouplist->addData(0,row,tmp);
						grouplist->addData(1,row,(*itr)->getName());
						grouplist->addData(2,row,crArgumentParser::appItoa((*itr)->getLevel()));
						if (postTab->queryOneRecord(0,crArgumentParser::appItoa((*itr)->getPos()),record) >= 0)
						{
							grouplist->addData(3,row,record[govpostindex]);
						}
						grouplist->addData(row,(*itr)->getPlayerID());
					}
					if (applybtn[0].valid())applybtn[0]->setVisiable(true);
					if (disapplybtn[0].valid())disapplybtn[0]->setVisiable(true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJResetCurPageMethod
//
/////////////////////////////////////////
crJXJResetCurPageMethod::crJXJResetCurPageMethod():
	m_msg(0)
{
}

crJXJResetCurPageMethod::crJXJResetCurPageMethod(const crJXJResetCurPageMethod& handle):
	m_canvas(handle.m_canvas)
{
}

void crJXJResetCurPageMethod::inputParam(int i, void *param)
{
}

void crJXJResetCurPageMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_msg = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJResetCurPageMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if(canvas.valid() && playerData)
	{
		void *param; // parameter extracting
		crData *canvasdata = canvas->getDataClass();	
		if (canvasdata && m_msg > 0)
		{
			canvasdata->getParam(m_msg, param);
			int *cur_page = ((int *)param);
			*cur_page = 1;
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryGroupApplyListMethod
//
/////////////////////////////////////////
crJXJQueryGroupApplyListMethod::crJXJQueryGroupApplyListMethod()
{
}

crJXJQueryGroupApplyListMethod::crJXJQueryGroupApplyListMethod(const crJXJQueryGroupApplyListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}

void crJXJQueryGroupApplyListMethod::inputParam(int i, void *param)
{
}

void crJXJQueryGroupApplyListMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJQueryGroupApplyListMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		void *param;
		bool ifquery = false;
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			crData *canvasdata = canvas->getDataClass();
			if (canvasdata)
			{
				canvasdata->getParam(WCHDATA_JXJMyGroupInfo,param);
				crJXJGroupInfo *groupinfo = (crJXJGroupInfo *)param;
				if (groupinfo->getCreatorName().empty())
				{
					ifquery = true;
				}
				else if(groupinfo->getCreatorName().compare(playerGameData->getCharacterName()) == 0)
				{
					ifquery = true;
				}
				if (ifquery)
				{
					canvasdata->getParam(WCHDATA_JXJGroupApplyCurPage,param);
					int startpage = *(int *)param;
					CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
					stream->createBuf(1);
					stream->_writeUChar((unsigned char)startpage);
					CRNetApp::crPlayerDataEventPacket packet;
					CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryGroupApplyList, stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryGroupApplyListMethod
//
/////////////////////////////////////////
crJXJRecvQueryGroupApplyListMethod::crJXJRecvQueryGroupApplyListMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryGroupApplyListMethod::crJXJRecvQueryGroupApplyListMethod(const crJXJRecvQueryGroupApplyListMethod& handle):
	crMethod(handle),
	m_applycanvas(handle.m_applycanvas)
{
}
void crJXJRecvQueryGroupApplyListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryGroupApplyListMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_applycanvas = str;
		break;
	}
}

void crJXJRecvQueryGroupApplyListMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (data && m_this->getMainRole() && m_this->getMainRole()->getDataClass() && playerData.valid())
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				unsigned char perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGroupApplyPerPageNum,viplv).c_str());
				int invalidapplytime = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJInvalidApplyTime,viplv).c_str());
				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;
				unsigned char startpage = m_stream->_readUChar();
				int startline = (startpage - 1) * perpagenum;
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
				ConsortiaMap *consortiamap = (ConsortiaMap *)param;
				ConsortiaMap::iterator itr = consortiamap->find(mygroupid);
				ref_ptr<crData>groupdata;
				if (itr != consortiamap->end())
				{
					groupdata = itr->second->getDataClass();
				}
				if (groupdata.valid())
				{
					int size = 0;
					crPlayerDataEventPacket packet;
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					groupdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
					ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
					if (!applyvec->empty())
					{
						if(startline < applyvec->size())
						{
							for (int i = startline; i <startline+perpagenum && i < applyvec->size();++i)
							{
								size +=14 + (*applyvec)[i]->getName().size();
							}
							unsigned char querycount = perpagenum;
							if (startline+perpagenum >= applyvec->size())
							{
								querycount = applyvec->size() - startline;
							}
							stream->createBuf(1 + size);
							stream->_writeUChar(querycount);
							for (int i = startline; i <startline+perpagenum && i < applyvec->size();++i)
							{
								stream->_writeInt((*applyvec)[i]->getPlayerID());
								stream->_writeString((*applyvec)[i]->getName());
								stream->_writeUChar((*applyvec)[i]->getLevel());
								stream->_writeUChar((*applyvec)[i]->getPos());
								stream->_writeInt((*applyvec)[i]->getTime());
							}
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvQueryGroupApplyList,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
					else
					{
						stream->createBuf(1);
						stream->_writeUChar(0);
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvQueryGroupApplyList,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if (m_netType == GameClient_Game)
		{
			void *param;
			unsigned char querycount = m_stream->_readUChar();
			ref_ptr<crCanvasNode>applycanvas = crFilterRenderManager::getInstance()->findCanvas(m_applycanvas);
			ConsortiaApplyVec *groupapplyvec;
			if (applycanvas.valid())
			{
				crData *canvasdata = applycanvas->getDataClass();
				if (canvasdata)
				{
					canvasdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
					groupapplyvec = (ConsortiaApplyVec *)param;
					groupapplyvec->clear();
					bool hasNewApplyer = querycount ? true : false;
					canvasdata->inputParam(WCHDATA_JXJConsortiaHasNewApplyer,&hasNewApplyer);
					for (int i = 0; i < querycount; i++)
					{
						ref_ptr<crJXJConsortiaApplyMember> applymember = new crJXJConsortiaApplyMember(m_stream->_readInt());
						applymember->setName(m_stream->_readString());
						applymember->setLevel(m_stream->_readUChar());
						applymember->setPos(m_stream->_readUChar());
						applymember->setTime(m_stream->_readInt());
						groupapplyvec->push_back(applymember);
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJGroupSetCurSelectPlayerIDMethod
//
/////////////////////////////////////////
crJXJGroupSetCurSelectPlayerIDMethod::crJXJGroupSetCurSelectPlayerIDMethod():
	m_index(0)
{
}

crJXJGroupSetCurSelectPlayerIDMethod::crJXJGroupSetCurSelectPlayerIDMethod(const crJXJGroupSetCurSelectPlayerIDMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_index(handle.m_index),
	m_gamelist(handle.m_gamelist)
{
}

void crJXJGroupSetCurSelectPlayerIDMethod::inputParam(int i, void *param)
{
}

void crJXJGroupSetCurSelectPlayerIDMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_gamelist = str;
		break;
	//case 1:
	//	m_index = atoi(str.c_str());
	//	break;
	default:
		break;
	}
}

void crJXJGroupSetCurSelectPlayerIDMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	if (canvas.valid())
	{
//		void *param;
		int curselectid = 0;
		crData *canvasdata = canvas->getDataClass();
		if (canvasdata)
		{
			ref_ptr<crTableWidgetNode> grouplist = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_gamelist));
			if (grouplist.valid())
			{
				curselectid = grouplist->getSelectData();
			}
			//canvasdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
			//ConsortiaApplyVec *groupapplyvec = (ConsortiaApplyVec *)param;
			//if (m_index < groupapplyvec->size())
			//{
			//	curselectid = (*groupapplyvec)[m_index]->getPlayerID();
			//}
			canvasdata->inputParam(WCHDATA_JXJGroupSelectPlayerid,&curselectid);
		}
	}
}
/////////////////////////////////////////
//
//crJXJAgreeGroupApplyMethod
//
/////////////////////////////////////////
crJXJAgreeGroupApplyMethod::crJXJAgreeGroupApplyMethod()
{
}

crJXJAgreeGroupApplyMethod::crJXJAgreeGroupApplyMethod(const crJXJAgreeGroupApplyMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_gameList(handle.m_gameList)
{
}

void crJXJAgreeGroupApplyMethod::inputParam(int i, void *param)
{
}

void crJXJAgreeGroupApplyMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_gameList = str;
		break;
	default:
		break;
	}
}

void crJXJAgreeGroupApplyMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			ref_ptr<crTableWidgetNode> grouplist = dynamic_cast<crTableWidgetNode *>(canvas->getWidget(m_gameList));
			if ( grouplist.valid())
			{
				int playerid = grouplist->getSelectData();
				if (playerid)
				{
					CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
					stream->createBuf(4);
					stream->_writeInt(playerid);
					CRNetApp::crPlayerDataEventPacket packet;
					CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvAgreeGroupApply, stream.get());
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvAgreeGroupApplyMethod
//
/////////////////////////////////////////
crJXJRecvAgreeGroupApplyMethod::crJXJRecvAgreeGroupApplyMethod():
	m_netType(GameClient_Game){}
crJXJRecvAgreeGroupApplyMethod::crJXJRecvAgreeGroupApplyMethod(const crJXJRecvAgreeGroupApplyMethod& handle):
	crMethod(handle),
	m_applycanvas(handle.m_applycanvas)
{
}
void crJXJRecvAgreeGroupApplyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvAgreeGroupApplyMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_applycanvas = str;
		break;
	}
}

void crJXJRecvAgreeGroupApplyMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char suc = JXJGroupAddMember_unknow;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> memberData;
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;

				data -> getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *( unsigned char *)param;

				if(shiliid >= c_startShiliID)
				{
					ref_ptr<crData> applyMainRoledata;
					ref_ptr<crData> applydata;
					int applyplayerid = 0;
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					gsBrainData->getParam(WCHDATA_JXJShiliWei+shiliid-c_startShiliID,param);
					crJXJShili *shili = (crJXJShili *)param;
					if(shili && shili->getDataClass())
					{
						crData *shilidata = shili->getDataClass();
						CRCore::ScopedLock<crData> lock(*shilidata);

						shilidata->getParam(WCHDATA_JXJPeopleMap,param);
						PeopleMap * peopleMap = (PeopleMap *)param;

						applyplayerid = m_stream->_readInt();
						gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
						ConsortiaMap *consortiamap = (ConsortiaMap *)param;
						ConsortiaMap::iterator itr;
						crData *groupdata = NULL,* tmpData = NULL;
						bool hasPermission = false;

						for(itr = consortiamap->begin(); itr != consortiamap->end(); ++itr)
						{
							if (itr->first == mygroupid)
							{
								if (itr->second.valid())
								{
									groupdata = itr->second->getDataClass();
									if (itr->second->checkPermission(playerid,	JXJGroup_AgreeGroupMember))
									{
										hasPermission = true;
									}
								}
							}
							do 
							{
								if (! (itr->second.valid()) ) break;
								tmpData = itr->second->getDataClass();
								//if (!groupdata) break;
								tmpData->getParam(WCHDATA_JXJConsortiaMemberMap,param);
								ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
								ConsortiaMemberMap::iterator cmmItr = membermap->find(applyplayerid);
								if (cmmItr != membermap->end())
								{
									suc = JXJGroupAddMember_HasGroup;			
									break;
								}
								
								PeopleMap::iterator pmItr = peopleMap->find(applyplayerid);
								if (pmItr == peopleMap->end())
								{
									unsigned char applyShiliid  = 0;
									ref_ptr<crGameServerPlayerData> applyplayerData 
										= dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(applyplayerid));
									if (applyplayerData.valid()&& applyplayerData->getPlayerGameData() )
									{
										crData * applydata = applyplayerData->getPlayerGameData()->getDataClass(); 
										if(applydata)
										{
											applydata-> getParam(WCHDATA_JXJShiliID,param);
											applyShiliid = *( unsigned char *)param;
										}
									}
									if (applyShiliid != shiliid)
									{
										suc = JXJGroupAddMember_differCounty;
										break;
									}
								}
							} while (0);
						}
						if (groupdata)
						{
							if (hasPermission)
							{
								int size = 0;

								groupdata->getParam(WCHDATA_JXJConsortialv,param);
								unsigned char groupLv = *(unsigned char *)param;
								
								groupdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
								ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
								time_t t = time(NULL);
								ConsortiaApplyVec::iterator citr = applyvec->begin();
								for (; citr != applyvec->end(); ++citr)
								{
									if ((*citr)->getPlayerID() == applyplayerid) break;
								}
								do 
								{
									groupdata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
									ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
									ref_ptr<crTableIO> groupUpgradeTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJMyGroupUpgradeTab);
									crTableIO::StrVec record;
									if (!groupUpgradeTab) break;
									int memeberNumIdx = groupUpgradeTab->getTitleIndex("成员上限");
									if (groupUpgradeTab->queryOneRecord(0,crArgumentParser::appItoa(groupLv),record) >= 0 ) 
									{
										if (membermap->size() >= atoi(record[memeberNumIdx].c_str()))
										{
											suc = JXJGroupAddMember_Full;
											break;
										}
									}
									if (citr == applyvec->end()) break;
									if (JXJGroupAddMember_HasGroup == suc 
										|| JXJGroupAddMember_differCounty == suc)
									{
										applyvec->erase(citr);
										break;
									}
									suc = JXJGroupAddMember_Offline;
									ref_ptr<crJXJConsortiaMember> memberinfo = new crJXJConsortiaMember(applyplayerid);
									std::string applyplayername = (*citr)->getName();
									memberinfo->setName(applyplayername);
									memberinfo->setLevel((*citr)->getLevel());
									memberinfo->setPos((*citr)->getPos());
									memberinfo->setTime(t);
									ref_ptr<crGameServerPlayerData> ApplyplayerData 
										= dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(applyplayerid));
									if(ApplyplayerData.valid() && ApplyplayerData->getPlayerGameData() && ApplyplayerData->getPlayerGameData()->getMainRole())
									{
										applyMainRoledata = ApplyplayerData->getPlayerGameData()->getMainRole()->getDataClass();
										applydata =ApplyplayerData->getPlayerGameData()->getDataClass(); 
										if(applydata.valid() && applyMainRoledata.valid())
										{
											suc = JXJGroupAddMember_Success;
							
											applyMainRoledata -> getParam(WCHDATA_Level,param);
											unsigned char playerlv = *( unsigned char *)param;
											applyMainRoledata -> getParam(WCHDATA_JXJGovPost,param);
											unsigned char playergovpost = *( unsigned char *)param;
											memberinfo->setLevel(playerlv);
											memberinfo->setPos(playergovpost);
											ref_ptr<crStreamBuf> stream = new crStreamBuf;
											stream->createBuf(4);
											stream->_writeInt(mygroupid);
											crPlayerDataEventPacket packet;
											crPlayerDataEventPacket::buildReplyPacket(packet,applyplayerid,WCH_JXJClientJoinGroup,stream.get());
											gameServer->getNetManager()->sendPacket(ApplyplayerData->getPlayerConnectServerAddress(),packet);
										}
									}
									membermap->insert(std::make_pair(applyplayerid,memberinfo));
									//m_this->doEvent(WCH_JXJRefreshGroupCantonSpecialty,MAKECREPARAM(&mygroupid,&applyplayerid));
									applyvec->erase(citr);
									bool modify = true;
									groupdata->inputParam(WCHDATA_JXJConsortiaModify,&modify);

									std::string groupnotice = applyplayername + "加入了军团";
									CRCore::ref_ptr<crJXJChatMessageInfo > msg = new crJXJChatMessageInfo("[通告]", groupnotice,0,0,mygroupid);
									gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
									crServerBrainHandle::getInstance()->doEvent(WCH_JXJSystermNoticeCreate,MAKECREPARAM(msg.get(),NULL));
									gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

									/*ref_ptr<JXJGroupAddNewmemberMsg> chatMsg = new JXJGroupAddNewmemberMsg;
									chatMsg->m_name = memberinfo->getName();
									crServerBrainHandle::getInstance()->doEvent(WCH_JXJPutIntoGroupChatMsgQueue,MAKEINT64(chatMsg.get(),mygroupid));*/
									///游戏日志
									std::string logdata = "批准加入军团:"+crArgumentParser::appVectoa(crVector3i(playerid,mygroupid,applyplayerid),'|');
									GameLogData gamelog(Log_AgreeGroupApply,logdata);
									crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
								} while (0);
							}
							else
							{
								suc = JXJGroupAddMember_NoPermission;
							}
							if (playerData.valid())
							{
								ref_ptr<crStreamBuf> stream2 = new crStreamBuf;
								stream2->createBuf(4);
								stream2->_writeUChar(suc);
								crPlayerDataEventPacket packet2;
								crPlayerDataEventPacket::buildReplyPacket(packet2,playerid,WCH_JXJRecvAgreeGroupApply,stream2.get());
								gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet2);
							}
						}
					}
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

					if(suc == JXJGroupAddMember_Success)
					{
						applydata->excHandle(MAKECREPARAM(WCH_LockData,1));
						applydata->getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
						MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *)param;
						myGroupApplySet->clear();
						applydata -> inputParam(WCHDATA_JXJConsortiaID,&mygroupid);
						applydata->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
				}
			}
		}
		else if (m_netType == GameClient_Game)
		{
			unsigned char suc = m_stream->_readUChar();
			switch (suc)
			{
			case JXJGroupAddMember_HasGroup:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3034,NULL));
				break;
			case JXJGroupAddMember_Success:
			case JXJGroupAddMember_Offline:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3043,NULL));
				break;
			case JXJGroupAddMember_differCounty:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(4065,NULL));
				break;
			case JXJGroupAddMember_Full:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2014,NULL));
				break;
			default:
				break;
			}
			m_this->doEvent(WCH_JXJQueryGroupApplyerList);
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientJoinGroupMethod
//
/////////////////////////////////////////
crJXJClientJoinGroupMethod::crJXJClientJoinGroupMethod():
	m_netType(GameClient_Game){}
crJXJClientJoinGroupMethod::crJXJClientJoinGroupMethod(const crJXJClientJoinGroupMethod& handle):
	crMethod(handle),
	m_applycanvas(handle.m_applycanvas)
{
}
void crJXJClientJoinGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientJoinGroupMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientJoinGroupMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if (m_netType == GameClient_Game)
		{
			int mygroupid = 0;
			int index = 2018;
			m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
			mygroupid = m_stream->_readInt();
			crData * data = m_this->getDataClass();
			//if (m_this->getMainRole() && m_this->getMainRole()->getDataClass() && mygroupid > 0)
			{
				//crData *applydata = m_this->getMainRole()->getDataClass();
				data-> inputParam(WCHDATA_JXJConsortiaID,&mygroupid);
				bool hadshow = true;
				data->inputParam(WCHDATA_JXJHadShowDismissTip,&hadshow);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJLeaveMyGroupMethod
//
/////////////////////////////////////////
crJXJLeaveMyGroupMethod::crJXJLeaveMyGroupMethod()
{
}

crJXJLeaveMyGroupMethod::crJXJLeaveMyGroupMethod(const crJXJLeaveMyGroupMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}

void crJXJLeaveMyGroupMethod::inputParam(int i, void *param)
{
}

void crJXJLeaveMyGroupMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJLeaveMyGroupMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
		stream->createBuf(4);
		stream->_writeInt(-1);
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvKickMemberOutofGroup, stream.get());
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJUIKickMemberOutofGroupMethod
//
/////////////////////////////////////////
crJXJUIKickMemberOutofGroupMethod::crJXJUIKickMemberOutofGroupMethod():
	m_index(0),
	m_font("simhei.ttf"),
	m_characterSize(16),
	m_goldColor(0.0f,1.0f,1.0f,1.0f),
	m_textColor(1.0f,1.0f,0.0f,1.0f)
{
}
crJXJUIKickMemberOutofGroupMethod::crJXJUIKickMemberOutofGroupMethod(const crJXJUIKickMemberOutofGroupMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_promptCanvas(handle.m_promptCanvas),
	m_information(handle.m_information),
	m_textColor(handle.m_textColor),
	m_goldColor(handle.m_goldColor),
	m_font(handle.m_font),
	m_characterSize(handle.m_characterSize),
	m_okbtn(handle.m_okbtn),
	m_groupcanvas(handle.m_groupcanvas)
{
}
void crJXJUIKickMemberOutofGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIKickMemberOutofGroupMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_promptCanvas = str;
		break;
	case 2:
		m_information = str;
		break;
	case 3:
		m_okbtn = str;
		break;
	case 4:
		m_font = str;
		break;
	case 5:
		m_groupcanvas = str;
		break;
	}
}
void crJXJUIKickMemberOutofGroupMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
		ref_ptr<crCanvasNode>groupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_groupcanvas);
		if (canvas.valid() && groupcanvas.valid())
		{
			ref_ptr<crHypertextWidgetNode> information = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_information));
			ref_ptr<crButtonWidgetNode> okbtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_okbtn));
			crData *canvasdata = groupcanvas->getDataClass();
			canvasdata->getParam(WCHDATA_JXJMyGroupSelPlayData,param);
			crJXJConsortiaMember *playerData = (crJXJConsortiaMember *)param;
			if (playerData)
			{
				std::vector<float>v_i;
				ItemMap itemMap;
				rcfg::ConfigScript cfg_script(&itemMap);
				cfg_script.Add("Hypertext");
				cfg_script.Push("Hypertext");
				//cfg_script.Add("Font",m_font);
				//cfg_script.Add("CharacterSize",m_characterSize);

				cfg_script.Add("Content");
				cfg_script.Push("Content",1);
				v_i.clear();
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color",v_i);
				cfg_script.Add("Text","您确认要将");
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",2);
				v_i.clear();
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(0.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color",v_i);
				cfg_script.Add("Text",playerData->getName());
				cfg_script.Pop();

				cfg_script.Add("Content");
				cfg_script.Push("Content",3);
				v_i.clear();
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color",v_i);
				cfg_script.Add("Text","逐出军团吗？");
				cfg_script.Pop();

				cfg_script.Pop();

				if(information.valid())information->setHypertext(cfg_script);
				if(okbtn.valid())okbtn->setEnable(true);
				crData *dlgData = canvas->getDataClass();
				int commandtype = CDP_Widget;
				dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
				dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
				crFilterRenderManager::getInstance()->doModal(canvas.get());
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJKickMemberOutofGroupMethod
//
/////////////////////////////////////////
crJXJKickMemberOutofGroupMethod::crJXJKickMemberOutofGroupMethod()
{
}

crJXJKickMemberOutofGroupMethod::crJXJKickMemberOutofGroupMethod(const crJXJKickMemberOutofGroupMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_groupList(handle.m_groupList)
{
}

void crJXJKickMemberOutofGroupMethod::inputParam(int i, void *param)
{
}

void crJXJKickMemberOutofGroupMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_groupList = str;
		break;
	default:
		break;
	}
}

void crJXJKickMemberOutofGroupMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			ref_ptr<crTableWidgetNode>  memberList = dynamic_cast<crTableWidgetNode *> (canvas->getWidget(m_groupList));
			crData *canvasdata = canvas->getDataClass();
			if (canvasdata && memberList.valid())
			{
				void * param;
				PermissionCheck checkPermission;
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(4);				
				int curId = memberList->getSelectData();
				std::wstring groupPosName ;
				bool z = memberList->getData(2,memberList->getRowCount()-1,groupPosName);
				canvasdata->getParam(WCHDATA_JXJMySelfGroupMemberINfo,param);
				crJXJConsortiaMember * mySelfInfo = (crJXJConsortiaMember *) param;
				canvasdata->getParam(WCHDATA_JXJMyGroupInfo,param);
				crJXJGroupInfo  *myGroup = (crJXJGroupInfo *)param;
				int myGroupPos = 0;
				if (mySelfInfo) myGroupPos = mySelfInfo->getGroupPos();			
				if (curId != playerGameData->getPlayerID())
				{
					if (( groupPosName != L"副军团长" && groupPosName != L"军团长") || (checkPermission(myGroupPos,JXJGroup_ChangeLeader)))
					{
						stream->_writeInt(curId);
						CRNetApp::crPlayerDataEventPacket packet;
						CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvKickMemberOutofGroup, stream.get());
						netConductor->getNetManager()->sendPacket("all",packet);
					}
					else
					{
						playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(4106,NULL));
					}
				}
				else
					playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(4062,NULL));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvKickMemberOutofGroupMethod
//
/////////////////////////////////////////
crJXJRecvKickMemberOutofGroupMethod::crJXJRecvKickMemberOutofGroupMethod():
	m_netType(GameClient_Game){}
crJXJRecvKickMemberOutofGroupMethod::crJXJRecvKickMemberOutofGroupMethod(const crJXJRecvKickMemberOutofGroupMethod& handle):
	crMethod(handle),
	m_applycanvas(handle.m_applycanvas)
{
}
void crJXJRecvKickMemberOutofGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvKickMemberOutofGroupMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_applycanvas = str;
		break;
	}
}

void crJXJRecvKickMemberOutofGroupMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				//mainroledata -> getParam(WCHDATA_JXJConsortiaID,param);
				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;
				int kickplayerid = m_stream->_readInt();
				unsigned int permission = JXJGroup_KickMember;
				if (kickplayerid == -1 || kickplayerid == playerid)
				{
					kickplayerid = playerid;
					permission = JXJGroup_LeaveGroup;
				}
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				CRCore::ScopedLock<crData> lock(*gsBrainData);
				gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
				ConsortiaMap *consortiamap = (ConsortiaMap *)param;
				crData *groupdata = NULL;
	//			bool ifcankick = false;
				ref_ptr<crJXJConsortia> consortia;
				ConsortiaMap::iterator cmitr = consortiamap->find(mygroupid);
				if (cmitr != consortiamap->end())
				{
					consortia = cmitr->second;
				}
				if(consortia.valid())
				{
					groupdata = consortia->getDataClass();
					int mygrouppos = consortia->getUserGroupPos(playerid);
					int kickgrouppos = consortia->getUserGroupPos(kickplayerid);
					if (groupdata && consortia->checkPermission(playerid,permission))
					{
						if ( kickgrouppos != JXJGroup_FirstLeader)
						{		
							if(mygrouppos == JXJGroup_FirstLeader || kickgrouppos != JXJGroup_SecondLeader || permission == JXJGroup_LeaveGroup)
							{
								do 
								{
									int size = 0;
									groupdata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
									ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
									ConsortiaMemberMap::iterator itr ;
									itr = membermap->find(kickplayerid);
									if (itr != membermap->end() && itr->second.valid())
									{
										std::string kickplayername = itr->second->getName();
										time_t curtime = time(0);
										crPlayerDataEventPacket packet;
										ref_ptr<crStreamBuf> streamBuf = new crStreamBuf;
										streamBuf->createBuf(2);
										if (curtime - itr->second->getTime() < c_24hours)
										{
											if (playerid != kickplayerid)
											{
												streamBuf->_writeBool(true);
												streamBuf->_writeBool(false);
												crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvKickMemberOutofGroup,streamBuf.get());
												gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
											}
											else
											{
												streamBuf->_writeBool(false);
												streamBuf->_writeBool(false);
												crPlayerDataEventPacket::buildReplyPacket(packet,kickplayerid,WCH_JXJRecvKickMemberOutofGroup,streamBuf.get());
												gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
											}
											break;
										}
										ref_ptr<crGameServerPlayerData> ApplyplayerData 
											= dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(itr->first));
										if(ApplyplayerData.valid() && ApplyplayerData->getPlayerGameData() && ApplyplayerData->getPlayerGameData()->getMainRole())
										{
											crData *applydata = ApplyplayerData->getPlayerGameData()->getDataClass();
											if(applydata )
											{
												applydata -> inputParam(WCHDATA_JXJConsortiaID,0);
												//去除playerdata 里面的城池特产
												applydata->excHandle(MAKECREPARAM(WCH_LockData,1));
												applydata->getParam(WCHDATA_JXJGroupCantonSpecialtyVec,param);
												GroupCantonSpecialtyVec *gcspecialtyVec = (GroupCantonSpecialtyVec *)param;
												for( GroupCantonSpecialtyVec::iterator gvitr = gcspecialtyVec->begin();
													gvitr != gcspecialtyVec->end();
													++gvitr )
												{
													*gvitr = NULL;
												}
												//删除已通关副本
												applydata->getParam(WCHDATA_JXJHadWonGroupFuBenSet,param);
												HadWonGroupFuBenSet * hadWonGroupFuBenSet = (HadWonGroupFuBenSet *)param;
												hadWonGroupFuBenSet->clear();
												applydata->excHandle(MAKECREPARAM(WCH_LockData,0));
												crPlayerDataEventPacket::buildReplyPacket(packet,itr->first,WCH_JXJClientLeaveGroup,NULL);
												gameServer->getNetManager()->sendPacket(ApplyplayerData->getPlayerConnectServerAddress(),packet);
											}
										}
										std::string groupnotice;
										if (playerid != kickplayerid)
										{
											/*ref_ptr<JXJGroupKickeMemberMsg> chatMsg = new JXJGroupKickeMemberMsg;
											chatMsg->m_name = itr->second->getName();
											crServerBrainHandle::getInstance()->doEvent(WCH_JXJPutIntoGroupChatMsgQueue,MAKEINT64(chatMsg.get(),mygroupid));*/
											groupnotice = kickplayername + "被移出了军团";
										}
										else
										{
											groupnotice = kickplayername + "离开了军团";
										}
										CRCore::ref_ptr<crJXJChatMessageInfo > msg = new crJXJChatMessageInfo("[通告]", groupnotice,0,0,mygroupid);
										gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
										crServerBrainHandle::getInstance()->doEvent(WCH_JXJSystermNoticeCreate,MAKECREPARAM(msg.get(),NULL));
										gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

										//去除被移出成员分封的城池
										groupdata->getParam(WCHDATA_JXJFenFengedChengChiMap,param);
										FenFengedChengChiMap* fenFengedChengChiMap = (FenFengedChengChiMap*)param;
										for (FenFengedChengChiMap::iterator ffccmitr = fenFengedChengChiMap->begin();ffccmitr != fenFengedChengChiMap->end();++ffccmitr)
										{
											if (ffccmitr->second == kickplayerid)
											{
												fenFengedChengChiMap->erase(ffccmitr);
												break;
											}
										}

										membermap->erase(itr);
										bool modify = true;
										groupdata->inputParam(WCHDATA_JXJConsortiaModify,&modify);


										consortia->updateLeaderVec();
										consortia->updateToRank(gsBrainData);
										if (playerid != kickplayerid)
										{
											streamBuf->_writeBool(true);
											streamBuf->_writeBool(true);
											crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvKickMemberOutofGroup,streamBuf.get());
											gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);

											streamBuf->seekBegin();
											streamBuf->_writeBool(false);
											streamBuf->_writeBool(true);
											crPlayerDataEventPacket::buildReplyPacket(packet,kickplayerid,WCH_JXJRecvKickMemberOutofGroup,streamBuf.get());
											gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
										}
									}
								} while (0);
							}
							// 不在线情况由checkgroupid 来检测
						}
					}
				}
				///游戏日志
				std::string logdata = crArgumentParser::appVectoa(crVector2i(mygroupid,kickplayerid));
				GameLogData gamelog(Log_LeaveGroup,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if (m_netType == GameClient_Game)
		{
			bool isKicker = m_stream->_readBool();
			bool ret = m_stream->_readBool();
			if (isKicker)
			{
				if (ret)
				{
					m_this->doEvent(WCH_JXJQueryGroupMemberList);
				}
				else
				{
					m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKECREPARAM(5021, NULL));//该成员入团未满24小时，暂时无法移出
				}
			}
			else
			{
				if (ret)
				{
					crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
					if (noticeHandle)
					{
						std::string outString;
						std::string name = "你";
						int texid = 4071;
						noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
						int mode = 2;
						noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
						noticeHandle->inputParam(WCHDATA_NoticeParam1,&name);
						noticeHandle->inputParam(WCHDATA_NoticeOutPut,&outString);
						CRNetApp::crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);

						ref_ptr<crJXJChatRecord> record = new crJXJChatRecord();
						record->setChatChannelName("[系统]");
						record->setChatText(outString);
						crBrain::getInstance()->doEvent(WCH_JXJPutInChatRecordDeque,MAKECREPARAM(record.get(),NULL));
					}
				}
				else
				{
					m_this->doEvent(WCH_JXJUIShowTipsCanvas, MAKECREPARAM(5020, NULL));		//您入团未满24小时暂时无法离开
				}
			}
		}
	}
}


/////////////////////////////////////////
//
//crJXJClientLeaveGroupMethod
//
/////////////////////////////////////////
crJXJClientLeaveGroupMethod::crJXJClientLeaveGroupMethod():
	m_netType(GameClient_Game){}
crJXJClientLeaveGroupMethod::crJXJClientLeaveGroupMethod(const crJXJClientLeaveGroupMethod& handle):
	crMethod(handle),
	m_groupcanvas(handle.m_groupcanvas)
{
}
void crJXJClientLeaveGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientLeaveGroupMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_groupcanvas = str;
		break;
	default:
		break;
	}
}

void crJXJClientLeaveGroupMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if (m_netType == GameClient_Game)
		{
			crData * data = m_this->getDataClass();
			data-> inputParam(WCHDATA_JXJConsortiaID,0);
			ref_ptr<crCanvasNode> canvas = crFilterRenderManager::getInstance()->findCanvas(m_groupcanvas);
			if (canvas.valid())
			{
				crData *canvasdata = canvas->getDataClass();
				if (canvasdata)
				{
					void *param;
					canvasdata->getParam(WCHDATA_JXJMyGroupStartedFuBenMap,param);
					StartedFubenMap *startedFubenMap = (StartedFubenMap *)param;
					startedFubenMap->clear();
				}
			}

			//m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2019,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJCheckMyGroupIDMethod
//
/////////////////////////////////////////
crJXJCheckMyGroupIDMethod::crJXJCheckMyGroupIDMethod():m_this(NULL)
{
}

crJXJCheckMyGroupIDMethod::crJXJCheckMyGroupIDMethod(const crJXJCheckMyGroupIDMethod& handle):
	crMethod(handle),
	m_this(NULL)
{
}

void crJXJCheckMyGroupIDMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crRole*)param;
		break;
	}
}

void crJXJCheckMyGroupIDMethod::addParam(int i, const std::string& str)
{
}

void crJXJCheckMyGroupIDMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData 
			= dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(!playerData.valid())
			return;
		void *param;
		crData * playerGameData = playerData->getPlayerGameData()->getDataClass();
		crData *mainroledata = m_this->getDataClass();
		playerGameData-> getParam(WCHDATA_JXJConsortiaID,param);
		int mygroupid = *(int *)param;
		crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
		gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
		gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
		ConsortiaMap *consortiamap = (ConsortiaMap *)param;
		ConsortiaMap::iterator itr = consortiamap->begin();
		/*
		1.刚创建军团，服务器宕机，mygroupid == 0 不可检索
		2.刚退出军团，服务器宕机，mygroupid 无效 可检索 重置
		3.刚退出军团，立即加入其他军团，服务团宕机，mygroupid 无效 不可检索
		统一按3处理
		*/

		time_t nowTime = time(0);
		int realGroupId = 0;
		for (; itr != consortiamap->end(); ++ itr)
		{
			if (itr->second.valid())
			{
				crData * groupData = itr->second->getDataClass();
				do 
				{
					if (!groupData) break;
					groupData->getParam(WCHDATA_JXJConsortiaMemberMap,param);
					ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
					ConsortiaMemberMap::iterator finditr = membermap->find(playerid);
					if (finditr == membermap->end()) break;

					finditr->second->setIfOnlie(true);
					mainroledata->getParam(WCHDATA_Level,param);
					unsigned char lv = *(unsigned char *)param;
					finditr->second->setLevel(lv);
					mainroledata->getParam(WCHDATA_JXJGovPost,param);
					unsigned char post = *(unsigned char *)param;
					finditr->second->setPos(post);
					finditr->second->setName(playerData->getCharacterName());
					finditr->second->setLoginTime(nowTime);
					realGroupId = itr->first;
				} while (0);
				if (realGroupId) break;
			}
		}
		do 
		{
			// reset group id
			if (mygroupid == realGroupId) break;
			int msgid = WCH_JXJGroupResetGroupId;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(msgid);
			stream->_writeInt(realGroupId);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientDesposeEvent,stream.get());
			gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
		} while (0);
				
		// maintain applied group set
		gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		playerGameData-> inputParam(WCHDATA_JXJConsortiaID,&realGroupId);
		playerGameData->excHandle(MAKECREPARAM(WCH_LockData,1));
		playerGameData->getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
		MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *)param;
		if (realGroupId)
		{
			myGroupApplySet->clear();
		}
		if (realGroupId == 0)
		{
			//删除playerdata 里的 城池特产
			playerGameData->getParam(WCHDATA_JXJGroupCantonSpecialtyVec,param);
			GroupCantonSpecialtyVec *gcspecialtyVec = (GroupCantonSpecialtyVec *)param;
			for( GroupCantonSpecialtyVec::iterator gvitr = gcspecialtyVec->begin();
				gvitr != gcspecialtyVec->end();
				++gvitr )
			{
				*gvitr = NULL;
			}

			//删除已通关副本
			playerGameData->getParam(WCHDATA_JXJHadWonGroupFuBenSet,param);
			HadWonGroupFuBenSet * hadWonGroupFuBenSet = (HadWonGroupFuBenSet *)param;
			hadWonGroupFuBenSet->clear();
		}
		//MyGroupApplySet::iterator mgasIt = myGroupApplySet->begin();
		//for (; mgasIt != myGroupApplySet->end(); )
		//{
		//	itr = consortiamap->find(*mgasIt);
		//	do 
		//	{
		//		if (itr == consortiamap->end()) 
		//		{
		//			++ mgasIt;
		//			break;
		//		}
		//		if (! (itr->second.valid()) ) 
		//		{
		//			++ mgasIt;
		//			break;
		//		}
		//		crData * groupData = itr->second->getDataClass();
		//		if (!groupData) 
		//		{
		//			++ mgasIt;
		//			break;
		//		}
		//		groupData->getParam(WCHDATA_JXJConsortiaApplyVec,param);
		//		ConsortiaApplyVec *applyVec = (ConsortiaApplyVec *)param;
		//		ConsortiaApplyVec::iterator appitr = applyVec->begin();
		//		for (; appitr != applyVec->end(); ++ appitr)
		//		{
		//			if ( (*appitr).valid() )
		//			{
		//				if ( (*appitr)->getPlayerID() == playerid )
		//					break;
		//			}
		//		}
		//		if (appitr != applyVec->end())
		//		{
		//			++ mgasIt;
		//			break;
		//		}
		//		mgasIt = myGroupApplySet->erase(mgasIt);
		//	} while (0);
		//}
		playerGameData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJUICreateGroupCanvasUpdateMethod
//
/////////////////////////////////////////
crJXJUICreateGroupCanvasUpdateMethod::crJXJUICreateGroupCanvasUpdateMethod()
{
}

crJXJUICreateGroupCanvasUpdateMethod::crJXJUICreateGroupCanvasUpdateMethod(const crJXJUICreateGroupCanvasUpdateMethod& handle):
	crMethod(handle),
//	m_lvinput(handle.m_lvinput),
//	m_copperinput(handle.m_copperinput),
//	m_goldinput(handle.m_goldinput),
	m_coppercreatbtn(handle.m_coppercreatbtn),
	m_goldcreatbtn(handle.m_goldcreatbtn)
{
}

void crJXJUICreateGroupCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUICreateGroupCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	//case 0:
	//	m_nameInput = str;
	//	break;
	//case 1:
	//	m_infoInput = str;
	//	break;
	case 0:
		m_coppercreatbtn = str;
		break;
	case 1:
		m_goldcreatbtn = str;
		break;
	default:
		break;
	}
}

void crJXJUICreateGroupCanvasUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor && m_this)
	{
		void *param;
		crData *data = playerGameData->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		//ref_ptr<crStaticTextWidgetNode> nameInput= dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nameInput));
		ref_ptr<crStaticTextWidgetNode> infoInput= dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_infoInput));
		ref_ptr<crButtonWidgetNode> coppercreatbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_coppercreatbtn));
		ref_ptr<crButtonWidgetNode> goldcreatbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_goldcreatbtn));
//		int needlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedLv,viplv).c_str());
//		int needcopper = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedCopper,viplv).c_str());
//		int needgold = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCreateGroupNeedGold,viplv).c_str());
		//void *param;
		unsigned char rushcount = 0;

		//if (infoInput.valid())
		//{
		//	int texid = 3017;//
		//	crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
		//	noticeHandle->inputParam(WCHDATA_NoticeTextID,&texid);
		//	int mode = 2;
		//	noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
		//	std::string output;
		//	noticeHandle->inputParam(WCHDATA_NoticeOutPut,&output);
		//	crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
		//	infoInput->setString(output);
		//}
		if (coppercreatbtn.valid())
		{
			coppercreatbtn->setVisiable(true);
		}
		if (goldcreatbtn.valid())
		{
			goldcreatbtn->setVisiable(true);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIShowGroupCanvasMethod
//
/////////////////////////////////////////
crJXJUIShowGroupCanvasMethod::crJXJUIShowGroupCanvasMethod()
{
}

crJXJUIShowGroupCanvasMethod::crJXJUIShowGroupCanvasMethod(const crJXJUIShowGroupCanvasMethod& handle):
	crMethod(handle),
	m_grouplistcanvas(handle.m_grouplistcanvas),
	m_mygroupcanvas(handle.m_mygroupcanvas)
{
}

void crJXJUIShowGroupCanvasMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIShowGroupCanvasMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_grouplistcanvas = str;
		break;
	case 1:
		m_mygroupcanvas = str;
		break;
	case 2:
		m_strLoseGroupCanvas = str;
		break;
	default:
		break;
	}
}

void crJXJUIShowGroupCanvasMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor && m_this)
	{
		crData *mainroledata = playerGameData->getMainRole()->getDataClass();
		if (mainroledata)
		{
			void *param;
			ref_ptr<crCanvasNode>grouplistcanvas = crFilterRenderManager::getInstance()->findCanvas(m_grouplistcanvas);
			ref_ptr<crCanvasNode>mygroupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_mygroupcanvas);
			ref_ptr<crCanvasNode>losegroupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_strLoseGroupCanvas);

			crData *playerData = playerGameData->getDataClass();
			if(playerData)
			{
				bool isLoseCountry = false;
				playerData->getParam(WCHDATA_JXJShiliID,param);
				unsigned char shiliid = *(unsigned char *)param;

				playerGameData->doEvent(WCH_JXJCheckCountryLose,MAKECREPARAM(&isLoseCountry,&shiliid));

				if(isLoseCountry)
				{
					if(losegroupcanvas.valid())crFilterRenderManager::getInstance()->showCanvas(losegroupcanvas.get(),true);
				}
				else
				{
					if (mygroupcanvas.valid() && grouplistcanvas.valid())
					{
						playerData->getParam(WCHDATA_JXJConsortiaID,param);
						int mygroupid = *(int *)param;
						if (mygroupid > 0)
						{
							crFilterRenderManager::getInstance()->showCanvas(grouplistcanvas.get(),false);
							crFilterRenderManager::getInstance()->showCanvas(mygroupcanvas.get(),!mygroupcanvas->getVisiable());
						}
						else
						{
							crFilterRenderManager::getInstance()->showCanvas(mygroupcanvas.get(),false);
							crFilterRenderManager::getInstance()->showCanvas(grouplistcanvas.get(),!grouplistcanvas->getVisiable());
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryMyGroupInfoMethod
//
/////////////////////////////////////////
crJXJQueryMyGroupInfoMethod::crJXJQueryMyGroupInfoMethod()
{
}

crJXJQueryMyGroupInfoMethod::crJXJQueryMyGroupInfoMethod(const crJXJQueryMyGroupInfoMethod& handle):
	crMethod(handle)
{
}

void crJXJQueryMyGroupInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJQueryMyGroupInfoMethod::addParam(int i, const std::string& str)
{
}

void crJXJQueryMyGroupInfoMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryMyGroupInfo,NULL);
			netConductor->getNetManager()->sendPacket("all",packet);
		}
		playerGameData->doEvent(WCH_JXJQueryGroupMemberList);
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryMyGroupInfoMethod
//
/////////////////////////////////////////
crJXJRecvQueryMyGroupInfoMethod::crJXJRecvQueryMyGroupInfoMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryMyGroupInfoMethod::crJXJRecvQueryMyGroupInfoMethod(const crJXJRecvQueryMyGroupInfoMethod& handle):
	crMethod(handle),
	m_mygroupcanvas(handle.m_mygroupcanvas)
{
}
void crJXJRecvQueryMyGroupInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryMyGroupInfoMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_mygroupcanvas = str;
		break;
	}
}

void crJXJRecvQueryMyGroupInfoMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				//mainroledata -> getParam(WCHDATA_JXJConsortiaID,param);
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;
				if(mygroupid > 0)
				{
					bool changenotice = false;
					bool changegroupname = false;
					bool changegroupcreatorname = false;
					bool changegroupcreatordata = false;
					int bufsize = 0;
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					ref_ptr<crJXJConsortia> consortia;
					gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
					ConsortiaMap *consortiamap = (ConsortiaMap *)param;
					ConsortiaMap::iterator itr = consortiamap->find(mygroupid);
					if(itr != consortiamap->end())
					{
						consortia = itr->second;
					}
					if(consortia.valid())
					{
						crData *groupdata = consortia->getDataClass();
						if (groupdata)
						{
							groupdata->getParam(WCHDATA_JXJConsortiaName,param);
							std::string *groupName = (std::string *)param;
							groupdata->getParam(WCHDATA_JXJConsortiaFengYi,param);
							std::string *groupFengYi = (std::string *)param;

							groupdata->getParam(WCHDATA_JXJConsortiaFunds,param);
							int groupExp = *(int *)param;
							groupdata->getParam(WCHDATA_JXJConsortialv,param);
							unsigned char groupLevel = *(unsigned char *)param;

							groupdata->getParam(WCHDATA_JXJConsortiaRecruitNotice,param);
							std::string *recruitNotice = (std::string *)param;

							groupdata->getParam(WCHDATA_JXJConsortiaContactNotice,param);
							std::string *contactNotice = (std::string *)param;
							groupdata->getParam(WCHDATA_JXJConsortiaNormalNotice,param);
							std::string *normalNotice = (std::string *)param;

							groupdata->getParam(WCHDATA_JXJGroupFenFengedCantonMapT,param);
							FenFengedCantonMap * fenFengedChengChiMap = (FenFengedCantonMap *)param;

							groupdata->getParam(WCHDATA_JXJConsortiaDismissTime,param);
							int dismissTime = *(int *)param;
							groupdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
							ConsortiaApplyVec *applyVec = (ConsortiaApplyVec *)param;

							ref_ptr<crStreamBuf> stream = new crStreamBuf;
							stream->createBuf(512);
							stream->_writeString(*groupName);
							stream->_writeBool(!(applyVec->empty()) );

							groupdata->getParam(WCHDATA_JXJConquest,param);
							unsigned char conquest = *(unsigned char *)param;

							groupdata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
							ConsortiaMemberMap *membermap = (ConsortiaMemberMap *)param;
							stream->_writeUChar(membermap->size());
							stream->_writeInt(consortia->getRankNum(gsBrainData)); 
							stream->_writeString(*groupFengYi);
							stream->_writeUChar(groupLevel);
							stream->_writeInt(groupExp);
							stream->_writeInt(dismissTime);
							stream->_writeUChar(conquest);


							stream->_writeUChar(fenFengedChengChiMap->size());
							FenFengedCantonMap::iterator gcsItr = fenFengedChengChiMap->begin();
							for (; gcsItr != fenFengedChengChiMap->end(); ++ gcsItr)
							{
								stream->_writeInt(gcsItr->first);
							}

							groupdata->getParam(WCHDATA_JXJConsortiaLeaderVec,param);
							GroupLeaderVec * groupLeaderVec = (GroupLeaderVec *)param;

							GroupLeaderVec::iterator it = groupLeaderVec->begin();
							char *ptr = stream->getPtr();
							stream->_writeUChar(groupLeaderVec->size());
							unsigned char relsize = 0;
							for (it = groupLeaderVec->begin();it != groupLeaderVec->end(); ++ it)
							{
								ConsortiaMemberMap::iterator cmmIt = membermap->find(*it);
								if (cmmIt != membermap->end() )
								{
									if (cmmIt->second.valid())
									{
										relsize++;
										stream->_writeString(cmmIt->second->getName());
										stream->_writeInt(cmmIt->second->getLevel());
									}
								}
							}
							char *nowptr = stream->getPtr();
							int bufsize = stream->getBufSize();
							stream->seek(ptr-nowptr);
							stream->_writeUChar(relsize);
							stream->setBufSize(bufsize);
							stream->seekEnd();
							groupdata->getParam(WCHDATA_JXJConsortiaActiveRank,param);
							ConsortiaActiveRank *activeRank = (ConsortiaActiveRank *)param;
							ConsortiaActiveRank::RankSet & rankSet = activeRank->getRankSet();
							unsigned char size = min(10,rankSet.size());
							stream->_writeUChar(size); 

							ConsortiaActiveRank::RankSet::iterator mitr = rankSet.begin();

							for (unsigned char i = 0; mitr != rankSet.end() && i < size; ++ mitr)
							{
								if (mitr->valid())
								{
									stream->_writeString( (*mitr)->m_name);
									stream->_writeInt((*mitr)->m_activeVal);
								}
							}
							ConsortiaMemberMap::iterator citr = membermap->find(playerid);
							if (citr == membermap->end())
							{
								stream->_writeBool(false);
							}
							if (citr != membermap->end())
							{
								stream->_writeBool(true);
								stream->_writeInt(citr->second->getTodayWeekActive());
								stream->_writeUChar(citr->second->getGroupPos());
								stream->_writeInt64(citr->second->getTime());
								stream->_writeInt(citr->second->getGroupContribute());
								stream->_writeInt(citr->second->getTroopStoredNumT());
								stream->_writeInt(citr->second->getTroopTakedNumT());
								data->getParam(WCHDATA_JXJGroupContributeiType,param);
								unsigned char type = *(unsigned char *)param;
								data->getParam(WCHDATA_JXJGroupContributeiTimes,param);
								unsigned char times = *(unsigned char *)param;
								stream->_writeUChar(type);
								stream->_writeUChar(times);
							}
							
							stream->_writeString(*recruitNotice);
							stream->_writeString(*contactNotice);
							stream->_writeString(*normalNotice);

							/*groupdata->getParam(WCHDATA_JXJMyGroupStartedFuBenSet,param);
							StartedFubenSet * startedFubenSet = (StartedFubenSet *) param;

							stream->_writeUChar(startedFubenSet->size());
							StartedFubenSet::iterator sfsItr = startedFubenSet->begin();
							for (; sfsItr != startedFubenSet->end(); ++ sfsItr)
							{
							stream->_writeInt(*sfsItr);
							}*/

							groupdata->getParam(WCHDATA_JXJMyGroupStartedFuBenMap,param);
							StartedFubenMap * startedFubenMap = (StartedFubenMap *) param;

							stream->_writeUChar(startedFubenMap->size());
							StartedFubenMap::iterator sfmItr = startedFubenMap->begin();
							for (; sfmItr != startedFubenMap->end(); ++ sfmItr)
							{
								stream->_writeUShort(sfmItr->first);
								stream->_writeInt(sfmItr->second.first);
							}

							groupdata->getParam(WCHDATA_JXJGroupTroopsMap,param);
							TroopsMap * grouptroopmap = (TroopsMap *) param;

							stream->_writeUChar(grouptroopmap->size());
							TroopsMap::iterator gtmItr = grouptroopmap->begin();
							for (; gtmItr != grouptroopmap->end(); ++ gtmItr)
							{
								stream->_writeInt(gtmItr->first);
								stream->_writeInt(gtmItr->second);
							}

							data->getParam(WCHDATA_JXJHadWonGroupFuBenSet,param);
							HadWonGroupFuBenSet * hadWonGroupFuBenSet = (HadWonGroupFuBenSet *)param;
							stream->_writeUChar(hadWonGroupFuBenSet->size());
							HadWonGroupFuBenSet::iterator hwgfItr = hadWonGroupFuBenSet->begin();
							for (; hwgfItr != hadWonGroupFuBenSet->end(); ++ hwgfItr)
							{
								stream->_writeInt(*hwgfItr);
							}

							crPlayerDataEventPacket packet;
							crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvQueryMyGroupInfo,stream.get());
							gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
						}
					}
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if (m_netType == GameClient_Game)
		{
			if (m_stream.valid())
			{
				void *param;

				crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
				ref_ptr<crCanvasNode>mygroupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_mygroupcanvas);
				crJXJGroupInfo *groupinfo;
				if (mygroupcanvas.valid() && playerGameData && playerGameData->getDataClass())
				{
					crData * data = playerGameData->getDataClass();
					crData *canvasdata = mygroupcanvas->getDataClass();
					if (canvasdata)
					{
						CRCore::ScopedLock<crData> lock(*canvasdata);
						canvasdata->getParam(WCHDATA_JXJMyGroupInfo,param);
						groupinfo = (crJXJGroupInfo *)param;

						groupinfo->setName(m_stream->_readString());

						bool hasNewApplyer = m_stream->_readBool();
						canvasdata->inputParam(WCHDATA_JXJConsortiaHasNewApplyer,&hasNewApplyer);

						groupinfo->setMemberCount(m_stream->_readUChar());
						groupinfo->setRank(m_stream->_readInt());
						groupinfo->setFengYi(m_stream->_readString());
						groupinfo->setLv(m_stream->_readUChar());
						groupinfo->setFunds(m_stream->_readInt());
						groupinfo->setDismissTime(m_stream->_readInt());
						groupinfo->setConquest(m_stream->_readUChar());

						canvasdata->getParam(WCHDATA_JXJAllocateCantonVec,param);
						MyAllocatedCantonVec *groupCantonVec = (MyAllocatedCantonVec *)param;
						groupCantonVec->clear();
						unsigned char size = m_stream->_readUChar();
						for (unsigned char i = 0; i < size; ++ i)
						{
							groupCantonVec->push_back(m_stream->_readInt());
						}

						GroupLeaderInfoVec & groupLeaderInfoVec = groupinfo->getLeaderVec();
						groupLeaderInfoVec.clear();
						size = m_stream->_readUChar();
						for (unsigned char i = 0; i < size; ++ i)
						{
							std::string groupName = m_stream->_readString();
							int level = m_stream->_readInt();
							groupLeaderInfoVec.push_back( std::make_pair(groupName,level));
						}

						canvasdata->getParam(WCHDATA_JXJMyGroupActiveMemberVec,param);
						GroupActiveMemberVec * groupActiveMemberVec = (GroupActiveMemberVec *)param;
						size = m_stream->_readUChar();
						groupActiveMemberVec->clear();
						for (unsigned char i = 0; i < size; ++ i)
						{
							std::string memberName = m_stream->_readString();
							int activeValue = m_stream->_readInt();
							groupActiveMemberVec->push_back( std::make_pair(memberName,activeValue));
						}
						bool hasMySelf = m_stream->_readBool();
						if (hasMySelf)
						{
							crJXJConsortiaMember *mySelf = new crJXJConsortiaMember(playerGameData->getPlayerID());
							mySelf->setTodayWeekActive(m_stream->_readInt());
							mySelf->setGroupPos(m_stream->_readUChar());
							mySelf->setTime(m_stream->_readInt64());
							mySelf->setGroupContribute(m_stream->_readInt());
							mySelf->setTroopStoredNumT(m_stream->_readInt());
							mySelf->setTroopTakedNumT(m_stream->_readInt());

							unsigned char type = m_stream->_readUChar();
							data->inputParam(WCHDATA_JXJGroupContributeiType,&type);
							unsigned char times = m_stream->_readUChar();
							data->inputParam(WCHDATA_JXJGroupContributeiTimes,&times);

							canvasdata->inputParam(WCHDATA_JXJMySelfGroupMemberINfo,mySelf);
						}
						std::string notice = m_stream->_readString();
						groupinfo->setRecruitNotice(notice);
						notice = m_stream->_readString();
						groupinfo->setContactNotice(notice);
						notice = m_stream->_readString();
						groupinfo->setNotice(notice);

						/*canvasdata->getParam(WCHDATA_JXJMyGroupStartedFuBenSet,param);
						StartedFubenSet * startedFubenSet = (StartedFubenSet *) param;

						startedFubenSet->clear();
						size = m_stream->_readUChar();
						for (unsigned char i = 0; i < size; ++ i)
						{
						startedFubenSet->insert(m_stream->_readInt());
						}*/

						canvasdata->getParam(WCHDATA_JXJMyGroupStartedFuBenMap,param);
						StartedFubenMap * startedFubenMap = (StartedFubenMap *)param;
						size = m_stream->_readUChar();
						startedFubenMap->clear();
						unsigned short fubenid = 0;
						int roomid = 0;
						ConsortiaPlayerReliveCount countmap;
						for (unsigned char i = 0; i < size; ++ i)
						{
							fubenid = m_stream->_readUShort();
							roomid = m_stream->_readInt();
							startedFubenMap->insert(std::make_pair(fubenid,std::make_pair(roomid,countmap)));
						}

						canvasdata->getParam(WCHDATA_JXJGroupTroopsMap,param);
						TroopsMap * grouptroopsmap = (TroopsMap *)param;
						size = m_stream->_readUChar();
						grouptroopsmap->clear();
						int abstractid = 0;
						int count = 0;
						for (unsigned char i = 0; i < size; ++ i)
						{
							abstractid = m_stream->_readInt();
							count = m_stream->_readInt();
							grouptroopsmap->insert(std::make_pair(abstractid,count));
						}

						canvasdata->getParam(WCHDATA_JXJHadWonGroupFuBenSet,param);
						HadWonGroupFuBenSet *hadWonGroupFuBenSet = (HadWonGroupFuBenSet *)param;
						hadWonGroupFuBenSet->clear();
						size = m_stream->_readUChar();
						for (unsigned char i = 0; i < size; ++ i)
						{
							hadWonGroupFuBenSet->insert(m_stream->_readInt());
						}
					}
					mygroupcanvas->doEvent(WCH_UI_UpdateData);
				}
			}

		}
	}
}
/////////////////////////////////////////
//
//crJXJMyGroupInfoCanvasUpdateMethod
//
/////////////////////////////////////////
crJXJMyGroupInfoCanvasUpdateMethod::crJXJMyGroupInfoCanvasUpdateMethod()
{
}

crJXJMyGroupInfoCanvasUpdateMethod::crJXJMyGroupInfoCanvasUpdateMethod(const crJXJMyGroupInfoCanvasUpdateMethod& handle):
	crMethod(handle),
	m_groupnameinput(handle.m_groupnameinput),
	m_creatornameinput(handle.m_creatornameinput),
	m_creatortimeinput(handle.m_creatortimeinput),
	m_pagesw(handle.m_pagesw),
	m_radio(handle.m_radio),
	m_examinebtn(handle.m_examinebtn)
{
}

void crJXJMyGroupInfoCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJMyGroupInfoCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_groupnameinput = str;
		break;
	case 1:
		m_creatornameinput = str;
		break;
	case 2:
		m_creatortimeinput = str;
		break;
	case 3:
		m_pagesw = str;
		break;
	case 4:
		m_radio = str;
		break;
	case 5:
		m_examinebtn = str;
		break;
	default:
		break;
	}
}

void crJXJMyGroupInfoCanvasUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		crData *canvasdata = m_this->getDataClass();
		if (canvasdata)
		{
			void *param;
			canvasdata->getParam(WCHDATA_JXJMyGroupInfo,param);
			crJXJGroupInfo *groupinfo = (crJXJGroupInfo *)param;
			ref_ptr<crStaticTextWidgetNode> groupnameinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_groupnameinput));
			ref_ptr<crStaticTextWidgetNode> creatornameinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_creatornameinput));
			ref_ptr<crStaticTextWidgetNode> creatortimeinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_creatortimeinput));
			ref_ptr<crRadioGroupWidgetNode> groupradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radio));
			crMultiSwitch *pagesw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_pagesw));
			ref_ptr<crButtonWidgetNode> examinebtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_examinebtn));
			if (groupnameinput.valid())
			{
				groupnameinput->setString(groupinfo -> getName());
			}
			if (creatornameinput.valid())
			{
				creatornameinput->setString(groupinfo -> getCreatorName());
			}
			if (creatortimeinput.valid())
			{
				creatortimeinput->setString(groupinfo -> getCreatedata());
			}
			if (pagesw && groupradio.valid())
			{
				pagesw->setActiveSwitchSet(groupradio->getSelect());
			}
			if (examinebtn.valid())
			{
				if(groupinfo -> getCreatedata().compare(playerGameData->getCharacterName()) == 0)
				{
					examinebtn->setVisiable(true);
				}
				else
				{
					examinebtn->setVisiable(false);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJMyGroupInfoPageUpdateMethod
//
/////////////////////////////////////////
crJXJMyGroupInfoPageUpdateMethod::crJXJMyGroupInfoPageUpdateMethod()
{
}

crJXJMyGroupInfoPageUpdateMethod::crJXJMyGroupInfoPageUpdateMethod(const crJXJMyGroupInfoPageUpdateMethod& handle):
	crMethod(handle),
	m_grouplv(handle.m_grouplv),
	m_notice(handle.m_notice),
	m_membercount(handle.m_membercount),
	m_editnotice(handle.m_editnotice),
	m_noticesw(handle.m_noticesw),
	m_savenotice(handle.m_savenotice),
	m_cancelnotice(handle.m_cancelnotice),
	m_groupranking(handle.m_groupranking),
	m_storeleft(handle.m_storeleft)
{
}

void crJXJMyGroupInfoPageUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJMyGroupInfoPageUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_grouplv = str;
		break;
	case 1:
		m_notice = str;
		break;
	case 2:
		m_membercount = str;
		break;
	case 3:
		m_editnotice = str;
		break;
	case 4:
		m_noticesw = str;
		break;
	case 5:
		m_savenotice = str;
		break;
	case 6:
		m_cancelnotice = str;
		break;
	case 7:
		m_groupranking = str;
		break;
	case 8:
		m_storeleft = str;
		break;
	default:
		break;
	}
}

void crJXJMyGroupInfoPageUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crTableIO>fubentab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJFubenTab);
	if(m_this && playerGameData && fubentab.valid())
	{
		std::string myplayername = playerGameData->getCharacterName();
		ref_ptr<crStaticTextWidgetNode> grouplv = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_grouplv));
		ref_ptr<crStaticTextWidgetNode> notice = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_notice));
		ref_ptr<crStaticTextWidgetNode> membercount = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_membercount));
		ref_ptr<crEditWidgetNode> editnotice = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_editnotice));
		crMultiSwitch *noticesw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_noticesw));
		ref_ptr<crButtonWidgetNode> savenotice = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_savenotice));
		ref_ptr<crButtonWidgetNode> cancelnotice = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_cancelnotice));
		ref_ptr<crStaticTextWidgetNode> groupranking = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_groupranking));
		ref_ptr<crStaticTextWidgetNode> storeleft = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_storeleft));
		crData *canvasdata = m_this->getDataClass();
		if (canvasdata)
		{
			void *param;
			if(savenotice.valid())savenotice->setVisiable(false);
			if(cancelnotice.valid())cancelnotice->setVisiable(false);
			//crData *mainroledata = playerGameData->getMainRole()->getDataClass();
			//mainroledata -> getParam(WCHDATA_JXJConsortiaID,param);
			//int mygroupid = *( int *)param;
			std::string myname = playerGameData->getCharacterName();
			
			canvasdata->getParam(WCHDATA_JXJMyGroupInfo,param);
			crJXJGroupInfo *groupinfo = (crJXJGroupInfo *)param;
			if (groupinfo->getCreatorName().compare(myname) == 0)
			{
				if (noticesw)
				{
					noticesw->setActiveSwitchSet(1);
				}
				if(savenotice.valid())savenotice->setVisiable(true);
				if(cancelnotice.valid())cancelnotice->setVisiable(true);
			}

			if (grouplv.valid())
			{
				grouplv->setString(crArgumentParser::appItoa(groupinfo->getLv()));
			}
			if (notice.valid())
			{
				notice->setString(groupinfo->getNotice());
			}
			if (membercount.valid())
			{
				membercount->setString(crArgumentParser::appItoa(groupinfo->getMemberCount()));
			}
			if (editnotice.valid())
			{
				if (editnotice->getUTF8String().empty())
				{
					editnotice->setString(groupinfo->getNotice());
				}
			}
			if (groupranking.valid())
			{
				groupranking->setString(crArgumentParser::appItoa(groupinfo->getID()));
			}
			if (storeleft.valid())
			{
				storeleft->setString(std::string("0")/*crArgumentParser::appItoa(0)*/);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJAgreeGroupApplyMethod
//
/////////////////////////////////////////
crJXJDisAgreeGroupApplyMethod::crJXJDisAgreeGroupApplyMethod()
{
}

crJXJDisAgreeGroupApplyMethod::crJXJDisAgreeGroupApplyMethod(const crJXJDisAgreeGroupApplyMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_groupList(handle.m_groupList)
{
}

void crJXJDisAgreeGroupApplyMethod::inputParam(int i, void *param)
{
}

void crJXJDisAgreeGroupApplyMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_groupList = str;
		break;
	default:
		break;
	}
}

void crJXJDisAgreeGroupApplyMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		unsigned char rushcount = 0;
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			ref_ptr<crTableWidgetNode>  memberList = dynamic_cast<crTableWidgetNode *> (canvas->getWidget(m_groupList));
			crData *canvasdata = canvas->getDataClass();
			if (canvasdata)
			{
				//canvasdata->getParam(WCHDATA_JXJGroupSelectPlayerid,param);
				//int playerid = *(int *)param;
				int playerid = memberList->getSelectData();
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(playerid);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvDisAgreeGroupApply, stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvDisAgreeGroupApplyMethod
//
/////////////////////////////////////////
crJXJRecvDisAgreeGroupApplyMethod::crJXJRecvDisAgreeGroupApplyMethod():
	m_netType(GameClient_Game){}
crJXJRecvDisAgreeGroupApplyMethod::crJXJRecvDisAgreeGroupApplyMethod(const crJXJRecvDisAgreeGroupApplyMethod& handle):
	crMethod(handle),
	m_applycanvas(handle.m_applycanvas),
	m_applycanvas2(handle.m_applycanvas2)
{
}
void crJXJRecvDisAgreeGroupApplyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvDisAgreeGroupApplyMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_applycanvas = str;
		break;
	case 1:
		m_applycanvas2 = str;
		break;
	}
}

void crJXJRecvDisAgreeGroupApplyMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			int Creatorplayerid = 0;
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				//mainroledata -> getParam(WCHDATA_JXJConsortiaID,param);
				CRCore::ScopedLock<crData> lock(*data);

				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;
				int applyplayerid = m_stream->_readInt();
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
				gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
				ConsortiaMap *consortiamap = (ConsortiaMap *)param;
				ConsortiaMap::iterator itr = consortiamap->find(mygroupid);
				ref_ptr<crData> groupdata;
				std::string groupname;
				bool canDo = false;
				if (itr != consortiamap->end())
				{
					if (itr->second.valid())
					{
						canDo = itr->second->checkPermission(playerid,JXJGroup_RejectGroupMember);
						groupdata = itr->second->getDataClass();
						itr->second->getName(groupname);
					}
				}
				ref_ptr<crGameServerPlayerData> ApplyplayerData 
					= dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(applyplayerid));

				if (groupdata.valid() && canDo)
				{
					int size = 0;
					groupdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
					ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
					for (ConsortiaApplyVec::iterator citr = applyvec->begin();
						citr != applyvec->end(); ++citr)
					{
						if ((*citr)->getPlayerID() == applyplayerid)
						{
							if(ApplyplayerData.valid() 
								&& ApplyplayerData->getPlayerGameData() 
								&& ApplyplayerData->getPlayerGameData()->getMainRole())
							{
								crData *applyGameData = ApplyplayerData->getPlayerGameData()->getDataClass();
								if (applyGameData )
								{
									applyGameData ->getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
									MyGroupApplySet* myGroupApplySet = (MyGroupApplySet *)param;
									if (myGroupApplySet)
									{
										MyGroupApplySet::iterator mitr = myGroupApplySet->find(mygroupid);
										if (myGroupApplySet->end() != mitr)
										{
											myGroupApplySet->erase(mitr);
											ref_ptr<crStreamBuf> streamBuf1 = new crStreamBuf;
											streamBuf1->createBuf(1);
											streamBuf1->_writeBool(false);
											crPlayerDataEventPacket packet1;
											crPlayerDataEventPacket::buildReplyPacket(packet1,applyplayerid,WCH_JXJRecvDisAgreeGroupApply,streamBuf1.get());
											gameServer->getNetManager()->sendPacket(ApplyplayerData->getPlayerConnectServerAddress(),packet1);
										}
									}
								}
								//CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
								//stream->createBuf(4) ;
								//stream->_writeInt(applyplayerid);
								//crPlayerDataEventPacket packet;
								//crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvDisAgreeGroupApply,NULL);
								//gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							}
							applyvec->erase(citr);
							groupdata->inputParam(WCHDATA_JXJConsortiaModify,&success);
							
							std::string content = "加入军团" + groupname +"失败,"+ m_this->getCharacterName() + "拒绝了您的申请.";
							CRUI::crTextAttrWidgetNode::transformText(content);
							std::vector<float>v_i;
							ItemMap itemMap;
							rcfg::ConfigScript cfg_script(&itemMap);
							cfg_script.Add("Hypertext");
							cfg_script.Push("Hypertext");
							v_i.clear();
							v_i.push_back(255.0);
							v_i.push_back(255.0);
							v_i.push_back(255.0);
							v_i.push_back(255.0);
							cfg_script.Add("Color",v_i);

							cfg_script.Add("Content");
							cfg_script.Push("Content",1);
							cfg_script.Add("Text",content);
							cfg_script.Pop();

							cfg_script.Pop();
							CRCore::ref_ptr<CRCore::crStreamBuf> bodystream = new CRCore::crStreamBuf;
							crGlobalHandle::getInstance()->getScriptStream(cfg_script,bodystream);
							
							ref_ptr<crMailInfo> mail = new crMailInfo; 
							
							mail->setTitle("加入军团失败");
							mail->setBody(bodystream.get());
							mail->setRecvID(applyplayerid);
							mail->setSenderID(0);
							mail->setSenderName("系统");
							mail->setState(Mail_Recvd);
							crData *server_data = crServerBrainHandle::getInstance()->getDataClass();
							server_data->excHandle(MAKECREPARAM(WCH_LockData,1));
							void *param;
							server_data->getParam(WCHDATA_JXJMailTaskList, param);
							MailTaskDeque *mail_deque = (MailTaskDeque *)param;
							mail_deque->push_back(mail);
							server_data->excHandle(MAKECREPARAM(WCH_LockData,0));
							break;
						}
					}
				}
				gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));

				ref_ptr<crStreamBuf> streamBuf2 = new crStreamBuf;
				streamBuf2->createBuf(1);
				streamBuf2->_writeBool(true);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvDisAgreeGroupApply,streamBuf2.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = crArgumentParser::appVectoa(crVector2i(mygroupid,applyplayerid));
				GameLogData gamelog(Log_DisagreeGroupApply,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}

		}
		else if (m_netType == GameClient_Game)
		{
			bool isleader = m_stream->_readBool();
			if (isleader)
			{
				m_this->doEvent(WCH_JXJQueryGroupApplyerList);
			}
			else
			{
				ref_ptr<crCanvasNode> canvas1 = crFilterRenderManager::getInstance()->findCanvas(m_applycanvas);
				ref_ptr<crCanvasNode> canvas2 = crFilterRenderManager::getInstance()->findCanvas(m_applycanvas2);
				if (canvas1.valid() && canvas2.valid())
				{
					crFilterRenderManager::getInstance()->showCanvas(canvas1.get(),false);
					crFilterRenderManager::getInstance()->showCanvas(canvas2.get(),false);
				}
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2020,NULL));
			}
			//int applyerid =  m_stream->_readInt();
			//ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_applycanvas);
			//if (canvas)
			//{
			//}
		}
	}
}
/////////////////////////////////////////
//
//crJXJCancelApplyJionGroupMethod
//
/////////////////////////////////////////
crJXJCancelApplyJionGroupMethod::crJXJCancelApplyJionGroupMethod()
{
}

crJXJCancelApplyJionGroupMethod::crJXJCancelApplyJionGroupMethod(const crJXJCancelApplyJionGroupMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}

void crJXJCancelApplyJionGroupMethod::inputParam(int i, void *param)
{
}

void crJXJCancelApplyJionGroupMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJCancelApplyJionGroupMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		void *param;
		//crData *mainroledata = playerGameData->getMainRole()->getDataClass();
		crData * data = playerGameData->getDataClass();
		if (data)
		{
			data->getParam(WCHDATA_JXJConsortiaID,param);
			int groupid = *(int *)param;
			if (groupid == 0)
			{
				unsigned char rushcount = 0;
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if (canvas.valid())
				{
					crData *canvasdata = canvas->getDataClass();
					if (canvasdata)
					{
						canvasdata->getParam(WCHDATA_JXJCurSelectGroupID,param);
						int *selectid = (int *)param;
						canvasdata->getParam(WCHDATA_JXJMyApplyGroupInfoSet,param);
						MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *)param;

						if (myGroupApplySet && myGroupApplySet->find(*selectid) != myGroupApplySet->end())
						{
							CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
							stream->createBuf(4);
							stream->_writeInt(*selectid);
							CRNetApp::crPlayerDataEventPacket packet;
							CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCancelApplyJionGroup, stream.get());
							netConductor->getNetManager()->sendPacket("all",packet);
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCancelApplyJionGroupMethod
//
/////////////////////////////////////////
crJXJRecvCancelApplyJionGroupMethod::crJXJRecvCancelApplyJionGroupMethod():
	m_netType(GameClient_Game){}
crJXJRecvCancelApplyJionGroupMethod::crJXJRecvCancelApplyJionGroupMethod(const crJXJRecvCancelApplyJionGroupMethod& handle):
	crMethod(handle),
	m_groupcanvas(handle.m_groupcanvas)
{
}
void crJXJRecvCancelApplyJionGroupMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCancelApplyJionGroupMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_groupcanvas = str;
		break;
	}
}

void crJXJRecvCancelApplyJionGroupMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid())
			{
				crData *data = m_this->getDataClass();
				if (data /*&& m_this->getMainRole() && m_this->getMainRole()->getDataClass()*/)
				{
					CRCore::ScopedLock<crData> lock(*data);
					int selectid = m_stream->_readInt();
					data->getParam(WCHDATA_JXJConsortiaID,param);
					int groupid = *(int *)param;
					if (groupid == 0)
					{
						crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
						gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
						ref_ptr<crData> groupdata;
						gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
						ConsortiaMap *consortiaMap = (ConsortiaMap *)param;
						ConsortiaMap::iterator itr = consortiaMap->find(selectid);
						if(itr != consortiaMap->end())
						{
							groupdata = itr->second->getDataClass(); 
						}
						if (groupdata.valid())
						{
							groupdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
							ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
							ConsortiaApplyVec::iterator citr;
							for (citr = applyvec->begin();
								citr != applyvec->end();
								++citr)
							{
								if ((*citr)->getPlayerID() == playerid)
								{
									applyvec->erase(citr);
									bool modify = true;
									groupdata->inputParam(WCHDATA_JXJConsortiaModify,&modify);
									break;
								}
							}
						}
						gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
					}

					data->getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
					MyGroupApplySet *myGroupApplySet = (MyGroupApplySet *)param;

					if (myGroupApplySet)
					{
						MyGroupApplySet::iterator setIt = myGroupApplySet->find(selectid);
						if (setIt != myGroupApplySet->end())
						{
							myGroupApplySet->erase(setIt);
						}
					}

					crPlayerDataEventPacket packet;
					ref_ptr<crStreamBuf> streamBuf = new crStreamBuf;
					streamBuf->createBuf(4);
					streamBuf->_writeInt(selectid);
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCancelApplyJionGroup,streamBuf.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					///游戏日志
					std::string logdata = crArgumentParser::appItoa(selectid);
					GameLogData gamelog(Log_CancelApplyJionGroup,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			int selectid = m_stream->_readInt();
			int index = 0;
			ref_ptr<crCanvasNode>groupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_groupcanvas);
			if (groupcanvas.valid())
			{
				crData *canvasdata = groupcanvas->getDataClass();
				if (canvasdata)
				{
					void *param;
					canvasdata->getParam(WCHDATA_JXJMyApplyGroupInfoSet,param);
					MyGroupApplySet * myGroupApplySet= (MyGroupApplySet *)param;
					if (myGroupApplySet)
					{
						MyGroupApplySet::iterator itr = myGroupApplySet->find(selectid);
						if (myGroupApplySet->end() != itr)
						{
							myGroupApplySet->erase(itr);
						}
					}
					crData *mainroledata = m_this->getMainRole()->getDataClass();
				}
			}
			m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3028,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIGroupListUpdateMethod
//
/////////////////////////////////////////
crJXJCheckGroupInfoCanvasUpdateMethod::crJXJCheckGroupInfoCanvasUpdateMethod():
	m_this(NULL)
{
}
crJXJCheckGroupInfoCanvasUpdateMethod::crJXJCheckGroupInfoCanvasUpdateMethod(const crJXJCheckGroupInfoCanvasUpdateMethod& handle):
	crMethod(handle),
	m_memberlist(handle.m_memberlist),
	m_applybtn(handle.m_applybtn),
	m_disapplybtn(handle.m_disapplybtn),
	m_pageinput(handle.m_pageinput),
	m_farleftbtn(handle.m_farleftbtn),
	m_leftbtn(handle.m_leftbtn),
	m_rightbtn(handle.m_rightbtn),
	m_farrightbtn(handle.m_farrightbtn),
	m_canvas(handle.m_canvas)
{
	for (int i = 0; i < 9; i++)
	{
		m_textinput[i] = handle.m_textinput[i];
	}
}
void crJXJCheckGroupInfoCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJCheckGroupInfoCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_textinput[i] = str;//名称
		break;
	case 1:
		m_textinput[i] = str;//公告
		break;
	case 2:
		m_textinput[i] = str;//团长名
		break;
	case 3:
		m_textinput[i] = str;//军团等级
		break;
	case 4:
		m_textinput[i] = str;//领地资金
		break;
	case 5:
		m_textinput[i] = str;//排名
		break;
	case 6:
		m_textinput[i] = str;//军团资金
		break;
	case 7:
		m_textinput[i] = str;//兵营资金
		break;
	case 8:
		m_textinput[i] = str;//无，待定
		break;
	case 9:
		m_memberlist = str;
		break;
	case 10:
		m_applybtn = str;
		break;
	case 11:
		m_disapplybtn = str;
		break;
	case 12:
		m_pageinput = str;
		break;
	case 13:
		m_farleftbtn = str;
		break;
	case 14:
		m_leftbtn = str;
		break;
	case 15:
		m_rightbtn = str;
		break;
	case 16:
		m_farrightbtn = str;
		break;
	case 17:
		m_canvas = str;
		break;
	}
}
void crJXJCheckGroupInfoCanvasUpdateMethod::operator()(crHandle &handle)
{	
	//crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	//if (playerGameData && m_this)
	//{
	//	void *param;
	//	crData *data = playerGameData->getDataClass();
	//	ref_ptr<crCanvasNode>grouplistcanvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
	//	if (data && grouplistcanvas.valid())
	//	{
	//		ref_ptr<crTableWidgetNode> memberlist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_memberlist));
	//		ref_ptr<crButtonWidgetNode> applybtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_applybtn));
	//		ref_ptr<crButtonWidgetNode> disapplybtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_disapplybtn));
	//		ref_ptr<crStaticTextWidgetNode> pageinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pageinput));
	//		ref_ptr<crButtonWidgetNode> farleftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_farleftbtn));
	//		ref_ptr<crButtonWidgetNode> leftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_leftbtn));
	//		ref_ptr<crButtonWidgetNode> rightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_rightbtn));
	//		ref_ptr<crButtonWidgetNode> farrightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_farrightbtn));
	//		ref_ptr<crStaticTextWidgetNode> textinput[9] = {NULL};
	//		data->getParam(WCHDATA_JXJShiliID,param);
	//		unsigned char shiliid = *(unsigned char *)param;
	//		bool shilisame = false;
	//		bool showbtn = true;
	//		for (int i = 0;i < 9;i++)
	//		{
	//			textinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_textinput[i]));
	//			if (textinput[i].valid())textinput[i]->clearString();
	//		}

	//		if (applybtn.valid())
	//		{
	//			applybtn->setVisiable(false);
	//		}
	//		if (disapplybtn.valid())
	//		{
	//			disapplybtn->setVisiable(false);
	//		}
	//		crData *canvasdata = m_this->getDataClass();
	//		crData *grouplistcanvasdata = grouplistcanvas->getDataClass();
	//		if (canvasdata && grouplistcanvasdata && memberlist.valid())
	//		{
	//			ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
	//			crTableIO::StrVec record;
	//			int govpostindex = postTab->getTitleIndex("govpost");
	//			data->getParam(WCHDATA_JXJVipLv,param);
	//			unsigned char viplv = *(unsigned char *)param;
	//			unsigned char perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCheckGroupPerPageNum,viplv).c_str());
	//			canvasdata->getParam(WCHDATA_JXJCheckGroupCurPage,param);
	//			int curpage = *( int *)param;
	//			canvasdata->getParam(WCHDATA_JXJCheckGroupTotalPage,param);
	//			int totalpage = *( int *)param;
	//			canvasdata->getParam(WCHDATA_JXJCheckGroupMemberVec,param);
	//			GroupMemberInfoMap *groupmembermap = (GroupMemberInfoMap *)param;
	//			if (pageinput.valid())
	//			{
	//				pageinput->setString(crArgumentParser::appItoa(curpage) + "/" + crArgumentParser::appItoa(totalpage));
	//			}
	//			grouplistcanvasdata->getParam(WCHDATA_JXJGroupInfoVec,param);
	//			GroupInfoVec *groupinfovec = (GroupInfoVec *)param;
	//			grouplistcanvasdata->getParam(WCHDATA_JXJMyApplyGroupInfoSet,param);
	//			//crJXJGroupInfo *groupapplyinfo = (crJXJGroupInfo *)param;
	//			MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *)param;
	//			grouplistcanvasdata->getParam(WCHDATA_JXJCurSelectGroupID,param);
	//			int curselectgroupid = *(int *)param;
	//			std::string creatorname;
	//			if (!groupinfovec->empty())
	//			{
	//				for( GroupInfoVec::iterator itr = groupinfovec->begin();
	//					itr != groupinfovec->end();
	//					++itr)
	//				{
	//					if ((*itr)->getID() == curselectgroupid)
	//					{
	//						if (textinput[0].valid())
	//						{
	//							textinput[0]->setString((*itr)->getName());
	//						}
	//						if (textinput[1].valid())
	//						{
	//							textinput[1]->setString((*itr)->getNotice());
	//						}
	//						if (textinput[2].valid())
	//						{
	//							creatorname = (*itr)->getCreatorName();
	//							textinput[2]->setString(creatorname);
	//						}
	//						if (textinput[3].valid())
	//						{
	//							textinput[3]->setString(crArgumentParser::appItoa((*itr)->getLv()));
	//						}
	//						if (textinput[5].valid())
	//						{
	//							textinput[5]->setString(crArgumentParser::appItoa(curselectgroupid));
	//						}
	//						if ((*itr)->getShiliID() == shiliid)
	//						{
	//							shilisame = true;
	//						}
	//						//break;
	//					}
	//				}
	//			}

	//			if (myGroupApplySet && myGroupApplySet->find(curselectgroupid) != myGroupApplySet->end())
	//		//	if (groupapplyinfo->getID() == curselectgroupid)
	//			{
	//				showbtn = false;
	//			}
	//			int row = 0;// -(curpage  - 1) * perpagenum;
	//			std::string str;
	//			memberlist->clearData();
	//			for (GroupMemberInfoMap::iterator itr = groupmembermap->begin();
	//				itr != groupmembermap->end();
	//				++itr,++row)
	//			{
	//				memberlist->addData(0,row,itr->second->getName());
	//				memberlist->addData(1,row,crArgumentParser::appItoa(itr->second->getLevel()));
	//				if (itr->second->getGroupPos() == 1)
	//				{
	//					str = "团长";
	//				}
	//				else
	//				{
	//					str = "小喽喽";
	//				}
	//				memberlist->addData(2,row,str);
	//				if (postTab->queryOneRecord(0,crArgumentParser::appItoa(itr->second->getPos()),record) >= 0)
	//				{
	//					memberlist->addData(3,row,record[govpostindex]);
	//				}
	//				memberlist->addData(row,itr->second->getPlayerID());
	//			}
	//		}
	//		if (shilisame)
	//		{
	//			if (applybtn.valid())
	//			{
	//				applybtn->setVisiable(showbtn);
	//			}
	//			if (disapplybtn.valid())
	//			{
	//				disapplybtn->setVisiable(!showbtn);
	//			}
	//		}
	//	}
	//}
}
/////////////////////////////////////////
//
//crJXJCheckInvalidWordsMethod
//
/////////////////////////////////////////
crJXJCheckInvalidWordsMethod::crJXJCheckInvalidWordsMethod():
	m_this(NULL)
{
}
crJXJCheckInvalidWordsMethod::crJXJCheckInvalidWordsMethod(const crJXJCheckInvalidWordsMethod& handle):
	crMethod(handle),
	m_checkstring(handle.m_checkstring)
{
}
void crJXJCheckInvalidWordsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_checkstring = *(std::string *)HICREPARAM(param64);
			m_success = (int *)LOCREPARAM(param64);
		}
		else
		{
			m_checkstring.clear();
			*m_success = 0;
		}
		break;
	}
}
void crJXJCheckInvalidWordsMethod::addParam(int i, const std::string& str)
{
}
void crJXJCheckInvalidWordsMethod::operator()(crHandle &handle)
{	
	ref_ptr<crTableIO>InvalidNameTab;
	if (*m_success == 0)
	{//屏蔽词表
		InvalidNameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInvalidWordTab);
	}
	if (*m_success == 1)
	{//屏蔽名称表
		InvalidNameTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJInvalidWordTab);
	}
	*m_success = 1;
	if (InvalidNameTab.valid())
	{
		std::wstring wtext = CRIOManager::convertUTF8toUTF16(m_checkstring.c_str());
		std::wstring invalidstring;
		int ipos = 0;
		int invalidwordsize;
		for (int i = 0; i < InvalidNameTab->getRowCount();i++)
		{
			invalidstring = CRIOManager::convertUTF8toUTF16(InvalidNameTab->getData(i,0).c_str());
			invalidwordsize = invalidstring.length();
			if (invalidwordsize > 0 && invalidwordsize <=  wtext.length())
			{
				ipos = wtext.find(invalidstring);
				if(ipos != std::string::npos)
				{
					if(crGlobalHandle::isClient())
						m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2021,NULL));
					*m_success = 0;
					break;
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryMyApplyGroupVecMethod
//
/////////////////////////////////////////
crJXJQueryMyApplyGroupVecMethod::crJXJQueryMyApplyGroupVecMethod()
{
}

crJXJQueryMyApplyGroupVecMethod::crJXJQueryMyApplyGroupVecMethod(const crJXJQueryMyApplyGroupVecMethod& handle):
	crMethod(handle)
{
}

void crJXJQueryMyApplyGroupVecMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJQueryMyApplyGroupVecMethod::addParam(int i, const std::string& str)
{
}

void crJXJQueryMyApplyGroupVecMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(netConductor)
		{
			//crData *mainroledata = playerGameData->getMainRole()->getDataClass();
			crData *data = playerGameData->getDataClass();
			if(data)
			{
				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;
				if (mygroupid == 0)
				{
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryMyApplyGroupVec,NULL);
					netConductor->getNetManager()->sendPacket("all",packet);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryMyApplyGroupVecMethodMethod
//
/////////////////////////////////////////
crJXJRecvQueryMyApplyGroupVecMethodMethod::crJXJRecvQueryMyApplyGroupVecMethodMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryMyApplyGroupVecMethodMethod::crJXJRecvQueryMyApplyGroupVecMethodMethod(const crJXJRecvQueryMyApplyGroupVecMethodMethod& handle):
	crMethod(handle),
	m_mygroupcanvas(handle.m_mygroupcanvas)
{
}
void crJXJRecvQueryMyApplyGroupVecMethodMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryMyApplyGroupVecMethodMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_mygroupcanvas = str;
		break;
	}
}

void crJXJRecvQueryMyApplyGroupVecMethodMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//int curgold = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() /*&& m_this->getMainRole() && m_this->getMainRole()->getDataClass()*/)
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				data-> getParam(WCHDATA_JXJMyApplyGroupIDSet,param);
				MyGroupApplySet * myGroupApplySet = (MyGroupApplySet *)param;
				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;
				if(mygroupid == 0)
				{
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					//if (!myGroupApplySet->empty())
					{
						stream->createBuf(32);
						stream->_writeInt(0); // 占首4字节
						int count = 0;
						MyGroupApplySet ::iterator groupItr  = myGroupApplySet->begin();
						for (; groupItr != myGroupApplySet->end(); ++ groupItr)
						{
							stream->_writeInt(*groupItr);
							++ count ;
						}
						int bufsize = stream->getBufSize() ;
						stream->seekBegin();
						stream->_writeInt(count);
						stream->setBufSize(bufsize);
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvQueryMyApplyGroupVec,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
			}
		}
		else if (m_netType == GameClient_Game)
		{
			void *param;
			ref_ptr<crCanvasNode>mygroupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_mygroupcanvas);
			if (mygroupcanvas.valid())
			{
				crData *canvasdata = mygroupcanvas->getDataClass();
				if (canvasdata)
				{
					canvasdata->getParam(WCHDATA_JXJMyApplyGroupInfoSet,param);
					MyGroupApplySet * myGroupApplySet = (MyGroupApplySet*)param;
					
					if (myGroupApplySet)
					{
						myGroupApplySet->clear();
						int size = m_stream->_readInt();
						for (int i = 0; i < size; ++ i)
						{
							myGroupApplySet->insert(m_stream->_readInt());
						}
					}
				}
				mygroupcanvas->doEvent(WCH_UI_UpdateData);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryMyGroupMemberListMethod
//
/////////////////////////////////////////
crJXJQueryMyGroupMemberListMethod::crJXJQueryMyGroupMemberListMethod()
{
}

crJXJQueryMyGroupMemberListMethod::crJXJQueryMyGroupMemberListMethod(const crJXJQueryMyGroupMemberListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}

void crJXJQueryMyGroupMemberListMethod::inputParam(int i, void *param)
{
}

void crJXJQueryMyGroupMemberListMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJQueryMyGroupMemberListMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		void *param;
		unsigned char querytype = QueryGroupMemberListType_MyGroup;
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		if (canvas.valid())
		{
			crData *canvasdata = canvas->getDataClass();
			if (canvasdata)
			{
				canvasdata->getParam(WCHDATA_JXJMyGroupMemberCurPage,param);
				int startpage = *(int *)param;
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(2);
				stream->_writeUChar((unsigned char)querytype);
				stream->_writeUChar((unsigned char)startpage);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryGroupMemberList, stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryGroupMemberListMethod
//
/////////////////////////////////////////
crJXJQueryGroupMemberListMethod::crJXJQueryGroupMemberListMethod()
{
}

crJXJQueryGroupMemberListMethod::crJXJQueryGroupMemberListMethod(const crJXJQueryGroupMemberListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_grouplistcanvas(handle.m_grouplistcanvas)
{
}

void crJXJQueryGroupMemberListMethod::inputParam(int i, void *param)
{
}

void crJXJQueryGroupMemberListMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_grouplistcanvas = str;
		break;
	case 2:
		m_offset = atoi(str.c_str());
	default:
		break;
	}
}

void crJXJQueryGroupMemberListMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		void *param;
		unsigned char querytype = QueryGroupMemberListType_OtherGroup;
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
		ref_ptr<crCanvasNode>groupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_grouplistcanvas);
		if (canvas.valid()  && groupcanvas.valid())
		{
			crData *canvasdata = canvas->getDataClass();
			crData * groupListCanvasData = groupcanvas->getDataClass();

			if (canvasdata && groupListCanvasData)
			{
				if (m_offset)
				{
					m_offset = 1;
					canvasdata->inputParam(WCHDATA_JXJCheckGroupCurPage,&m_offset); // to do 是否做了清0操作
				}
				canvasdata->getParam(WCHDATA_JXJCheckGroupCurPage,param); 
				int startpage = *(int *)param;
				groupListCanvasData->getParam(WCHDATA_JXJCurSelectGroupID,param);
				int curselectgroupid = *(int *)param;
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(6);
				stream->_writeUChar((unsigned char)querytype);
				stream->_writeUChar((unsigned char)startpage);
				stream->_writeInt(curselectgroupid);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryGroupMemberList, stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryGroupMemberListMethod
//
/////////////////////////////////////////
crJXJRecvQueryGroupMemberListMethod::crJXJRecvQueryGroupMemberListMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryGroupMemberListMethod::crJXJRecvQueryGroupMemberListMethod(const crJXJRecvQueryGroupMemberListMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvQueryGroupMemberListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryGroupMemberListMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvQueryGroupMemberListMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			unsigned char querytype = m_stream->_readUChar();
			unsigned char startpage = m_stream->_readUChar();
			int groupid = 0;
			unsigned char perpagenum = 0;
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			if (querytype == QueryGroupMemberListType_MyGroup && m_this->getMainRole())
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				//if (mainroledata)
				{
					data->getParam(WCHDATA_JXJConsortiaID,param);
					groupid = *(int *)param;
				}
				perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMyGroupMemberPerPageNum,viplv).c_str());
			}
			else
			{
				groupid = m_stream->_readInt();
				perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCheckGroupPerPageNum,viplv).c_str());
			}
			if(groupid == 0)
				return;
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
			if(!playerData.valid())
				return;
			ref_ptr<crGameServerPlayerData> memberplayerData;
//			crPlayerGameData *playerGameData;
			int firstline = (startpage - 1) * perpagenum;
			ref_ptr<crStreamBuf> stream;
			ref_ptr<crData>condata;
			ConsortiaMemberMap *membermap;
			ConsortiaMemberMap::iterator memitr;
			std::string bossname;
			ConsortiaMap::iterator mapitr;
			unsigned char membermapsize = 0;
			int count = 0;
			int size = 0;
			int bufsize = 0;
			crPlayerDataEventPacket packet;
			crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
			gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
			ConsortiaMap *consortiamap = ( ConsortiaMap *)param;
			mapitr = consortiamap->find(groupid);
			if (mapitr != consortiamap->end())
			{
				condata = mapitr->second->getDataClass();
			}
			if(condata.valid())
			{
				condata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
				membermap = (ConsortiaMemberMap *)param;
				condata->getParam(WCHDATA_JXJConsortiaMemberRank,param);
				ConsortiaMemberRank *rank = (ConsortiaMemberRank *)param;

				//condata->getParam(WCHDATA_JXJConsortiaModify,param);
				//bool modify = *(bool *)param;

				//if (rank->empty() || rank->size() != membermap->size() || modify)
				{
					rank->clear();
					ConsortiaMemberMap::iterator memitr = membermap->begin();
					for (; memitr != membermap->end() ; ++memitr)
					{
						if (memitr->second.valid())
						{
							memberplayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(memitr->second->getPlayerID()));
							if(memberplayerData.valid() && memberplayerData->getPlayerGameData()
								&& memberplayerData->getPlayerGameData()->getMainRole())
							{
								crData * mainRoleData = memberplayerData->getPlayerGameData()->getMainRole()->getDataClass();
								if (mainRoleData)
								{
									mainRoleData->getParam(WCHDATA_Level,param);
									unsigned char level = *(unsigned char *)param;
									memitr->second->setLevel(level);

									mainRoleData->getParam(WCHDATA_JXJGovPost,param);
									unsigned char govPost = *(unsigned char *)param;
									memitr->second->setPos(govPost);
								}
							}
							CRCore::ref_ptr<ConsortiaMemberRankItem> rankItem = new ConsortiaMemberRankItem(0);
							rankItem->fullOfData(memitr->second.get());
							rank->updateRank(rankItem->getKey(),rankItem);
						}
					}
				}
				stream = new crStreamBuf;
				stream->createBuf(512);
				stream->_writeUChar(0);
				stream->_writeInt(rank->size());
				unsigned char size = 0;
				//unsigned char * size = (unsigned char *)stream->getPtr();
				ConsortiaMemberRank::RankSet rankSet = rank->getRankSet();
				int i = -firstline;
				ConsortiaMemberRank::RankSet::iterator rsItr = rankSet.begin();
				//ConsortiaMemberMap::iterator memitr = membermap->begin();
				for (; rsItr != rankSet.end() && i< perpagenum; ++ rsItr,++i)
				{
					if ( i >= 0)
					{
						if ((*rsItr).valid())
						{
							unsigned char ifonline = 0;
							int contributemoney = 0;
							memberplayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData((*rsItr)->m_id));
							if(memberplayerData.valid())
							{
								ifonline = 1;
							}
							stream->_writeInt((*rsItr)->m_id);//玩家ID
							stream->_writeString((*rsItr)->m_name);//玩家名称
							stream->_writeUChar((*rsItr)->m_level);//玩家等级
							stream->_writeUChar((*rsItr)->m_govPos);//玩家官职
							stream->_writeUChar((*rsItr)->m_groupPos);//玩家团内职务
							if (querytype == QueryGroupMemberListType_MyGroup)
							{//我的军团需要多查询的数据
								//stream->_writeInt(contributemoney);//上贡资金
								stream->_writeUChar(ifonline);//在线状态
								stream->_writeInt((*rsItr)->m_activeVal);//玩家ID
								memitr = membermap->find((*rsItr)->m_id);
								if (memitr != membermap->end())
								{
									stream->_writeInt(memitr->second->getGroupContribute());
									stream->_writeBool(memitr->second->getNewer());
									stream->_writeInt64(memitr->second->getLoginTime());
								}
								else
								{
									stream->_writeInt(0);
									stream->_writeBool(true);
									stream->_writeInt64(0);
								}
							}
							++ size;
							//++ (*size);
						}
					}
				}
				bufsize = stream->getBufSize();
				stream->seekBegin();
				stream->_writeUChar(size);
				stream->setBufSize(bufsize);
				stream->seekEnd();
			}
			if (playerData.valid() && stream.valid())
			{
				if (querytype == QueryGroupMemberListType_MyGroup)
				{
					condata->getParam(WCHDATA_JXJConsortiaLeaderVec,param);
					GroupLeaderVec * groupLeaderVec = (GroupLeaderVec *)param;

					GroupLeaderVec::iterator it = groupLeaderVec->begin();
					char *ptr = stream->getPtr();
					stream->_writeUChar(groupLeaderVec->size());
					unsigned char relsize = 0;
					for (it = groupLeaderVec->begin();it != groupLeaderVec->end(); ++ it)
					{
						ConsortiaMemberMap::iterator cmmIt = membermap->find(*it);
						if (cmmIt != membermap->end() )
						{
							if (cmmIt->second.valid())
							{
								relsize++;
								stream->_writeString(cmmIt->second->getName());
								stream->_writeInt(cmmIt->second->getLevel());
							}
						}
					}
					char *nowptr = stream->getPtr();
					bufsize = stream->getBufSize();
					stream->seek(ptr-nowptr);
					stream->_writeUChar(relsize);
					stream->setBufSize(bufsize);
					stream->seekEnd();

					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvMyGroupMemberList,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				else
				{
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvGroupMemberList,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
			gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryGroupMemberDisposeMethod
//
/////////////////////////////////////////
crJXJQueryGroupMemberDisposeMethod::crJXJQueryGroupMemberDisposeMethod():
	m_this(NULL),
	m_dt(NULL),
	m_validterm(60){}
crJXJQueryGroupMemberDisposeMethod::crJXJQueryGroupMemberDisposeMethod(const crJXJQueryGroupMemberDisposeMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_dt(NULL),
	m_validterm(handle.m_validterm)
{
}
void crJXJQueryGroupMemberDisposeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crServerBrainHandle*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = (float*)LOCREPARAM(param64);
		}
		else
		{
			m_dt = NULL;
		}
		break;
	}
}

void crJXJQueryGroupMemberDisposeMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_validterm = atof(str.c_str());
		break;
	}
}

void crJXJQueryGroupMemberDisposeMethod::operator()(crHandle &handle)
{
	crDataBase *gameglobaldb = crDataBaseManager::getInstance()->getDataBase(GameGlobalDB);
	if(m_this && gameglobaldb)
	{
		//GoodsCountMap Update;
		for( GroupRecordMap::iterator itr = m_groupRecordMap.begin();
			itr != m_groupRecordMap.end(); )
		{
			itr->second.second -= *m_dt;
			if(itr->second.second<=0)
			{
				itr = m_groupRecordMap.erase(itr);
				continue;
			}
			++itr;
		}
		for( GroupRecordMap::iterator itr = m_mygroupRecordMap.begin();
			itr != m_mygroupRecordMap.end(); )
		{
			itr->second.second -= *m_dt;
			if(itr->second.second<=0)
			{
				itr = m_mygroupRecordMap.erase(itr);
				continue;
			}
			++itr;
		}

		void *param;
		crData *data = m_this->getDataClass();
		data->excHandle(MAKECREPARAM(WCH_LockData,1));
		data->getParam(WCHDATA_JXJConsortiaMap,param);
		ConsortiaMap *consortiamap = ( ConsortiaMap *)param;
		data->getParam(WCHDATA_JXJQueryGroupMemberDisposeDeq,param);
		QueryGroupMemberDeq *querygroupmemberdeq = (QueryGroupMemberDeq *)param;
		if(!querygroupmemberdeq->empty())
		{
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			crNetDataManager *netDataManager = gameServer->getNetDataManager();
			ref_ptr<crGameServerPlayerData> playerData;
			ref_ptr<crGameServerPlayerData> memberplayerData;
			crPlayerGameData *playerGameData;

			crVector2i groupR;
			ref_ptr<crQueryGroupMemberInfo> query;
			GroupRecordMap::iterator groupRecordItr;
			int count = 0,bufsize = 0,playerid;
			ref_ptr<crStreamBuf> stream;
			crPlayerDataEventPacket packet;
			GroupRecordMap tempgroupRecordMap;
			int querygroupid = 0;
			while(!querygroupmemberdeq->empty())
			{
				query = querygroupmemberdeq->front();
				querygroupmemberdeq->pop_front();
				querygroupid = query->getGroupID();
				playerid = query->getPlayerID();
				if (query->getQueryType() == QueryGroupMemberListType_MyGroup)
				{
					tempgroupRecordMap = m_mygroupRecordMap;
				}
				else
				{
					tempgroupRecordMap = m_groupRecordMap;
				}
				//int size = 0;
				playerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(playerid));
				if(playerData.valid())
				{
					playerGameData = playerData->getPlayerGameData();
					if(playerGameData)
					{
						//查询记录
						int firstline = (query->getStartPage() - 1) * query->getPerPageNum();
						groupR.set(firstline,query->getPerPageNum());
						groupRecordItr = tempgroupRecordMap.find(groupR);
						if(groupRecordItr == tempgroupRecordMap.end())
						{
							stream = new crStreamBuf;
							crData *condata;
							ConsortiaMemberMap *membermap;
							ConsortiaMemberMap::iterator memitr;
							std::string bossname;
							ConsortiaMap::iterator mapitr;
							if(groupR[0]<consortiamap->size())
							{
								unsigned char membermapsize = 0;
								stream->createBuf(5+(groupR[1]-groupR[0])*32);
								stream->_writeInt(0);
								stream->_writeUChar(membermapsize);
								int i = 0;
								bossname.clear();
								mapitr = consortiamap->find(querygroupid);
								if (mapitr != consortiamap->end() && mapitr->second->getDataClass())
								{
									condata = mapitr->second->getDataClass();
									condata->getParam(WCHDATA_JXJConsortiaMemberMap,param);
									membermap = (ConsortiaMemberMap *)param;
									count = membermap->size(); 
									for (memitr = membermap->begin();
										memitr != membermap->end() && i< groupR[1];
										++memitr,++i)
									{
										if(i<groupR[0]) continue;
										if (memitr->second.valid())
										{
											unsigned char ifonline = 0;
											int contributemoney = 0;
											memberplayerData = dynamic_cast<crGameServerPlayerData *>(netDataManager->getPlayerData(memitr->second->getPlayerID()));
											if(memberplayerData.valid())
											{
												ifonline = 1;
											}
											membermapsize++;
											stream->_writeInt(memitr->second->getPlayerID());//玩家ID
											stream->_writeString(memitr->second->getName());//玩家名称20
											stream->_writeUChar(memitr->second->getLevel());//玩家等级
											stream->_writeUChar(memitr->second->getPos());//玩家官职
											stream->_writeUChar(memitr->second->getGroupPos());//玩家团内职务
											if (query->getQueryType() == QueryGroupMemberListType_MyGroup)
											{//我的军团需要多查询的数据
												stream->_writeInt(contributemoney);//上贡资金
												stream->_writeUChar(ifonline);//在线状态
											}
										}
									}
									tempgroupRecordMap[groupR] = std::make_pair(stream.get(),m_validterm);
									if (query->getQueryType() == QueryGroupMemberListType_MyGroup)
									{
										m_mygroupRecordMap = tempgroupRecordMap;
									}
									else
									{
										m_groupRecordMap = tempgroupRecordMap;
									}
									bufsize = stream->getBufSize();
									stream->seekBegin();
									stream->_writeInt(count);
									stream->_writeUChar(membermapsize);
									stream->setBufSize(bufsize);
									//向客户端发送数据
									if (query->getQueryType() == QueryGroupMemberListType_MyGroup)
									{
										crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvMyGroupMemberList,stream.get());
										gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
									}
									else
									{
										crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvGroupMemberList,stream.get());
										gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
									}
								}
							}
						}
						//else
						//{
							//stream = groupRecordItr->second.first.get();
							//bufsize = stream->getBufSize();
							//stream->seekBegin();
							//stream->_writeInt(count);
							//stream->setBufSize(bufsize);
							////向客户端发送数据
							//if (query->getQueryType() == QueryGroupMemberListType_MyGroup)
							//{
							//	crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvMyGroupMemberList,stream.get());
							//	gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							//}
							//else
							//{
							//	crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJClientRecvGroupMemberList,stream.get());
							//	gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
							//}
						//}
					}
				}
			}
		}
		data->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvGroupMemberListMethod
//
/////////////////////////////////////////
crJXJClientRecvGroupMemberListMethod::crJXJClientRecvGroupMemberListMethod():
	m_netType(GameClient_Game){}
crJXJClientRecvGroupMemberListMethod::crJXJClientRecvGroupMemberListMethod(const crJXJClientRecvGroupMemberListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}
void crJXJClientRecvGroupMemberListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvGroupMemberListMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvas = str;
		break;
	}
}

void crJXJClientRecvGroupMemberListMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvas.valid())
			{
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				crData *canvasdata = canvas->getDataClass();
				if (canvasdata)
				{
					unsigned char perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCheckGroupPerPageNum,viplv).c_str());
					canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
					canvasdata ->getParam(WCHDATA_JXJCheckGroupMemberVec,param);
					GroupMemberInfoVec *groupinfoVec = (GroupMemberInfoVec *)param;
					groupinfoVec->clear();
					unsigned char  size = m_stream->_readUChar();
					groupinfoVec->reserve(size);
					int groupcount = m_stream->_readInt();
					int curplayerid = 0;
					unsigned char posid = 0;
					ref_ptr<crJXJConsortiaMember> groupinfo;
					for (int i = 0; i < size; i++)
					{
						curplayerid = m_stream -> _readInt();
						groupinfo = new crJXJConsortiaMember(curplayerid);
						groupinfo->setName(m_stream -> _readString());
						groupinfo->setLevel(m_stream -> _readUChar());
						posid = m_stream -> _readUChar();
						groupinfo->setPos(posid);
						groupinfo->setGroupPos(m_stream -> _readUChar());
						groupinfoVec->push_back(groupinfo);
					}
					int totalpage = ceil((float)groupcount/(float)perpagenum) ;
					if (totalpage < 1)
					{
						totalpage = 1;
					}
					canvasdata ->inputParam(WCHDATA_JXJCheckGroupTotalPage,&totalpage);
					canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
					//canvas->doEvent(WCH_UI_UpdateData);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJClientRecvMyGroupMemberListMethod
//
/////////////////////////////////////////
crJXJClientRecvMyGroupMemberListMethod::crJXJClientRecvMyGroupMemberListMethod():
	m_netType(GameClient_Game){}
crJXJClientRecvMyGroupMemberListMethod::crJXJClientRecvMyGroupMemberListMethod(const crJXJClientRecvMyGroupMemberListMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas),
	m_renmingcanvas(handle.m_renmingcanvas)
{
}
void crJXJClientRecvMyGroupMemberListMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientRecvMyGroupMemberListMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_renmingcanvas = str;
		break;
	}
}

void crJXJClientRecvMyGroupMemberListMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvas.valid())
			{
				crData *canvasdata = canvas->getDataClass();
				if (canvasdata)
				{
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					unsigned char perpagenum = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJMyGroupMemberPerPageNum,viplv).c_str());
					canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
					canvasdata ->getParam(WCHDATA_JXJMyGroupMemberVec,param);
					ConsortiaMemberVec *groupMemberVec = (ConsortiaMemberVec *)param;
					groupMemberVec->clear();

					unsigned char  size = m_stream->_readUChar();
					int groupcount = m_stream->_readInt();
					int curplayerid = 0;
					for (int i = 0; i < size; i++)
					{
						curplayerid = m_stream -> _readInt();
						ref_ptr<crJXJConsortiaMember> memberInfo = new crJXJConsortiaMember(curplayerid);
						memberInfo->setName(m_stream -> _readString());
						memberInfo->setLevel(m_stream -> _readUChar());
						memberInfo->setPos(m_stream -> _readUChar());
						memberInfo->setGroupPos(m_stream -> _readUChar());
						//groupinfo->setTribute(m_stream -> _readInt());
						memberInfo->setIfOnlie(m_stream -> _readUChar());
						memberInfo->setTodayWeekActive(m_stream->_readInt());
						memberInfo->setGroupContribute(m_stream->_readInt());
						memberInfo->setNewer(m_stream->_readBool());
						memberInfo->setLoginTime(m_stream->_readInt64());
						groupMemberVec->push_back(memberInfo);
					}
					int totalpage = ceil((float)groupcount/(float)perpagenum) ;
					if (totalpage < 1)
					{
						totalpage = 1;
					}
					canvasdata ->inputParam(WCHDATA_JXJMyGroupMemberTotalPage,&totalpage);
					if (!m_stream->eof())
					{
						canvasdata->getParam(WCHDATA_JXJMyGroupInfo,param);
						crJXJGroupInfo *groupinfo = (crJXJGroupInfo *)param;
						size = m_stream->_readUChar();
						GroupLeaderInfoVec & groupLeaderInfoVec = groupinfo->getLeaderVec();
						groupLeaderInfoVec.clear();
						for (unsigned char i = 0; i < size; ++ i)
						{
							std::string groupName = m_stream->_readString();
							int level = m_stream->_readInt();
							groupLeaderInfoVec.push_back( std::make_pair(groupName,level));
						}
					}
					canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
					canvas->doEvent(WCH_UI_UpdateData);
					//ref_ptr<crCanvasNode> renmingcanvas = crFilterRenderManager::getInstance()->findCanvas(m_renmingcanvas);
					//if (renmingcanvas.valid())
					//{
					//	renmingcanvas->doEvent(WCH_UI_UpdateData);
					//}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIChangePageShowWidgetMethod
//
/////////////////////////////////////////
crJXJUIChangePageShowWidgetMethod::crJXJUIChangePageShowWidgetMethod():
	m_this(NULL),
	m_curpageid(0),
	m_totalpageid(0)
{
}
crJXJUIChangePageShowWidgetMethod::crJXJUIChangePageShowWidgetMethod(const crJXJUIChangePageShowWidgetMethod& handle):
	crMethod(handle),
	m_curpageid(handle.m_curpageid),
	m_totalpageid(handle.m_totalpageid),
	m_farleftbtn(handle.m_farleftbtn),
	m_leftbtn(handle.m_leftbtn),
	m_rightbtn(handle.m_rightbtn),
	m_farrightbtn(handle.m_farrightbtn),
	m_needCanvas(handle.m_needCanvas)
{
}
void crJXJUIChangePageShowWidgetMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJUIChangePageShowWidgetMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_curpageid = atoi(str.c_str());
		break;
	case 1:
		m_totalpageid = atoi(str.c_str());
		break;
	case 2:
		m_farleftbtn = str;
		break;
	case 3:
		m_leftbtn = str;
		break;
	case 4:
		m_rightbtn = str;
		break;
	case 5:
		m_farrightbtn = str;
		break;
	case 6:
		m_needCanvas = str;
		break;
	}
}
void crJXJUIChangePageShowWidgetMethod::operator()(crHandle &handle)
{	
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData && m_curpageid > 0 && m_totalpageid > 0)
	{
		void *param;
		int curpagenum,totalpage;

		crData *canvasdata = m_this->getDataClass();
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_needCanvas);
		if (canvas.valid()) canvasdata = canvas->getDataClass();
		if (canvasdata)
		{
			canvasdata->getParam(m_curpageid,param);
			curpagenum = *(int *)param;
			canvasdata->getParam(m_totalpageid,param);
			totalpage = *(int *)param;
			ref_ptr<crButtonWidgetNode> farleftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_farleftbtn));
			ref_ptr<crButtonWidgetNode> leftbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_leftbtn));
			ref_ptr<crButtonWidgetNode> rightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_rightbtn));
			ref_ptr<crButtonWidgetNode> farrightbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_farrightbtn));
			if(farleftbtn.valid())farleftbtn->setEnable(true);
			if(leftbtn.valid())leftbtn->setEnable(true);
			if(rightbtn.valid())rightbtn->setEnable(true);
			if(farrightbtn.valid())farrightbtn->setEnable(true);
			if (curpagenum <= 1)
			{
				if (farleftbtn.valid())
				{
					farleftbtn->setEnable(false);
				}
				if (leftbtn.valid())
				{
					leftbtn->setEnable(false);
				}
			}
			if (curpagenum == totalpage)
			{
				if (farrightbtn.valid())
				{
					farrightbtn->setEnable(false);
				}
				if (rightbtn.valid())
				{
					rightbtn->setEnable(false);
				}
			}
		}
	}
}

///////////////////////////////////////////
////
////crJXJChangeGroupNoticeMethod
////
///////////////////////////////////////////
//crJXJChangeGroupNoticeMethod::crJXJChangeGroupNoticeMethod():
//	m_validtime(5),
//	m_lasttime(0)
//{
//}

//crJXJChangeGroupNoticeMethod::crJXJChangeGroupNoticeMethod(const crJXJChangeGroupNoticeMethod& handle):
//	crMethod(handle),
//	m_noticeedit(handle.m_noticeedit),
//	m_validtime(handle.m_validtime),
//	m_lasttime(handle.m_lasttime)
//{
//}

//void crJXJChangeGroupNoticeMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}

//void crJXJChangeGroupNoticeMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_noticeedit = str;
//		break;
//	case 1:
//		m_validtime = atoi(str.c_str());
//		break;
//	case 2:
//		m_noticetype = (unsigned char )atoi(str.c_str());
//		break;
//	default:
//		break;
//	}
//}

//void crJXJChangeGroupNoticeMethod::operator()(crHandle &handle)
//{
//	void *param;
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && playerGameData)
//	{
//		bool ifcansave = false;
//		time_t t1 = time(0);
//		if (t1 - m_lasttime >= m_validtime)
//		{
//			m_lasttime = t1;
//			ifcansave = true;
//		}
//		else
//		{
//			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2025,NULL));//过于频繁
//		}
//		if (ifcansave)
//		{
//			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
//			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
//			if(netConductor && canvas)
//			{
//				ref_ptr<crEditWidgetNode> editwidget = dynamic_cast<crEditWidgetNode *>(canvas -> getWidget(m_noticeedit));
//				crData *mainroledata = playerGameData->getMainRole()->getDataClass();
//				if( editwidget && mainroledata)
//				{
//					std::string noticestr = editwidget->getUTF8String();
//					mainroledata -> getParam(WCHDATA_JXJConsortiaID,param);
//					int mygroupid = *( int *)param;
//					if (mygroupid > 0)
//					{
//						int success = 1;
//						playerGameData->doEvent(WCH_JXJCheckInvalidWords,MAKECREPARAM(&success,&noticestr));
//						if (success == 1)
//						{
//							ref_ptr<crStreamBuf> stream = new crStreamBuf;
//							stream->createBuf(4+noticestr.length());
//							stream->_writeUChar(m_noticetype);
//							stream->_writeString(noticestr);
//							crPlayerDataEventPacket packet;
//							crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvChangeGroupNotice,stream.get());
//							netConductor->getNetManager()->sendPacket("all",packet);
//						}
//					}
//					editwidget->setEnable(false);
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJRecvChangeGroupNoticeMethodMethod
//
/////////////////////////////////////////
//crJXJRecvChangeGroupNoticeMethodMethod::crJXJRecvChangeGroupNoticeMethodMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvChangeGroupNoticeMethodMethod::crJXJRecvChangeGroupNoticeMethodMethod(const crJXJRecvChangeGroupNoticeMethodMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvChangeGroupNoticeMethodMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}

//void crJXJRecvChangeGroupNoticeMethodMethod::addParam(int i, const std::string& str)
//{
//}

//void crJXJRecvChangeGroupNoticeMethodMethod::operator()(crHandle &handle)
//{
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			void *param;
//			unsigned char success = 0;
//			unsigned char noticetype = m_stream->_readUChar();
//			std::string noticestr = m_stream->_readString();
//			int playerid = m_this->getPlayerID();
//			crData *data = m_this->getDataClass();
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if (playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
//			{
//				crData *mainroledata = m_this->getMainRole()->getDataClass();
//				//MyGroupApplyVec::iterator mitr;
//				mainroledata -> getParam(WCHDATA_JXJConsortiaID,param);
//				int mygroupid = *( int *)param;
//				if(mygroupid > 0)
//				{
//					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
//					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
//					gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
//					ConsortiaMap *consortiamap = (ConsortiaMap *)param;
//					ConsortiaMap::iterator itr;
//					ref_ptr<crStreamBuf> stream = new crStreamBuf;
//					itr = consortiamap->find(mygroupid);
//					if (itr != consortiamap->end())
//					{
//						if (itr->second->getCommander() == playerid)
//						{
//							success = 1;
//							itr->second->setAffiche(noticestr);
//							crData *consortiaData = itr->second->getDataClass();
//							if (consortiaData)
//							{
//								consortiaData->inputParam(WCHDATA_JXJConsortiaModify,&success);
//							}
//						}
//					}
//					stream->createBuf(1);
//					stream->_writeUChar(success);
//					crPlayerDataEventPacket packet;
//					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvChangeGroupNotice,stream.get());
//					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
//				}
//				///游戏日志
//				std::string logdata = crArgumentParser::appItoa(success);
//				GameLogData gamelog(Log_ChangeGroupNotice,logdata);
//				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
//			}
//		}
//		else if (m_netType == GameClient_Game)
//		{
//			unsigned char success = m_stream->_readUChar();
//			if (success)
//			{
//				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2026,NULL));//修改成功
//			}
//			else
//			{
//				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2027,NULL));//修改失败
//			}
//		}
//	}
//}

/////////////////////////////////////////
//
//crJXJClientJoinGroupMethod
//
/////////////////////////////////////////
crJXJClientDesposeEventMethod::crJXJClientDesposeEventMethod():
	m_netType(GameClient_Game){}
crJXJClientDesposeEventMethod::crJXJClientDesposeEventMethod(const crJXJClientDesposeEventMethod& handle):
	crMethod(handle),
	m_applycanvas(handle.m_applycanvas)
{
}
void crJXJClientDesposeEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJClientDesposeEventMethod::addParam(int i, const std::string& str)
{
}

void crJXJClientDesposeEventMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if (m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			int msgid = m_stream->_readInt();
			if (msgid > 0)
			{
				int groupid = 0;
				data->getParam(WCHDATA_JXJClientDesposeEventDeque,param);
				ClientDesposeEventDeque *clientdeque = (ClientDesposeEventDeque *)param;
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(m_stream->getRemainSize());
				stream->write(m_stream->getPtr(),m_stream->getRemainSize());
				stream->seekBegin();
				clientdeque->push_back(std::make_pair(msgid,stream));
			}
			//m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJDoClientDesposeEventMethod
//
/////////////////////////////////////////
crJXJDoClientDesposeEventMethod::crJXJDoClientDesposeEventMethod():
	m_netType(GameClient_Game){}
crJXJDoClientDesposeEventMethod::crJXJDoClientDesposeEventMethod(const crJXJDoClientDesposeEventMethod& handle):
	crMethod(handle),
	m_applycanvas(handle.m_applycanvas)
{
}
void crJXJDoClientDesposeEventMethod::inputParam(int i, void *param)
{
}

void crJXJDoClientDesposeEventMethod::addParam(int i, const std::string& str)
{
}

void crJXJDoClientDesposeEventMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		void *param;
		crData *data = playerGameData->getDataClass();
		data->getParam(WCHDATA_JXJClientDesposeEventDeque,param);
		ClientDesposeEventDeque *clientdeque = (ClientDesposeEventDeque *)param;
		int msgid = 0;
		if (!clientdeque->empty())
		{
			for (ClientDesposeEventDeque::iterator itr = clientdeque->begin();
				itr != clientdeque->end();
				++itr)
			{
				msgid = itr->first;
				if (msgid > 0)
				{
					if (itr->second.valid())
					{
						playerGameData->doEvent(msgid, MAKECREPARAM(itr->second.get(),GameClient_Game));
					}
					else
					{
						playerGameData->doEvent(msgid, MAKECREPARAM(0,GameClient_Game));
					}
				}
			}
			clientdeque->clear();
			//m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(index,NULL));
		}
	}
}
/////////////////////////////////////////
//
//crJXJIgnoreAllApplyMethod
//
/////////////////////////////////////////
crJXJIgnoreAllApplyMethod::crJXJIgnoreAllApplyMethod():
	m_validtime(5),
	m_lasttime(0)
{
}

crJXJIgnoreAllApplyMethod::crJXJIgnoreAllApplyMethod(const crJXJIgnoreAllApplyMethod& handle):
	crMethod(handle),
	m_validtime(handle.m_validtime),
	m_lasttime(handle.m_lasttime)
{
}

void crJXJIgnoreAllApplyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJIgnoreAllApplyMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_validtime = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJIgnoreAllApplyMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		bool ifcansave = false;
		time_t t1 = time(0);
		if (t1 - m_lasttime >= m_validtime)
		{
			m_lasttime = t1;
			ifcansave = true;
		}
		else
		{
			playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2025,NULL));//过于频繁
		}
		if (ifcansave)
		{
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
			if(netConductor && canvas.valid())
			{
				//crData *mainroledata = playerGameData->getMainRole()->getDataClass();
				crData * data = playerGameData->getDataClass();
				crData *canvasdata = canvas ->getDataClass();
				if(data && canvasdata)
				{
					data-> getParam(WCHDATA_JXJConsortiaID,param);
					int mygroupid = *( int *)param;
					canvasdata->getParam(WCHDATA_JXJMyGroupInfo,param);
					crJXJGroupInfo *groupinfo = (crJXJGroupInfo *)param;
					if (mygroupid > 0)
					{
						if (groupinfo->getCreatorName().compare(playerGameData->getCharacterName()) == 0)
						{
							canvasdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
							ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
							if (!applyvec->empty())
							{
								crPlayerDataEventPacket packet;
								crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvIgnoreAllApply,NULL);
								netConductor->getNetManager()->sendPacket("all",packet);
							}
						}
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvIgnoreAllApplyMethod
//
/////////////////////////////////////////
crJXJRecvIgnoreAllApplyMethod::crJXJRecvIgnoreAllApplyMethod():
	m_netType(GameClient_Game){}
crJXJRecvIgnoreAllApplyMethod::crJXJRecvIgnoreAllApplyMethod(const crJXJRecvIgnoreAllApplyMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}
void crJXJRecvIgnoreAllApplyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvIgnoreAllApplyMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJRecvIgnoreAllApplyMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			//std::string noticestr = m_stream->_readString();
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				//MyGroupApplyVec::iterator mitr;
				data-> getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *( int *)param;
				if(mygroupid > 0)
				{
					crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					ref_ptr<crData> consortiaData;
					gsBrainData->getParam(WCHDATA_JXJConsortiaMap,param);
					ConsortiaMap *consortiamap = (ConsortiaMap *)param;
					ConsortiaMap::iterator itr = consortiamap->find(mygroupid);
					if (itr != consortiamap->end())
					{
						if (itr->second.valid() && itr->second->checkPermission(playerid,JXJGroup_RejectGroupMember))
						{
							consortiaData = itr->second->getDataClass();
						}
					}
						
					if (consortiaData.valid())
					{
						consortiaData->getParam(WCHDATA_JXJConsortiaApplyVec,param);
						ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
						if (!applyvec->empty())
						{
							success = 1;
							applyvec->clear();
						}
					}
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
					stream->createBuf(1);
					stream->_writeUChar(success);
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvIgnoreAllApply,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
			}
		}
		else if (m_netType == GameClient_Game)
		{
			void *param;
			unsigned char success = m_stream->_readUChar();
			if (success)
			{
				ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
				if (canvas.valid())
				{
					crData *canvasdata = canvas->getDataClass();
					if (canvasdata)
					{
						canvasdata->getParam(WCHDATA_JXJConsortiaApplyVec,param);
						ConsortiaApplyVec *applyvec = (ConsortiaApplyVec *)param;
						if (!applyvec->empty())
						{
							applyvec->clear();
						}
					}
				}
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2028,NULL));//修改成功
			}
			else
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2029,NULL));//修改失败
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIButtonTipMethod
//
/////////////////////////////////////////
crJXJUIButtonTipMethod::crJXJUIButtonTipMethod():
	m_noticeid(0)
{
}
crJXJUIButtonTipMethod::crJXJUIButtonTipMethod(const crJXJUIButtonTipMethod& handle):
	crMethod(handle),
	m_noticeid(handle.m_noticeid),
	m_tipsCanvas(handle.m_tipsCanvas),
	m_tipsTextWidget(handle.m_tipsTextWidget)
{
}
void crJXJUIButtonTipMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIButtonTipMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_noticeid = atoi(str.c_str());
		break;
	case 1:
		m_tipsCanvas = str;
		break;
	case 2:
		m_tipsTextWidget = str;
		break;
	default:
		break;
	}
}
void crJXJUIButtonTipMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		ref_ptr<crCanvasNode>tips = crFilterRenderManager::getInstance()->findCanvas(m_tipsCanvas);
		if (tips.valid())
		{
			int textid = m_noticeid;
			char buildtimes = 0;
			ref_ptr<crStaticTextWidgetNode> tipsText = dynamic_cast<crStaticTextWidgetNode *>(tips->getWidget(m_tipsTextWidget));
			if (tipsText.valid())
			{
				crData *data = myPlayer->getDataClass();
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				if (m_noticeid == 2030)
				{
					crData *mainroledata = myPlayer->getMainRole()->getDataClass();
					if (mainroledata)
					{
						mainroledata->getParam(WCHDATA_Level,param);
						unsigned char mylv = *(unsigned char *)param;
						int countrybuildlv = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCountryBuildLv, viplv).c_str());
						if (mylv < countrybuildlv)
						{
							textid = 5001;
						}
						else
						{
							data->getParam(WCHDATA_JXJBuildCountryTimes,param);
							buildtimes = *(char *)param;
							if(buildtimes>=0)
							{
								textid = 1122;
							}
						}
					}
				}
				std::string str;
				if(textid > 0)
				{
					//ref_ptr<crTableIO>textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
					//crTableIO::StrVec record;
					//if(textTab->queryOneRecord(0,crArgumentParser::appItoa(m_noticeid),record) >= 0 )
					//{
					//	str = record[1];
					//	int i = str.find("%s");
					//	if(i != std::string::npos)
					//	{
					crHandle *noticeHandle = crGlobalHandle::getInstance()->getDataClass()->getHandle(WCH_GlobalNotice);
					int mode = 2;
					switch (textid)
					{
					case 1122:
						{
							noticeHandle->inputParam(WCHDATA_NoticeTextID,&textid);
							noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
							std::string param1 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJContriCountryOnceCopper,viplv);
							noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
							std::string param2 = crArgumentParser::appItoa(buildtimes);
							noticeHandle->inputParam(WCHDATA_NoticeParam2,&param2);
							noticeHandle->inputParam(WCHDATA_NoticeOutPut,&str);
							crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						}
						break;
					case 5001:
						{
							//str = str.substr(0,i)+crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCountryBuildLv,viplv)+str.substr(i+2,str.length());
							noticeHandle->inputParam(WCHDATA_NoticeTextID,&textid);
							noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
							std::string param1 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCountryBuildLv,viplv);
							noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
							noticeHandle->inputParam(WCHDATA_NoticeOutPut,&str);
							crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						}
						break;
					case 2030:
						{
							//str = str.substr(0,i)+crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJContriCountryOnceCopper,viplv)+str.substr(i+2,str.length());
							noticeHandle->inputParam(WCHDATA_NoticeTextID,&textid);
							noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
							std::string param1 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJContriCountryOnceCopper,viplv);
							noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
							noticeHandle->inputParam(WCHDATA_NoticeOutPut,&str);
							crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						}
						break;
					case 5044:
						{
							int RefreshCost = 0;
							data->getParam(WCHDATA_JXJSpecialtyRefreshTimes,param);
							unsigned char times = *(unsigned char *)param;
							ref_ptr<crTableIO>  SpecialtyRefreshTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJSpecialtyRefreshTab);
							crTableIO::StrVec record;
							if (SpecialtyRefreshTab.valid())
							{
								int timesIdx = SpecialtyRefreshTab->getTitleIndex("次数");
								int costIdx = SpecialtyRefreshTab->getTitleIndex("消耗元宝");
								if (timesIdx >=0 && costIdx >= 0)
								{
									if (SpecialtyRefreshTab->queryOneRecord(timesIdx,crArgumentParser::appItoa(times + 1),record) >= 0)
									{
										RefreshCost = atoi(record[costIdx].c_str());
									}
								}
							}
							//str = str.substr(0,i)+crArgumentParser::appItoa(RefreshCost)+str.substr(i+2,str.length());
							noticeHandle->inputParam(WCHDATA_NoticeTextID,&textid);
							noticeHandle->inputParam(WCHDATA_NoticeMode,&mode);
							std::string param1 = crArgumentParser::appItoa(RefreshCost);
							noticeHandle->inputParam(WCHDATA_NoticeParam1,&param1);
							noticeHandle->inputParam(WCHDATA_NoticeOutPut,&str);
							crGlobalHandle::getInstance()->doEvent(WCH_GlobalNotice);
						}
						break;
					default:
						break;
					}

						//}
					//}
				}
				tipsText->setColor(FCOLOR_BLACK);
				if (!str.empty())
				{
					tipsText->setString(str);
					const crBoundingBox &btnbox = m_this->getBoundBox();
					//
					const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
					float posx = btnbox.m_min[0];
					float posy = (btnbox.m_min[1]+2.0f*(btnbox.m_max[1]-btnbox.m_min[1]));
					//
					crVector2 mouse(crVector2(posx,posy));
					tips->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f) * mat);
					crFilterRenderManager::getInstance()->showCanvas(tips.get(),true);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvClientNoticeMethod
//
/////////////////////////////////////////
crJXJRecvClientNoticeMethod::crJXJRecvClientNoticeMethod():
	m_netType(GameClient_Game){}
crJXJRecvClientNoticeMethod::crJXJRecvClientNoticeMethod(const crJXJRecvClientNoticeMethod& handle):
	crMethod(handle),
	m_canvas(handle.m_canvas)
{
}
void crJXJRecvClientNoticeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvClientNoticeMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	case 1:
		m_strChatCanvas = str;
		break;
	case 2:
		m_strBattleChatCanvas = str;
		break;
	case 3:
		m_strHyperTxt = str;
		break;
	default:
		break;
	}
}

void crJXJRecvClientNoticeMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if (m_netType == GameClient_Game)
		{
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
			if (canvas.valid())
			{
				crData *data = m_this->getDataClass();
// 				rcfg::ConfigScript cfg_script;
// 				crGlobalHandle::getInstance()->getStreamScript(m_stream.get(),cfg_script);
// 				cfg_script.Write("232425.cfg");
				data->inputParam(WCHDATA_JXJOldCenterNotice, m_stream.get());
				data->inputParam(WCHDATA_JXJCenterNotice,m_stream.get());
			}


			//插入聊天队列
			std::vector<float>v_i;
			ItemMap itemMap,itemMap2;
			rcfg::ConfigScript cfg_script(&itemMap);
			rcfg::ConfigScript cfg_script2(&itemMap2);
			cfg_script.Add("Hypertext");
			cfg_script.Push("Hypertext");

			cfg_script.Add("Content");
			cfg_script.Push("Content");
			cfg_script.Add("DrawMode","TEXT");
			cfg_script.Add("CharacterSize",16);
			cfg_script.Add("Text","[游戏]");
			cfg_script.Pop();

			cfg_script.Pop();

			cfg_script2.Add("Hypertext");
			cfg_script2.Push("Hypertext");

			cfg_script2.Add("Content");
			cfg_script2.Push("Content");
			cfg_script2.Add("DrawMode","TEXT");
			cfg_script2.Add("Text"," /n");
			cfg_script2.Pop();

			cfg_script2.Pop();

			ref_ptr<crStreamBuf> bufferFront = new crStreamBuf;
			ref_ptr<crStreamBuf> bufferBack = new crStreamBuf;
			crGlobalHandle::getInstance()->getScriptStream(cfg_script,bufferFront);
			crGlobalHandle::getInstance()->getScriptStream(cfg_script2,bufferBack);

			crMyPlayerData *me = crMyPlayerData::getInstance();
			if(me && me->getPlayerGameData())
			{
				void *param;
				crData *playerData = me->getPlayerGameData()->getDataClass();
				if(playerData)
				{
					playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
					playerData->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;

					playerData->getParam(WCHDATA_JXJChatRecordMap,param);
					ChatRecordMap *chatRecordMap = (ChatRecordMap *)param;

					int maxDequeSize = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLimitChatLine, viplv).c_str());

					if(chatRecordMap)
					{
						for (int chatMode = ChatAll; chatMode < ChatNull;chatMode++)
						{
							ChatRecordDeque & chatDeque = (*chatRecordMap)[(JXJChatMode)chatMode];
							if(chatDeque.size()>=maxDequeSize-2)
							{
								chatDeque.pop_front();
							}
							chatDeque.push_back(bufferFront.get());
							chatDeque.push_back(m_stream.get());
							chatDeque.push_back(bufferBack.get());
						}
					}
					playerData->excHandle(MAKECREPARAM(WCH_LockData,0));

					ref_ptr<crCanvasNode> chatCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strChatCanvas);
					ref_ptr<crCanvasNode> battlechatCanvas = crFilterRenderManager::getInstance()->findCanvas(m_strBattleChatCanvas);

					if(chatCanvas.valid())
					{
						rcfg::ConfigScript cfg_script3;
						crGlobalHandle::getInstance()->getStreamScript(m_stream.get(),cfg_script3);
						ref_ptr<crHypertextWidgetNode> chatShow = dynamic_cast<crHypertextWidgetNode *>(chatCanvas->getWidget(m_strHyperTxt));
						ref_ptr<crHypertextWidgetNode> chatShow2 = dynamic_cast<crHypertextWidgetNode *>(chatCanvas->getWidget(m_strHyperTxt + "2"));

						if(chatShow.valid())
						{
							if(chatShow->getValidTextSize()>maxDequeSize*2)
								chatShow->popTexts(maxDequeSize/2);
							chatShow->setHypertext(cfg_script,true);
							chatShow->setHypertext(cfg_script3,true);
							chatShow->setHypertext(cfg_script2,true);
						}
						if(chatShow2.valid())
						{
							if(chatShow2->getValidTextSize()>maxDequeSize*2)
								chatShow2->popTexts(maxDequeSize/2);
							chatShow2->setHypertext(cfg_script,true);
							chatShow2->setHypertext(cfg_script3,true);
							chatShow2->setHypertext(cfg_script2,true);
						}
					}
					if(battlechatCanvas.valid())
					{
						rcfg::ConfigScript cfg_script3;
						crGlobalHandle::getInstance()->getStreamScript(m_stream.get(),cfg_script3);

						ref_ptr<crHypertextWidgetNode> chatShow = dynamic_cast<crHypertextWidgetNode *>(battlechatCanvas->getWidget(m_strHyperTxt));
						ref_ptr<crHypertextWidgetNode> chatShow2 = dynamic_cast<crHypertextWidgetNode *>(battlechatCanvas->getWidget(m_strHyperTxt + "2"));

						if(chatShow.valid())
						{
							if(chatShow->getValidTextSize()>maxDequeSize*2)
								chatShow->popTexts(maxDequeSize/2);
							chatShow->setHypertext(cfg_script,true);
							chatShow->setHypertext(cfg_script3,true);
							chatShow->setHypertext(cfg_script2,true);
						}
						if(chatShow2.valid())
						{
							if(chatShow2->getValidTextSize()>maxDequeSize*2)
								chatShow2->popTexts(maxDequeSize/2);
							chatShow2->setHypertext(cfg_script,true);
							chatShow2->setHypertext(cfg_script3,true);
							chatShow2->setHypertext(cfg_script2,true);
						}
					}
					//if(crRunGameHandle::getInstance()->isInManor()||crRunGameHandle::getInstance()->isInBattle())
					//	crBrain::getInstance()->doEvent(WCH_JXJUIUpdateChatMessageList);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryPlayerRankingMethod
//
/////////////////////////////////////////
crJXJQueryPlayerRankingMethod::crJXJQueryPlayerRankingMethod():
	m_issearch(0)
	//  m_this(NULL)
	//	m_queryInterval(86400)//24hour
	//	m_queryCount(10)
{
}
crJXJQueryPlayerRankingMethod::crJXJQueryPlayerRankingMethod(const crJXJQueryPlayerRankingMethod& handle):
	crMethod(handle),
	m_paraminput(handle.m_paraminput),
	//  m_this(handle.m_this),
	m_canvasName(handle.m_canvasName)
	//	m_queryInterval(handle.m_queryInterval)
	//	m_queryCount(handle.m_queryCount)
{
	for (int i = 0; i < 2;i++)
	{
		m_combobox[i] = handle.m_combobox[i];
	}
}
void crJXJQueryPlayerRankingMethod::inputParam(int i, void *param)
{
	//switch(i) 
	//{
	//case 0:
	//	if(param == 0)
	//	{//释放
	//		m_this = NULL;
	//	}
	//	break;
	//case 1:
	//	m_this = (crCanvasNode*)param;
	//	break;
	//}
}
void crJXJQueryPlayerRankingMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_combobox[0] = str;
		break;
	case 2:
		m_combobox[1] = str;
		break;
	case 3:
		m_paraminput = str;
		break;
	case 4:
		m_issearch = atoi(str.c_str());
		break;
	default:
		break;
	}
}
void crJXJQueryPlayerRankingMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);

	bool cancelTask = false;
	void *param;
	if (canvas.valid())
	{
		std::string name;
		if(m_issearch == 1)
		{
			ref_ptr<crEditWidgetNode> inputedit = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_paraminput));
			if (inputedit.valid())
			{
				name = inputedit->getUTF8String();
			}
		}
		char queryindex = -1;
		char shiliindex = 0;
		ref_ptr<crComboBoxWidgetNode> combobox[2] = {NULL};
		for(int i = 0; i < 2; i++)
		{
			combobox[i] = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_combobox[i]));
		}
		if (combobox[0].valid())
		{
			shiliindex = combobox[0]->getSelectIndex();
			if (shiliindex > 0)
			{
				shiliindex += c_startShiliID - 1;
			}
		}
		if (combobox[1].valid())
		{
			queryindex = combobox[1]->getSelectIndex();
		}
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		unsigned char querycount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str());
		crData *canvasdata = canvas->getDataClass();
		canvasdata->getParam(WCHDATA_JXJRankingPageNum,param);
		int curpagenum = *(int *)param;
		unsigned short startline = (curpagenum - 1) * querycount;
		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(myPlayer && netConductor && queryindex >= 0)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			if (m_issearch == 1)
			{
				stream->createBuf(4+8+name.length());
			}
			else
			{
				stream->createBuf(4);
			}
			stream->_writeUShort(startline);//start
			stream->_writeUChar(querycount);//count
			stream->_writeUChar(shiliindex);//shiliid
			if (m_issearch == 1)
			{
				stream->_writeString(name);
			}		
			crPlayerDataEventPacket packet;
			switch (queryindex)
			{
			case RankingType_Level:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPlayerLevelRanking,stream.get());
				break;
			case RankingType_GovPost:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvGovPostRanking,stream.get());
				break;
			case RankingType_Exploit:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvExploitRanking,stream.get());
				break;
			case RankingType_Troops:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvTroopsRanking,stream.get());
				break;
			case RankingType_Manorlv:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvManorLvRanking,stream.get());
				break;
			case RankingType_Accomplishpoint:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvAccomplishRanking,stream.get());
				break;
			case RankingType_Countrycontribute:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvCountrycontributeRanking,stream.get());
				break;
			default:
				break;
			}
			netConductor->getNetManager()->sendPacket("all",packet);
			cancelTask = true;
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJRecvGovPostRankingMethod
//
/////////////////////////////////////////
crJXJRecvGovPostRankingMethod::crJXJRecvGovPostRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvGovPostRankingMethod::crJXJRecvGovPostRankingMethod(const crJXJRecvGovPostRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName),
	m_canvasName1(handle.m_canvasName1)
{
}
void crJXJRecvGovPostRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvGovPostRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_canvasName1 = str;
		break;
	}
}

void crJXJRecvGovPostRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				crPlayerRanking *expRank;
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJGovpostRankingMap,param);
				GovpostRankingMap *govpostRankingMap = (GovpostRankingMap *)param;
				int count = CRCore::minimum((int)querycount,(int)(govpostRankingMap->size()-start));
				int index = 0;
				if(!m_stream->eof())
				{
					name = m_stream->_readString();
					for( GovpostRankingMap::iterator itr = govpostRankingMap->begin(); 
						itr != govpostRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if(shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if (name == expRank->getName())
							{
								start = index;
								count = 1;
								break;
							}
							index++;
						}
					}
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;				
					for( GovpostRankingMap::iterator itr = govpostRankingMap->begin(); 
						itr != govpostRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i >= start && i < start + count)
							{
								recordcount ++;
							}
							if (expRank->getPlayerID() == playerid)
							{
								myranking = i;
							}
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(5+44*recordcount);
					stream->_writeUChar((unsigned char)recordcount);
					i = 0;
					for( GovpostRankingMap::iterator itr = govpostRankingMap->begin(); 
						i < start + count && itr != govpostRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeInt(expRank->getPlayerID());//4
								stream->_writeInt(expRank->getExploit());
								stream->_writeUChar(expRank->getGovpost());
								stream->_writeString(expRank->getName());//20
								stream->_writeUChar(expRank->getShiliID());
								stream->_writeUChar(expRank->getLevel());
								stream->_writeUChar(expRank->getNobility());
								stream->_writeUShort(expRank->getAccomplishPoint());
								stream->_writeInt(expRank->getTroops());
								stream->_writeUShort(expRank->getManorlv());
								stream->_writeInt(i+1); //排名
								++i;
							}
							else
							{
								++i;
							}
						}
					}
					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvGovPostRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			ref_ptr<crCanvasNode> canvas1 = crFilterRenderManager::getInstance()->findCanvas(m_canvasName1);
			crData *canvasdata = canvas->getDataClass();
			crData *data1 = canvas1->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJGovpostRankingMap,param);
			GovpostRankingMap *rankingMap = (GovpostRankingMap *)param;
			//data1->getParam(WCHDATA_JXJExpRankingMap,param);
			//ExpRankingMap *rankingMap1 = (ExpRankingMap *)param;
			//data1->lockParam(WCHDATA_JXJExpRankingMap);
			rankingMap->clear();
			//rankingMap1->clear();
			int count = (int)(m_stream->_readUChar());
			ref_ptr<crPlayerRanking> expRanking;
			for (int i = 0; i<count; i++)
			{
				expRanking = new crPlayerRanking;
				expRanking->setPlayerID(m_stream->_readInt());
				expRanking->setExploit(m_stream->_readInt());
				expRanking->setGovpost(m_stream->_readUChar());
				expRanking->setName(m_stream->_readString());
				expRanking->setShiliID(m_stream->_readUChar());
				expRanking->setLevel(m_stream->_readUChar());
				expRanking->setNobility(m_stream->_readUChar());
				expRanking->setAccomplishPoint(m_stream->_readUShort());
				expRanking->setTroops(m_stream->_readInt());
				expRanking->setManorlv(m_stream->_readUShort());
				expRanking->setPlayerRank(m_stream->_readInt());

				rankingMap->insert(std::make_pair(MAKEINT64(expRanking->getExploit(),expRanking->getGovpost()),expRanking));
				//rankingMap1->insert(std::make_pair(expRanking->getGovpost(),expRanking));
			}
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			data1->excHandle(MAKECREPARAM(WCH_LockData,1));
			data1->getParam(WCHDATA_JXJGovpostRankingMap,param);
			GovpostRankingMap *rankingMap1 = (GovpostRankingMap *)param;
			*rankingMap1 = *rankingMap;
			data1->excHandle(MAKECREPARAM(WCH_LockData,0));
			unsigned short mapsize = m_stream->_readUShort();
			unsigned short myranking = m_stream->_readUShort();

			int totalPage = ceil((float)mapsize/(float)pageCount);
			if(totalPage == 0) totalPage = 1;
			canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
			canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
			canvas->doEvent(WCH_UI_UpdateData);
			crData *braindata = crBrain::getInstance()->getDataClass();
			braindata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvAccomplishRankingMethod
//
/////////////////////////////////////////
crJXJRecvAccomplishRankingMethod::crJXJRecvAccomplishRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvAccomplishRankingMethod::crJXJRecvAccomplishRankingMethod(const crJXJRecvAccomplishRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvAccomplishRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvAccomplishRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvAccomplishRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				crPlayerRanking *expRank;
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJAccomplishRankingMap,param);
				AccomplishRankingMap *accomplishRankingMap = (AccomplishRankingMap *)param;
				int count = CRCore::minimum((int)querycount,(int)(accomplishRankingMap->size()-start));
				int index = 0;
				if(!m_stream->eof())
				{
					name = m_stream->_readString();
					for( AccomplishRankingMap::iterator itr = accomplishRankingMap->begin(); 
						itr != accomplishRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if(shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if (name == expRank->getName())
							{
								start = index;
								count = 1;
								break;
							}
							index++;
						}
					}
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;
					
					for( AccomplishRankingMap::iterator itr = accomplishRankingMap->begin(); 
						itr != accomplishRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i >= start && i < start + count)
							{
								recordcount ++;
							}
							if (expRank->getPlayerID() == playerid)
							{
								myranking = i;
							}
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(5+44*recordcount);
					stream->_writeUChar((unsigned char)recordcount);
					i = 0;
					for( AccomplishRankingMap::iterator itr = accomplishRankingMap->begin(); 
						i < start + count && itr != accomplishRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeInt(expRank->getPlayerID());//4
								stream->_writeInt(expRank->getExploit());
								stream->_writeUChar(expRank->getGovpost());
								stream->_writeString(expRank->getName());//20
								stream->_writeUChar(expRank->getShiliID());
								stream->_writeUChar(expRank->getLevel());
								stream->_writeUChar(expRank->getNobility());
								stream->_writeUShort(expRank->getAccomplishPoint());
								stream->_writeInt(expRank->getTroops());
								stream->_writeUShort(expRank->getManorlv());
								stream->_writeInt(i+1); //排名
								++i;
							}
							else
							{
								++i;
							}
						}
					}
					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvAccomplishRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			crData *canvasdata = canvas->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJAccomplishRankingMap,param);
			AccomplishRankingMap *rankingMap = (AccomplishRankingMap *)param;
			rankingMap->clear();
			int count = (int)(m_stream->_readUChar());
			ref_ptr<crPlayerRanking> expRanking;
			for (int i = 0; i<count; i++)
			{
				expRanking = new crPlayerRanking;
				expRanking->setPlayerID(m_stream->_readInt());
				expRanking->setExploit(m_stream->_readInt());
				expRanking->setGovpost(m_stream->_readUChar());
				expRanking->setName(m_stream->_readString());
				expRanking->setShiliID(m_stream->_readUChar());
				expRanking->setLevel(m_stream->_readUChar());
				expRanking->setNobility(m_stream->_readUChar());
				expRanking->setAccomplishPoint(m_stream->_readUShort());
				expRanking->setTroops(m_stream->_readInt());
				expRanking->setManorlv(m_stream->_readUShort());
				expRanking->setPlayerRank(m_stream->_readInt());

				rankingMap->insert(std::make_pair(expRanking->getAccomplishPoint(),expRanking));
			}
			unsigned short mapsize = m_stream->_readUShort();
			unsigned short myranking = m_stream->_readUShort();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			int totalPage = ceil((float)mapsize/(float)pageCount);
			if(totalPage == 0) totalPage = 1;
			canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
			canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
			canvas->doEvent(WCH_UI_UpdateData);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvTroopsRankingMethod
//
/////////////////////////////////////////
crJXJRecvTroopsRankingMethod::crJXJRecvTroopsRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvTroopsRankingMethod::crJXJRecvTroopsRankingMethod(const crJXJRecvTroopsRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvTroopsRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvTroopsRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvTroopsRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				crPlayerRanking *expRank;
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJTroopsRankingMap,param);
				TroopsRankingMap *expRankingMap = (TroopsRankingMap *)param;
				int count = CRCore::minimum((int)querycount,(int)(expRankingMap->size()-start));
				int index = 0;
				if(!m_stream->eof())
				{
					name = m_stream->_readString();
					for( TroopsRankingMap::iterator itr = expRankingMap->begin(); 
						itr != expRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if(shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if (name == expRank->getName())
							{
								start = index;
								count = 1;
								break;
							}
							index++;
						}
					}
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;
					for( TroopsRankingMap::iterator itr = expRankingMap->begin(); 
						itr != expRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i >= start && i < start + count)
							{
								recordcount ++;
							}
							if (expRank->getPlayerID() == playerid)
							{
								myranking = i;
							}
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(5+44*recordcount);
					stream->_writeUChar((unsigned char)recordcount);
					i = 0;
					for( TroopsRankingMap::iterator itr = expRankingMap->begin(); 
						i < start + count && itr != expRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeInt(expRank->getPlayerID());//4
								stream->_writeInt(expRank->getExploit());
								stream->_writeUChar(expRank->getGovpost());
								stream->_writeString(expRank->getName());//20
								stream->_writeUChar(expRank->getShiliID());
								stream->_writeUChar(expRank->getLevel());
								stream->_writeUChar(expRank->getNobility());
								stream->_writeUShort(expRank->getAccomplishPoint());
								stream->_writeInt(expRank->getTroops());
								stream->_writeUShort(expRank->getManorlv());
								stream->_writeInt(i+1); //排名
								++i;
							}
							else
							{
								++i;
							}
						}
					}
					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvTroopsRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			crData *canvasdata = canvas->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJTroopsRankingMap,param);
			TroopsRankingMap *rankingMap = (TroopsRankingMap *)param;
			rankingMap->clear();
			int count = (int)(m_stream->_readUChar());
			ref_ptr<crPlayerRanking> expRanking;
			for (int i = 0; i<count; i++)
			{
				expRanking = new crPlayerRanking;
				expRanking->setPlayerID(m_stream->_readInt());
				expRanking->setExploit(m_stream->_readInt());
				expRanking->setGovpost(m_stream->_readUChar());
				expRanking->setName(m_stream->_readString());
				expRanking->setShiliID(m_stream->_readUChar());
				expRanking->setLevel(m_stream->_readUChar());
				expRanking->setNobility(m_stream->_readUChar());
				expRanking->setAccomplishPoint(m_stream->_readUShort());
				expRanking->setTroops(m_stream->_readInt());
				expRanking->setManorlv(m_stream->_readUShort());
				expRanking->setPlayerRank(m_stream->_readInt());

				rankingMap->insert(std::make_pair(expRanking->getTroops(),expRanking));
			}
			unsigned short mapsize = m_stream->_readUShort();
			unsigned short myranking = m_stream->_readUShort();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			int totalPage = ceil((float)mapsize/(float)pageCount);
			if(totalPage == 0) totalPage = 1;
			canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
			canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
			canvas->doEvent(WCH_UI_UpdateData);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvCountrycontributeRankingMethod
//
/////////////////////////////////////////
crJXJRecvCountrycontributeRankingMethod::crJXJRecvCountrycontributeRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvCountrycontributeRankingMethod::crJXJRecvCountrycontributeRankingMethod(const crJXJRecvCountrycontributeRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvCountrycontributeRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvCountrycontributeRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvCountrycontributeRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				crPlayerRanking *expRank;
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
				CountrycontributeRankingMap *countrycontributeRankingMap = (CountrycontributeRankingMap *)param;
				int count = CRCore::minimum((int)querycount,(int)(countrycontributeRankingMap->size()-start));
				int index = 0;
				if(!m_stream->eof())
				{
					name = m_stream->_readString();
					for( CountrycontributeRankingMap::iterator itr = countrycontributeRankingMap->begin(); 
						itr != countrycontributeRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if(shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if (name == expRank->getName())
							{
								start = index;
								count = 1;
								break;
							}
							index++;
						}
					}
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;
					
					for( CountrycontributeRankingMap::iterator itr = countrycontributeRankingMap->begin(); 
						itr != countrycontributeRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i >= start && i < start + count)
							{
								recordcount ++;
							}
							if (expRank->getPlayerID() == playerid)
							{
								myranking = i;
							}
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(5+44*recordcount);
					stream->_writeUChar((unsigned char)recordcount);
					i = 0;
					for( CountrycontributeRankingMap::iterator itr = countrycontributeRankingMap->begin(); 
						i < start + count && itr != countrycontributeRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeInt(expRank->getPlayerID());//4
								stream->_writeInt(expRank->getExploit());
								stream->_writeUChar(expRank->getGovpost());
								stream->_writeString(expRank->getName());//20
								stream->_writeUChar(expRank->getShiliID());
								stream->_writeUChar(expRank->getLevel());
								stream->_writeUChar(expRank->getNobility());
								stream->_writeUShort(expRank->getAccomplishPoint());
								stream->_writeInt(expRank->getTroops());
								stream->_writeUShort(expRank->getManorlv());
								stream->_writeInt(i+1); //排名
								++i;
							}
							else
							{
								++i;
							}
						}
					}
					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvCountrycontributeRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			crData *canvasdata = canvas->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJCountrycontributeRankingMap,param);
			CountrycontributeRankingMap *rankingMap = (CountrycontributeRankingMap *)param;
			rankingMap->clear();
			int count = (int)(m_stream->_readUChar());
			ref_ptr<crPlayerRanking> expRanking;
			for (int i = 0; i<count; i++)
			{
				expRanking = new crPlayerRanking;
				expRanking->setPlayerID(m_stream->_readInt());
				expRanking->setExploit(m_stream->_readInt());
				expRanking->setGovpost(m_stream->_readUChar());
				expRanking->setName(m_stream->_readString());
				expRanking->setShiliID(m_stream->_readUChar());
				expRanking->setLevel(m_stream->_readUChar());
				expRanking->setNobility(m_stream->_readUChar());
				expRanking->setAccomplishPoint(m_stream->_readUShort());
				expRanking->setTroops(m_stream->_readInt());
				expRanking->setManorlv(m_stream->_readUShort());
				expRanking->setPlayerRank(m_stream->_readInt());

				rankingMap->insert(std::make_pair(expRanking->getCountrycontribute(),expRanking));
			}
			unsigned short mapsize = m_stream->_readUShort();
			unsigned short myranking = m_stream->_readUShort();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			int totalPage = ceil((float)mapsize/(float)pageCount);
			if(totalPage == 0) totalPage = 1;
			canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
			canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
			canvas->doEvent(WCH_UI_UpdateData);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvPlayerLevelRankingMethod
//
/////////////////////////////////////////
crJXJRecvPlayerLevelRankingMethod::crJXJRecvPlayerLevelRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvPlayerLevelRankingMethod::crJXJRecvPlayerLevelRankingMethod(const crJXJRecvPlayerLevelRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvPlayerLevelRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPlayerLevelRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvPlayerLevelRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				crPlayerRanking *expRank;
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJLevelRankingMap,param);
				LevelRankingMap *levelRankingMap = (LevelRankingMap *)param;
				int count = CRCore::minimum((int)querycount,(int)(levelRankingMap->size()-start));
				int index = 0;
				if(!m_stream->eof())
				{
					name = m_stream->_readString();
					for( LevelRankingMap::iterator itr = levelRankingMap->begin(); 
						itr != levelRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if(shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if (name == expRank->getName())
							{
								start = index;
								count = 1;
								break;
							}
							index++;
						}
					}
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;
					for( LevelRankingMap::iterator itr = levelRankingMap->begin(); 
						itr != levelRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i >= start && i < start + count)
							{
								recordcount ++;
							}
							if (expRank->getPlayerID() == playerid)
							{
								myranking = i;
							}
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(5+44*recordcount);
					stream->_writeUChar((unsigned char)recordcount);
					i = 0;
					for( LevelRankingMap::iterator itr = levelRankingMap->begin(); 
						i < start + count && itr != levelRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeInt(expRank->getPlayerID());//4
								stream->_writeInt(expRank->getExploit());
								stream->_writeUChar(expRank->getGovpost());
								stream->_writeString(expRank->getName());//20
								stream->_writeUChar(expRank->getShiliID());
								stream->_writeUChar(expRank->getLevel());
								stream->_writeUChar(expRank->getNobility());
								stream->_writeUShort(expRank->getAccomplishPoint());
								stream->_writeInt(expRank->getTroops());
								stream->_writeUShort(expRank->getManorlv());
								stream->_writeInt(i+1); //排名
								++i;
							}
							else
							{
								++i;
							}
						}
					}

					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPlayerLevelRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			crData *canvasdata = canvas->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJLevelRankingMap,param);
			LevelRankingMap *rankingMap = (LevelRankingMap *)param;
			rankingMap->clear();
			int count = (int)(m_stream->_readUChar());
			ref_ptr<crPlayerRanking> expRanking;
			for (int i = 0; i<count; i++)
			{
				expRanking = new crPlayerRanking;
				expRanking->setPlayerID(m_stream->_readInt());
				expRanking->setExploit(m_stream->_readInt());
				expRanking->setGovpost(m_stream->_readUChar());
				expRanking->setName(m_stream->_readString());
				expRanking->setShiliID(m_stream->_readUChar());
				expRanking->setLevel(m_stream->_readUChar());
				expRanking->setNobility(m_stream->_readUChar());
				expRanking->setAccomplishPoint(m_stream->_readUShort());
				expRanking->setTroops(m_stream->_readInt());
				expRanking->setManorlv(m_stream->_readUShort());
				expRanking->setPlayerRank(m_stream->_readInt());
				rankingMap->insert(std::make_pair(expRanking->getLevel(),expRanking));
			}
			unsigned short mapsize = m_stream->_readUShort();
			unsigned short myranking = m_stream->_readUShort();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			int totalPage = ceil((float)mapsize/(float)pageCount);
			if(totalPage == 0) totalPage = 1;
			canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
			canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
			canvas->doEvent(WCH_UI_UpdateData);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvManorLvRankingMethod
//
/////////////////////////////////////////
crJXJRecvManorLvRankingMethod::crJXJRecvManorLvRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvManorLvRankingMethod::crJXJRecvManorLvRankingMethod(const crJXJRecvManorLvRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvManorLvRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvManorLvRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvManorLvRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				crPlayerRanking *expRank;
				void *param;
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
				serverData->getParam(WCHDATA_JXJManorlvRankingMap,param);
				ManorlvRankingMap *levelRankingMap = (ManorlvRankingMap *)param;
				int count = CRCore::minimum((int)querycount,(int)(levelRankingMap->size()-start));
				int index = 0;
				if(!m_stream->eof())
				{
					name = m_stream->_readString();
					for( ManorlvRankingMap::iterator itr = levelRankingMap->begin(); 
						itr != levelRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if(shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if (name == expRank->getName())
							{
								start = index;
								count = 1;
								break;
							}
							index++;
						}
					}
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;
					
					for( ManorlvRankingMap::iterator itr = levelRankingMap->begin(); 
						itr != levelRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i >= start && i < start + count)
							{
								recordcount ++;
							}
							if (expRank->getPlayerID() == playerid)
							{
								myranking = i;
							}
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(5+44*recordcount);
					stream->_writeUChar((unsigned char)recordcount);
					i = 0;
					for( ManorlvRankingMap::iterator itr = levelRankingMap->begin(); 
						i < start + count && itr != levelRankingMap->end();
						++itr)
					{
						expRank = itr->second.get();
						if (shiliindex == 0 || expRank->getShiliID() == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeInt(expRank->getPlayerID());//4
								stream->_writeInt(expRank->getExploit());
								stream->_writeUChar(expRank->getGovpost());
								stream->_writeString(expRank->getName());//20
								stream->_writeUChar(expRank->getShiliID());
								stream->_writeUChar(expRank->getLevel());
								stream->_writeUChar(expRank->getNobility());
								stream->_writeUShort(expRank->getAccomplishPoint());
								stream->_writeInt(expRank->getTroops());
								stream->_writeUShort(expRank->getManorlv());
								stream->_writeInt(i+1); //排名
								++i;
							}
							else
							{
								++i;
							}
						}
					}
					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvManorLvRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			crData *canvasdata = canvas->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJManorlvRankingMap,param);
			ManorlvRankingMap *rankingMap = (ManorlvRankingMap *)param;
			rankingMap->clear();
			int count = (int)(m_stream->_readUChar());
			ref_ptr<crPlayerRanking> expRanking;
			for (int i = 0; i<count; i++)
			{
				expRanking = new crPlayerRanking;
				expRanking->setPlayerID(m_stream->_readInt());
				expRanking->setExploit(m_stream->_readInt());
				expRanking->setGovpost(m_stream->_readUChar());
				expRanking->setName(m_stream->_readString());
				expRanking->setShiliID(m_stream->_readUChar());
				expRanking->setLevel(m_stream->_readUChar());
				expRanking->setNobility(m_stream->_readUChar());
				expRanking->setAccomplishPoint(m_stream->_readUShort());
				expRanking->setTroops(m_stream->_readInt());
				expRanking->setManorlv(m_stream->_readUShort());
				expRanking->setPlayerRank(m_stream->_readInt());

				rankingMap->insert(std::make_pair(expRanking->getManorlv(),expRanking));
			}
			unsigned short mapsize = m_stream->_readUShort();
			unsigned short myranking = m_stream->_readUShort();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			int totalPage = ceil((float)mapsize/(float)pageCount);
			if(totalPage == 0) totalPage = 1;
			canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
			canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
			canvas->doEvent(WCH_UI_UpdateData);
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIStartRollCardsMethod
//
/////////////////////////////////////////
crJXJUIStartRollCardsMethod::crJXJUIStartRollCardsMethod()
{
}

crJXJUIStartRollCardsMethod::crJXJUIStartRollCardsMethod(const crJXJUIStartRollCardsMethod& handle):
	crMethod(handle)
{
}

void crJXJUIStartRollCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIStartRollCardsMethod::addParam(int i, const std::string& str)
{
}

void crJXJUIStartRollCardsMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			crData *canvasdata = canvas->getDataClass();
			canvasdata->inputParam(WCHDATA_JXJLuckyCardFirstShowTimer,0);
			m_this->setVisiable(false);
		}
	}
}
/////////////////////////////////////////
//
//crJXJPlayerRankingPageUpdateMethod
//
/////////////////////////////////////////
crJXJPlayerRankingPageUpdateMethod::crJXJPlayerRankingPageUpdateMethod():
	m_this(NULL)
{
}

crJXJPlayerRankingPageUpdateMethod::crJXJPlayerRankingPageUpdateMethod(const crJXJPlayerRankingPageUpdateMethod& handle):
	crMethod(handle),
	m_gamelist(handle.m_gamelist),
	m_shilicombobox(handle.m_shilicombobox),
	m_typecombobox(handle.m_typecombobox),
	m_this(NULL)
{
}
void crJXJPlayerRankingPageUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJPlayerRankingPageUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_gamelist = str;
		break;
	case 1:
		m_shilicombobox = str;
		break;
	case 2:
		m_typecombobox = str;
		break;
	}
}

void crJXJPlayerRankingPageUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		ref_ptr<crTableWidgetNode> gamelist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_gamelist));
		ref_ptr<crComboBoxWidgetNode> shilicombobox = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(m_shilicombobox));
		ref_ptr<crComboBoxWidgetNode> typecombobox = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(m_typecombobox));
		void *param;
		crData *canvasdata = m_this->getDataClass();
		if (canvasdata && typecombobox.valid())
		{
			int row = 0;
			if(gamelist.valid())
			{
				gamelist->clearData();
				ref_ptr<crPlayerRanking> expRank;
				unsigned char selectindex = typecombobox -> getSelectIndex();
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
				if(selectindex == RankingType_Level)
				{
					canvasdata->getParam(WCHDATA_JXJLevelRankingMap,param);
					LevelRankingMap *lvRankingMap = (LevelRankingMap *)param;
					for( LevelRankingMap::iterator itr = lvRankingMap->begin();
						itr != lvRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if (selectindex == RankingType_GovPost)
				{
					canvasdata->getParam(WCHDATA_JXJGovpostRankingMap,param);
					GovpostRankingMap *govpostRankingMap = (GovpostRankingMap *)param;
					for( GovpostRankingMap::iterator itr = govpostRankingMap->begin();
						itr != govpostRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if (selectindex == RankingType_Exploit)
				{
					canvasdata->getParam(WCHDATA_JXJExpRankingMap,param);
					ExpRankingMap *expRankingMap = (ExpRankingMap *)param;
					for( ExpRankingMap::iterator itr = expRankingMap->begin();
						itr != expRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if(selectindex == RankingType_Troops)
				{
					canvasdata->getParam(WCHDATA_JXJTroopsRankingMap,param);
					TroopsRankingMap *troopsRankingMap = (TroopsRankingMap *)param;
					for( TroopsRankingMap::iterator itr = troopsRankingMap->begin();
						itr != troopsRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if(selectindex == RankingType_Manorlv)
				{
					canvasdata->getParam(WCHDATA_JXJManorlvRankingMap,param);
					ManorlvRankingMap *manorlvRankingMap = (ManorlvRankingMap *)param;
					for( ManorlvRankingMap::iterator itr = manorlvRankingMap->begin();
						itr != manorlvRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if(selectindex == RankingType_Accomplishpoint)
				{
					canvasdata->getParam(WCHDATA_JXJAccomplishRankingMap,param);
					AccomplishRankingMap *accomplishRankingMap = (AccomplishRankingMap *)param;
					for( AccomplishRankingMap::iterator itr = accomplishRankingMap->begin();
						itr != accomplishRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
	}
}
void crJXJPlayerRankingPageUpdateMethod::displayRankingList(CRCore::ref_ptr<crPlayerRanking> playerRank, int row)
{
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = myPlayer->getDataClass();
	data->getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
	crData *canvasdata = m_this->getDataClass();
	crTableIO::StrVec record;
	ref_ptr<crTableIO>govPostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
	if (canvasdata)
	{
		canvasdata->getParam(WCHDATA_JXJRankingPageNum,param);
		int curpageNum = *(int * )param;
		ref_ptr<crTableWidgetNode> gamelist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_gamelist));
		if (gamelist.valid())
		{
			unsigned char postid;
			unsigned char shiliid;
			std::string shilistr;
			shiliid = playerRank->getShiliID();
			switch (shiliid - c_startShiliID)
			{
			case 0:
				shilistr = "魏";
				break;
			case 1:
				shilistr = "蜀";
				break;
			case 2:
				shilistr = "吴";
				break;
			default:
				break;
			};
			postid = playerRank->getGovpost();
			int retVal = govPostTab->queryOneRecord(0,crArgumentParser::appItoa(postid),record);
		//	gamelist->addData(0,row,crArgumentParser::appItoa(row+1+pageCount*(curpageNum - 1)));
			gamelist->addData(0,row,crArgumentParser::appItoa(playerRank->getPlayerRank()));
			gamelist->addData(1,row,playerRank->getName());
			gamelist->addData(2,row,crArgumentParser::appItoa(playerRank->getLevel()));
			if (retVal >= 0)
			{
				gamelist->addData(3,row,record[1]);
			}
			gamelist->addData(4,row,crArgumentParser::appItoa(playerRank->getExploit()));
			gamelist->addData(5,row,crArgumentParser::appItoa(playerRank->getTroops()));
			gamelist->addData(6,row,crArgumentParser::appItoa(playerRank->getManorlv()));
			gamelist->addData(7,row,crArgumentParser::appItoa(playerRank->getAccomplishPoint()));
			gamelist->addData(8,row,shilistr);
		}
	}
}
/////////////////////////////////////////
//
//crJXJCountryRankingPageUpdateMethod
//
/////////////////////////////////////////
crJXJCountryRankingPageUpdateMethod::crJXJCountryRankingPageUpdateMethod():
	m_this(NULL)
{
}

crJXJCountryRankingPageUpdateMethod::crJXJCountryRankingPageUpdateMethod(const crJXJCountryRankingPageUpdateMethod& handle):
	crMethod(handle),
	m_gamelist(handle.m_gamelist),
	m_typecombobox(handle.m_typecombobox),
	m_this(NULL)
{
}
void crJXJCountryRankingPageUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJCountryRankingPageUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_gamelist = str;
		break;
	case 1:
		m_typecombobox = str;
		break;
	}
}

void crJXJCountryRankingPageUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		ref_ptr<crTableWidgetNode> gamelist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_gamelist));
		ref_ptr<crComboBoxWidgetNode> typecombobox = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(m_typecombobox));
		void *param;
		crData *canvasdata = m_this->getDataClass();
		if (canvasdata && typecombobox.valid())
		{
			int row = 0;
			if(gamelist.valid())
			{
				gamelist->clearData();
				ref_ptr<crJXJCountryInfo> expRank;
				unsigned char selectindex = typecombobox -> getSelectIndex();
				if(selectindex == CountryRankingType_CityNum)
				{
					canvasdata->getParam(WCHDATA_JXJCountryCityNumRankingMap,param);
					CountryCityNumRankingMap *citynumRankingMap = (CountryCityNumRankingMap *)param;
					for( CountryCityNumRankingMap::iterator itr = citynumRankingMap->begin();
						itr != citynumRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if (selectindex == CountryRankingType_Money)
				{
					canvasdata->getParam(WCHDATA_JXJCountryMoneyRankingMap,param);
					CountryMoneyRankingMap *moneyRankingMap = (CountryMoneyRankingMap *)param;
					for( CountryMoneyRankingMap::iterator itr = moneyRankingMap->begin();
						itr != moneyRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
			}
		}
	}
}
void crJXJCountryRankingPageUpdateMethod::displayRankingList(CRCore::ref_ptr<crJXJCountryInfo> countryinfo, int row)
{
	crData *canvasdata = m_this->getDataClass();
	if (canvasdata)
	{
		ref_ptr<crTableWidgetNode> gamelist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_gamelist));
		if (gamelist.valid())
		{
			unsigned char shiliid;
			std::string shilistr;
			shiliid = countryinfo->getShiliID();
			switch (shiliid - c_startShiliID)
			{
			case 0:
				shilistr = "魏";
				break;
			case 1:
				shilistr = "蜀";
				break;
			case 2:
				shilistr = "吴";
				break;
			default:
				break;
			}
			gamelist->addData(0,row,crArgumentParser::appItoa(row+1));
			gamelist->addData(1,row,shilistr);
			gamelist->addData(2,row,crArgumentParser::appItoa(countryinfo->getCityNum()));
			gamelist->addData(3,row,crArgumentParser::appItoa(countryinfo->getMoney()));
		}
	}
}
/////////////////////////////////////////
//
//crJXJGroupRankingPageUpdateMethod
//
/////////////////////////////////////////
crJXJGroupRankingPageUpdateMethod::crJXJGroupRankingPageUpdateMethod():
	m_this(NULL)
{
}

crJXJGroupRankingPageUpdateMethod::crJXJGroupRankingPageUpdateMethod(const crJXJGroupRankingPageUpdateMethod& handle):
	crMethod(handle),
	m_gamelist(handle.m_gamelist),
	m_shilicombobox(handle.m_shilicombobox),
	m_typecombobox(handle.m_typecombobox),
	m_this(NULL)
{
}
void crJXJGroupRankingPageUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJGroupRankingPageUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_gamelist = str;
		break;
	case 1:
		m_shilicombobox = str;
		break;
	case 2:
		m_typecombobox = str;
		break;
	}
}

void crJXJGroupRankingPageUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(myPlayer && m_this)
	{
		ref_ptr<crTableWidgetNode> gamelist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_gamelist));
		ref_ptr<crComboBoxWidgetNode> shilicombobox = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(m_shilicombobox));
		ref_ptr<crComboBoxWidgetNode> typecombobox = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(m_typecombobox));
		void *param;
		crData *canvasdata = m_this->getDataClass();
		if (canvasdata && typecombobox.valid())
		{
			int row = 0;
			if(gamelist.valid())
			{
				gamelist->clearData();
				ref_ptr<crJXJGroupInfo> expRank;
				unsigned char selectindex = typecombobox -> getSelectIndex();
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
				if (selectindex == GroupRankingType_Exploit)
				{
					canvasdata->getParam(WCHDATA_JXJConsortiaExploitRankingMap,param);
					GroupExploitRankingMap *ExploitRankingMap = (GroupExploitRankingMap *)param;
					for( GroupExploitRankingMap::iterator itr = ExploitRankingMap->begin();
						itr != ExploitRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if(selectindex == GroupRankingType_Level)
				{
					canvasdata->getParam(WCHDATA_JXJConsortialvRankingMap,param);
					GrouplvRankingMap *lvRankingMap = (GrouplvRankingMap *)param;
					for( GrouplvRankingMap::iterator itr = lvRankingMap->begin();
						itr != lvRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if (selectindex == GroupRankingType_MemberCount)
				{
					canvasdata->getParam(WCHDATA_JXJConsortiaMemberRankingMap,param);
					GroupMemberRankingMap *govpostRankingMap = (GroupMemberRankingMap *)param;
					for( GroupMemberRankingMap::iterator itr = govpostRankingMap->begin();
						itr != govpostRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				else if (selectindex == GroupRankingType_Troops)
				{
					canvasdata->getParam(WCHDATA_JXJConsortiaTroopsRankingMap,param);
					GroupTroopsRankingMap *troopsRankingMap = (GroupTroopsRankingMap *)param;
					for( GroupTroopsRankingMap::iterator itr = troopsRankingMap->begin();
						itr != troopsRankingMap->end();
						++itr,row++)
					{
						expRank = itr->second.get();
						displayRankingList(expRank,row);
					}
				}
				//else if(selectindex == GroupRankingType_Exploit)
				//{
					//canvasdata->getParam(WCHDATA_JXJTroopsRankingMap,param);
					//TroopsRankingMap *troopsRankingMap = (TroopsRankingMap *)param;
					//for( TroopsRankingMap::iterator itr = troopsRankingMap->begin();
					//	itr != troopsRankingMap->end();
					//	++itr,row++)
					//{
					//	expRank = itr->second.get();
					//	displayRankingList(expRank,row);
					//}
				//}
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
	}
}
void crJXJGroupRankingPageUpdateMethod::displayRankingList(CRCore::ref_ptr<crJXJGroupInfo> playerRank, int row)
{
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = myPlayer->getDataClass();
	data->getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	crData *canvasdata = m_this->getDataClass();
	int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
	if (canvasdata)
	{
		canvasdata->getParam(WCHDATA_JXJRankingPageNum,param);
		int curpageNum = *(int * )param;
		ref_ptr<crTableWidgetNode> gamelist = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_gamelist));
		if (gamelist.valid())
		{
			unsigned char shiliid;
			std::string shilistr;
			shiliid = playerRank->getShiliID();
			switch (shiliid - c_startShiliID)
			{
			case 0:
				shilistr = "魏";
				break;
			case 1:
				shilistr = "蜀";
				break;
			case 2:
				shilistr = "吴";
				break;
			default:
				break;
			}
			gamelist->addData(0,row,crArgumentParser::appItoa(playerRank->getRank()));
			gamelist->addData(1,row,playerRank->getName());
			gamelist->addData(2,row,playerRank->getCreatorName());
			gamelist->addData(3,row,crArgumentParser::appItoa(playerRank->getLv()));
			gamelist->addData(4,row,crArgumentParser::appItoa(playerRank->getMemberCount()));
			gamelist->addData(5,row,crArgumentParser::appItoa(playerRank->getGroupTroops()));
			gamelist->addData(6,row,crArgumentParser::appItoa(playerRank->getGroupExploit()));
			gamelist->addData(7,row,shilistr);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRankingCanvasUpdateMethod
//
/////////////////////////////////////////
crJXJRankingCanvasUpdateMethod::crJXJRankingCanvasUpdateMethod()
{
}

crJXJRankingCanvasUpdateMethod::crJXJRankingCanvasUpdateMethod(const crJXJRankingCanvasUpdateMethod& handle):
	crMethod(handle),
	m_pageinput(handle.m_pageinput),
	m_radio(handle.m_radio),
	m_pagesw(handle.m_pagesw),
	m_mygroupcanvas(handle.m_mygroupcanvas)
{
	for(int i = 0; i < 5; i++)
	{
		if (i < 2)
		{
			m_myrankinput[i] = handle.m_myrankinput[i];
		}
		m_combobox[i] = handle.m_combobox[i];
	}
}

void crJXJRankingCanvasUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJRankingCanvasUpdateMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_pageinput = str;
		break;
	case 1:
		m_radio = str;
		break;
	case 2:
		m_pagesw = str;
		break;
	case 3:
		m_myrankinput[0] = str;
		break;
	case 4:
		m_myrankinput[1] = str;
		break;
	case 5:
		m_combobox[0] = str;
		break;
	case 6:
		m_combobox[1] = str;
		break;
	case 7:
		m_combobox[2] = str;
		break;
	case 8:
		m_combobox[3] = str;
		break;
	case 9:
		m_combobox[4] = str;
		break;
	case 10:
		m_mygroupcanvas = str;
		break;
	}
}

void crJXJRankingCanvasUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		void *param;
		crData *canvasdata = m_this->getDataClass();
		crData *data = playerGameData->getDataClass();
		crData *mainroledata = playerGameData->getMainRole()->getDataClass();
		if (canvasdata && data && mainroledata)
		{
			ref_ptr<crStaticTextWidgetNode> inputpage = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pageinput));
			ref_ptr<crStaticTextWidgetNode> rankinput[2] = {NULL};
			ref_ptr<crComboBoxWidgetNode> combobox[5] = {NULL};
			for (int i = 0; i < 5; i++)
			{
				if (i < 2)
				{
					rankinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_myrankinput[i]));
					if (rankinput[i].valid())
					{
						rankinput[i]->clearString();
					}
				}
				combobox[i] = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(m_combobox[i]));
			}
			canvasdata->getParam(WCHDATA_JXJRankingPageNum,param);
			int curpageNum = *(int * )param;
			canvasdata->getParam(WCHDATA_JXJRankingTotal,param);
			int totalpageNum = *(int * )param;
			canvasdata->getParam(WCHDATA_JXJMyRanking,param);
			unsigned short myranking = *(unsigned short * )param;
			if (inputpage.valid())
			{
				inputpage -> setString(crArgumentParser::appItoa(curpageNum) + "/" + crArgumentParser::appItoa(totalpageNum));
			}
			ref_ptr<crRadioGroupWidgetNode> groupradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_radio));
			crMultiSwitch *pagesw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_pagesw));
			if (pagesw && groupradio.valid())
			{
				crTableIO::StrVec govrecord;
				ref_ptr<crTableIO>postTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
				int postnameid = postTab->getTitleIndex("govpost");
				int mytroops = 0;
				int myaccomplish = 0;
				unsigned short manorlv = 0;
				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,1));
				data->getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *(int *)param;
				data->getParam(WCHDATA_JXJTroopsMap,param);
				TroopsMap *troopsMap = (TroopsMap*)param;
				for (TroopsMap::iterator itr = troopsMap->begin();
					itr != troopsMap->end();
					++itr)
				{
					mytroops += itr->second;
				}
				mainroledata->getParam(WCHDATA_JXJAccomplishMap,param);
				AccomplishMap *accomplishMap = (AccomplishMap *)param;
				for( AccomplishMap::iterator itr = accomplishMap->begin();
					itr != accomplishMap->end();
					++itr )
				{
					if(itr->second!=NULL && !itr->second->isComplete())
						myaccomplish++;
				}
				mainroledata->excHandle(MAKECREPARAM(WCH_LockData,0));
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				std::string str[2];
				int rankinglisttype = groupradio->getSelect();
				pagesw->setActiveSwitchSet(rankinglisttype);
				if (rankinglisttype == RankingListType_Country)
				{
				}
				else if (rankinglisttype == RankingListType_Group)
				{
					if (mygroupid > 0 && combobox[2].valid())
					{
						void *param;
						ref_ptr<crCanvasNode>mygroupcanvas = crFilterRenderManager::getInstance()->findCanvas(m_mygroupcanvas);
						crJXJGroupInfo *groupinfo = NULL;
						if (mygroupcanvas.valid())
						{
							crData *canvasdata2 = mygroupcanvas->getDataClass();
							if (canvasdata2)
							{
								canvasdata2->getParam(WCHDATA_JXJMyGroupInfo,param);
								groupinfo = (crJXJGroupInfo *)param;
							}
						}
						int rankingtype = combobox[2] -> getSelectIndex();
						if (groupinfo)
						{
							switch (rankingtype)
							{
							case GroupRankingType_Level:
								str[0] = "我军团等级："+crArgumentParser::appItoa(groupinfo->getLv());
								break;
							case GroupRankingType_MemberCount:
								str[0] = "我军团人数："+crArgumentParser::appItoa(groupinfo->getMemberCount());
								break;
								/*case GroupRankingType_Troops:
								str[0] = "我军团兵力："+crArgumentParser::appItoa(groupinfo->getGroupTroops());
								break;
								case GroupRankingType_Exploit:
								str[0] = "我军团功勋："+crArgumentParser::appItoa(groupinfo->getGroupExploit());
								break;*/
							default:
								break;
							}
						}
						
						if (myranking == 0)
						{
							str[1] = "我军团排名:无";
						}
						else
						{
							str[1] = "我军团排名："+crArgumentParser::appItoa(myranking);
						}
					}
					else
					{
						str[0] = "未加入军团";
					}
				}
				else if (rankinglisttype == RankingListType_Player)
				{
					if (combobox[4].valid())
					{
						int rankingtype = combobox[4] -> getSelectIndex();
						switch (rankingtype)
						{
						case RankingType_Level:
							mainroledata->getParam(WCHDATA_Level,param);
							str[0] = "我的等级："+crArgumentParser::appItoa(*(unsigned char *)param);
							break;
						case RankingType_GovPost:
							mainroledata->getParam(WCHDATA_JXJGovPost,param);
							if(postTab->queryOneRecord(0,crArgumentParser::appItoa(*(unsigned char *)param),govrecord) >= 0 )
								str[0] = "我的官职："+govrecord[postnameid];
							break;
						case RankingType_Exploit:
							mainroledata->getParam(WCHDATA_JXJExploit,param);
							str[0] = "我的功勋："+crArgumentParser::appItoa(*(int *)param);
							break;
						case RankingType_Troops:
							str[0] = "我的兵力："+crArgumentParser::appItoa(mytroops);
							break;
						case RankingType_Manorlv:
							///统计领地总等级
							for (int i = WCHDATA_JXJFuyalv; i <= WCHDATA_JXJFukulv; i++)
							{
								data->getParam(i,param);
								manorlv += *(unsigned char *)param;
							}
							for (int i = WCHDATA_JXJMingjulv1; i <= WCHDATA_JXJKuangshanlv4; i++)
							{
								data->getParam(i,param);
								manorlv += *(unsigned char *)param;
							}
							/////////////////////////
							str[0] = "我的领地："+crArgumentParser::appItoa(manorlv);
							break;
						case RankingType_Accomplishpoint:
							mainroledata->getParam(WCHDATA_JXJAccomplishPoint,param);
							str[0] = "我的成就："+crArgumentParser::appItoa(*(unsigned short *)param);
							break;
						case RankingType_Countrycontribute:
							data->getParam(WCHDATA_JXJCountryContribute,param);
							str[0] = "我的贡献："+crArgumentParser::appItoa(*(int *)param);
							break;
						default:
							break;
						}
						if (myranking == 0)
						{
							str[1] = "我的排名:无";
						}
						else
						{
							str[1] = "我的排名："+crArgumentParser::appItoa(myranking);
						}
					}
				}
				for (int i = 0;i < 2;i++)
				{
					if(rankinput[i].valid())rankinput[i]->setString(str[i]);
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRankingCanvasInitMethod
//
/////////////////////////////////////////
crJXJRankingCanvasInitMethod::crJXJRankingCanvasInitMethod()
{
}

crJXJRankingCanvasInitMethod::crJXJRankingCanvasInitMethod(const crJXJRankingCanvasInitMethod& handle):
	crMethod(handle),
	m_pageinput(handle.m_pageinput)
{
	for (int i = 0; i < 5; i++)
	{
		m_combobox[i] = handle.m_combobox[i];
		m_gamelist[i] = handle.m_gamelist[i];
		m_paraminput[i] = handle.m_paraminput[i];
	}
}

void crJXJRankingCanvasInitMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJRankingCanvasInitMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_pageinput = str;
		break;
	case 1:
		m_combobox[i - 1] = str;
		break;
	case 2:
		m_combobox[i - 1] = str;
		break;
	case 3:
		m_combobox[i - 1] = str;
		break;
	case 4:
		m_combobox[i - 1] = str;
		break;
	case 5:
		m_combobox[i - 1] = str;
		break;
	case 6:
		m_gamelist[i - 6] = str;
		break;
	case 7:
		m_gamelist[i - 6] = str;
		break;
	case 8:
		m_gamelist[i - 6] = str;
		break;
	case 9:
		m_gamelist[i - 6] = str;
		break;
	case 10:
		m_gamelist[i - 6] = str;
		break;
	case 11:
		m_paraminput[i - 11] = str;
		break;
	case 12:
		m_paraminput[i - 11] = str;
		break;
	case 13:
		m_paraminput[i - 11] = str;
		break;
	case 14:
		m_paraminput[i - 11] = str;
		break;
	case 15:
		m_paraminput[i - 11] = str;
		break;
	}
}

void crJXJRankingCanvasInitMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		void *param;
		ref_ptr<crTableIO>showtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJRankingListTab);
		crTableIO::DataVec records;
		int typeindex = showtab->getTitleIndex("type");
		int nameindex = showtab->getTitleIndex("name");
		ref_ptr<crStaticTextWidgetNode> inputpage = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pageinput));
		ref_ptr<crComboBoxWidgetNode> combobox[5] = {NULL};
		ref_ptr<crTableWidgetNode> gamelist[5] = {NULL};
		ref_ptr<crStaticTextWidgetNode> paraminput[5] = {NULL};
		for (int i = 0; i < 5; i++)
		{
			gamelist[i] = dynamic_cast<crTableWidgetNode *>(m_this->getWidget(m_gamelist[i]));
			paraminput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_paraminput[i]));
			combobox[i] = dynamic_cast<crComboBoxWidgetNode *>(m_this->getWidget(m_combobox[i]));
			//if (paraminput[i])
			//{
			//	paraminput[i]->setCanSelectText(true);
			//}

			if (gamelist[i].valid())
			{
				gamelist[i]->setMouseMoveSelect(true);
				//gamelist[i]->initWindow();
			}
		}
		for (int i = 0; i < 5; i++)
		{
			records.clear();
			showtab->queryRecords(typeindex,crArgumentParser::appItoa(i),records);
			if (gamelist[i].valid())
			{
				gamelist[i]->clearData();
				for (int ii = 0; ii < records.size();ii++)
				{
					gamelist[i]->addData(0,ii,records[ii][nameindex]);
					gamelist[i]->addData(ii,atoi(records[ii][0].c_str()));
					if (ii == 0)
					{
						//paraminput[i] -> setString(records[ii][nameindex]);
					}
				}
			}
			if (combobox[i].valid())
			{
				combobox[i]->select(0);
			}
		}

		crData *canvasdata = m_this->getDataClass();
		if (canvasdata)
		{
			canvasdata->getParam(WCHDATA_JXJRankingPageNum,param);
			int curpageNum = *(int * )param;
			canvasdata->getParam(WCHDATA_JXJRankingTotal,param);
			int totalpageNum = *(int * )param;
			if (inputpage.valid())
			{
				inputpage -> setString(crArgumentParser::appItoa(curpageNum) + "/" + crArgumentParser::appItoa(totalpageNum));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPutItemInBagMethod
//
/////////////////////////////////////////
crJXJPutItemInBagMethod::crJXJPutItemInBagMethod():
	m_this(NULL),
	m_bagitem(NULL),
	m_type(0),
	m_cycle(0)
{
}
crJXJPutItemInBagMethod::crJXJPutItemInBagMethod(const crJXJPutItemInBagMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_bagitem(NULL),
	m_type(0),
	m_cycle(0)
{
}
void crJXJPutItemInBagMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_bagitem = (crBagItemData *)(LOCREPARAM(param64));
			_crInt32 hi = HICREPARAM(param64);
			m_type = LOINT32(hi);
			m_cycle = HIINT32(hi);
		}
		else
		{
			m_type = 0;
			m_cycle = 0;
		}
		break;
	}
}
void crJXJPutItemInBagMethod::addParam(int i, const std::string& str)
{
}
bool crJXJPutItemInBagMethod::isNotice(int tianshu)
{
	if(tianshu == 0)
		return false;
	if(tianshu == -1)
		return true;
	//int tianshu = 0;
	//if(crGlobalHandle::isClient())
	//{
	//	crGlobalHandle::getInstance()->doEvent(WCH_JXJGetTianshu,MAKECREPARAM(&tianshu,NULL));
	//}
	//else
	//{
	//	crServerBrainHandle::getInstance()->doEvent(WCH_JXJGetTianshu,MAKECREPARAM(&tianshu,NULL));
	//}

	std::string &start = crGlobalHandle::gData()->gStartDate();
	time_t t = time(0);
	char tmp[20];
	strftime( tmp, sizeof(tmp), "%Y|%m|%d\0", localtime(&t) );
	crVector3i vstart,vnow;
	crArgumentParser::appAtoVec(start,vstart);
	crArgumentParser::appAtoVec(tmp,vnow);
	int nowtianshu = (vnow[0]-vstart[0]) * 365 + (vnow[1] - vstart[1]) * 30 + vnow[2]- vstart[2];
	return tianshu>=nowtianshu;
}
void crJXJPutItemInBagMethod::operator()(crHandle &handle)
{	
	if (m_bagitem)
	{
		int itemid = m_bagitem->getItemID();
		int itemcount = m_bagitem->getItemCount();
		_crInt32 equipmagic = m_bagitem->getEquipMagic();
		ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
		bagitemdata->setItemID(itemid);
		bagitemdata->setItemCount(itemcount);
		bagitemdata->setEquipMagic(equipmagic);
		void *param;
		char bagtype = 0;
		int maxnum = 0;
		int curindex = 0;
		ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
		int maxnumindex = itemtab->getTitleIndex("叠加数量");
		int typeindex = itemtab->getTitleIndex("类型");
		int qualityindex = itemtab->getTitleIndex("品质");
		int nameIndex = itemtab->getTitleIndex("name");
		int noticeIndex = itemtab->getTitleIndex("通告");
		crTableIO::StrVec itemrecord;
		crData *data = m_this->getDataClass();
		if(data)
		{
			typedef std::map<unsigned char,unsigned char > PutItemInBagMap;//bagindex,count
			PutItemInBagMap puiteminbagmap;
			if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(bagitemdata->getItemID()),itemrecord) >= 0 )
			{
				data->excHandle(MAKECREPARAM(WCH_LockData,1));

				int itemtype = atoi(itemrecord[typeindex].c_str());
				JXJItemBagVec *bagvec;
				if(itemtype == IT_Jiangka)
				{
					data->getParam(WCHDATA_JXJJiangkaBagVec,param);
					bagvec = (JXJItemBagVec *)param;
					bagtype = IT_Jiangka;
				}
				else
				{
					data->getParam(WCHDATA_JXJItemBagVec,param);
					bagvec = (JXJItemBagVec *)param;
				}

				maxnum = atoi(itemrecord[maxnumindex].c_str());
				curindex = -1;
				bool inputempty = false;
				while (itemcount > 0)
				{
					//////////////////////////////////////////////////////////////////////////
					if(maxnum>1)
					{
						curindex = getItemIndex(bagvec,bagitemdata->getItemID(),bagitemdata->getEquipMagic(),curindex + 1);
						if (curindex >= 0)
						{
							if((*bagvec)[curindex]->getItemCount() > maxnum - itemcount )
							{
								// 超过最大数量
								if ((*bagvec)[curindex]->getItemCount() != maxnum)
								{
									itemcount -= (maxnum - (*bagvec)[curindex]->getItemCount());
									bagitemdata->setItemCount(itemcount);
									(*bagvec)[curindex]->setItemCount(maxnum);
									puiteminbagmap.insert(std::make_pair((unsigned char)curindex,maxnum));
								}
							}
							else
							{
								(*bagvec)[curindex] -> setItemCount((*bagvec)[curindex]->getItemCount() + itemcount);
								puiteminbagmap.insert(std::make_pair((unsigned char)curindex,(*bagvec)[curindex]->getItemCount()));
								break;
							}
						}
						else
						{
							inputempty = true;
						}
					}
					else
					{
						inputempty = true;
					}
					if(inputempty)
					{
						curindex = getFirstEmptyIndex(bagvec);
						if (curindex >= 0)
						{
							(*bagvec)[curindex] = bagitemdata;
							puiteminbagmap.insert(std::make_pair((unsigned char)curindex,bagitemdata->getItemCount()));
						}
						break;
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				////////////////////////////////////////////////
				if (m_type!=1)
				{
					int playerid = m_this->getPlayerID(); 
					crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
					ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
					if(playerData.valid())
					{
						int mapsize = puiteminbagmap.size();
						ref_ptr<crStreamBuf> stream = new crStreamBuf;
						stream->createBuf(12 + mapsize * 2);
						stream->_writeChar(bagtype);
						stream->_writeChar(m_type);
						stream->_writeInt(itemid);
						stream->_writeInt(equipmagic);
						stream->_writeUChar(m_bagitem->getItemCount());
						stream->_writeUChar(mapsize);
						for (PutItemInBagMap::iterator itr = puiteminbagmap.begin();
							itr != puiteminbagmap.end();
							itr++)
						{
							stream->_writeUChar(itr->first);
							stream->_writeUChar(itr->second);
						}
						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPutItemInBag,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
				////////////////////////////////////////////////
				if (!crGlobalHandle::isClient() && !m_type)
				{//////////////////////////////////////////////////////////////////////////全服广播玩家获得将卡消息
					//检查将卡品级是否为橙卡
					int quality = atoi(itemrecord[qualityindex].c_str());
					bool needsave = false;
					bool neednotice = false;
					//if(itemtype == IT_Gemstone && quality>=CardColor_Blue)
					//{//蓝色以上八卦石
					//	needsave = true;
					//}
                    if (itemtype == IT_Jiangka)
                    {
                        m_this->doEvent(WCH_JXJCheck7Day);
                    }
					if((itemtype == IT_Jiangka || itemtype == IT_Equip) && quality>=CardColor_Orange/* && !itemrecord[nameIndex].empty()*/)
					{
						needsave = true;
					}
					if(needsave)
					{
						crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
						ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(m_this->getPlayerID()));
						if(playerData.valid())
						{
							crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
							callback->savePlayerData(playerData.get());
						}
					}
					if(!m_cycle && !itemrecord[nameIndex].empty() && noticeIndex>0 && isNotice(atoi(itemrecord[noticeIndex].c_str())))
						neednotice = true;
					if(neednotice)
					{
						std::string strItemName = std::string("[")+itemrecord[nameIndex]+std::string("]");
						if(itemtype == IT_Jiangka) 
						{
							switch(quality - CardColor_Orange)
							{
							case 1:
								strItemName+=std::string("(一星)");
								break;
							case 2:
								strItemName+=std::string("(二星)");
								break;
							case 3:
								strItemName+=std::string("(三星)");
								break;
							case 4:
								strItemName+=std::string("(四星)");
								break;
							case 5:
								strItemName+=std::string("(五星)");
								break;
							}
						}

						std::string strMessage = std::string("恭喜玩家(")+m_this->getCharacterName()+std::string(")获得")+strItemName;

						strMessage += std::string("{");
						strMessage += std::string("(")+crArgumentParser::appItoa(bagitemdata->getItemID())+std::string("|0")+std::string(")");
						strMessage += std::string("}");

						ref_ptr<crJXJChatMessageInfo> chatInfo = new crJXJChatMessageInfo("[通告]",strMessage,0,0);
						crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
						serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
						crServerBrainHandle::getInstance()->doEvent(WCH_JXJSystermNoticeCreate,MAKECREPARAM(chatInfo.get(),NULL));
						serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
				}
			}
		}
	}
}
int crJXJPutItemInBagMethod::getFirstEmptyIndex(JXJItemBagVec *bagvec)
{
	int emptybagindex = 0;
	int size = bagvec->size();
	for( ; emptybagindex<size; ++emptybagindex )
	{
		if(!(*bagvec)[emptybagindex].valid())
			return emptybagindex;
	}
	return -1;
}
int crJXJPutItemInBagMethod::getItemIndex(JXJItemBagVec *bagvec,int itemid,int equipmagic,int beginindex)
{
	int itemindex = beginindex;
	int size = bagvec->size();
	CRCore::ref_ptr<crBagItemData> bagitem;
	for( ; itemindex<size; ++itemindex )
	{
		bagitem = (*bagvec)[itemindex];
		if(bagitem.valid() && bagitem->getItemID() == itemid && bagitem->getEquipMagic() == equipmagic)
			return itemindex;
	}
	return -1;
}
/////////////////////////////////////////
//
//crJXJRecvJPutItemInBagMethod
//
/////////////////////////////////////////
crJXJRecvPutItemInBagMethod::crJXJRecvPutItemInBagMethod():
	m_netType(GameClient_Game){}
crJXJRecvPutItemInBagMethod::crJXJRecvPutItemInBagMethod(const crJXJRecvPutItemInBagMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvPutItemInBagMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPutItemInBagMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvPutItemInBagMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		void *param;
		if(m_netType == GameClient_Game)
		{
			int lastcount = 0;
			crData *data = m_this->getDataClass();
			char bagtype = m_stream->_readChar();
			char puttype = m_stream->_readChar();
			int itemid = m_stream->_readInt();
			int equipmagic = m_stream->_readInt();
			unsigned char getcount = m_stream->_readUChar();
			unsigned char mapsize = m_stream->_readUChar();
			unsigned char itemcount = 0;
			unsigned char bagindex = 0;
			ref_ptr<crBagItemData> bagitemdata;
			ref_ptr<crBagItemData> bagitemdataget;
			JXJItemBagVec *bagvec;
			if(bagtype == IT_Jiangka)
			{
				data->getParam(WCHDATA_JXJJiangkaBagVec,param);
				bagvec = (JXJItemBagVec *)param;
			}
			else
			{
				data->getParam(WCHDATA_JXJItemBagVec,param);
				bagvec = (JXJItemBagVec *)param;
			}
			for (int i = 0; i < mapsize; i++)
			{
				//lastcount = 0;
				bagindex = m_stream->_readUChar();
				itemcount = m_stream->_readUChar();
				bagitemdata = new crBagItemData;
				bagitemdata->setItemID(itemid);
				bagitemdata->setItemCount(itemcount);
				bagitemdata->setEquipMagic(equipmagic);
				//if ((*bagvec)[bagindex] != NULL)
				//{
				//	lastcount = (*bagvec)[bagindex]->getItemCount();
				//}
				//getcount = itemcount - lastcount;
				(*bagvec)[bagindex] = bagitemdata;
				if(!puttype && getcount > 0)
				{
					//播放进背包动画
					bagitemdataget = new crBagItemData;
					bagitemdataget->setItemID(itemid);
					bagitemdataget->setItemCount(getcount);
					bagitemdataget->setEquipMagic(equipmagic);
					crData *braindata = crBrain::getInstance()->getDataClass();
					if(braindata)
					{
						braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
						braindata->getParam(WCHDATA_JXJRecvBagItemDeq,param);
						if(param)
						{
							RecvBagItemDeq *itemDeq = (RecvBagItemDeq *)param;
							itemDeq->push_back(std::make_pair(T_Item,bagitemdataget));
						}									
						braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJProduceCardValidTimeMethod
//
/////////////////////////////////////////
crJXJProduceCardValidTimeMethod::crJXJProduceCardValidTimeMethod():
	m_dt(0)
{
}
crJXJProduceCardValidTimeMethod::crJXJProduceCardValidTimeMethod(const crJXJProduceCardValidTimeMethod& handle):
	crMethod(handle),
	m_dt(handle.m_dt)
{
}
void crJXJProduceCardValidTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = *((int*)(LOCREPARAM(param64)));
		}
		else
		{
			m_dt = 0;
		}
		break;
	}
}
void crJXJProduceCardValidTimeMethod::addParam(int i, const std::string& str)
{
}
void crJXJProduceCardValidTimeMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			void *param;
			crData *thisData = m_this->getDataClass();
			thisData->excHandle(MAKECREPARAM(WCH_LockData,1));
			thisData->getParam(WCHDATA_JXJExtraProduceMap,param);
			ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			crPlayerDataEventPacket packet;
			int validtime = 0;
			stream->createBuf(extraProduceMap->size() * 4 + 1);
			stream->_writeUChar(extraProduceMap->size());
			for (ExtraProduceMap::iterator itr = extraProduceMap->begin();
				itr != extraProduceMap->end();
				++itr)
			{
				stream->_writeInt(itr->second->timer());
			}
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJProduceCardValidTime,stream.get());
			gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvProduceCardValidTimeMethod
//
/////////////////////////////////////////
crJXJRecvProduceCardValidTimeMethod::crJXJRecvProduceCardValidTimeMethod():
	m_this(NULL)
{
}
crJXJRecvProduceCardValidTimeMethod::crJXJRecvProduceCardValidTimeMethod(const crJXJRecvProduceCardValidTimeMethod& handle):
	crMethod(handle),
	m_this(handle.m_this)
{
}
void crJXJRecvProduceCardValidTimeMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}
void crJXJRecvProduceCardValidTimeMethod::addParam(int i, const std::string& str)
{
}
void crJXJRecvProduceCardValidTimeMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		unsigned char mapsize = m_stream->_readUChar();
		unsigned char type = 0;
		crData *thisData = m_this->getDataClass();
		thisData->excHandle(MAKECREPARAM(WCH_LockData,1));
		thisData->getParam(WCHDATA_JXJExtraProduceMap,param);
		ExtraProduceMap *extraProduceMap = (ExtraProduceMap *)param;
		int i = 0;
		for (ExtraProduceMap::iterator itr = extraProduceMap->begin();
			itr != extraProduceMap->end() && i < mapsize; ++itr,i++)
		{
			itr->second->timer() = m_stream->_readInt();
		}
		thisData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}

/////////////////////////////////////////
//
//crJXJUseImpressionBuyCardMethod
//
/////////////////////////////////////////
crJXJUseImpressionBuyCardMethod::crJXJUseImpressionBuyCardMethod()
{}
crJXJUseImpressionBuyCardMethod::crJXJUseImpressionBuyCardMethod(const crJXJUseImpressionBuyCardMethod& handle):
	crMethod(handle)
{
}
void crJXJUseImpressionBuyCardMethod::inputParam(int i, void *param)
{
}
void crJXJUseImpressionBuyCardMethod::addParam(int i, const std::string& str)
{
}

void crJXJUseImpressionBuyCardMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		void *param;
		crData *data = playerGameData->getDataClass();
		if (data)
		{
			int needbagcount = 1;
			playerGameData->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
			if (needbagcount == 0)
			{
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				//unsigned short needimpression = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJNeedCardImpression,viplv).c_str());
				data->getParam(WCHDATA_JXJCardImpression,param);
				unsigned short cardimpression = *(unsigned short *)param;

				ref_ptr<crTableIO>impressionTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressionTab);
				data->getParam(WCHDATA_JXJCardImpressionLevel,param);
				unsigned short level = *(unsigned short *)param;
				int expIndex = impressionTab->getTitleIndex("exp");
				crTableIO::StrVec record;
				unsigned short needimpression;
				if(impressionTab->queryOneRecord(0,crArgumentParser::appItoa(level),record)>=0)
				{
					needimpression = atoi(record[expIndex].c_str());
				}
				if (cardimpression >= needimpression)
				{
					CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
					CRNetApp::crPlayerDataEventPacket packet;
					CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUseImpressionBuyCard,NULL);
					net_conductor->getNetManager()->sendPacket("all",packet);
				}
				else
				{
					playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2035,NULL));//好感度不足
				}
			}
			else
			{
				playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));//背包已满
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvUseImpressionBuyCardMethod
//
/////////////////////////////////////////
crJXJRecvUseImpressionBuyCardMethod::crJXJRecvUseImpressionBuyCardMethod():
	m_netType(GameClient_Game){}
crJXJRecvUseImpressionBuyCardMethod::crJXJRecvUseImpressionBuyCardMethod(const crJXJRecvUseImpressionBuyCardMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvUseImpressionBuyCardMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvUseImpressionBuyCardMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvUseImpressionBuyCardMethod::operator()(crHandle &handle)
{
	//////////////////////////////////
	//返回
	//0：失败
	//1：成功
	//2：好感度不足
	//3：背包已满
	//////////////////////////////////
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crTableIO>impressionTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressionTab);
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			void *param;
			crData *data = m_this->getDataClass();
			std::string log="好感度兑换";
			if(playerData.valid() && impressionTab.valid() && data)
			{
				crVector2i giftbag;
				int needbagcount = 1;
				m_this->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
				if (needbagcount == 0)
				{
					
					int needimpression ;
					int color;
					std::vector<std::string > cardsVec;
					crTableIO::StrVec record;
					data->getParam(WCHDATA_JXJCardImpressionLevel,param);
					unsigned short level = *(unsigned short *)param;
					int expIndex = impressionTab->getTitleIndex("exp");
					int colorIndex = impressionTab->getTitleIndex("color");
					int cardsIndex = impressionTab->getTitleIndex("cards");
					if(impressionTab->queryOneRecord(0,crArgumentParser::appItoa(level),record)>=0)
					{
						needimpression = -(atoi(record[expIndex].c_str()));
						color = atoi(record[colorIndex].c_str());
						crArgumentParser::appAtoVec(record[cardsIndex],cardsVec,'|');
						//crJXJConsortiaData::split(record[cardsIndex],"|",cardsVec);
					}


					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					m_this->doEvent(WCH_JXJChangePlayerData,MAKECREPARAM(&needimpression,T_CardImpression));
					//data->getParam(WCHDATA_JXJCardImpression,param);
					//unsigned short *impression = (unsigned short *)param;
					if(needimpression == 0)
					{
						success = 1;
						data->getParam(WCHDATA_JXJShiliID,param);
						unsigned char myshiliid = *(unsigned char *)param;

						unsigned char cardshiliid = 0;
						int cardType = 0;
						ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
						int attrid = itemTable->getTitleIndex("类型");
						int colorindex = itemTable->getTitleIndex("品质");
						int typeindex = itemTable->getTitleIndex("将卡类型");
						int shiliindex = itemTable->getTitleIndex("国家");
						for (std::vector<std::string>::iterator it = cardsVec.begin(); it != cardsVec.end();)
						{
							record.clear();
							if(itemTable->queryOneRecord(0,*it,record) >= 0)
							{
								cardshiliid = atoi(record[shiliindex].c_str());
								cardType = atoi(record[typeindex].c_str());
								if (cardshiliid == 2 || myshiliid == cardshiliid)
								{
									 ++it;
								}
								else
								{
									it = cardsVec.erase(it);
								}
							}else
							{
								it = cardsVec.erase(it);
							}
						}
				
						int jiangkaCount = cardsVec.size();
						int rnd;
						CRCore::rangei r(0,jiangkaCount);
						rnd = r.get_random();
						int cardId = atoi(cardsVec[rnd].c_str());
						log += cardsVec[rnd];
						//获得将卡
						ref_ptr<crBagItemData> newcard =new crBagItemData;
						newcard->setItemID(cardId);
						newcard->setItemCount(1);
						RewardItemVec rewardItems;
						rewardItems.push_back(newcard);
						m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
					}
					else
					{
						success = 2;
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				else
				{
					success = 3;
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				if (success == 1)
				{
					data->getParam(WCHDATA_JXJCardImpressionLevel,param);
					unsigned short level = *(unsigned short *)param;
					crTableIO::StrVec record;
					ref_ptr<crTableIO>impressionTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressionTab);
					if(impressionTab.valid() && impressionTab->queryOneRecord(0,crArgumentParser::appItoa(level+1),record)>=0)
					{
						level++;
						data->inputParam(WCHDATA_JXJCardImpressionLevel,&level);
					}
					

					stream->createBuf(3);
					stream->_writeUChar(success);
					stream->_writeUShort(level);
				}else
				{
					stream->createBuf(1);
					stream->_writeUChar(success);
				}
				
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseImpressionBuyCard,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
			///游戏日志
			GameLogData gamelog(Log_UseImpressionBuyCard,log);
			crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
		}
		else if(m_netType == GameClient_Game)
		{
			crData *data = m_this->getDataClass();
			unsigned char success = m_stream->_readUChar();
			if (success == 1)
			{
				//data->inputParam(WCHDATA_JXJCardImpression,0);
				unsigned short level = m_stream->_readUShort();
				data->inputParam(WCHDATA_JXJCardImpressionLevel,&level);
			}
			if (success == 2)
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2035,NULL));//好感度不足
			}
			if (success == 3)
			{
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));//背包已满
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIResetFubenCompleteCountMethod
//
/////////////////////////////////////////
crJXJUIResetFubenCompleteCountMethod::crJXJUIResetFubenCompleteCountMethod():
	m_index(0),
	m_font("simhei.ttf"),
	m_characterSize(16),
	m_goldColor(0.0f,1.0f,1.0f,1.0f),
	m_textColor(1.0f,1.0f,0.0f,1.0f)
{
}

crJXJUIResetFubenCompleteCountMethod::crJXJUIResetFubenCompleteCountMethod(const crJXJUIResetFubenCompleteCountMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_promptCanvas(handle.m_promptCanvas),
	m_information(handle.m_information),
	m_textColor(handle.m_textColor),
	m_goldColor(handle.m_goldColor),
	m_font(handle.m_font),
	m_characterSize(handle.m_characterSize),
	m_okbtn(handle.m_okbtn)
{
}

void crJXJUIResetFubenCompleteCountMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIResetFubenCompleteCountMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_promptCanvas = str;
		break;
	case 2:
		m_information = str;
		break;
	case 3:
		m_okbtn = str;
		break;
	case 4:
		m_font = str;
		break;
	case 5:
		m_characterSize = atoi(str.c_str());
		break;
	case 6:
		crArgumentParser::appAtoVec(str,m_textColor);
		m_textColor = m_textColor / 255.0f;
		break;
	case 7:
		crArgumentParser::appAtoVec(str,m_goldColor);
		m_goldColor = m_goldColor / 255.0f;
		break;
	}
}

void crJXJUIResetFubenCompleteCountMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
		if (canvas.valid())
		{
			std::string buildingname;
			crData *data = playerGameData->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int price = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJContriCountryOnceCopper,viplv).c_str()));
			data ->getParam(WCHDATA_JXJCoppercash,param);
			int mycopper = *(int *)param;
			data->getParam(WCHDATA_JXJGoldCostHintInt,param);
			unsigned int ifhint = *(unsigned int *)param & JXJGoldCostType_ResetFubenProgressHint;
			if (mycopper >= price)
			{
				ref_ptr<crHypertextWidgetNode> information = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_information));
				ref_ptr<crButtonWidgetNode> okbtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_okbtn));
				if (ifhint)
				{
					int hinttype = JXJGoldCostType_ResetFubenProgressHint;
					crData *braindata = crBrain::getInstance()->getDataClass();
					braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);
					std::vector<float>v_i;
					ItemMap itemMap;
					rcfg::ConfigScript cfg_script(&itemMap);
					cfg_script.Add("Hypertext");
					cfg_script.Push("Hypertext");
					//cfg_script.Add("Font",m_font);
					//cfg_script.Add("CharacterSize",m_characterSize);

					cfg_script.Add("Content");
					cfg_script.Push("Content",1);
					v_i.clear();
					v_i.push_back(255.0f);
					v_i.push_back(255.0f);
					v_i.push_back(255.0f);
					v_i.push_back(255.0f);
					cfg_script.Add("Color",v_i);
					cfg_script.Add("Text","您确认要花费");
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",2);
					v_i.clear();
					v_i.push_back(255.0f);
					v_i.push_back(255.0f);
					v_i.push_back(0.0f);
					v_i.push_back(255.0f);
					cfg_script.Add("Color",v_i);
					char tmpText[32];
					sprintf(tmpText,"%d礼金/元宝\0",price);
					cfg_script.Add("Text",tmpText);
					cfg_script.Pop();

					cfg_script.Add("Content");
					cfg_script.Push("Content",3);
					v_i.clear();
					v_i.push_back(255.0f);
					v_i.push_back(255.0f);
					v_i.push_back(255.0f);
					v_i.push_back(255.0f);
					cfg_script.Add("Color",v_i);
					cfg_script.Add("Text","重置进度吗？");
					cfg_script.Pop();

					cfg_script.Pop();

					if(information.valid())information->setHypertext(cfg_script);
				}
				if(okbtn.valid())okbtn->setEnable(true);
				crData *dlgData = canvas->getDataClass();
				int commandtype = CDP_Widget;
				dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
				dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
				if (ifhint)
				{
					crFilterRenderManager::getInstance()->doModal(canvas.get());
				}
				else
				{
					if(okbtn.valid())okbtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
				}
			}
			else
			{
				playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3032,NULL));
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJResetFubenCompleteCountMethod
//
/////////////////////////////////////////
crJXJResetFubenCompleteCountMethod::crJXJResetFubenCompleteCountMethod()
{}
crJXJResetFubenCompleteCountMethod::crJXJResetFubenCompleteCountMethod(const crJXJResetFubenCompleteCountMethod& handle):
	crMethod(handle)
{
}
void crJXJResetFubenCompleteCountMethod::inputParam(int i, void *param)
{
}
void crJXJResetFubenCompleteCountMethod::addParam(int i, const std::string& str)
{
}

void crJXJResetFubenCompleteCountMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		void *param;
		crData *data = playerGameData->getDataClass();
		if (data)
		{
			unsigned char needbagcount = 1;
			m_this->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
			if (needbagcount == 0)
			{
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				//unsigned short needimpression = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJNeedCardImpression,viplv).c_str());
				data->getParam(WCHDATA_JXJCardImpression,param);
				unsigned short cardimpression = *(unsigned short *)param;
				data->getParam(WCHDATA_JXJCardImpressionLevel,param);
				unsigned short level = *(unsigned short *)param;
				ref_ptr<crTableIO>impressionTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressionTab);
				int expIndex = impressionTab->getTitleIndex("exp");
				crTableIO::StrVec record;
				unsigned short needimpression;
				if(impressionTab->queryOneRecord(0,crArgumentParser::appItoa(level),record)>=0)
				{
					needimpression = atoi(record[expIndex].c_str());
				}

				
				if (cardimpression >= needimpression)
				{
					CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
					CRNetApp::crPlayerDataEventPacket packet;
					CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvUseImpressionBuyCard,NULL);
					net_conductor->getNetManager()->sendPacket("all",packet);
				}
				else
				{
					playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2035,NULL));//好感度不足
				}
			}
			else
			{
				playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));//背包已满
			}
		}
	}
}
///////////////////////////////////////////
////
////crJXJRecvResetFubenCompleteCountMethod
////
///////////////////////////////////////////
//crJXJRecvResetFubenCompleteCountMethod::crJXJRecvResetFubenCompleteCountMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvResetFubenCompleteCountMethod::crJXJRecvResetFubenCompleteCountMethod(const crJXJRecvResetFubenCompleteCountMethod& handle):
//	crMethod(handle),
//	m_tiptitle(handle.m_tiptitle),
//	m_tipcontent(handle.m_tipcontent),
//	m_tipcanvas(handle.m_tipcanvas)
//{
//}
//void crJXJRecvResetFubenCompleteCountMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvResetFubenCompleteCountMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_tipcanvas = str;
//		break;
//	case 1:
//		m_tiptitle = str;
//		break;
//	case 2:
//		m_tipcontent = str;
//		break;
//	}
//}
//
//void crJXJRecvResetFubenCompleteCountMethod::operator()(crHandle &handle)
//{
//	//////////////////////////////////
//	//返回
//	//0：失败
//	//1：成功
//	//2：好感度不足
//	//3：背包已满
//	//////////////////////////////////
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			unsigned char success = 0;
//			int playerid = m_this->getPlayerID();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				crVector2i giftbag;
//				unsigned char needbagcount = 1;
//				m_this->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
//				if (needbagcount == 0)
//				{
//					void *param;
//					crData *data = m_this->getDataClass();
//					data->getParam(WCHDATA_JXJVipLv,param);
//					unsigned char viplv = *(unsigned char *)param;
//					unsigned short needimpression = (unsigned short)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJNeedCardImpression,viplv).c_str()));
//					crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCardGiftBagID,viplv),giftbag);
//
//					data->excHandle(MAKECREPARAM(WCH_LockData,1));
//					data->getParam(WCHDATA_JXJCardImpression,param);
//					unsigned short *impression = (unsigned short *)param;
//					if(*impression >= needimpression)
//					{
//						success = 1;
//						*impression = 0;
//						ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
//						bagitemdata->setItemID(giftbag[0]);
//						bagitemdata->setItemCount((unsigned char)giftbag[1]);
//						m_this->doEvent(WCH_JXJPutItemInBag,MAKECREPARAM(bagitemdata.get(),NULL));
//					}
//					else
//					{
//						success = 2;
//					}
//					data->excHandle(MAKECREPARAM(WCH_LockData,0));
//				}
//				else
//				{
//					success = 3;
//				}
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				if (success == 1)
//				{
//					stream->createBuf(9);
//					stream->_writeUChar(success);
//					stream->_writeInt(giftbag[0]);
//					stream->_writeUChar((unsigned char)giftbag[1]);
//				}
//				else
//				{
//					stream->createBuf(1);
//					stream->_writeUChar(success);
//				}
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvUseImpressionBuyCard,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			unsigned char success = m_stream->_readUChar();
//			crData *data = m_this->getDataClass();
//			if (success == 1)
//			{
//				data->inputParam(WCHDATA_JXJCardImpression,0);
//				ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
//				bagitemdata->setItemID(m_stream->_readInt());
//				bagitemdata->setItemCount(m_stream->_readUChar());
//				m_this->doEvent(WCH_JXJPutItemInBag,MAKECREPARAM(bagitemdata.get(),NULL));
//			}
//			if (success == 2)
//			{
//				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2035,NULL));//好感度不足
//			}
//			if (success == 3)
//			{
//				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));//背包已满
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJCardShopOnShowMethod
////
///////////////////////////////////////////
//crJXJCardShopOnShowMethod::crJXJCardShopOnShowMethod()
//{
//}
//
//crJXJCardShopOnShowMethod::crJXJCardShopOnShowMethod(const crJXJCardShopOnShowMethod& handle):
//	crMethod(handle)
//{
//}
//
//void crJXJCardShopOnShowMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//
//void crJXJCardShopOnShowMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJCardShopOnShowMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && playerGameData)
//	{
//		//void *param;
//		//crTableIO::StrVec record;
//		//CRUI::ref_ptr<crCheckBoxWidgetNode> checkBox = NULL;
//		//int junlingindex = fubentab -> getTitleIndex("军令");
//		//int nameindex = fubentab -> getTitleIndex("name");
//		//ref_ptr<crCanvasNode>junlingtips = crFilterRenderManager::getInstance()->findCanvas(m_junlingtips);
//		//ref_ptr<crStaticTextWidgetNode> fubeninput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_fubeninput));
//		//ref_ptr<crRadioGroupWidgetNode> rushradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_rushradio));
//		//ref_ptr<crEditWidgetNode> rushcountedit = dynamic_cast<crEditWidgetNode *>(m_this->getWidget(m_rushcountedit));
//		//ref_ptr<crStaticTextWidgetNode> junlingcountinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_junlingcountinput));
//		//ref_ptr<crButtonWidgetNode> startbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_startrushbtn));
//
//	}
//}
///////////////////////////////////////////
////
////crJXJCardShopUpdateMethod
////
///////////////////////////////////////////
//crJXJCardShopUpdateMethod::crJXJCardShopUpdateMethod()
//{
//}
//
//crJXJCardShopUpdateMethod::crJXJCardShopUpdateMethod(const crJXJCardShopUpdateMethod& handle):
//	crMethod(handle),
//	m_typeradio(handle.m_typeradio),
//	m_colorradio(handle.m_colorradio),
//	m_cardpiecesinput(handle.m_cardpiecesinput),
//	m_pagenuminput(handle.m_pagenuminput)
//{
//	for (int i = 0; i < 8; i++)
//	{
//		m_priceinput[i] = handle.m_priceinput[i];
//		m_purchasebtn[i] = handle.m_purchasebtn[i];
//		m_cardicon[i] = handle.m_cardicon[i];
//	}
//}
//
//void crJXJCardShopUpdateMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//
//void crJXJCardShopUpdateMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_typeradio = str;
//		break;
//	case 1:
//		m_colorradio = str;
//		break;
//	case 2:
//		m_cardpiecesinput = str;
//		break;
//	case 3:
//		m_priceinput[i-3] = str;
//		break;
//	case 4:
//		m_priceinput[i-3] = str;
//		break;
//	case 5:
//		m_priceinput[i-3] = str;
//		break;
//	case 6:
//		m_priceinput[i-3] = str;
//		break;
//	case 7:
//		m_priceinput[i-3] = str;
//		break;
//	case 8:
//		m_priceinput[i-3] = str;
//		break;
//	case 9:
//		m_priceinput[i-3] = str;
//		break;
//	case 10:
//		m_priceinput[i-3] = str;
//		break;
//	case 11:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 12:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 13:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 14:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 15:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 16:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 17:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 18:
//		m_purchasebtn[i - 11] = str;
//		break;
//	case 19:
//		m_cardicon[i - 19] = str;
//		break;
//	case 20:
//		m_cardicon[i - 19] = str;
//		break;
//	case 21:
//		m_cardicon[i - 19] = str;
//		break;
//	case 22:
//		m_cardicon[i - 19] = str;
//		break;
//	case 23:
//		m_cardicon[i - 19] = str;
//		break;
//	case 24:
//		m_cardicon[i - 19] = str;
//		break;
//	case 25:
//		m_cardicon[i - 19] = str;
//		break;
//	case 26:
//		m_cardicon[i - 19] = str;
//		break;
//	case 27:
//		m_pagenuminput = str;
//		break;
//	default:
//		break;
//	}
//}
//
//void crJXJCardShopUpdateMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//	if(m_this && playerGameData && itemtab)
//	{
//		void *param;
//		crData *data = playerGameData->getDataClass();
//		data ->getParam(WCHDATA_JXJShiliID,param);
//		unsigned char shiliid = *(unsigned char *)param;
//		int typeindex = itemtab->getTitleIndex("类型");
//		int colorindex = itemtab->getTitleIndex("品质");
//		int iconindex = itemtab->getTitleIndex("icon");
//		int priceindex = itemtab->getTitleIndex("商店价格");
//		int shiliindex = itemtab->getTitleIndex("国家");
//		int onepagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCardShopPerPageNum).c_str()));
//		crData *canvasdata = m_this->getDataClass();
//		ref_ptr<crRadioGroupWidgetNode> typeradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_typeradio));
//		ref_ptr<crRadioGroupWidgetNode> colorradio = dynamic_cast<crRadioGroupWidgetNode *>(m_this->getWidget(m_colorradio));
//		ref_ptr<crStaticTextWidgetNode> cardpiecesinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_cardpiecesinput));
//		ref_ptr<crStaticTextWidgetNode> pagenuminput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pagenuminput));
//		ref_ptr<crImageBoxWidgetNode> cardicon[8] = {NULL};
//		ref_ptr<crStaticTextWidgetNode> priceinput[8] = {NULL};
//		ref_ptr<crButtonWidgetNode> perchagebtn[8] = {NULL};
//		for (int i = 0; i < 8; i++)
//		{
//			cardicon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_cardicon[i]));
//			priceinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_priceinput[i]));
//			perchagebtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_purchasebtn[i]));
//			if (cardicon[i])cardicon[i]->setVisiable(false);
//			if (priceinput[i])priceinput[i]->setVisiable(false);
//			if (perchagebtn[i])perchagebtn[i]->setVisiable(false);
//		}
//		if (canvasdata && typeradio && colorradio && typeindex >= 0 && colorindex >= 0 && iconindex >= 0 && priceindex >= 0)
//		{
//			crTableIO::DataVec cardrecords;
//			int jiangkatype = typeradio->getSelect();
//			int jiangkacolor = colorradio->getSelect();
//			canvasdata->getParam(WCHDATA_JXJCardShopCurPage,param);
//			int curpage = *(int *)param;
//			canvasdata->getParam(WCHDATA_JXJCardShopItemDeq,param);
//			ShopCardIDDeq *cardiddeq = (ShopCardIDDeq *)param;
//			cardiddeq->clear();
//			int row = -(curpage - 1) * onepagecount;
//			unsigned char cardshili = 0;
//			itemtab->queryRecords(typeindex,crArgumentParser::appItoa(jiangkatype),colorindex,crArgumentParser::appItoa(jiangkacolor),cardrecords);
//			if (!cardrecords.empty())
//			{
//				for (crTableIO::DataVec::iterator itr = cardrecords.begin();
//					itr != cardrecords.end() && row < onepagecount;
//					++itr)
//				{
//					cardshili = atoi((*itr)[shiliindex].c_str());
//					if (cardshili < c_startShiliID || shiliid == cardshili)
//					{
//						if (row >= 0)
//						{
//							cardiddeq->push_back(atoi((*itr)[0].c_str()));
//							if (cardicon[row])
//							{
//								cardicon[row]->setVisiable(true);
//								cardicon[row]->setImageName((*itr)[iconindex]);
//							}
//							if (priceinput[row])
//							{
//								priceinput[row]->setVisiable(true);
//								priceinput[row]->setString((*itr)[priceindex]);
//							}
//							if (perchagebtn[row])
//							{
//								perchagebtn[row]->setVisiable(true);
//							}
//						}
//						row++;
//					}
//				}
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJUIPurChaseCardMethod
////
///////////////////////////////////////////
//crJXJUIPurChaseCardMethod::crJXJUIPurChaseCardMethod():
//	m_index(0),
//	m_font("simhei.ttf"),
//	m_characterSize(16),
//	m_goldColor(0.0f,1.0f,1.0f,1.0f),
//	m_textColor(1.0f,1.0f,0.0f,1.0f)
//{
//}
//
//crJXJUIPurChaseCardMethod::crJXJUIPurChaseCardMethod(const crJXJUIPurChaseCardMethod& handle):
//	crMethod(handle),
//	m_index(handle.m_index),
//	m_promptCanvas(handle.m_promptCanvas),
//	m_information(handle.m_information),
//	m_textColor(handle.m_textColor),
//	m_goldColor(handle.m_goldColor),
//	m_font(handle.m_font),
//	m_characterSize(handle.m_characterSize),
//	m_okbtn(handle.m_okbtn)
//{
//}
//
//void crJXJUIPurChaseCardMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//
//void crJXJUIPurChaseCardMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_index = atoi(str.c_str());
//		break;
//	case 1:
//		m_promptCanvas = str;
//		break;
//	case 2:
//		m_information = str;
//		break;
//	case 3:
//		m_okbtn = str;
//		break;
//	case 4:
//		m_font = str;
//		break;
//	case 5:
//		m_characterSize = atoi(str.c_str());
//		break;
//	case 6:
//		crArgumentParser::appAtoVec(str,m_textColor);
//		m_textColor = m_textColor / 255.0f;
//		break;
//	case 7:
//		crArgumentParser::appAtoVec(str,m_goldColor);
//		m_goldColor = m_goldColor / 255.0f;
//		break;
//	}
//}
//
//void crJXJUIPurChaseCardMethod::operator()(crHandle &handle)
//{
//	void *param;
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	if(m_this && playerGameData)
//	{
//		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
//		if (canvas)
//		{
//			std::string buildingname;
//			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//			crData *data = playerGameData->getDataClass();
//			int cardid = 0;
//			int price = 0;
//			crData *canvasdata = m_this->getParentCanvas()->getDataClass();
//			if (canvasdata)
//			{
//				canvasdata->getParam(WCHDATA_JXJCardShopItemDeq,param);
//				ShopCardIDDeq *cardiddeq = (ShopCardIDDeq *)param;
//				if (m_index < cardiddeq->size())
//				{
//					cardid  = (*cardiddeq)[m_index];
//				}
//			}
//			if (cardid > 0)
//			{
//				unsigned char needbagcount = 1;
//				m_this->doEvent(WCH_JXJCheckJiangkaBagEmpty,MAKECREPARAM(&needbagcount,NULL));
//				if (needbagcount == 0)
//				{
//					crTableIO::StrVec record;
//					if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),record) >= 0 )
//					{
//						int priceindex = itemtab->getTitleIndex("商店价格");
//						if (priceindex > 0)
//						{
//							price = atoi(record[priceindex].c_str());
//							data->getParam(WCHDATA_JXJCardPieces,param);
//							int cardimpression = *(int *)param;
//							if (cardimpression >= price)
//							{
//								canvasdata->inputParam(WCHDATA_JXJPurchaseCardID,&cardid);
//								ref_ptr<crHypertextWidgetNode> information = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_information));
//								ref_ptr<crButtonWidgetNode> okbtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_okbtn));
//								std::vector<float>v_i;
//								ItemMap itemMap;
//								rcfg::ConfigScript cfg_script(&itemMap);
//								cfg_script.Add("Hypertext");
//								cfg_script.Push("Hypertext");
//								//cfg_script.Add("Font",m_font);
//								//cfg_script.Add("CharacterSize",m_characterSize);
//
//								cfg_script.Add("Content");
//								cfg_script.Push("Content",1);
//								v_i.clear();
//								v_i.push_back(255.0f);
//								v_i.push_back(255.0f);
//								v_i.push_back(255.0f);
//								v_i.push_back(255.0f);
//								cfg_script.Add("Color",v_i);
//								cfg_script.Add("Text","您确认要花费");
//								cfg_script.Pop();
//
//								cfg_script.Add("Content");
//								cfg_script.Push("Content",2);
//								v_i.clear();
//								v_i.push_back(255.0f);
//								v_i.push_back(255.0f);
//								v_i.push_back(0.0f);
//								v_i.push_back(255.0f);
//								cfg_script.Add("Color",v_i);
//								char tmpText[32];
//								sprintf(tmpText,"%d将魂\0",price);
//								cfg_script.Add("Text",tmpText);
//								cfg_script.Pop();
//
//								cfg_script.Add("Content");
//								cfg_script.Push("Content",3);
//								v_i.clear();
//								v_i.push_back(255.0f);
//								v_i.push_back(255.0f);
//								v_i.push_back(255.0f);
//								v_i.push_back(255.0f);
//								cfg_script.Add("Color",v_i);
//								cfg_script.Add("Text","购买吗？");
//								cfg_script.Pop();
//
//								cfg_script.Pop();
//
//								if(information)information->setHypertext(cfg_script);
//								if(okbtn)okbtn->setEnable(true);
//								crData *dlgData = canvas->getDataClass();
//								dlgData->inputParam(WCHDATA_CommandDlgWidget,m_this);
//								crFilterRenderManager::getInstance()->doModal(canvas);
//							}
//							else
//							{
//								playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3032,NULL));
//							}
//						}
//					}
//				}
//				else
//				{
//					playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(3034,NULL));
//				}
//			}
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJPurChaseCardMethod
////
///////////////////////////////////////////
//crJXJPurChaseCardMethod::crJXJPurChaseCardMethod()
//{}
//crJXJPurChaseCardMethod::crJXJPurChaseCardMethod(const crJXJPurChaseCardMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJPurChaseCardMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crWidgetNode*)param;
//		break;
//	}
//}
//void crJXJPurChaseCardMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJPurChaseCardMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	crData *data = playerGameData->getDataClass();
//	if(playerGameData)
//	{
//		void *param;
//		crData *canvasdata = m_this->getParentCanvas()->getDataClass();
//		if (canvasdata)
//		{
//			canvasdata->getParam(WCHDATA_JXJPurchaseCardID,param);
//			int cardid = *(int *)param;
//
//			ref_ptr<crStreamBuf> stream = new crStreamBuf;
//			stream->createBuf(4);
//			stream->_writeInt(cardid);
//			CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
//			CRNetApp::crPlayerDataEventPacket packet;
//			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPurChaseCard,stream.get());
//			net_conductor->getNetManager()->sendPacket("all",packet);
//		}
//	}
//}
///////////////////////////////////////////
////
////crJXJRecvPurChaseCardMethod
////
///////////////////////////////////////////
//crJXJRecvPurChaseCardMethod::crJXJRecvPurChaseCardMethod():
//	m_netType(GameClient_Game){}
//crJXJRecvPurChaseCardMethod::crJXJRecvPurChaseCardMethod(const crJXJRecvPurChaseCardMethod& handle):
//	crMethod(handle)
//{
//}
//void crJXJRecvPurChaseCardMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//			m_stream = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crPlayerGameData*)param;
//		break;
//	case 2:
//		if(param)
//		{
//			CREPARAM& param64 = *(CREPARAM*)param;
//			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
//			m_netType = HICREPARAM(param64);
//		}
//		else
//		{
//			m_stream = NULL;
//		}
//		break;
//	}
//}
//
//void crJXJRecvPurChaseCardMethod::addParam(int i, const std::string& str)
//{
//}
//
//void crJXJRecvPurChaseCardMethod::operator()(crHandle &handle)
//{
//	//////////////////////////////////
//	//返回
//	//0：失败
//	//1：成功
//	//2：将魂不足
//	//3：背包已满
//	//////////////////////////////////
//	if(m_this && m_stream.valid())
//	{
//		if(m_netType == GameServer)
//		{
//			unsigned char success = 0;
//			int cardid = m_stream->_readInt();
//			int playerid = m_this->getPlayerID();
//			crData *data = m_this->getDataClass();
//			//返回信息
//			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
//			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
//			if(playerData.valid())
//			{
//				void *param;
//				crVector2i giftbag;
//				unsigned char needbagcount = 1;
//				int price = 0;
//				data->getParam(WCHDATA_JXJCardPieces,param);
//				int *cardpieces = (int *)param;
//				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//				m_this->doEvent(WCH_JXJCheckJiangkaBagEmpty,MAKECREPARAM(&needbagcount,NULL));
//				if (needbagcount == 0)
//				{
//					crTableIO::StrVec record;
//					if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),record) >= 0 )
//					{
//						int priceindex = itemtab->getTitleIndex("商店价格");
//						if (priceindex > 0)
//						{
//							price = atoi(record[priceindex].c_str());
//							data->excHandle(MAKECREPARAM(WCH_LockData,1));
//							if(*cardpieces >= price)
//							{
//								success = 1;
//								*cardpieces -= price;
//								ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
//								bagitemdata->setItemID(cardid);
//								bagitemdata->setItemCount(1);
//								m_this->doEvent(WCH_JXJPutItemInBag,MAKECREPARAM(bagitemdata.get(),NULL));
//							}
//							else
//							{
//								success = 2;
//							}
//							data->excHandle(MAKECREPARAM(WCH_LockData,0));
//						}
//
//					}
//				}
//				else
//				{
//					success = 3;
//				}
//				ref_ptr<crStreamBuf> stream = new crStreamBuf;
//				if (success == 1)
//				{
//					stream->createBuf(9);
//					stream->_writeUChar(success);
//					stream->_writeInt(cardid);
//					stream->_writeInt(*cardpieces);
//				}
//				else
//				{
//					stream->createBuf(5);
//					stream->_writeUChar(success);
//					stream->_writeInt(*cardpieces);
//				}
//				crPlayerDataEventPacket packet;
//				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPurChaseCard,stream.get());
//				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
//			}
//		}
//		else if(m_netType == GameClient_Game)
//		{
//			unsigned char success = m_stream->_readUChar();
//			int cardpiece = m_stream->_readInt();
//			crData *data = m_this->getDataClass();
//			data->inputParam(WCHDATA_JXJCardPieces,&cardpiece);
//			if (success == 1)
//			{
//				ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
//				bagitemdata->setItemID(m_stream->_readInt());
//				bagitemdata->setItemCount(1);
//				m_this->doEvent(WCH_JXJPutItemInBag,MAKECREPARAM(bagitemdata.get(),NULL));
//			}
//			if (success == 2)
//			{
//				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2035,NULL));//将魂不足
//			}
//			if (success == 3)
//			{
//				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));//背包已满
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIRollCardsMethod
//
/////////////////////////////////////////
crJXJUIRollCardsMethod::crJXJUIRollCardsMethod():
	m_this(NULL),
	m_namecolor(crVector4f(100.0f,190.0f,12.0f,255.0f)),
	m_index(0)
{}
crJXJUIRollCardsMethod::crJXJUIRollCardsMethod(const crJXJUIRollCardsMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_namecolor(handle.m_namecolor),
	m_index(handle.m_index),
	m_this(NULL)
{
}
void crJXJUIRollCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIRollCardsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_namecolor);
		break;
	case 5:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJUIRollCardsMethod::operator()(crHandle &handle)
{
	bool cancelTask = false;
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
	if (msgCanvas.valid() && m_this && playerGameData)
	{
		ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
		ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
		ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		crData *data = playerGameData->getDataClass();
		if (canvas.valid() && data)
		{
			void *param;
			crVector2i coppercost;
			crVector2i goldcost;
			crVector2i batchcost;
			crVector3i supercost;
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCopperRefreshVector2i,viplv).c_str(),coppercost);
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGoldRefreshVector2i,viplv).c_str(),goldcost);
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGoldBatchRefreshVector2i,viplv).c_str(),batchcost);
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSuperRollCard,viplv).c_str(),supercost);
			int batchcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBatchRollCardCount,viplv).c_str());
			int needbagcount = 1;
			if (m_index == RefreshCardType_GoldBatch)
			{
				needbagcount = batchcount * needbagcount;
			}
			playerGameData -> doEvent(WCH_JXJCheckJiangkaBagEmpty,MAKECREPARAM(&needbagcount,NULL));
			if (needbagcount == 0)
			{
				int needmoney = 0;
				if (m_index == RefreshCardType_Free)
				{
					needmoney = coppercost[0];
					data->getParam(WCHDATA_JXJRollCardFreeCount,param);
					unsigned short freecount = *(unsigned short *)param;
					if(freecount < 100)
					{
						cancelTask = true;
						playerGameData -> doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2079,NULL));  
					}
				}
				else
				{
					cancelTask = true;
					if (m_index == RefreshCardType_Gold)
					{
						needmoney = goldcost[0];
					}
					else if (m_index == RefreshCardType_GoldBatch)
					{
						needmoney = batchcost[0] * batchcount;
					}
					else if (m_index == RefreshCardType_Super)
					{
						needmoney = supercost[0];
					}
					int checkmoney = needmoney;
					playerGameData->doEvent(WCH_JXJCheckLijinGold,MAKECREPARAM(&checkmoney,NULL));
					if (checkmoney == 0)
					{
						data->getParam(WCHDATA_JXJGoldCostHintInt,param);
						unsigned int ifhint = *(unsigned int *)param;
						int hinttype = 0;
						if (m_index == RefreshCardType_Gold)
						{
							hinttype = JXJGoldCostType_GoldRollCardHint;
							ifhint &= JXJGoldCostType_GoldRollCardHint;
						}
						else if(m_index == RefreshCardType_GoldBatch)
						{
							hinttype = JXJGoldCostType_GoldBatchCardHint;
							ifhint &= JXJGoldCostType_GoldBatchCardHint;
						}
						else if(m_index == RefreshCardType_Super)
						{
							hinttype = JXJGoldCostType_GoldBatchCardHint;
							ifhint &= JXJGoldCostType_GoldBatchCardHint;
						}
						if(okBtn.valid())okBtn->setEnable(true);
						if (ifhint)
						{
							crData *braindata = crBrain::getInstance()->getDataClass();
							braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);
							std::vector<float>v_i;
							ItemMap itemMap;
							rcfg::ConfigScript cfg_script(&itemMap);
							int ncontent = 1;
							cfg_script.Add("Hypertext");
							cfg_script.Push("Hypertext");
							cfg_script.Add("Content");
							cfg_script.Push("Content",ncontent++);
							cfg_script.Add("Text","您确认要花费");
							cfg_script.Pop();

							char tmpText[160]/*,tmpText2[80]*/;
							if(m_index!=RefreshCardType_Free)
							{
								cfg_script.Add("Content");
								cfg_script.Push("Content",ncontent++);
								v_i.clear();
								v_i.push_back(m_namecolor[0]);
								v_i.push_back(m_namecolor[1]);
								v_i.push_back(m_namecolor[2]);
								v_i.push_back(m_namecolor[3]);
								cfg_script.Add("Color",v_i);
								/*if (m_index == RefreshCardType_Free)
								{
								sprintf(tmpText,"[%d铜钱]\0",needmoney);
								}
								else */if(m_index == RefreshCardType_Gold)
								{
									sprintf(tmpText,"[%d礼金/元宝]\0",needmoney);
								}
								else if(m_index == RefreshCardType_GoldBatch)
								{
									sprintf(tmpText,"[%d(礼金/元宝)/次]\0",batchcost[0]);
								}
								else if(m_index == RefreshCardType_Super)
								{
									sprintf(tmpText,"[%d礼金/元宝]\0",needmoney);
								}
								cfg_script.Add("Text",tmpText);
								cfg_script.Pop();
							}

							cfg_script.Add("Content");
							cfg_script.Push("Content",ncontent++);
							if (m_index == RefreshCardType_GoldBatch)
							{
								cfg_script.Add("Text","批量刷新将卡吗？");
							}
							else
							{
								cfg_script.Add("Text","刷新将卡吗？");
							}
							cfg_script.Pop();

							if(m_index == RefreshCardType_Super)
							{
								cfg_script.Add("Content");
								cfg_script.Push("Content",ncontent++);
								if (m_index == RefreshCardType_Super)
								{
									cfg_script.Add("Text","/n额外获得");
								}
								cfg_script.Pop();

								ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
								int nameindex = itemtab->getTitleIndex("name");
								int colorindex = itemtab->getTitleIndex("品质");
								crTableIO::StrVec itemrecord;
								if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(supercost[2]),itemrecord)>=0)
								{
									crVector4f colormode;
									crTableIO::StrVec colorrecord;
									ref_ptr<crTableIO> qualitytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJQualityTab);
									int qualityindex = qualitytab->getTitleIndex("color");
									if(qualitytab->queryOneRecord(0,itemrecord[colorindex],colorrecord) >= 0 )
									{
										crArgumentParser::appAtoVec(colorrecord[qualityindex],colormode);
									}
									cfg_script.Add("Content");
									cfg_script.Push("Content",ncontent++);
									v_i.clear();
									v_i.push_back(colormode[0]);
									v_i.push_back(colormode[1]);
									v_i.push_back(colormode[2]);
									v_i.push_back(colormode[3]);
									cfg_script.Add("Color",v_i);
									sprintf(tmpText,"[%s]*1\0",itemrecord[nameindex].c_str());
									cfg_script.Add("Text",tmpText);
									cfg_script.Pop();
								}
							}
							cfg_script.Pop();
							if(msg.valid())msg->setHypertext(cfg_script);
						}

						if (msgCanvas.valid())
						{
							crData *dlgData = msgCanvas->getDataClass();
							int commandtype = CDP_Widget;
							dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
							dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
							if (ifhint)
							{
								crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
							}
							else
							{
								if(okBtn.valid())okBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
							}
						}
					}
					else
					{
						playerGameData -> doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2036,NULL));//元宝不足
					}
				}
			}
			else
			{
				cancelTask = true;
				playerGameData -> doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2034,NULL));
				//std::string str = "将卡背包已满，请先整理将卡背包！";
			}
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJRollCardsMethod
//
/////////////////////////////////////////
crJXJRollCardsMethod::crJXJRollCardsMethod():
	m_index(0)
{}
crJXJRollCardsMethod::crJXJRollCardsMethod(const crJXJRollCardsMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_progresscanvas(handle.m_progresscanvas)
{
}
void crJXJRollCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJRollCardsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_progresscanvas = str;
		break;
	}
}

void crJXJRollCardsMethod::operator()(crHandle &handle)
{
	crData *braindata = crBrain::getInstance()->getDataClass();
	void *param;
	unsigned char index = m_index;
	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	ref_ptr<crCanvasNode>progresscanvas = dynamic_cast<crCanvasNode*>(crFilterRenderManager::getInstance()->findCanvas(m_progresscanvas));
	playerData->getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	int batchcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBatchRollCardCount,viplv).c_str());
	CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if (playerData && net_conductor)
	{
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid() && braindata && progresscanvas.valid())
		{
			CRCore::ref_ptr<CRCore::crStreamBuf> stream;
			CRNetApp::crPlayerDataEventPacket packet;
			if (m_index == RefreshCardType_GoldBatch)
			{
				braindata -> inputParam(WCHDATA_JXJRollCardRemainCount,&batchcount);
				crFilterRenderManager::getInstance()->doModal(progresscanvas.get());//crFilterRenderManager::getInstance()->showCanvas(progresscanvas,true);
				//index = RefreshCardType_GoldBatch;
			}
			else
			{
				braindata -> inputParam(WCHDATA_JXJRollCardRemainCount,0);
			}
			stream = new CRCore::crStreamBuf;
			stream->createBuf(1);
			stream->_writeUChar(index);
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvRollCards,stream.get());
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvRollCardsMethod
//
/////////////////////////////////////////
crJXJRecvRollCardsMethod::crJXJRecvRollCardsMethod():
	m_netType(GameClient_Game){}
crJXJRecvRollCardsMethod::crJXJRecvRollCardsMethod(const crJXJRecvRollCardsMethod& handle):
	crMethod(handle),
	m_jiusicanvas(handle.m_jiusicanvas),
	m_cardswitch(handle.m_cardswitch),
	m_promptinput(handle.m_promptinput),
	m_tipcanvas(handle.m_tipcanvas),
	m_tiptitle(handle.m_tiptitle),
	m_tipcontent(handle.m_tipcontent),
	m_page1(handle.m_page1),
	m_progresscanvas(handle.m_progresscanvas),
	m_purplecanvas(handle.m_purplecanvas),
	m_orangecanvas(handle.m_orangecanvas),
	m_baojicanvas(handle.m_baojicanvas),
	m_baojisw(handle.m_baojisw)
{
	m_rollcardBtn[0] = handle.m_rollcardBtn[0];
	m_rollcardBtn[1] = handle.m_rollcardBtn[1];
	m_rollcardBtn[2] = handle.m_rollcardBtn[2];
}
void crJXJRecvRollCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvRollCardsMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_jiusicanvas = str;
		break;
	case 1:
		m_cardswitch = str;
		break;
	case 2:
		m_promptinput = str;
		break;
	case 3:
		m_tipcanvas = str;
		break;
	case 4:
		m_tiptitle = str;
		break;
	case 5:
		m_tipcontent = str;
		break;
	case 6:
		m_page1 = str;
		break;
	case 7:
		m_progresscanvas = str;
		break;
	case 8:
		m_purplecanvas = str;
		break;
	case 9:
		m_orangecanvas = str;
		break;
	case 10:
		m_baojicanvas = str;
		break;
	case 11:
		m_baojisw = str;
		break;
	case 12:
	case 13:
	case 14:
		m_rollcardBtn[i-12] = str;
		break;
	}
}

void crJXJRecvRollCardsMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			bool success = false;
			bool cardsuccess = false;
			int playerid = m_this->getPlayerID();
			int cardid = 0;
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid())
			{
				crData *data = m_this->getDataClass();
				data->getParam(WCHDATA_JXJVipLv,param);
				unsigned char viplv = *(unsigned char *)param;
				unsigned char select = m_stream->_readUChar();
				//返回信息
				int needmoney = 0;
				int impressionadd = 0;
				unsigned char cardcost = 0;
				unsigned char cardshiliid = 0;
				unsigned char critindex = 0; 
				std::vector<int> impressionrnd;
				crTableIO::StrVec record;
				//ref_ptr<crTableIO>LuckyCardCostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLuckyCardCostTab);
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				unsigned short maximpression = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJNeedCardImpression,viplv).c_str());
				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCardImpressionCritTimesVec,viplv).c_str(),impressionrnd);

				data->excHandle(MAKECREPARAM(WCH_LockData,1));
				ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				ref_ptr<crTableIO>jiusitab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJJiushiTab);
				crTableIO::DataVec jiangkaRec;
				crTableIO::StrVec prorecord,autosellrecord;
				int rollindex;
				int color = 0;
				int attrid = itemTable->getTitleIndex("类型");
				int colorindex = itemTable->getTitleIndex("品质");
				int typeindex = itemTable->getTitleIndex("将卡类型");
				int shiliindex = itemTable->getTitleIndex("国家");
				int priceindex = itemTable->getTitleIndex("回收价格");
				if (select == RefreshCardType_Free)
				{
					rollindex = jiusitab->getTitleIndex("大厅");
				}
				else if(select == RefreshCardType_Super)
				{
					rollindex = jiusitab->getTitleIndex("至尊");
				}
				else
				{
					rollindex = jiusitab->getTitleIndex("雅间");
				}
				data->getParam(WCHDATA_JXJShiliID,param);
				unsigned char myshiliid = *(unsigned char *)param;
				data->getParam(WCHDATA_JXJLuckyCard,param);
				int *luckycard = (int *)param;
				int j = 0;
				int cardcount = 0;
				for (j = 0; j < 3; j++)
				{
					if(*(luckycard + j) != 0)
					{
						cardcount++;
					}
				}
				if (cardcount > 0)
				{
					m_this->doEvent(WCH_JXJSeverPickLuckyCard,MAKECREPARAM(&cardid,NULL));
				}
				data->getParam(WCHDATA_JXJJiusilv,param);
				if(jiusitab->queryOneRecord(0,crArgumentParser::appItoa(*(unsigned char*)param),prorecord) >= 0 )
				{
					//随机抽取
					//std::vector<int> pickcardAdd;
					//pickcardAdd.resize(5);
					//for (int i = 0; i < 5; i++)
					//{
					//	pickcardAdd[i] = 0;
					//}
					////data->getParam(WCHDATA_JXJFreeRollCardTechLv,param);
					////unsigned char freerollcardtechlv = *(unsigned char *)param;
					////if (select == RefreshCardType_Free && freerollcardtechlv > 0)
					////{
					////	crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFreeRollCardTechPro,viplv).c_str(),pickcardAdd);
					////}

					std::vector<int> pickcardRnd;
					int rndmax = 0;
					crArgumentParser::appAtoVec(prorecord[rollindex],pickcardRnd);
					for( std::vector<int>::iterator itr = pickcardRnd.begin();
						itr != pickcardRnd.end();
						++itr )
					{
						rndmax += *itr;
					}
					CRCore::rangei rr(1,rndmax);
					for (int i = JiangkaType_ji;i<=JiangkaType_zheng;i++)
					{
						//for (int ii = 0; ii<5; ii++)
						//{
						//	pickcardRnd[ii] = 0;
						//	//获取将卡的属性，
						//	//获取该属性的概率
						//	switch (ii)
						//	{
						//	case 0:
						//		if (colorwhite >=0)
						//		{
						//			pickcardRnd[ii] = atoi(prorecord[colorwhite].c_str()) + pickcardAdd[ii];
						//		}
						//		break;
						//	case 1:
						//		if (colorgreen >=0)
						//		{
						//			pickcardRnd[ii] = atoi(prorecord[colorgreen].c_str()) + pickcardAdd[ii];
						//		}
						//		break;
						//	case 2:
						//		if (colorblue >=0)
						//		{
						//			pickcardRnd[ii] = atoi(prorecord[colorblue].c_str()) + pickcardAdd[ii];
						//		}
						//		break;
						//	case 3:
						//		if (colorpurple >=0)
						//		{
						//			pickcardRnd[ii] = atoi(prorecord[colorpurple].c_str()) + pickcardAdd[ii];
						//		}
						//		break;
						//	case 4:
						//		if (colororange >=0)
						//		{
						//			pickcardRnd[ii] = atoi(prorecord[colororange].c_str()) + pickcardAdd[ii];
						//		}
						//		break;
						//	default:
						//		break;
						//	}
						//	rndmax += pickcardRnd[ii];
						//}
						int _rr = rr.get_random();
						int cardi = 0;
						for (cardi = 0; cardi<5; cardi++)
						{
							if(_rr<=pickcardRnd[cardi])
								break;
							_rr -= pickcardRnd[cardi];
						}
						color = cardi;
						if (color <= CardColor_Orange)
						{
							jiangkaRec.clear();
							itemTable->queryRecords(attrid,crArgumentParser::appItoa(IT_Jiangka),colorindex,crArgumentParser::appItoa(color),typeindex,crArgumentParser::appItoa(i),jiangkaRec);
							///////////////////////////////////////删除非本势力将卡
							if (shiliindex > 0)
							{
								for (crTableIO::DataVec::iterator ditr = jiangkaRec.begin();
									ditr != jiangkaRec.end();)
								{
									cardshiliid = atoi((*ditr)[shiliindex].c_str());
									if (cardshiliid == 2 || myshiliid == cardshiliid)
									{
										ditr++;
									}
									else
									{
										ditr = jiangkaRec.erase(ditr);
									}
								}
							}
							/////////////////////////////////////////////////////////////////
							int jiangkaCount = jiangkaRec.size();
							int rnd;
							CRCore::rangei r(0,jiangkaCount);
							rnd = r.get_random();
							*(luckycard+i) = atoi(jiangkaRec[rnd][0].c_str());
							cardsuccess = true;
						}
					}
				}
				else
				{
					cardsuccess = false;
				}
				bool needdeductgold = false;
				if (cardsuccess)
				{
					if(playerData.valid())
					{
						unsigned short *freecount;
						if (select == RefreshCardType_Free)
						{
							crVector2i coppercost;
							crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCopperRefreshVector2i,viplv).c_str(),coppercost);
							impressionadd = coppercost[1];
							data->getParam(WCHDATA_JXJRollCardFreeCount,param);
							freecount = (unsigned short *)param;
							if (*freecount >= 100)
							{
								*freecount -= 100;
								success = true;
								//mymoney = *freecount;
							}
						}
						else if (select == RefreshCardType_Gold)
						{
							crVector2i goldcost;
							crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGoldRefreshVector2i,viplv).c_str(),goldcost);
							needmoney = goldcost[0];
							impressionadd = goldcost[1];
							MoneyChangeData moneydata(needmoney,"元宝抽将卡");
							m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
							if (0 == moneydata.first)
							{
								success = true;
							}
						}
						else if (select == RefreshCardType_GoldBatch)
						{
							crVector2i batchcost;
							crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGoldBatchRefreshVector2i,viplv).c_str(),batchcost);
							needmoney = batchcost[0];
							impressionadd = batchcost[1];
							MoneyChangeData moneydata(needmoney,"自动抽将卡");
							m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
							if (0 == moneydata.first)
							{
								success = true;
							}
						}
						else if(select == RefreshCardType_Super)
						{
							crVector3i cost;
							crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSuperRollCard,viplv).c_str(),cost);
							needmoney = cost[0];
							impressionadd = cost[1];
							MoneyChangeData moneydata(needmoney,"至尊抽将卡");
							m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
							if (0 == moneydata.first)
							{
								success = true;
								//获得道具
								if(cost[2]>0)
								{
									ref_ptr<crBagItemData> newItem =new crBagItemData;
									newItem->setItemID(cost[2]);
									newItem->setItemCount(1);
									RewardItemVec rewardItems;
									rewardItems.push_back(newItem);
									m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
								}
							}
						}
						//data->getParam(WCHDATA_JXJCardImpression,param);
						//unsigned short *cardimpression = (unsigned short *)param;
						//*cardimpression += impressionadd;
						//if(*cardimpression > maximpression)
						//{
						//	*cardimpression = maximpression;
						//}
						//for( int i = 0; i<5; ++i )
						ref_ptr<crStreamBuf> stream = new crStreamBuf;

						int buffsize = 4;
						if (select == RefreshCardType_Free)
						{
							buffsize += 2;
						}
						if (success)
						{
							buffsize += 17;
							if (cardid > 0)
							{
								//是否自动出售将卡
								data->getParam(WCHDATA_JXJAutoSellCard,param);
								unsigned short autosellcard = *(unsigned short *)param;
								if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),autosellrecord) >= 0 )
								{
									if (select == RefreshCardType_Free)
									{//免费抽才有暴击;
										critindex = getImpressionCrit();
										impressionadd *= impressionrnd[critindex];
									}
									
									m_this->doEvent(WCH_JXJChangePlayerData,MAKECREPARAM(&impressionadd,T_CardImpression));
									bool ifsell = autosellcard & (1 << atoi(autosellrecord[colorindex].c_str()));
									if(ifsell)
									{
										//出售将卡
										int jianghunadd = atoi(autosellrecord[priceindex].c_str());
										m_this->doEvent(WCH_JXJChangePlayerData,MAKECREPARAM(&jianghunadd,T_JiangHun));
									}
									else
									{
										//获得将卡
										ref_ptr<crBagItemData> newcard =new crBagItemData;
										newcard->setItemID(cardid);
										newcard->setItemCount(1);
										RewardItemVec rewardItems;
										rewardItems.push_back(newcard);
										m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
									}
								}
							}
						}
						stream->createBuf(buffsize);
						//stream->_writeUChar(success);
						stream->_writeBool(success);
						stream->_writeUChar(select);
						stream->_writeUChar(cardcost);
						if (select == RefreshCardType_Free)
						{
							stream->_writeUShort(*freecount);
						}
						if (success)
						{
							stream->_writeUChar(critindex);
							for( int i = 0; i<3; ++i )
							{
								stream->_writeInt(*(luckycard+i));
							}
							stream->_writeInt(cardid);
						//	stream->_writeUShort(*cardimpression);
						}

						crPlayerDataEventPacket packet;
						crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvRollCards,stream.get());
						gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					}
				}
				data->excHandle(MAKECREPARAM(WCH_LockData,0));
				if (needdeductgold)
				{
					crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
					callback->savePlayerData(playerData.get());
				}
				///游戏日志
				if(success)
				{
					//增加活跃度/////////////////////////////////
					m_this->doEvent(WCH_JXJRecvHuoyuedu, MAKECREPARAM(HYD_RollCard, 1));
					///////////////////////////////////////////////
					std::string logdata = "前三个ID是酒肆刷出的将卡，最后一个ID是获得的将卡ID（0为未获得）："+crArgumentParser::appItoa(*(luckycard+0)) + "|" + crArgumentParser::appItoa(*(luckycard+1)) + "|" + crArgumentParser::appItoa(*(luckycard+2)) + "|" + crArgumentParser::appItoa(cardid);
					GameLogData gamelog(Log_RollCards,logdata);
					crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			bool success = m_stream->_readBool();
			unsigned char select = m_stream->_readUChar();
			unsigned char cardcost = m_stream->_readUChar();

			ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			crTableIO::StrVec record;
			int colorindex = itemTable->getTitleIndex("品质");
			void*param;
			crData *data = m_this->getDataClass();
			if (data)
			{
				if (select == 0)
				{
					unsigned short freecount = m_stream->_readUShort();
					data->inputParam(WCHDATA_JXJRollCardFreeCount,&freecount);
				}
				ref_ptr<crCanvasNode>jiusi = crFilterRenderManager::getInstance()->findCanvas(m_jiusicanvas);
				ref_ptr<crCanvasNode>progresscanvas = crFilterRenderManager::getInstance()->findCanvas(m_progresscanvas);
				if (success)
				{
					unsigned char critindex = m_stream->_readUChar();
					if (critindex > 0)
					{
						ref_ptr<crCanvasNode>baojicanvas = crFilterRenderManager::getInstance()->findCanvas(m_baojicanvas);
						if (baojicanvas.valid())
						{
							crMultiSwitch *baojisw = dynamic_cast<crMultiSwitch *>(baojicanvas->getChildNode(m_baojisw));
							if (baojisw)
							{
								baojisw->setActiveSwitchSet(critindex - 1);
								crFilterRenderManager::getInstance()->showCanvas(baojicanvas.get(),true);
							}
						}
					}
					unsigned char ifgoodcard = 0;
					data->getParam(WCHDATA_JXJLuckyCard,param);
					int *luckycard = (int *)param;
					for( int i = 0; i<3; i++)
					{
						*(luckycard+i) = m_stream->_readInt();
						if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(*(luckycard+i)),record) >= 0 )
						{
							if (atoi(record[colorindex].c_str()) == CardColor_Purple)
							{
								ifgoodcard = 1;
							}
							else if (atoi(record[colorindex].c_str()) == CardColor_Orange)
							{
								ifgoodcard = 2;
							}
						}

					}

					int cardid = m_stream->_readInt();
				//	int impression = m_stream->_readUShort();
				//	data->inputParam(WCHDATA_JXJCardImpression,&impression);
					//if (jiusi)
					//{
					//	jiusi->doEvent(WCH_JXJShowluckyCards);
					//}
					crData *braindata = crBrain::getInstance()->getDataClass();
					if (braindata)
					{
						braindata->excHandle(MAKECREPARAM(WCH_LockData,1));
						braindata->getParam(WCHDATA_JXJRollCardRemainCount,param);
						unsigned char *remaincount = (unsigned char *)param;
						braindata->getParam(WCHDATA_JXJNewguideRollCardCount,param);
						int *rollcardcount = (int *)param;
						(*rollcardcount) += 1;
						//if (*remaincount > 0)
						//{
						//	*remaincount -= 1;
						//}
						if (ifgoodcard != 0)
						{
							*remaincount = 0;
						}
						if (*remaincount > 0)
						{
							//CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
							//CRNetApp::crPlayerDataEventPacket packet;
							//ref_ptr<crStreamBuf> stream = new CRCore::crStreamBuf;
							//stream->createBuf(1);
							//stream->_writeUChar(RefreshCardType_Gold);
							//CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvRollCards,stream.get());
							//net_conductor->getNetManager()->sendPacket("all",packet);
						}
						else
						{
							if (progresscanvas.valid())
							{
								crFilterRenderManager::getInstance()->showCanvas(progresscanvas.get(),false);
							}
						}
						if(ifgoodcard>0)
						{
							if (ifgoodcard == 1)
							{
								ref_ptr<crCanvasNode>purplecanvas = crFilterRenderManager::getInstance()->findCanvas(m_purplecanvas);
								if(purplecanvas.valid())crFilterRenderManager::getInstance()->showCanvas(purplecanvas.get(),true);
							}
							else if (ifgoodcard == 2)
							{
								ref_ptr<crCanvasNode>orangecanvas = crFilterRenderManager::getInstance()->findCanvas(m_orangecanvas);
								if(orangecanvas.valid())crFilterRenderManager::getInstance()->showCanvas(orangecanvas.get(),true);
							}
							ref_ptr<crButtonWidgetNode> rollcardBtn0 = dynamic_cast<crButtonWidgetNode *>(jiusi->getWidget(m_rollcardBtn[0]));
							ref_ptr<crButtonWidgetNode> rollcardBtn1 = dynamic_cast<crButtonWidgetNode *>(jiusi->getWidget(m_rollcardBtn[1]));
							ref_ptr<crButtonWidgetNode> rollcardBtn2 = dynamic_cast<crButtonWidgetNode *>(jiusi->getWidget(m_rollcardBtn[2]));
							if(rollcardBtn0.valid())
							{
								rollcardBtn0->swapEnable(1.0f);
							}
							if(rollcardBtn1.valid())
							{
								rollcardBtn1->swapEnable(1.0f);
							}
							if(rollcardBtn2.valid())
							{
								rollcardBtn2->swapEnable(1.0f);
							}
						}
						braindata->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
				}
				else
				{
					crData *braindata = crBrain::getInstance()->getDataClass();
					if (braindata)
					{
						braindata->inputParam(WCHDATA_JXJRollCardRemainCount,NULL);
					}
				}
			}
		}
	}
}
unsigned char crJXJRecvRollCardsMethod::getImpressionCrit()
{
	void *param;
	std::vector<int> impressionpro;
	crData *data = m_this->getDataClass();
	data->getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	data->getParam(WCHDATA_JXJTechJiusibaojiLv, param);
	unsigned char techbaoji = *(unsigned char *)param;
	unsigned char CardImpressionCritTechLv[4];
	for(int i = 0; i < 4; i++)
	{
		data->getParam(WCHDATA_JXJCardImpression2CritTechLv+i,param);
		CardImpressionCritTechLv[i] = *(unsigned char *)param;
	}
	if (techbaoji > 0)
	{
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJTechCardImpressionCritProVec, viplv).c_str(), impressionpro);
	}
	else
	{
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCardImpressionCritProVec, viplv).c_str(), impressionpro);
	}
	int rndmax = 0;
	for (int ii = 0; ii<impressionpro.size(); ii++)
	{
		rndmax += impressionpro[ii];
	}
	CRCore::rangei rr(0,rndmax);
	int _rr = rr.get_random();
	unsigned char crittime = 0;
	for (crittime = 0; crittime<impressionpro.size(); crittime++)
	{
		if(_rr<=impressionpro[crittime])
			break;
		_rr -= impressionpro[crittime];
	}
	if (crittime > 0)
	{
		if (CardImpressionCritTechLv[crittime - 1] <= 0)
		{
			crittime = 0;
		}
	}
	return crittime;//1,2,4,6,10
}
/////////////////////////////////////////
//
//crJXJUIPickCardsMethod
//
/////////////////////////////////////////
crJXJUIPickCardsMethod::crJXJUIPickCardsMethod():
	m_this(NULL),
	m_namecolor(crVector4f(100.0f,190.0f,12.0f,255.0f)),
	m_index(0)
{}
crJXJUIPickCardsMethod::crJXJUIPickCardsMethod(const crJXJUIPickCardsMethod& handle):
	crMethod(handle),
	m_msgbox(handle.m_msgbox),
	m_title(handle.m_title),
	m_msg(handle.m_msg),
	m_ok(handle.m_ok),
	m_namecolor(handle.m_namecolor),
	m_index(handle.m_index),
	m_this(NULL)
{
}
void crJXJUIPickCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIPickCardsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_msgbox = str;
		break;
	case 1:
		m_title = str;
		break;
	case 2:
		m_msg = str;
		break;
	case 3:
		m_ok = str;
		break;
	case 4:
		crArgumentParser::appAtoVec(str,m_namecolor);
		break;
	case 5:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJUIPickCardsMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	ref_ptr<crCanvasNode>msgCanvas = crFilterRenderManager::getInstance()->findCanvas(m_msgbox);
	if (msgCanvas.valid() && m_index<3 && playerGameData)
	{
		ref_ptr<crStaticTextWidgetNode> title = dynamic_cast<crStaticTextWidgetNode *>(msgCanvas->getWidget(m_title));
		ref_ptr<crHypertextWidgetNode> msg = dynamic_cast<crHypertextWidgetNode *>(msgCanvas->getWidget(m_msg));
		ref_ptr<crButtonWidgetNode> okBtn = dynamic_cast<crButtonWidgetNode *>(msgCanvas->getWidget(m_ok));
		ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
		if (canvas.valid())
		{
			crData *data = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
			if (data)
			{
				void *param;
				int needbagcount = 1;
				playerGameData -> doEvent(WCH_JXJCheckJiangkaBagEmpty,MAKECREPARAM(&needbagcount,NULL));
				if (needbagcount == 0)
				{
					data->getParam(WCHDATA_JXJVipLv,param);
					unsigned char viplv = *(unsigned char *)param;
					std::vector<int> pickpriceVec;
					crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPickCardPrice,viplv),pickpriceVec);
					data->getParam(WCHDATA_JXJLuckyCard,param);
					int *luckycard = (int *)param;
					int cardid = *(luckycard + m_index);
					if(cardid>0)
					{
						ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
						int colorindex = itemtab->getTitleIndex("品质");
						crTableIO::StrVec itemrecord;
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),itemrecord)>=0)
						{
							int quality = atoi(itemrecord[colorindex].c_str());
							if(quality<pickpriceVec.size())
							{
								int needgold = pickpriceVec[quality];
								int checkneedgold = 0;
								checkneedgold = needgold;
								playerGameData->doEvent(WCH_JXJCheckLijinGold,MAKECREPARAM(&checkneedgold,NULL));
								if(checkneedgold == 0)
								{
									data->getParam(WCHDATA_JXJGoldCostHintInt,param);
									unsigned int ifhint = *(unsigned int *)param & JXJGoldCostType_GoldPickCardHint;
									if(okBtn.valid())okBtn->setEnable(true);
									if (ifhint)
									{
										int hinttype = JXJGoldCostType_GoldPickCardHint;
										crData *braindata = crBrain::getInstance()->getDataClass();
										braindata->inputParam(WCHDATA_JXJCurGoldHintType,&hinttype);
										std::vector<float>v_i;
										ItemMap itemMap;
										rcfg::ConfigScript cfg_script(&itemMap);
										cfg_script.Add("Hypertext");
										cfg_script.Push("Hypertext");
										cfg_script.Add("Content");
										cfg_script.Push("Content");
										cfg_script.Add("Text","您确认要花费");
										cfg_script.Pop();

										cfg_script.Add("Content");
										cfg_script.Push("Content",2);
										v_i.clear();
										v_i.push_back(/*m_namecolor[0]*/140.0);
										v_i.push_back(/*m_namecolor[1]*/40.0);
										v_i.push_back(/*m_namecolor[2]*/40.0);
										v_i.push_back(/*m_namecolor[3]*/255.0);
										cfg_script.Add("Color",v_i);
										char tmpText[160]/*,tmpText2[80]*/;
										sprintf(tmpText,"【%d礼金/元宝】\0",needgold);
										cfg_script.Add("Text",tmpText);
										cfg_script.Pop();

										cfg_script.Add("Content");
										cfg_script.Push("Content",3);
										cfg_script.Add("Text","征辟将卡吗？");
										cfg_script.Pop();

										cfg_script.Pop();
										if(msg.valid())msg->setHypertext(cfg_script);
									}

									if (msgCanvas.valid())
									{
										crData *dlgData = msgCanvas->getDataClass();
										int commandtype = CDP_Widget;
										dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
										dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
										if (ifhint)
										{
											crFilterRenderManager::getInstance()->doModal(msgCanvas.get());
										}
										else
										{
											if(okBtn.valid())okBtn->doEvent(MAKEINT32(crGUIEventAdapter::LEFT_MOUSE_BUTTON,crGUIEventAdapter::RELEASE));
										}
									}
								}
								else
								{
									playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2036,NULL));//元宝不足
								}
							}
						}
					}
				}
				else
				{
					playerGameData -> doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2034,NULL));
					//std::string str = "将卡背包已满，请先整理将卡背包！";
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPickCardsMethod
//
/////////////////////////////////////////
crJXJPickCardsMethod::crJXJPickCardsMethod():
	m_index(0)
{}
crJXJPickCardsMethod::crJXJPickCardsMethod(const crJXJPickCardsMethod& handle):
	crMethod(handle),
	m_index(handle.m_index)
{
}
void crJXJPickCardsMethod::inputParam(int i, void *param)
{
}
void crJXJPickCardsMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	}
}
void crJXJPickCardsMethod::operator()(crHandle &handle)
{
	unsigned char index = m_index;
	crData *playerData = crMyPlayerData::getInstance()->getPlayerGameData()->getDataClass();
	if (playerData)
	{
		void *param;
		playerData->excHandle(MAKECREPARAM(WCH_LockData,1));
		unsigned char success = 0;
		if (m_index>=0 && m_index<=2)
		{
			int cardid = 0;
			playerData->getParam(WCHDATA_JXJLuckyCard,param);
			int *luckycard = (int *)param;
			if (index < 3)
			{
				cardid = *(luckycard + index);//知天命
			}
			if (cardid > 0)
			{
				CRCore::ref_ptr<CRCore::crStreamBuf> stream = new CRCore::crStreamBuf;
				stream->createBuf(4);
				stream->_writeInt(cardid);
				CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
				CRNetApp::crPlayerDataEventPacket packet;
				CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPickCards,stream.get());
				net_conductor->getNetManager()->sendPacket("all",packet);
			}
		}
		playerData->excHandle(MAKECREPARAM(WCH_LockData,0));
	}
}
/////////////////////////////////////////
//
//crJXJRecvRollCardsMethod
//
/////////////////////////////////////////
crJXJRecvPickCardsMethod::crJXJRecvPickCardsMethod():
	m_netType(GameClient_Game){}
crJXJRecvPickCardsMethod::crJXJRecvPickCardsMethod(const crJXJRecvPickCardsMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvPickCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPickCardsMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvPickCardsMethod::operator()(crHandle &handle)
{
	//////////////////////
	//0失败
	//1成功
	//2背包不足
	//3元宝不足
	///////////////////////
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			unsigned char success = 0;
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			if (data)
			{
				int selcardid = 0;
				selcardid = m_stream->_readInt();
				//返回信息
				int needmoney = 0;
				int mymoney = 0;
				//unsigned char cardcost = 0;
				//unsigned char *goldcost = 0;
				crTableIO::StrVec record;
				crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
				ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));

				if(playerData.valid())
				{
					bool needdeductgold = false;
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					data->getParam(WCHDATA_JXJLuckyCard,param);
					int *luckycard = (int *)param;
					m_this->doEvent(WCH_JXJSeverPickLuckyCard,MAKECREPARAM(&selcardid,NULL));
					if (selcardid>0)
					{
						int needgold = 0;
						int needbagcount = 1;
						m_this -> doEvent(WCH_JXJCheckJiangkaBagEmpty,MAKECREPARAM(&needbagcount,NULL));
						if (needbagcount == 0)
						{
							data->getParam(WCHDATA_JXJVipLv,param);
							unsigned char viplv = *(unsigned char *)param;
							std::vector<int> pickpriceVec;
							crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPickCardPrice,viplv),pickpriceVec);
							ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
							int colorindex = itemtab->getTitleIndex("品质");
							crTableIO::StrVec itemrecord;
							if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(selcardid),itemrecord)>=0)
							{
								int quality = atoi(itemrecord[colorindex].c_str());
								if(quality<pickpriceVec.size())
								{
									needgold = pickpriceVec[quality];

									MoneyChangeData moneydata(needgold,"征辟将卡ID" + crArgumentParser::appItoa(selcardid));
									m_this->doEvent(WCH_JXJDeductLijinGold,MAKECREPARAM(&moneydata,&needdeductgold));
									if (moneydata.first == 0)
									{
										for (int i = 0; i <3;i++)
										{
											if(*(luckycard + i) == selcardid)
											{
												*(luckycard + i) = 0;
												break;
											}
										}
										success = 1;
										ref_ptr<crBagItemData> newcard =new crBagItemData;
										newcard->setItemID(selcardid);
										newcard->setItemCount(1);
										RewardItemVec rewardItems;
										rewardItems.push_back(newcard);
										m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
									}
								}
								else
								{
									success = 3;
								}
							}
						}
						else
						{
							success = 2;//背包已满
						}
					}

					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					if (success == 1)
					{
						stream->createBuf(6);
						stream->_writeUChar(success);
						stream->_writeInt(selcardid);
						//stream->_writeUChar(*goldcost);
					}
					else
					{
						stream->createBuf(1);
						stream->_writeUChar(success);
					}
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPickCards,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
					if (needdeductgold)
					{
						crGameServerCallback *callback = dynamic_cast<crGameServerCallback *>(gameServer->getNetDataManager()->getNetCallback());
						callback->savePlayerData(playerData.get());
					}
					if(success == 1)
					{
						///游戏日志
						std::string logdata = crArgumentParser::appItoa(selcardid);
						GameLogData gamelog(Log_PickCards,logdata);
						crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
					}
				}
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			unsigned char success = m_stream->_readUChar();
			crData *data = m_this->getDataClass();
			int strindex = 0;
			if (data)
			{
				unsigned char index = 0;
				if (success == 1)
				{
					data->excHandle(MAKECREPARAM(WCH_LockData,1));
					int cardid = m_stream->_readInt();
					//unsigned char goldcost = m_stream->_readUChar();
					if (cardid > 0)
					{
						//data->inputParam(WCHDATA_JXJLuckyCardGoldCost,&goldcost);
						//ref_ptr<crBagItemData> newcard = new crBagItemData;
						//newcard->setItemID(cardid);
						//newcard->setItemCount(1);
						//RewardItemVec rewardItems;
						//rewardItems.push_back(newcard);
						//m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));

						data->getParam(WCHDATA_JXJLuckyCard,param);
						int *luckycard = (int *)param;
						for (int i = 0; i <3;i++)
						{
							if(*(luckycard + i) == cardid)
							{
								*(luckycard + i) = 0;
								break;
							}
						}
					}
					data->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
				else if (success == 2)
				{
					strindex = 2034;
				}
				else if (success == 3)
				{
					strindex = 2036;
				}

				if(success!=1)
				{
					m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(strindex,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJServerPickCardsMethod
//
/////////////////////////////////////////
crJXJServerPickCardsMethod::crJXJServerPickCardsMethod():
	m_itemid(0)
{
}
crJXJServerPickCardsMethod::crJXJServerPickCardsMethod(const crJXJServerPickCardsMethod& handle):
	crMethod(handle),
	m_itemid(handle.m_itemid)
{
}
void crJXJServerPickCardsMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_itemid = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_itemid = (int *)(LOCREPARAM(param64));
		}
		else
		{
			m_itemid = NULL;
		}
		break;
	}
}

void crJXJServerPickCardsMethod::addParam(int i, const std::string& str)
{
}

void crJXJServerPickCardsMethod::operator()(crHandle &handle)
{
	if(m_this)
	{
		void *param;
		crData *data = m_this->getDataClass();
		if (data)
		{
			bool canpick = false;
			int index = *m_itemid;
			int cardcount = 0;
			//技、谋、政卡概率
			crVector3i pro;
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJLuckyCardprobability,viplv).c_str(),pro);
			int jipro = (int)pro[0];
			int cepro = (int)pro[1];
			int zhengpro = (int)pro[2];
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJLuckyCard,param);
			int *luckycard = (int *)param;

			int cardid = 0;
			if (index == 0)
			{
				for (int i = 0; i < 3; i++)
				{
					if (*(luckycard + i) > 0)
					{
						cardcount++;
						cardid = *(luckycard + i);
					}
				}
				if (cardcount >= 2)
				{
					canpick = true;
				}
				if (canpick)
				{
					cardid = 0;
					//随机抽取
					std::vector<int> pickcardRnd;
					pickcardRnd.resize(3);
					int rndmax = 0;
					for (int i = 0; i<3; i++)
					{
						//获取将卡的属性，
						//获取该属性的概率
						switch (i)
						{
						case 0:
							pickcardRnd[i] = jipro;
							break;
						case 1:
							pickcardRnd[i] = cepro;
							break;
						case 2:
							pickcardRnd[i] = zhengpro;
							break;
						default:
							break;
						}
						rndmax += pickcardRnd[i];
					}
					CRCore::rangei rr(0,rndmax);
					int cardi = 0;
					int _rr = 0;
					while (cardid == 0)
					{
						_rr = rr.get_random();
						for (cardi = 0; cardi<3; cardi++)
						{
							if(_rr<pickcardRnd[cardi])
								break;
							_rr -= pickcardRnd[cardi];
						}
						if(cardi<3)
						{
							cardid = *(luckycard + cardi);
						}
					}
				}
			}
			else
			{
				for (int i = 0;i<3;i++)
				{
					if(index == *(luckycard + i))
					{
						cardid = index;
						break;
					}
				}
			}
			*m_itemid = 0;
			if (cardid>0)
			{
				ref_ptr<crTableIO>itemTable = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				crTableIO::StrVec record;
				if (itemTable.valid())
				{
					int typeindex = itemTable->getTitleIndex("类型");
					if(typeindex > 0)
					{
						if(itemTable->queryOneRecord(0,crArgumentParser::appItoa(cardid),record) >= 0 )
						{
							if (atoi(record[typeindex].c_str()) == IT_Jiangka)
							{
								*m_itemid = cardid;
							}
						}
					}
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIJiushiUpdateMethod
//
/////////////////////////////////////////
crJXJUIJiushiUpdateMethod::crJXJUIJiushiUpdateMethod():
	m_this(NULL)
{}
crJXJUIJiushiUpdateMethod::crJXJUIJiushiUpdateMethod(const crJXJUIJiushiUpdateMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_impressionprogress(handle.m_impressionprogress),
	m_impressioninput(handle.m_impressioninput),
	m_getgift(handle.m_getgift),
	m_coppercard(handle.m_coppercard),
	m_goldcard(handle.m_goldcard),
	m_getcards(handle.m_getcards),
	m_vipinfosw(handle.m_vipinfosw),
	m_freecountinput(handle.m_freecountinput),
	m_cardshopbtn(handle.m_cardshopbtn)
{
	for(int i = 0; i < 3; i++)
	{
		m_pickcards[i] = handle.m_pickcards[i];
	}
}
void crJXJUIJiushiUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJUIJiushiUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_impressionprogress = str;
		break;
	case 1:
		m_impressioninput = str;
		break;
	case 2:
		m_getgift = str;
		break;
	case 3:
		m_coppercard = str;
		break;
	case 4:
		m_goldcard = str;
		break;
	case 5:
		m_getcards = str;
		break;
	case 6:
		m_pickcards[0] = str;
		break;
	case 7:
		m_pickcards[1] = str;
		break;
	case 8:
		m_pickcards[2] = str;
		break;
	case 9:
		m_vipinfosw = str;
		break;
	case 10:
		m_freecountinput = str;
		break;
	case 11:
		m_cardshopbtn = str;
		break;
	case 12:
		m_cardSwitch = str;
		break;
	case 13:
		m_colorSwitch = str;
		break;
	case 14:
		m_cardDonghua = str;
		break;
	case 15 :
		m_blueDonghua = str;
		break;
	case 16:
		m_purpleDonghua = str;
		break;
	case 17:
		m_orangeDonghua = str;
		break;
	case 18:
		m_switch = str;
		break;
	}
}

void crJXJUIJiushiUpdateMethod::operator()(crHandle &handle)
{
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && myPlayer)
	{
		void *param;
		crVector3i pickcardopenlv;
		crData *data = myPlayer->getDataClass();
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		unsigned char FreeRollCardTechLv[3];
		data -> getParam(WCHDATA_JXJFreeRollCardTechLv,param);
		FreeRollCardTechLv[0] = *(unsigned char *)param;
		data -> getParam(WCHDATA_JXJFreeRollCard2TechLv,param);
		FreeRollCardTechLv[1] = *(unsigned char *)param;
		data -> getParam(WCHDATA_JXJFreeRollCard3TechLv,param);
		FreeRollCardTechLv[2] = *(unsigned char *)param;
		
		int maxfreecount = 0;
		int curtech = -1;
		for (int i = 0; i < 3; i++)
		{
			if (FreeRollCardTechLv[i] > 0)
			{
				curtech = i;
			}
		}
		crVector3i techmaxvec;
		if (curtech >= 0)
		{
			crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFreeRollCardTechMaxcount,viplv).c_str(),techmaxvec);
			maxfreecount = techmaxvec[curtech];
		}
		else
		{
			maxfreecount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRollCardFreeCountMax,viplv).c_str());
		}
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPickCardOpenViplv,0).c_str(),pickcardopenlv);
		ref_ptr<crProgressWidgetNode> impressionprogress = dynamic_cast<crProgressWidgetNode *>(m_this->getChildNode(m_impressionprogress));
		ref_ptr<crStaticTextWidgetNode> impressioninput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_impressioninput));
		ref_ptr<crButtonWidgetNode> getgift = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_getgift));
		ref_ptr<crButtonWidgetNode> coppercard = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_coppercard));
		ref_ptr<crButtonWidgetNode> goldcard = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_goldcard));
		ref_ptr<crButtonWidgetNode> getcards = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_getcards));
		ref_ptr<crButtonWidgetNode> cardshopbtn = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_cardshopbtn));
		crMultiSwitch *vipinfosw = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_vipinfosw));
		ref_ptr<crStaticTextWidgetNode> freecountinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_freecountinput));
		ref_ptr<crMultiSwitch> cardSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_cardSwitch));
		ref_ptr<crMultiSwitch> colorSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_colorSwitch));
		ref_ptr<crMultiSwitch> multiSwitch = dynamic_cast<crMultiSwitch *>(m_this->getChildNode(m_switch));
		ref_ptr<crSequence>cardDonghua = dynamic_cast<crSequence *>(m_this->getChildNode(m_cardDonghua));
		ref_ptr<crSequence>blueDonghua = dynamic_cast<crSequence *>(m_this->getChildNode(m_blueDonghua));
		ref_ptr<crSequence>purpleDonghua = dynamic_cast<crSequence *>(m_this->getChildNode(m_purpleDonghua));
		ref_ptr<crSequence>orangeDonghua = dynamic_cast<crSequence *>(m_this->getChildNode(m_orangeDonghua));

		ref_ptr<crTableIO>impressionTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressionTab);
		data ->getParam(WCHDATA_JXJCardImpression,param);
		unsigned short cardimpression = *(unsigned short *)param;
		data ->getParam(WCHDATA_JXJRollCardFreeCount,param);
		unsigned short freecount = *(unsigned short *)param;
		data ->getParam(WCHDATA_JXJCardShopOpenTechLv,param);
		unsigned char CardShopOpenTechLv = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJCardImpressionLevel,param);
		unsigned short level = *(unsigned short *)param;
		int color;
		int expIndex = impressionTab->getTitleIndex("exp");
		int colorIndex = impressionTab->getTitleIndex("color");
		crTableIO::StrVec record;
		//unsigned short needimpression = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJNeedCardImpression,viplv).c_str());
		unsigned short needimpression;
		if(impressionTab->queryOneRecord(0,crArgumentParser::appItoa(level),record)>=0)
		{
			needimpression = atoi(record[expIndex].c_str());
			color = atoi(record[colorIndex].c_str());
		}
		if (cardimpression > needimpression)
		{
			cardimpression = needimpression;
		}
		if (freecountinput.valid())
		{
			freecountinput->setString(crArgumentParser::appItoa(freecount/100) + "/" + crArgumentParser::appItoa(maxfreecount));
		}
		if (vipinfosw)
		{
			vipinfosw->setActiveSwitchSet(0);
		}
		if (impressionprogress.valid())
		{
			impressionprogress->setProgress((float)cardimpression/(float)needimpression);
		}
		if (impressioninput.valid())
		{
			impressioninput->setString(crArgumentParser::appItoa(cardimpression) + "/" + crArgumentParser::appItoa(needimpression));
		}
		ref_ptr<crButtonWidgetNode> pickcard[3] = {NULL};
		for (int i = 0; i < 3; i++)
		{
			pickcard[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_pickcards[i]));
			if (pickcard[i].valid())
			{
				if (viplv >= pickcardopenlv[i])
				{
					pickcard[i]->setVisiable(true);
					vipinfosw->setActiveSwitchSet(1);
				}
				else
				{
					pickcard[i]->setVisiable(false);
				}
			}
		}
		//data->getParam(WCHDATA_JXJLuckyCard,param);
		//int *luckycard = (int *)param;
		if (cardshopbtn.valid())
		{
			if (CardShopOpenTechLv > 0)
			{
				cardshopbtn->setEnable(true);
			}
			else
			{
				cardshopbtn->setEnable(false);
			}
		}
		if (cardSwitch.valid() && colorSwitch.valid() && cardDonghua.valid())
		{
			if (cardimpression>=needimpression)
			{
				cardSwitch->setActiveSwitchSet(1);
				cardDonghua->stopEffect();
				colorSwitch->setActiveSwitchSet(color-CardColor_Blue);
				if (blueDonghua.valid() && purpleDonghua.valid() && orangeDonghua.valid())
				{
					switch(color)
					{
					case CardColor_Blue:
						blueDonghua->startEffect();
						purpleDonghua->stopEffect();
						orangeDonghua->stopEffect();
						break;
					case CardColor_Purple:
						purpleDonghua->startEffect();
						blueDonghua->stopEffect();
						orangeDonghua->stopEffect();
						break;
					case CardColor_Orange:
						orangeDonghua->startEffect();
						blueDonghua->stopEffect();
						purpleDonghua->stopEffect();
						break;
					}
				}
			}else
			{
				cardSwitch->setActiveSwitchSet(0);
				cardDonghua->startEffect();
				if (multiSwitch.valid())
				{
					multiSwitch->setActiveSwitchSet(color-CardColor_Blue);
				}
			}
		}
		m_this->doEvent(WCH_JXJShowluckyCards);
	}
}
/////////////////////////////////////////
//
//crJXJCheckJiangkaBagEmptyMethod
//
/////////////////////////////////////////
crJXJCheckJiangkaBagEmptyMethod::crJXJCheckJiangkaBagEmptyMethod():
	m_this(NULL),
	m_count(0)
{
}
crJXJCheckJiangkaBagEmptyMethod::crJXJCheckJiangkaBagEmptyMethod(const crJXJCheckJiangkaBagEmptyMethod& handle):
	crMethod(handle),
	m_count(handle.m_count)
{
}
void crJXJCheckJiangkaBagEmptyMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_count = (int *)LOCREPARAM(param64);
		}
		else
		{
			m_count = 0;
		}
		break;
	}
}
void crJXJCheckJiangkaBagEmptyMethod::addParam(int i, const std::string& str)
{
}
void crJXJCheckJiangkaBagEmptyMethod::operator()(crHandle &handle)
{	
	//返回0代表格子足够
	if (*m_count > 0)
	{
		void *param;
		crData *data = m_this->getDataClass();
		data->getParam(WCHDATA_JXJJiangkaBagVec,param);
		JXJItemBagVec *itembagvec = (JXJItemBagVec *)param;
		if (*m_count <= itembagvec->size())
		{
			for(JXJItemBagVec::iterator itr = itembagvec->begin();
				itr!=itembagvec->end();
				++itr)
			{
				if (!itr->get())
				{
					(*m_count)--;
					if (*m_count == 0)
					{
						break;
					}
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJUIJiusiTipInfoMethod
//
/////////////////////////////////////////
crJXJUIJiusiTipInfoMethod::crJXJUIJiusiTipInfoMethod():
	m_ea(NULL),
	m_this(NULL),
	m_index(0)
{
}
crJXJUIJiusiTipInfoMethod::crJXJUIJiusiTipInfoMethod(const crJXJUIJiusiTipInfoMethod& handle):
	crMethod(handle),
	m_tips(handle.m_tips),
	m_name(handle.m_name),
	m_info1(handle.m_info1),
	m_sw(handle.m_sw),
	m_ea(NULL),
	m_this(NULL),
	m_kejiindex(0)
{
}
void crJXJUIJiusiTipInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_ea = NULL;
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_ea = (CRProducer::crGUIEventAdapter*)(LOCREPARAM(param64));
		}
		else
		{
			m_ea = NULL;
		}
		break;
	}
}
void crJXJUIJiusiTipInfoMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_tips = str;
		break;
	case 1:
		m_name = str;
		break;
	case 2:
		m_info1 = str;
		break;
	case 3:
		m_sw = str;
		break;
	case 4:
		m_index = atoi(str.c_str());
		break;
	case 5:
		m_kejiindex = atoi(str.c_str());
		break;
	}
}
void crJXJUIJiusiTipInfoMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>tipsCanvas = crFilterRenderManager::getInstance()->findCanvas(m_tips);
	crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(tipsCanvas.valid() && playerData)
	{
		void *param;
		crData *data = playerData->getDataClass();
		//ref_ptr<crTableIO>LuckyCardCostTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJLuckyCardCostTab);
		crTableIO::StrVec precord;
		//int goldindex = LuckyCardCostTab->getTitleIndex("征辟元宝");
		int needgold = 0;
		int checkneedgold = 0;
		int producefactor = 100;
		unsigned char techlv;
		crVector4i producevec;
		//data->getParam(WCHDATA_JXJLuckyCardGoldCost,param);
		//unsigned char goldneed = *(unsigned char *)param;
		data->getParam(WCHDATA_JXJVipLv,param);
		unsigned char viplv = *(unsigned char *)param;
		data -> getParam(WCHDATA_JXJFreeRollCardTechLv,param);
		unsigned char FreeRollCardTechLv = *(unsigned char *)param;
		crVector2i coppercost,goldcost,refinecost,smeltcost,batchcost;
		crVector3i supercost;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJCopperRefreshVector2i,viplv).c_str(),coppercost);
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGoldRefreshVector2i,viplv).c_str(),goldcost);
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGoldBatchRefreshVector2i,viplv).c_str(),batchcost);
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRefineEquipPriceVec2i,viplv).c_str(),refinecost);
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSmeltPriceVec2i,viplv).c_str(),smeltcost);
		int batchcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBatchRollCardCount,viplv).c_str());
		int onehourcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRefineEquipFreeCountProduce,viplv).c_str());
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRefineFreeCountProduceTech,viplv).c_str(),producevec);
		for (int i = 0; i < 4; ++i)
		{
			data -> getParam(WCHDATA_JXJAddRefineFreeProduce1TechLv + i,param);
			techlv = *(unsigned char *)param;
			if (techlv > 0)
			{
				if (producevec[i] > producefactor)
				{
					producefactor = producevec[i];
				}
			}
		}
		onehourcount = onehourcount * ( 100 + producefactor ) / 100;
		float produce = 0.0f;
		producefactor = 0;
		crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFreeRollCardProduceTech,viplv).c_str(),producevec);
		//if ( FreeRollCardTechLv > 0)
		//{
		//	produce = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJFreeRollCardTechProduce,viplv).c_str());
		//}
		//else
		//{
		produce = atof(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRollCardFreeCountProduce,viplv).c_str());
		for (int i = 0; i < 4; ++i)
		{
			data -> getParam(WCHDATA_JXJFreeRollCardProduce1TechLv + i,param);
			techlv = *(unsigned char *)param;
			if (techlv > 0)
			{
				if (producevec[i] > producefactor)
				{
					producefactor = producevec[i];
				}
			}
		}
		produce = produce * ( 100 + producefactor ) / 100;
		//}

		std::vector<float>v_i;
		ItemMap itemMap;
		rcfg::ConfigScript cfg_script(&itemMap);

		cfg_script.Add("Hypertext");
		cfg_script.Push("Hypertext");

		cfg_script.Add("Content");
		cfg_script.Push("Content", 1);
		v_i.clear();
		v_i.push_back(0.0f);
		v_i.push_back(0.0f);
		v_i.push_back(0.0f);
		v_i.push_back(255.0f);
		cfg_script.Add("Color", v_i);

		ref_ptr<crStaticTextWidgetNode> name = NULL;
		ref_ptr<crHypertextWidgetNode>  tipsText = NULL;
		if (m_tips == "UI_Tips_Jiusi_1")
		{
			tipsText = dynamic_cast<crHypertextWidgetNode *>(tipsCanvas->getWidget(m_name));
		}
		else
		{
			name = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_name));
		}
		//ref_ptr<crStaticTextWidgetNode> name = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_name));
		ref_ptr<crStaticTextWidgetNode> info1 = dynamic_cast<crStaticTextWidgetNode *>(tipsCanvas->getWidget(m_info1));
		crMultiSwitch *sw = dynamic_cast<crMultiSwitch *>(tipsCanvas->getWidget(m_sw));
		std::string str1,str2,str3,str4,str5;
		ref_ptr<crTableIO>textTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJCodeTextTab);
		crTableIO::StrVec record;
		std::string tipstr;
		int str2index = 0;
		int techid = 0;
		std::string needresourcestr[4];
		if (m_index == 16)
		{
			crTableIO::StrVec record;
			ref_ptr<crTableIO>techtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJTechlvTab);
			int copperindex = techtab->getTitleIndex("铜钱");
			int foodindex = techtab->getTitleIndex("粮食");
			int woodindex = techtab->getTitleIndex("木材");
			int ironindex = techtab->getTitleIndex("铁矿");
			ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
			if (canvas.valid())
			{
				crData *canvasdata = canvas->getDataClass();
				canvasdata->getParam(WCHDATA_JXJShowTechVec,param);
				ShowTechVec *techvec = (ShowTechVec *)param;
				if (m_kejiindex < techvec->size())
				{
					techid = (*techvec)[m_kejiindex];
				}
			}
			if(techid > 0)
			{
				if(techtab->queryOneRecord(0,crArgumentParser::appItoa(techid),record) >= 0)
				{
					needresourcestr[0] = record[copperindex].c_str();
					needresourcestr[1] = record[foodindex].c_str();
					needresourcestr[2] = record[woodindex].c_str();
					needresourcestr[3] = record[ironindex].c_str();
				}
			}
		}
		switch (m_index)
		{
		case RefreshCardType_Free:
			str1 = crArgumentParser::appItoa((float)c_24hours /60.0f / produce) + "分钟回复1次，" + "好感度+" + crArgumentParser::appItoa(coppercost[1]);
			str2index = 2040;
			break;
		case RefreshCardType_Gold:
			cfg_script.Add("Text", "花费");
			cfg_script.Pop();
			str3 = crArgumentParser::appItoa(goldcost[0]) + "礼金/元宝" ;
			str1 = "，好感度+" + crArgumentParser::appItoa(goldcost[1]);
			//str5 = "     ";
			str2index = 2040;
			break;
		case RefreshCardType_GoldBatch:
			cfg_script.Add("Text", "花费");
			cfg_script.Pop();
			str3 = crArgumentParser::appItoa(batchcost[0]) + "礼金/元宝"; 
			str1 = "，好感度+" + crArgumentParser::appItoa(batchcost[1]);
			//str5 = "     ";
			str2index = 2042;
			break;
		case RefreshCardType_Super:
			{
				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSuperRollCard,viplv).c_str(),supercost);
				cfg_script.Add("Text", "花费");
				cfg_script.Pop();
				str3 = crArgumentParser::appItoa(supercost[0]) + "礼金/元宝" ;
				str1 = "，好感度+" + crArgumentParser::appItoa(supercost[1]);
				//str5 = "     ";
				str2index = 2113;
			}
			break;
		case 4:
			{
				data->getParam(WCHDATA_JXJCardImpression,param);
				unsigned short cardimpression = *(unsigned short *)param;
				data->getParam(WCHDATA_JXJCardImpressionLevel,param);
				unsigned short level = *(unsigned short *)param;
				ref_ptr<crTableIO>impressionTab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJImpressionTab);
				if (impressionTab.valid())
				{
					int expIndex = impressionTab->getTitleIndex("exp");
					int colorIndex = impressionTab->getTitleIndex("color");
					crTableIO::StrVec record;
					int color = 0;
					unsigned short needImpression = 0;
					if(impressionTab->queryOneRecord(0,crArgumentParser::appItoa(level),record)>=0)
					{
						needImpression = atoi(record[expIndex].c_str());
						color = atoi(record[colorIndex].c_str());
					}
					bool flag = cardimpression >= needImpression ? true:false;
					if (color == CardColor_Blue)
					{
						str2index = flag?9164:9162;
					}else if(color == CardColor_Purple)
					{
						str2index = flag?9165:9163;
					}else if(color == CardColor_Orange)
					{
						str2index = flag?9166:2044;
					}
				}
			}
			break;
		case 5:
			{
				std::vector<int> pickpriceVec;
				crArgumentParser::appAtoVec(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJPickCardPrice,viplv),pickpriceVec);
				data->getParam(WCHDATA_JXJLuckyCard,param);
				int *luckycard = (int *)param;
				int cardcount = 0;
				for( int i = 0; i<3; i++)
				{
					if(*(luckycard+i)>0)
						cardcount++;
				}
				if(cardcount>1)
				{
					int cardid = *(luckycard + m_kejiindex);
					if(cardid>0)
					{
						ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
						int colorindex = itemtab->getTitleIndex("品质");
						crTableIO::StrVec itemrecord;
						if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(cardid),itemrecord)>=0)
						{
							int quality = atoi(itemrecord[colorindex].c_str());
							if(quality<pickpriceVec.size())
							{
								int needgold = pickpriceVec[quality];
								cfg_script.Add("Text", "花费");
								cfg_script.Pop();
								str3 = crArgumentParser::appItoa(needgold) + "礼金/元宝";
								//str1 = " ";
								//str5 = "     ";
								str2index = 2043;
							}
						}
					}
				}
				else
				{
					if(textTab->queryOneRecord(0,"2114",record) >= 0 )
					{
						cfg_script.Add("Text", record[1]);
						cfg_script.Pop();
					}
				}
			}
			break;
		case 10://工坊tips精炼
			str1 = "免费次数每" + crArgumentParser::appItoa((float)c_24hours /60.0f/onehourcount) + "分钟回复1次";
			str2index = 2060;
			break;
		case 11://工坊tips高级精炼
			cfg_script.Add("Text", "      花费");
			cfg_script.Pop();
			str3 = crArgumentParser::appItoa(refinecost[0]) + "礼金/元宝";
			str1 = " ";
			str5 = "      ";
			str2index = 2061;
			break;
		case 12://工坊tips至尊精炼
			cfg_script.Add("Text", "      花费");
			cfg_script.Pop();
			str3 = crArgumentParser::appItoa(refinecost[1]) + "礼金/元宝" ;
			str1 = " ";
			str5 = "      ";
			str2index = 2062;
			break;
		case 13://工坊tips附炼
			str2index = 2063;
			break;
		case 14://工坊tips普通熔炼
			str1 = "花费" + crArgumentParser::appItoa(smeltcost[0]) + "铜钱";
			str2index = 2064;
			break;
		case 15://工坊tips高级熔炼
			cfg_script.Add("Text", "         花费");
			cfg_script.Pop();
			str3 = crArgumentParser::appItoa(smeltcost[1]) + "礼金/元宝";
			str1 = " ";
			str5 = "   ";
			str2index = 2065;
			break;
		case 16://科技TIPS
			if (techid > 0)
			{
				str1 = "研发需要：\n";
				for (int i = 0; i < 4; ++i)
				{
					if (!needresourcestr[i].empty())
					{
						str1+=needresourcestr[i];
						switch (i)
						{
						case 0:
							str1 += "铜钱 ";
							break;
						case 1:
							str1 += "粮食\n";
							break;
						case 2:
							str1 += "木材 ";
							break;
						case 3:
							str1 += "铁矿";
							break;
						default:
							break;
						}
					}
				}
			}
			break;
		case 17://增加编队数2
			cfg_script.Add("Text", "         花费");
			cfg_script.Pop();
			str3 = "200礼金/元宝";
			str1 = " ";
			str5 = "           ";
			str2index = 3083;
			break;
		case 18://增加编队数3
			cfg_script.Add("Text", "         花费");
			cfg_script.Pop();
			str3 = "200礼金/元宝";
			str1 = " ";
			str5 = "           ";
			str2index = 3084;
			break;
		case 19://增加编队数4
			cfg_script.Add("Text", "         花费");
			cfg_script.Pop();
			str3 = "200礼金/元宝";
			str1 = " ";
			str5 = "           ";
			str2index = 3085;
			break;
		case 20://工坊tips八卦石剥离
			{
				cfg_script.Add("Text", "花费");
				cfg_script.Pop();
				str3 = crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJSmeltInlayStone, viplv) + "礼金/元宝";
				str1 = "";
				str5 = "";
				str2index = 1127;
			}
			break;
		case 21:
			{				
				int cost = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRefreshForeignCardCost, viplv).c_str());
				if(cost>0)
					str1 = "花费" + crArgumentParser::appItoa(cost/10000) + "W铜钱刷新";
				str2index = 1129;
			}
			break;
		//default:
		//	if(LuckyCardCostTab->queryOneRecord(0,crArgumentParser::appItoa(goldneed),precord) >= 0 )
		//	{
		//		needgold = atoi(precord[goldindex].c_str());
		//	}
		//	str1 = "花费" + crArgumentParser::appItoa(needgold) + "礼金/元宝";
		//	str2index = 2043;
		//	break;
		}
		if(textTab->queryOneRecord(0,crArgumentParser::appItoa(str2index),record) >= 0 )
		{
			str2 = record[1];		
		}
		if (m_tips == "UI_Tips_Jiusi_1")
		{
			if(!str3.empty())
			{
				cfg_script.Add("Content");
				cfg_script.Push("Content", 2);
				v_i.clear();
				v_i.push_back(140.0f);
				v_i.push_back(40.0f);
				v_i.push_back(40.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color", v_i);
				cfg_script.Add("Text", str3);
				cfg_script.Pop();

				if (!str1.empty())
					str4 = str1 + "\n" + str5 + str2;
				else
					str4 = str2;

				cfg_script.Add("Content");
				cfg_script.Push("Content", 3);
				v_i.clear();
				v_i.push_back(0.0f);
				v_i.push_back(0.0f);
				v_i.push_back(0.0f);
				v_i.push_back(255.0f);
				cfg_script.Add("Color", v_i);
				cfg_script.Add("Text", str4);
				cfg_script.Pop();

				if(m_index == RefreshCardType_Super)
				{
					cfg_script.Add("Content");
					cfg_script.Push("Content",4);
					cfg_script.Add("Text","\n额外获得");
					cfg_script.Pop();
					ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
					int nameindex = itemtab->getTitleIndex("name");
					int colorindex = itemtab->getTitleIndex("品质");
					crTableIO::StrVec itemrecord;
					if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(supercost[2]),itemrecord)>=0)
					{
						crVector4f colormode;
						crTableIO::StrVec colorrecord;
						ref_ptr<crTableIO> qualitytab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJQualityTab);
						int qualityindex = qualitytab->getTitleIndex("color");
						if(qualitytab->queryOneRecord(0,itemrecord[colorindex],colorrecord) >= 0 )
						{
							crArgumentParser::appAtoVec(colorrecord[qualityindex],colormode);
						}
						cfg_script.Add("Content");
						cfg_script.Push("Content",5);
						v_i.clear();
						v_i.push_back(colormode[0]);
						v_i.push_back(colormode[1]);
						v_i.push_back(colormode[2]);
						v_i.push_back(colormode[3]);
						cfg_script.Add("Color",v_i);
						char tmpText[64];
						sprintf(tmpText,"[%s]*1\0",itemrecord[nameindex].c_str());
						cfg_script.Add("Text",tmpText);
						cfg_script.Pop();
					}
				}
			}
			cfg_script.Pop();
			//cfg_script.Write("tipstest.cfg");
			if(tipsText.valid()) tipsText->setHypertext(cfg_script);
		
		}
		if (sw)
		{
			sw->setActiveSwitchSet(0);
		}
		if (name.valid())
		{
			if (!str1.empty())
			{
				name->setString(str1 + "\n" + str2);
			}
			else
			{
				name->setString(str2);
			}
		}
		//if (info1)
		//{
		//	info1->setString(str2);
		//}
		const crMatrix &mat = m_this->getParentCanvas()->getMatrix();
		const crBoundingBox &iconbox = m_this->getBoundBox();
		const crBoundingBox &tips = tipsCanvas->getBoundBox();
		float posx = (tips.m_max[0]-tips.m_min[0])*0.5;
		float posy = (tips.m_max[1]-tips.m_min[1])*0.5;
		crVector3 pos(iconbox.m_max[0],iconbox.m_max[1],0.0f);
		/////////////////////////////////////////
		crVector3 pos2(iconbox.m_min[0] ,iconbox.m_min[1],0.0f);
		float posx2,posy2;
		/////////////////////////////////////////
		if (pos2[0] >= 0)
		{
			posx2 = pos2[0] - posx;
		}
		else
		{
			posx2 = pos[0] + posx;
		}
		if (pos2[1] >= 0)
		{
			posy2 = pos[1] - posy;
		}
		else
		{
			posy2 = pos2[1] + posy;
		}
		crVector2 mouse(crVector2(posx2,posy2));
		/////////////////////////////////////////
		tipsCanvas->setMatrix(crMatrix::translate(mouse[0],mouse[1],0.0f) * mat);
		tipsCanvas->setCanFocus(false);
		crFilterRenderManager::getInstance()->showCanvas(tipsCanvas.get(),true);
	}
}	
/////////////////////////////////////////
//
//crJXJUIUndoFormationAddMethod
//
/////////////////////////////////////////
crJXJUIUndoFormationAddMethod::crJXJUIUndoFormationAddMethod()
{
}
crJXJUIUndoFormationAddMethod::crJXJUIUndoFormationAddMethod(const crJXJUIUndoFormationAddMethod& handle):
	crMethod(handle),
	m_index(handle.m_index)
{
	for (int i = 0; i < 3; i++)
	{
		m_curlead[i] = handle.m_curlead[i];
		m_curcount[i] = handle.m_curcount[i];
		m_curpower[i] = handle.m_curpower[i];
	}
}
void crJXJUIUndoFormationAddMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crImageBoxWidgetNode*)param;
		break;
	}
}
void crJXJUIUndoFormationAddMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
	case 2:
	case 3:
		m_curlead[i - 1] = str;
		break;
	case 4:
	case 5:
	case 6:
		m_curcount[i - 4] = str;
		break;
	case 7:
	case 8:
	case 9:
		m_curpower[i - 7] = str;
		break;
	}
}
void crJXJUIUndoFormationAddMethod::operator()(crHandle &handle)
{
	void *param;
	if(!m_this) return;
	ref_ptr<crCanvasNode>formationcanvas = m_this->getParentCanvas();
	if(!formationcanvas) return;
	ref_ptr<crStaticTextWidgetNode> curlead = dynamic_cast<crStaticTextWidgetNode *>(formationcanvas->getWidget(m_curlead[m_index]));
	ref_ptr<crStaticTextWidgetNode> curcount = dynamic_cast<crStaticTextWidgetNode *>(formationcanvas->getWidget(m_curcount[m_index]));
	ref_ptr<crStaticTextWidgetNode> curpower = dynamic_cast<crStaticTextWidgetNode *>(formationcanvas->getWidget(m_curpower[m_index]));
	crData *formationdata = formationcanvas->getDataClass();

	formationdata->excHandle(MAKECREPARAM(WCH_LockData,1));
	formationdata->getParam(WCHDATA_JXJTempFormationVec, param);
	FormationInfoVec *tempformationvec = (FormationInfoVec *)param;
	//m_this->setVisiable(false);
	m_this->setImageName("UI_Formation_Bingzhongdi.img");
	if (m_index < tempformationvec->size() && (*tempformationvec)[m_index] != NULL)
	{
		(*tempformationvec)[m_index]->setAbstractID(-1);
		if (curlead.valid()) curlead->clearString();
		if (curcount.valid()) curcount->clearString();
		if (curpower.valid()) curpower->clearString();
	}
	//ref_ptr<crScrollBarWidgetNode> slide = dynamic_cast<crScrollBarWidgetNode *>(formationcanvas->getWidget(m_slide));
	//slide->outerSetValue(0.0f);
	//slide->setVisiable(false);
	formationdata->excHandle(MAKECREPARAM(WCH_LockData,0));
}
/////////////////////////////////////////
//
//crJXJUIOnFormationMaxMethod
//
/////////////////////////////////////////
crJXJUIOnFormationMaxMethod::crJXJUIOnFormationMaxMethod()
{
}
crJXJUIOnFormationMaxMethod::crJXJUIOnFormationMaxMethod(const crJXJUIOnFormationMaxMethod& handle):
	crMethod(handle)
{
	for(int i = 0;i < 3; i++)
	{
		m_slide[i] = handle.m_slide[i];
		m_maxinput[i] = handle.m_maxinput[i];
	}
}
void crJXJUIOnFormationMaxMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJUIOnFormationMaxMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_slide[i] = str;
		break;
	case 1:
		m_slide[i] = str;
		break;
	case 2:
		m_slide[i] = str;
		break;
	case 3:
		m_maxinput[i - 3] = str;
		break;
	case 4:
		m_maxinput[i - 3] = str;
		break;
	case 5:
		m_maxinput[i - 3] = str;
		break;
	}
}
void crJXJUIOnFormationMaxMethod::operator()(crHandle &handle)
{
	if(!m_this) return;
	ref_ptr<crCanvasNode>formationcanvas = m_this->getParentCanvas();
	if(!formationcanvas) return;
	ref_ptr<crScrollBarWidgetNode> slide[3] = {NULL};
	ref_ptr<crStaticTextWidgetNode> maxinput[3] = {NULL};
	for (int i = 0; i < 3; i++)
	{
		slide [i] = dynamic_cast<crScrollBarWidgetNode *>(formationcanvas->getWidget(m_slide[i]));
		maxinput [i] = dynamic_cast<crStaticTextWidgetNode *>(formationcanvas->getWidget(m_maxinput[i]));
		if (slide[i].valid() && maxinput[i].valid() && slide[i]->getVisiable())
		{
			slide[i] -> setValue((atoi(maxinput[i]->getUTF8String().c_str())));
			slide[i] -> doEvent(WCH_UI_ValueChange);
		}
	}
}
/////////////////////////////////////////
//
//crJXJDoEventProgressOnShowMethod
//
/////////////////////////////////////////
crJXJDoEventProgressOnShowMethod::crJXJDoEventProgressOnShowMethod():
	m_flg(0)
{
}
crJXJDoEventProgressOnShowMethod::crJXJDoEventProgressOnShowMethod(const crJXJDoEventProgressOnShowMethod& handle):
	crMethod(handle),
	m_progress(handle.m_progress),
	m_flg(handle.m_flg)
{
}
void crJXJDoEventProgressOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJDoEventProgressOnShowMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = str;
		break;
	case 1:
		m_flg = atoi(str.c_str());
		break;
	}
}
void crJXJDoEventProgressOnShowMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = myPlayer->getDataClass();
	data->getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	ref_ptr<crProgressWidgetNode> progress = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_progress));
	if(progress.valid())progress->setProgress(0);
	crData *braindata = crBrain::getInstance()->getDataClass();
	int count = 0;
	//if(m_flg == 0)
	//{
	//	braindata->getParam(WCHDATA_JXJUseItemRemainCount,param);
	//	count = *(unsigned char *)param;
	//}
	//else
	//{
	//	count = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBatchRollCardCount,viplv).c_str());
	//}
	if (m_flg == 3)
	{
		count = 10;
	}
	crData *canvasdata = m_this->getDataClass();
	if(count==0)
	{
		count = 1;
	}
	canvasdata->inputParam(WCHDATA_JXJTotalCount,&count);
}
///////////////////////////////////////////
////
////crJXJDoEventProgressUpdateMethod
////
///////////////////////////////////////////
//crJXJDoEventProgressUpdateMethod::crJXJDoEventProgressUpdateMethod():
//	m_index(0),
//	m_totalcount(0)
//{
//}
//crJXJDoEventProgressUpdateMethod::crJXJDoEventProgressUpdateMethod(const crJXJDoEventProgressUpdateMethod& handle):
//	crMethod(handle),
//	m_index(handle.m_index),
//	m_progress(handle.m_progress),
//	m_totalcount(handle.m_totalcount)
//{
//}
//void crJXJDoEventProgressUpdateMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//void crJXJDoEventProgressUpdateMethod::addParam(int i, const std::string& str)
//{
//	switch(i) 
//	{
//	case 0:
//		m_index = atoi(str.c_str());
//		break;
//	case 1:
//		m_progress = str;
//		break;
//	}
//}
//void crJXJDoEventProgressUpdateMethod::operator()(crHandle &handle)
//{
//	void *param;
//	crData *braindata = crBrain::getInstance()->getDataClass();
//	unsigned char remaincount = 0;
//	unsigned char totalcount = 0;
//	if (m_index == 0)
//	{
//		braindata->getParam(WCHDATA_JXJUseItemRemainCount,param);
//		remaincount = *(unsigned char *)param;
//		if (m_totalcount == 0 && remaincount > 0)
//		{
//			m_totalcount = remaincount;
//		}
//		totalcount = m_totalcount;
//	}
//	else
//	{
//		totalcount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJBatchRollCardCount).c_str());
//		braindata->getParam(WCHDATA_JXJRollCardRemainCount,param);
//		remaincount = *(unsigned char *)param;
//	}
//	ref_ptr<crProgressWidgetNode> progress = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_progress));
//	crData *canvasdata = m_this->getDataClass();
//	if (progress && canvasdata)
//	{
//		float nextprogress = 0.0f;
//		if(totalcount > 0 && remaincount > 0)
//		{
//			//progress->setProgress((float)(totalcount-remaincount)/(float)totalcount);
//			//nextprogress = (float)(totalcount-remaincount-1)/(float)totalcount;
//		}
//		else
//		{
//			//nextprogress = 1.0f;
//			//crFilterRenderManager::getInstance()->showCanvas(m_this,false);
//			m_totalcount = 0;
//		}
//		canvasdata->inputParam(WCHDATA_JXJSpeedVar,&totalcount);
//	}
//}
/////////////////////////////////////////
//
//crJXJProgressFrameUpdateMethod
//
/////////////////////////////////////////
crJXJProgressFrameUpdateMethod::crJXJProgressFrameUpdateMethod():
	m_dt(0.0f),
	m_flg(0),
	m_netspeed(1.0f)
{
}
crJXJProgressFrameUpdateMethod::crJXJProgressFrameUpdateMethod(const crJXJProgressFrameUpdateMethod& handle):
	crMethod(handle),
	m_dt(handle.m_dt),
	m_progress(handle.m_progress),
	m_flg(handle.m_flg),
	m_netspeed(handle.m_netspeed)
{
}
void crJXJProgressFrameUpdateMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_dt = *(float *)(LOCREPARAM(param64));
		}
		break;
	}
}
void crJXJProgressFrameUpdateMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_progress = str;
		break;
	case 1:
		m_flg = atoi(str.c_str());
		break;
	case 2:
		m_netspeed = atof(str.c_str());
		break;
	}
}
void crJXJProgressFrameUpdateMethod::operator()(crHandle &handle)
{
	void *param;
	ref_ptr<crProgressWidgetNode> progress = dynamic_cast<crProgressWidgetNode *>(m_this->getWidget(m_progress));
	crData *canvasdata = m_this->getDataClass();
	crData *braindata = crBrain::getInstance()->getDataClass();
	if (progress.valid() && canvasdata && braindata)
	{
		unsigned char remaincount = 0;
		if (m_flg == 0)
		{
			braindata->getParam(WCHDATA_JXJUseItemRemainCount,param);
			remaincount = *(unsigned char *)param;
		}
		else if (m_flg == 1)
		{
			braindata->getParam(WCHDATA_JXJRollCardRemainCount,param);
			remaincount = *(unsigned char *)param;
		}
		else if(m_flg == 2)
		{
			braindata->getParam(WCHDATA_JXJBatchRebelCount,param);
			remaincount = *(unsigned char *)param;
		}
		if(remaincount>0)
		{
			//canvasdata->getParam(WCHDATA_JXJTotalCount,param);
			//int totalcount = *(int *)param;
			//float curprogress = (float)(totalcount-remaincount)/(float)totalcount;
			//if(progress->getProgress()<curprogress)
			//{
			//	progress->setProgress(curprogress);
			//}
			//else
			//{
			float pro = progress->getProgress();
			float _pro = 1.0f - pro;
			if(_pro<0.001f) _pro = 0.001f;
			float speed = _pro/(m_netspeed*(float)remaincount);
			float newpro = pro+m_dt * speed;
			progress->setProgress(newpro);
			if(newpro>=1.0f && m_flg != 2)
			{
				crFilterRenderManager::getInstance()->showCanvas(m_this,false);
			}
			//}
		}
		else if (m_flg != 2)
		{
			crFilterRenderManager::getInstance()->showCanvas(m_this,false);
		}
	}
	else if (m_flg != 2)
	{
		crFilterRenderManager::getInstance()->showCanvas(m_this,false);
	}
}
/////////////////////////////////////////
//
//crJXJParentCanvasDoEventMethod
//
/////////////////////////////////////////
crJXJParentCanvasDoEventMethod::crJXJParentCanvasDoEventMethod():
	m_buttonindex(0),
	m_eventindex(0)
{
}

crJXJParentCanvasDoEventMethod::crJXJParentCanvasDoEventMethod(const crJXJParentCanvasDoEventMethod& handle):
	crMethod(handle),
	m_buttonindex(handle.m_buttonindex),
	m_eventindex(handle.m_eventindex)
{
}

void crJXJParentCanvasDoEventMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJParentCanvasDoEventMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_buttonindex = atoi(str.c_str());
		break;
	case 1:
		m_eventindex = atoi(str.c_str());
		break;
	default:
		break;
	}
}

void crJXJParentCanvasDoEventMethod::operator()(crHandle &handle)
{
	ref_ptr<crCanvasNode>canvas = m_this->getParentCanvas();
	if (canvas.valid())
	{
		canvas->doEvent(MAKEINT32(m_buttonindex,m_eventindex));
	}
}

/////////////////////////////////////////
//
//crJXJQueryCountryInfoMethod
//
/////////////////////////////////////////
crJXJQueryCountryInfoMethod::crJXJQueryCountryInfoMethod()
{
}

crJXJQueryCountryInfoMethod::crJXJQueryCountryInfoMethod(const crJXJQueryCountryInfoMethod& handle):
	crMethod(handle)
{
}

void crJXJQueryCountryInfoMethod::inputParam(int i, void *param)
{
}

void crJXJQueryCountryInfoMethod::addParam(int i, const std::string& str)
{
}

void crJXJQueryCountryInfoMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	CRNet::crNetConductor *netConductor	= CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
	if(playerGameData && netConductor)
	{
		CRNetApp::crPlayerDataEventPacket packet;
		CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvQueryCountryInfo, NULL);
		netConductor->getNetManager()->sendPacket("all",packet);
	}
}
/////////////////////////////////////////
//
//crJXJRecvQueryCountryInfoMethod
//
/////////////////////////////////////////
crJXJRecvQueryCountryInfoMethod::crJXJRecvQueryCountryInfoMethod():
	m_netType(GameClient_Game){}
crJXJRecvQueryCountryInfoMethod::crJXJRecvQueryCountryInfoMethod(const crJXJRecvQueryCountryInfoMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvQueryCountryInfoMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvQueryCountryInfoMethod::addParam(int i, const std::string& str)
{
	switch	(i)
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvQueryCountryInfoMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			void *param;
			int totalmoney = 0;
			int playerid = m_this->getPlayerID();
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if (playerData.valid())
			{
				crData *gsBrainData = crServerBrainHandle::getInstance()->getDataClass();
				if (gsBrainData)
				{
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,1));
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					stream->createBuf(12);
					for (int i = 0; i < 3; i++)
					{
						totalmoney = 0;
						gsBrainData->getParam(WCHDATA_JXJShiliWei + i,param);
						crJXJShili *shili = (crJXJShili *)param;
						if(shili && shili->getDataClass())
						{
							crData *shilidata = shili->getDataClass();
							for (int ii = WCHDATA_JXJShenNongMiao; ii <= WCHDATA_JXJTaiMiao; ii++)
							{
								shilidata->getParam(ii,param);
								totalmoney += *(int *)param;
							}
							stream->_writeInt(totalmoney);
						}
					}
					crPlayerDataEventPacket packet;
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvQueryCountryInfo,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
					gsBrainData->excHandle(MAKECREPARAM(WCH_LockData,0));
				}
			}
		}
		else if (m_netType == GameClient_Game)
		{
			crData *data = m_this -> getDataClass();
			void *param;
			crVector3i moneyvec;
			crVector3i chenghinumvec;
			for (int i = 0; i < 3; i++)
			{
				moneyvec[i] = m_stream->_readInt();
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJChengChiMap,param);
			ChengchiMap *chengchiMap = (ChengchiMap *)param;
			unsigned char chengzhu;
			for (ChengchiMap::iterator itr = chengchiMap->begin();
				itr != chengchiMap->end();
				++itr)
			{
				chengzhu = itr->second->getChengzhuShili();
				if(chengzhu == c_startShiliID)
				{
					chenghinumvec[0] ++;
				}
				else if(chengzhu == c_startShiliID + 1)
				{
					chenghinumvec[1] ++;
				}
				else if(chengzhu == c_startShiliID + 2)
				{
					chenghinumvec[2] ++;
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			crData *canvasdata = canvas->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			ref_ptr<crJXJCountryInfo> countryinfo;
			canvasdata->getParam(WCHDATA_JXJCountryCityNumRankingMap,param);
			CountryCityNumRankingMap *CityNumrankingMap = (CountryCityNumRankingMap *)param;
			canvasdata->getParam(WCHDATA_JXJCountryMoneyRankingMap,param);
			CountryMoneyRankingMap *MoneyrankingMap = (CountryMoneyRankingMap *)param;
			CityNumrankingMap->clear();
			MoneyrankingMap->clear();
			for (int i = 0; i < 3; i++)
			{
				countryinfo = new crJXJCountryInfo;
				countryinfo->setMoney(moneyvec[i]);
				countryinfo->setCityNum((unsigned char)chenghinumvec[i]);
				countryinfo->setShiliID(c_startShiliID + i);
				CityNumrankingMap->insert(std::make_pair((unsigned char)chenghinumvec[i],countryinfo));
				MoneyrankingMap->insert(std::make_pair(moneyvec[i],countryinfo));
			}

			
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
		}
	}
}

/////////////////////////////////////////
//
//crJXJGovPostShopOnShowMethod
//
/////////////////////////////////////////
crJXJGovPostShopOnShowMethod::crJXJGovPostShopOnShowMethod()
{
}

crJXJGovPostShopOnShowMethod::crJXJGovPostShopOnShowMethod(const crJXJGovPostShopOnShowMethod& handle):
	crMethod(handle)
{
}

void crJXJGovPostShopOnShowMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}

void crJXJGovPostShopOnShowMethod::addParam(int i, const std::string& str)
{
}

void crJXJGovPostShopOnShowMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		ref_ptr<crScrollBarWidgetNode> scrollbar = dynamic_cast<crScrollBarWidgetNode *>(m_this->getWidget(m_scrollbar));
		if (scrollbar.valid())
		{
			scrollbar->setValue(0);
		}
	}
}
///////////////////////////////////////////
////
////crJXJGovPostShopUpdateMethod
////
///////////////////////////////////////////
//crJXJGovPostShopUpdateMethod::crJXJGovPostShopUpdateMethod()
//{
//}
//
//crJXJGovPostShopUpdateMethod::crJXJGovPostShopUpdateMethod(const crJXJGovPostShopUpdateMethod& handle):
//	crMethod(handle),
//	m_pageinput(handle.m_pageinput),
//	m_curmoney(handle.m_curmoney),
//	m_checkbox(handle.m_checkbox)
//{
//	for (int i = 0; i < 5; i++)
//	{
//		m_itemicon[i] = handle.m_itemicon[i];
//		m_nameinput[i] = handle.m_nameinput[i];
//		m_priceinput[i] = handle.m_priceinput[i];
//		m_infoinput[i] = handle.m_infoinput[i];
//		m_govpostinput[i] = handle.m_govpostinput[i];
//		m_purchasebtn[i] = handle.m_purchasebtn[i];
//		m_priceinfoinput[i] = handle.m_priceinfoinput[i];
//	}
//}
//
//void crJXJGovPostShopUpdateMethod::inputParam(int i, void *param)
//{
//	switch(i) 
//	{
//	case 0:
//		if(param == 0)
//		{//释放
//			m_this = NULL;
//		}
//		break;
//	case 1:
//		m_this = (crCanvasNode*)param;
//		break;
//	}
//}
//
//void crJXJGovPostShopUpdateMethod::addParam(int i, const std::string& str)
//{
//	switch (i)
//	{
//	case 0:
//		m_pageinput = str;
//		break;
//	case 1:
//		m_curmoney = str;
//		break;
//	case 2:
//		m_checkbox = str;
//		break;
//	case 3:
//		m_itemicon[i - 3] = str;
//		break;
//	case 4:
//		m_itemicon[i - 3] = str;
//		break;
//	case 5:
//		m_itemicon[i - 3] = str;
//		break;
//	case 6:
//		m_itemicon[i - 3] = str;
//		break;
//	case 7:
//		m_itemicon[i - 3] = str;
//		break;
//	case 8:
//		m_nameinput[i - 8] = str;
//		break;
//	case 9:
//		m_nameinput[i - 8] = str;
//		break;
//	case 10:
//		m_nameinput[i - 8] = str;
//		break;
//	case 11:
//		m_nameinput[i - 8] = str;
//		break;
//	case 12:
//		m_nameinput[i - 8] = str;
//		break;
//	case 13:
//		m_priceinput[i - 13] = str;
//		break;
//	case 14:
//		m_priceinput[i - 13] = str;
//		break;
//	case 15:
//		m_priceinput[i - 13] = str;
//		break;
//	case 16:
//		m_priceinput[i - 13] = str;
//		break;
//	case 17:
//		m_priceinput[i - 13] = str;
//		break;
//	case 18:
//		m_infoinput[i - 18] = str;
//		break;
//	case 19:
//		m_infoinput[i - 18] = str;
//		break;
//	case 20:
//		m_infoinput[i - 18] = str;
//		break;
//	case 21:
//		m_infoinput[i - 18] = str;
//		break;
//	case 22:
//		m_infoinput[i - 18] = str;
//		break;
//	case 23:
//		m_govpostinput[i - 23] = str;
//		break;
//	case 24:
//		m_govpostinput[i - 23] = str;
//		break;
//	case 25:
//		m_govpostinput[i - 23] = str;
//		break;
//	case 26:
//		m_govpostinput[i - 23] = str;
//		break;
//	case 27:
//		m_govpostinput[i - 23] = str;
//		break;
//	case 28:
//		m_purchasebtn[i - 28] = str;
//		break;
//	case 29:
//		m_purchasebtn[i - 28] = str;
//		break;
//	case 30:
//		m_purchasebtn[i - 28] = str;
//		break;
//	case 31:
//		m_purchasebtn[i - 28] = str;
//		break;
//	case 32:
//		m_purchasebtn[i - 28] = str;
//		break;
//	case 33:
//		m_priceinfoinput[i - 33] = str;
//		break;
//	case 34:
//		m_priceinfoinput[i - 33] = str;
//		break;
//	case 35:
//		m_priceinfoinput[i - 33] = str;
//		break;
//	case 36:
//		m_priceinfoinput[i - 33] = str;
//		break;
//	case 37:
//		m_priceinfoinput[i - 33] = str;
//		break;
//	default:
//		break;
//	}
//}
//
//void crJXJGovPostShopUpdateMethod::operator()(crHandle &handle)
//{
//	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
//	ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
//	ref_ptr<crTableIO>govpostshoptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostShopTab);
//	ref_ptr<crTableIO>govposttab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostTab);
//	if(m_this && playerGameData && itemtab.valid() && govpostshoptab.valid() && govposttab.valid())
//	{
//		crData *data = playerGameData->getDataClass();
//		crData *mainroledata = playerGameData->getMainRole()->getDataClass();
//		if (data && mainroledata)
//		{
//			void *param;
//			mainroledata -> getParam(WCHDATA_JXJGovPost,param);
//			unsigned char govPost = *(unsigned char *)param;
//			data -> getParam(WCHDATA_JXJCountryContribute,param);
//			int mycountrycontribute = *(int *)param;
//			crTableIO::StrVec record;
//			crTableIO::StrVec recordg;
//			int scrollvalue = 0;
//			int row = 0;
//			int showcurpos = 0;
//			int rowcount = govpostshoptab->getRowCount();
//			int govnameindex = govposttab->getTitleIndex("govpost");
//			int infoindex = itemtab->getTitleIndex("物品描述");
//			int colorindex = itemtab->getTitleIndex("品质");
//			int iconindex = itemtab->getTitleIndex("icon");
//			int nameindex = itemtab->getTitleIndex("name");
//			int priceindex = govpostshoptab->getTitleIndex("消耗贡献");
//			int govpostindex = govpostshoptab->getTitleIndex("官职需求");
//			data->getParam(WCHDATA_JXJVipLv,param);
//			unsigned char viplv = *(unsigned char *)param;
//			int onepagecount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJGovPostShopPerPage,viplv).c_str()));
//			crData *canvasdata = m_this->getDataClass();
//			ref_ptr<crStaticTextWidgetNode> pageinput = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_pageinput));
//			ref_ptr<crStaticTextWidgetNode> curmoney = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_curmoney));
//			ref_ptr<crCheckBoxWidgetNode> checkbox = dynamic_cast<crCheckBoxWidgetNode *>(m_this->getWidget(m_checkbox));
//			if (checkbox.valid())
//			{
//				showcurpos = checkbox->getSelect();
//			}
//			ref_ptr<crImageBoxWidgetNode> itemicon[5] = {NULL};
//			ref_ptr<crStaticTextWidgetNode> nameinput[5] = {NULL};
//			ref_ptr<crStaticTextWidgetNode> priceinput[5] = {NULL};
//			ref_ptr<crStaticTextWidgetNode> infoinput[5] = {NULL};
//			ref_ptr<crStaticTextWidgetNode> govpostinput[5] = {NULL};
//			ref_ptr<crStaticTextWidgetNode> priceinfoinput[5] = {NULL};
//			ref_ptr<crButtonWidgetNode> perchagebtn[5] = {NULL};
//			for (int i = 0; i < 5; i++)
//			{
//				itemicon[i] = dynamic_cast<crImageBoxWidgetNode *>(m_this->getWidget(m_itemicon[i]));
//				nameinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_nameinput[i]));
//				priceinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_priceinput[i]));
//				infoinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_infoinput[i]));
//				govpostinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_govpostinput[i]));
//				priceinfoinput[i] = dynamic_cast<crStaticTextWidgetNode *>(m_this->getWidget(m_priceinfoinput[i]));
//				perchagebtn[i] = dynamic_cast<crButtonWidgetNode *>(m_this->getWidget(m_purchasebtn[i]));
//				if (itemicon[i].valid())itemicon[i]->setVisiable(false);
//				if (nameinput[i].valid())nameinput[i]->clearString();
//				if (priceinput[i].valid())priceinput[i]->clearString();
//				if (infoinput[i].valid())infoinput[i]->clearString();
//				if (govpostinput[i].valid())govpostinput[i]->clearString();
//				if (priceinfoinput[i].valid())priceinfoinput[i]->clearString();
//				if (perchagebtn[i].valid())perchagebtn[i]->setVisiable(false);
//			}
//			canvasdata -> getParam(WCHDATA_JXJGovPostShopItemDeq,param);
//			GovPostShopItemIDDeq *govpostshopitemdeq = (GovPostShopItemIDDeq *)param;
//			govpostshopitemdeq->clear();
//			if (infoindex >= 0 && colorindex >= 0 && iconindex >= 0 && priceindex >= 0 && govpostindex >= 0 && onepagecount >= 0 && canvasdata)
//			{
//				std::string pricestr;
//				std::string itemidstr;
//				int saleitemcount = 0;
//				int price = 0;
//				int itemid = 0;
//				unsigned char needgovpost = 0;
//				bool ifshow = false;
//				if (!showcurpos)
//				{
//					saleitemcount = rowcount;
//				}
//				canvasdata->getParam(WCHDATA_JXJGovPostShopCurPage, param);
//				int curpage = *(int *)param;
//				row = (curpage - 1) * onepagecount;
//				int j = -row;
//				for (int i = 0; i < rowcount; i++)
//				{
//					ifshow = false;
//					pricestr = (*govpostshoptab)(i,priceindex);
//					price =  atoi(pricestr.c_str());
//					itemidstr = (*govpostshoptab)(i,0);
//					itemid =  atoi(itemidstr.c_str());
//					needgovpost = atoi((*govpostshoptab)(i,govpostindex).c_str());
//					if (showcurpos)
//					{
//						if (needgovpost == govPost)
//						{
//							ifshow = true;
//							saleitemcount ++;
//						}
//					}
//					else
//					{
//						ifshow = true;
//					}
//					if (ifshow)
//					{
//						if (j >= 0 && j < onepagecount)
//						{
//							if (itemtab->queryOneRecord(0,itemidstr,record) >= 0 )
//							{
//								govpostshopitemdeq->push_back(itemid);
//								if(itemicon[j].valid())
//								{
//									itemicon[j]->setVisiable(true);
//									itemicon[j]->setImageName(record[iconindex]);
//								}
//								if(nameinput[j].valid())
//								{
//									nameinput[j]->setString(record[nameindex]);
//								}
//								if(priceinput[j].valid())
//								{
//									if (mycountrycontribute>=price)
//									{
//										priceinput[j]->setColor(crVector4f(1.0f,1.0f,1.0f,1.0f));
//									}
//									else
//									{
//										priceinput[j]->setColor(crVector4f(0.8f,0.2f,0.1f,1.0f));
//									}
//									priceinput[j]->setString(pricestr);
//								}
//								if(infoinput[j].valid())
//								{
//									infoinput[j]->setString(record[infoindex]);
//								}
//								if(govpostinput[j].valid())
//								{
//									if (govPost >= needgovpost)
//									{
//										govpostinput[j]->setColor(crVector4f(210.0f,220.0f,200.0f,255.0f)/255.0f);
//									}
//									else
//									{
//										govpostinput[j]->setColor(crVector4f(0.8f,0.2f,0.1f,1.0f));
//									}
//									
//									if (govposttab->queryOneRecord(0,crArgumentParser::appItoa(needgovpost),recordg) >= 0 )
//									{
//										govpostinput[j]->setString(recordg[govnameindex]);
//									}
//								}
//								if(perchagebtn[j].valid())
//								{
//									perchagebtn[j]->setVisiable(true);
//								}
//								if(priceinfoinput[j].valid())
//								{
//									priceinfoinput[j]->setString(std::string("消耗国家贡献"));
//								}
//							}
//						}
//						j++;
//					}
//				}
//				int totalpage = ceil((float)saleitemcount/(float)onepagecount);
//				if (totalpage == 0)
//				{
//					totalpage = 1;
//				}
//				canvasdata -> inputParam(WCHDATA_JXJGovPostShopTotalPage,&totalpage);
//				if (pageinput.valid())
//				{
//					pageinput->setString(crArgumentParser::appItoa(curpage) + "/" + crArgumentParser::appItoa(totalpage));
//				}
//				if (curmoney.valid())
//				{
//					curmoney->setString(crArgumentParser::appItoa(mycountrycontribute));
//				}
//			}
//		}
//	}
//}
/////////////////////////////////////////
//
//crJXJUIPurChaseGovPostItemMethod
//
/////////////////////////////////////////
crJXJUIPurChaseGovPostItemMethod::crJXJUIPurChaseGovPostItemMethod():
	m_index(0),
	m_font("simhei.ttf"),
	m_characterSize(16),
	m_goldColor(0.0f,1.0f,1.0f,1.0f),
	m_textColor(1.0f,1.0f,0.0f,1.0f)
{
}

crJXJUIPurChaseGovPostItemMethod::crJXJUIPurChaseGovPostItemMethod(const crJXJUIPurChaseGovPostItemMethod& handle):
	crMethod(handle),
	m_index(handle.m_index),
	m_promptCanvas(handle.m_promptCanvas),
	m_information(handle.m_information),
	m_textColor(handle.m_textColor),
	m_goldColor(handle.m_goldColor),
	m_font(handle.m_font),
	m_characterSize(handle.m_characterSize),
	m_okbtn(handle.m_okbtn)
{
}

void crJXJUIPurChaseGovPostItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}

void crJXJUIPurChaseGovPostItemMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_index = atoi(str.c_str());
		break;
	case 1:
		m_promptCanvas = str;
		break;
	case 2:
		m_information = str;
		break;
	case 3:
		m_okbtn = str;
		break;
	case 4:
		m_font = str;
		break;
	case 5:
		m_characterSize = atoi(str.c_str());
		break;
	case 6:
		crArgumentParser::appAtoVec(str,m_textColor);
		m_textColor = m_textColor / 255.0f;
		break;
	case 7:
		crArgumentParser::appAtoVec(str,m_goldColor);
		m_goldColor = m_goldColor / 255.0f;
		break;
	}
}

void crJXJUIPurChaseGovPostItemMethod::operator()(crHandle &handle)
{
	void *param;
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(m_this && playerGameData)
	{
		ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_promptCanvas);
		if (canvas.valid())
		{
			std::string buildingname;
			ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
			ref_ptr<crTableIO>govpostshoptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostShopTab);
			crData *data = playerGameData->getDataClass();
			crData *mainroledata = playerGameData->getMainRole()->getDataClass();
			int nameindex = itemtab->getTitleIndex("name");
			int priceindex = govpostshoptab->getTitleIndex("消耗贡献");
			int govpostindex = govpostshoptab->getTitleIndex("官职需求");
			unsigned char shopid = 0;
			int itemid = 0;
			int price = 0;
			int needgovpost = 0;
			crTableIO::StrVec recordg;
			crData *canvasdata = m_this->getParentCanvas()->getDataClass();
			if (canvasdata)
			{
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
				canvasdata->getParam(WCHDATA_JXJGovShopIDVec,param);
				GovShopIDVec *itemiddeq = (GovShopIDVec *)param;
				if (m_index < itemiddeq->size())
				{
					shopid = (*itemiddeq)[m_index];
					if(govpostshoptab->queryOneRecord(0,crArgumentParser::appItoa(shopid),recordg) >= 0)
					{
						itemid = atoi(recordg[1].c_str());
					}
				}
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
			void *param;
			mainroledata -> getParam(WCHDATA_JXJGovPost,param);
			unsigned char govPost = *(unsigned char *)param;
			data -> getParam(WCHDATA_JXJCountryContribute,param);
			int mycountrycontribute = *(int *)param;
			if (itemid > 0)
			{
				int needbagcount = 1;
				playerGameData->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
				if (needbagcount == 0)
				{
					crTableIO::StrVec record;
					if(itemtab->queryOneRecord(0,crArgumentParser::appItoa(itemid),record) >= 0)
					{
						if (nameindex > 0 && priceindex > 0 && govpostindex > 0)
						{
							price = atoi(recordg[priceindex].c_str());
							needgovpost = atoi(recordg[govpostindex].c_str());
							if (mycountrycontribute >= price && govPost >= needgovpost)
							{
								canvasdata->inputParam(WCHDATA_JXJPurchaseGovPostShopItemID,&shopid);
								ref_ptr<crHypertextWidgetNode> information = dynamic_cast<crHypertextWidgetNode *>(canvas->getWidget(m_information));
								ref_ptr<crButtonWidgetNode> okbtn = dynamic_cast<crButtonWidgetNode *>(canvas->getWidget(m_okbtn));
								std::vector<float>v_i;
								ItemMap itemMap;
								rcfg::ConfigScript cfg_script(&itemMap);
								cfg_script.Add("Hypertext");
								cfg_script.Push("Hypertext");
								//cfg_script.Add("Font",m_font);
								//cfg_script.Add("CharacterSize",m_characterSize);

								cfg_script.Add("Content");
								cfg_script.Push("Content",1);
								v_i.clear();
								v_i.push_back(255.0f);
								v_i.push_back(255.0f);
								v_i.push_back(255.0f);
								v_i.push_back(255.0f);
								cfg_script.Add("Color",v_i);
								cfg_script.Add("Text","您确认要花费");
								cfg_script.Pop();

								cfg_script.Add("Content");
								cfg_script.Push("Content",2);
								v_i.clear();
								v_i.push_back(255.0f);
								v_i.push_back(255.0f);
								v_i.push_back(0.0f);
								v_i.push_back(255.0f);
								cfg_script.Add("Color",v_i);
								char tmpText[32];
								sprintf(tmpText,"%d国家贡献\0",price);
								cfg_script.Add("Text",tmpText);
								cfg_script.Pop();

								cfg_script.Add("Content");
								cfg_script.Push("Content",3);
								v_i.clear();
								v_i.push_back(255.0f);
								v_i.push_back(255.0f);
								v_i.push_back(255.0f);
								v_i.push_back(255.0f);
								cfg_script.Add("Color",v_i);
								char tmpText2[32];
								sprintf(tmpText2,"购买%s吗？\0",record[nameindex].c_str());
								cfg_script.Add("Text",tmpText2);
								cfg_script.Pop();

								cfg_script.Pop();

								if(information.valid())information->setHypertext(cfg_script);
								if(okbtn.valid())okbtn->setEnable(true);
								crData *dlgData = canvas->getDataClass();
								int commandtype = CDP_Widget;
								dlgData->inputParam(WCHDATA_CommandDlgParentType,&commandtype);
								dlgData->inputParam(WCHDATA_CommandDlgParent,m_this);
								crFilterRenderManager::getInstance()->doModal(canvas.get());
							}
							else
							{//国家贡献不足或官职不足
								if(mycountrycontribute < price)
									playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2048,NULL));
								else
									playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2116,NULL));
							}
						}
					}
				}
				else
				{//背包不足
					playerGameData->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));
				}
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJPurChaseGovPostItemMethod
//
/////////////////////////////////////////
crJXJPurChaseGovPostItemMethod::crJXJPurChaseGovPostItemMethod()
{}
crJXJPurChaseGovPostItemMethod::crJXJPurChaseGovPostItemMethod(const crJXJPurChaseGovPostItemMethod& handle):
	crMethod(handle)
{
}
void crJXJPurChaseGovPostItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crWidgetNode*)param;
		break;
	}
}
void crJXJPurChaseGovPostItemMethod::addParam(int i, const std::string& str)
{
}

void crJXJPurChaseGovPostItemMethod::operator()(crHandle &handle)
{
	crPlayerGameData *playerGameData = crMyPlayerData::getInstance()->getPlayerGameData();
	if(playerGameData)
	{
		void *param;
		crData *canvasdata = m_this->getParentCanvas()->getDataClass();
		if (canvasdata)
		{
			canvasdata->getParam(WCHDATA_JXJPurchaseGovPostShopItemID,param);
			unsigned char shopid = *(unsigned char *)param;

			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(1);
			stream->_writeUChar(shopid);
			CRNet::crNetConductor *net_conductor = CRNet::crNetContainer::getInstance()->getDynamicNetConductor(CRNetApp::GameClient_Game);
			CRNetApp::crPlayerDataEventPacket packet;
			CRNetApp::crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvPurChaseGovPostItem,stream.get());
			net_conductor->getNetManager()->sendPacket("all",packet);
		}
	}
}
/////////////////////////////////////////
//
//crJXJRecvPurChaseGovPostItemMethod
//
/////////////////////////////////////////
crJXJRecvPurChaseGovPostItemMethod::crJXJRecvPurChaseGovPostItemMethod():
	m_netType(GameClient_Game){}
crJXJRecvPurChaseGovPostItemMethod::crJXJRecvPurChaseGovPostItemMethod(const crJXJRecvPurChaseGovPostItemMethod& handle):
	crMethod(handle),
	m_canvas (handle.m_canvas)
{
}
void crJXJRecvPurChaseGovPostItemMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvPurChaseGovPostItemMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvas = str;
		break;
	default:
		break;
	}
}

void crJXJRecvPurChaseGovPostItemMethod::operator()(crHandle &handle)
{
	//////////////////////////////////
	//返回
	//0：失败
	//1：成功
	//2：贡献不足或官职不足
	//3：背包已满
	//////////////////////////////////
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			unsigned char success = 0;//1成功，2购买次数上线，3国家贡献不足，4官职不足，5背包不足
			unsigned char shopid = m_stream->_readUChar();
			int playerid = m_this->getPlayerID();
			crData *data = m_this->getDataClass();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				void *param;
				crData *mainroledata = m_this->getMainRole()->getDataClass();
				crVector2i giftbag;
				int needbagcount = 1;
				int price = 0;
				int needgovpost = 0;
				unsigned char buycount = 0;
				mainroledata -> getParam(WCHDATA_JXJGovPost,param);
				unsigned char govPost = *(unsigned char *)param;
				data -> getParam(WCHDATA_JXJCountryContribute,param);
				int *mycountrycontribute = (int *)param;
				ref_ptr<crTableIO>itemtab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJItemTab);
				ref_ptr<crTableIO>govpostshoptab = crGlobalHandle::gData()->gGlobalTable(WCHDATA_JXJGovPostShopTab);
				int priceindex = govpostshoptab->getTitleIndex("消耗贡献");
				int govpostindex = govpostshoptab->getTitleIndex("官职需求");
				int buycountindex = govpostshoptab->getTitleIndex("购买次数");
				m_this->doEvent(WCH_JXJCheckBagEmptyBag,MAKECREPARAM(&needbagcount,NULL));
				if (needbagcount == 0)
				{
					crTableIO::StrVec record,recordg;
					if(govpostshoptab->queryOneRecord(0,crArgumentParser::appItoa(shopid),recordg) >= 0)
					{
						int itemid = atoi(recordg[1].c_str());
						if(itemtab->queryOneRecord(0,recordg[1],record) >= 0)
						{
							if (priceindex > 0)
							{
								price = atoi(recordg[priceindex].c_str());
								needgovpost = atoi(recordg[govpostindex].c_str());
								data->excHandle(MAKECREPARAM(WCH_LockData,1));
								if(*mycountrycontribute >= price && govPost >= needgovpost)
								{
									int canbuycount = atoi(recordg[buycountindex].c_str());
									if(canbuycount>0)
									{
										data->getParam(WCHDATA_JXJGovShopMap,param);
										GovShopMap *govShopMap = (GovShopMap *)param;
										GovShopMap::iterator itr = govShopMap->find(shopid);
										if(itr != govShopMap->end())
										{
											buycount = itr->second;
											if(buycount>=canbuycount)
											{//购买次数达到上线
												success = 2;
											}
											else
											{
												buycount++;
												itr->second = buycount;
											}
										}
										else
										{
											buycount = 1;
											(*govShopMap)[shopid] = buycount;
										}
									}
									if(success == 0)
									{
										success = 1;
										*mycountrycontribute -= price;
										ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
										bagitemdata->setItemID(itemid);
										bagitemdata->setItemCount(1);
										RewardItemVec rewardItems;
										rewardItems.push_back(bagitemdata);
										m_this->doEvent(WCH_JXJRecvRewardItems,MAKECREPARAM(&rewardItems,0));
									}
								}
								else
								{
									success = govPost >= needgovpost?3:4;
								}
								data->excHandle(MAKECREPARAM(WCH_LockData,0));
							}
						}
					}
				}
				else
				{
					success = 5;
				}
				ref_ptr<crStreamBuf> stream = new crStreamBuf;
				stream->createBuf(7);
				stream->_writeUChar(success);
				stream->_writeUChar(shopid);
				stream->_writeUChar(buycount);
				stream->_writeInt(*mycountrycontribute);
				crPlayerDataEventPacket packet;
				crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvPurChaseGovPostItem,stream.get());
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				///游戏日志
				std::string logdata = crArgumentParser::appVectoa(crVector2i(success,shopid));
				GameLogData gamelog(Log_BuyGovpostItem,logdata);
				crServerBrainHandle::getInstance()->doEvent(WCH_GameLog,MAKECREPARAM(playerid,&gamelog));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			unsigned char success = m_stream->_readUChar();
			unsigned char shopid = m_stream->_readUChar();
			unsigned char buycount = m_stream->_readUChar();
			int mycountrycontribute = m_stream->_readInt();
			crData *data = m_this->getDataClass();
			switch (success)
			{//1成功，2购买次数上限，3国家贡献不足，4官职不足，5背包不足
			case 1:
				{

					ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvas);
					void *param;
					data->getParam(WCHDATA_JXJCountryContribute,param);
					int extra = mycountrycontribute-(*(int *)param);
					if(extra!=0)
					{
						crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Contribute,extra));
						data->inputParam(WCHDATA_JXJCountryContribute,&mycountrycontribute);
					}
					if(buycount>0)
					{
						data->excHandle(MAKECREPARAM(WCH_LockData,1));
						data->getParam(WCHDATA_JXJGovShopMap,param);
						GovShopMap *govShopMap = (GovShopMap *)param;
						(*govShopMap)[shopid] = buycount;
						data->excHandle(MAKECREPARAM(WCH_LockData,0));
					}
					//ref_ptr<crBagItemData> bagitemdata = new crBagItemData;
					//bagitemdata->setItemID(m_stream->_readInt());
					//bagitemdata->setItemCount(1);
					//JXJItemBagVec newitembagvec;
					//newitembagvec.push_back(bagitemdata);
					//m_this->doEvent(WCH_JXJPutItemInBag,MAKECREPARAM(bagitemdata.get(),NULL));
					//if(crBrain::getInstance())
					//	crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeItems,MAKECREPARAM(&newitembagvec,NULL));
					if (canvas.valid())
					{
						canvas->doEvent(WCH_UI_UpdateData);
					}
				}
				break;
			case 2:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2115,NULL));//购买次数上限
				break;
			case 3:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2048,NULL));//贡献不足
				break;
			case 4:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2116,NULL));//官职不足
				break;
			case 5:
				m_this->doEvent(WCH_JXJUIShowTipsCanvas,MAKECREPARAM(2008,NULL));//背包已满
				break;
			}
		}
	}
}
/////////////////////////////////////////
//
//crJXJQueryConsortiaRankingMethod
//
/////////////////////////////////////////
crJXJQueryConsortiaRankingMethod::crJXJQueryConsortiaRankingMethod():
	m_this(NULL),
	m_issearch(0)
	//	m_queryInterval(86400)//24hour
	//	m_queryCount(10)
{
}
crJXJQueryConsortiaRankingMethod::crJXJQueryConsortiaRankingMethod(const crJXJQueryConsortiaRankingMethod& handle):
	crMethod(handle),
	m_this(handle.m_this),
	m_canvasName(handle.m_canvasName),
	m_paraminput(handle.m_paraminput),
	m_issearch(handle.m_issearch)
	//	m_queryInterval(handle.m_queryInterval)
	//	m_queryCount(handle.m_queryCount)
{
	for (int i = 0; i < 2;i++)
	{
		m_combobox[i] = handle.m_combobox[i];
	}
}
void crJXJQueryConsortiaRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
		}
		break;
	case 1:
		m_this = (crCanvasNode*)param;
		break;
	}
}
void crJXJQueryConsortiaRankingMethod::addParam(int i, const std::string& str)
{
	switch (i)
	{
	case 0:
		m_canvasName = str;
		break;
	case 1:
		m_combobox[0] = str;
		break;
	case 2:
		m_combobox[1] = str;
		break;
	case 3:
		m_paraminput =str;
		break;
	case 4:
		m_issearch = atoi(str.c_str());
	default:
		break;
	}
}
void crJXJQueryConsortiaRankingMethod::operator()(crHandle &handle)
{
	void *param;
	ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
	crPlayerGameData *player = crMyPlayerData::getInstance()->getPlayerGameData();
	crData *data = player->getDataClass();
	data->getParam(WCHDATA_JXJVipLv,param);
	unsigned char viplv = *(unsigned char *)param;
	unsigned char querycount = atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str());
	bool cancelTask = false;
	if (canvas.valid())
	{
		std::string name;
		if(m_issearch == 1)
		{
			ref_ptr<crEditWidgetNode> inputedit = dynamic_cast<crEditWidgetNode *>(canvas->getWidget(m_paraminput));
			if (inputedit.valid())
			{
				name = inputedit->getUTF8String();
			}
		}
		char queryindex = -1;
		char shiliindex = 0;
		ref_ptr<crComboBoxWidgetNode> combobox[2] = {NULL};
		for(int i = 0; i < 2; i++)
		{
			combobox[i] = dynamic_cast<crComboBoxWidgetNode *>(canvas->getWidget(m_combobox[i]));
		}
		if (combobox[0].valid())
		{
			shiliindex = combobox[0]->getSelectIndex();
			if (shiliindex > 0)
			{
				shiliindex += c_startShiliID - 1;
			}
		}
		if (combobox[1].valid())
		{
			queryindex = combobox[1]->getSelectIndex();
		}
		crData *canvasdata = canvas->getDataClass();
		canvasdata->getParam(WCHDATA_JXJRankingPageNum,param);
		int curpagenum = *(int *)param;
		unsigned short startline = (curpagenum - 1) * querycount;
		crPlayerGameData *myPlayer = crMyPlayerData::getInstance()->getPlayerGameData();
		crNetConductor *netConductor = crNetContainer::getInstance()->getDynamicNetConductor(GameClient_Game);
		if(myPlayer && netConductor && queryindex >= 0)
		{
			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			if (m_issearch == 1)
			{
				stream->createBuf(4+8+name.length());
			}
			else
			{
				stream->createBuf(4);
			}
			stream->_writeUShort(startline);//start
			stream->_writeUChar(querycount);//count
			stream->_writeUChar(shiliindex);//shiliid
			if (m_issearch == 1)
			{
				stream->_writeString(name);
			}
			crPlayerDataEventPacket packet;
			switch (queryindex)
			{
			case GroupRankingType_Exploit:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvConsortiaExploitRanking,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				break;
			case GroupRankingType_Level:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvConsortialvRanking,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				break;
			case GroupRankingType_MemberCount://BUG 暂时注掉
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvConsortiaMemberRanking,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				break;
			case GroupRankingType_Troops:
				crPlayerDataEventPacket::buildRequestPacket(packet,WCH_JXJRecvConsortiaTroopsRanking,stream.get());
				netConductor->getNetManager()->sendPacket("all",packet);
				break;
			}
			cancelTask = true;
		}
	}
	handle.outputParam(0,&cancelTask);
}
/////////////////////////////////////////
//
//crJXJRecvConsortialvRankingMethod
//
/////////////////////////////////////////
crJXJRecvConsortialvRankingMethod::crJXJRecvConsortialvRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvConsortialvRankingMethod::crJXJRecvConsortialvRankingMethod(const crJXJRecvConsortialvRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvConsortialvRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvConsortialvRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvConsortialvRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				ConsortiaLvRankItem *rankItem;
				void *param;
				crData *data = m_this->getDataClass();
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				data->getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *(int *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));
				//serverData->getParam(WCHDATA_JXJConsortialvRankingMap,param);
				//ConsortialvRankingMap *levelRankingMap = (ConsortialvRankingMap *)param;
				serverData->getParam(WCHDATA_JXJConsortiaLvRank,param);
				ConsortialvRank * consortialvRank = (ConsortialvRank *)param;
				ConsortialvRank::RankSet & levelRankingSet = consortialvRank->getRankSet();
				int count = CRCore::minimum((int)querycount,(int)(levelRankingSet.size()-start));
				ConsortialvRank::RankSet::iterator itr = levelRankingSet.begin();
				int index = 0;
				if (!m_stream->eof())
				{
					name = m_stream->_readString();
					for(;itr != levelRankingSet.end(); ++itr)
					{
						if (itr->valid() == false) continue;
						rankItem = (ConsortiaLvRankItem *)( (*itr).get() );

						if (shiliindex == 0 || rankItem->m_shili == shiliindex)
						{
							if (name == rankItem->m_groupName)
							{
								start = index;
								count = 1;
								break;
							}
							index++;		
						}
					}

				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;
					unsigned char groupshiliid = 0;
					itr = levelRankingSet.begin(); 

					for(;itr != levelRankingSet.end(); ++itr)
					{
						if (itr->valid() == false) continue;
						rankItem = (ConsortiaLvRankItem *)( (*itr).get() );

						if (shiliindex == 0 || rankItem->m_shili == shiliindex)
						{
							if(i >= start && i < start + count) recordcount ++;
							if (rankItem->m_id == mygroupid) myranking = i;
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(132);
					stream->_writeUChar((unsigned char)recordcount);
					std::string leadername;
					std::string groupName;
					unsigned char grouplv = 0;
					unsigned short groupmembercount = 0;
					int grouptroops = 0;
					int groupexploit = 0;
					ConsortiaMemberMap::iterator mitr;
					itr = levelRankingSet.begin(); 
					for ( i = 0;i < start + count && itr != levelRankingSet.end(); ++itr)
					{
						if (itr->valid() == false) continue;
						rankItem = (ConsortiaLvRankItem * )(itr->get());
						if (rankItem == NULL) continue;
						if (shiliindex == 0 || rankItem->m_shili == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeString(rankItem->m_groupName);//20
								stream->_writeString(rankItem->m_leaderName);//20
								stream->_writeUChar(rankItem->m_lv);//1
								stream->_writeUShort(rankItem->m_memberCount);//2
								stream->_writeInt(rankItem->m_troops);//4
								stream->_writeInt(rankItem->m_exploit);//4
								stream->_writeUChar(rankItem->m_shili);//1
								stream->_writeInt(i+1); //排名
							}
							++i;
						}
					}

					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvConsortialvRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			if (canvas.valid() && canvas->getDataClass())
			{
				crData *canvasdata = canvas->getDataClass();
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
				canvasdata->getParam(WCHDATA_JXJConsortialvRankingMap,param);
				GrouplvRankingMap *rankingMap = (GrouplvRankingMap *)param;
				rankingMap->clear();
				int count = (int)(m_stream->_readUChar());
				ref_ptr<crJXJGroupInfo> expRanking;
				for (int i = 0; i<count; i++)
				{
					expRanking = new crJXJGroupInfo;
					expRanking->setName(m_stream->_readString());
					expRanking->setCreatorName(m_stream->_readString());
					expRanking->setLv(m_stream->_readUChar());
					expRanking->setMemberCount(m_stream->_readUShort());
					expRanking->setGroupTroops(m_stream->_readInt());
					expRanking->setGroupExploit(m_stream->_readInt());
					expRanking->setShiliID(m_stream->_readUChar());
					expRanking->setRank(m_stream->_readInt());
					rankingMap->insert(std::make_pair(expRanking->getLv(),expRanking));
				}
				unsigned short mapsize = m_stream->_readUShort();
				unsigned short myranking = m_stream->_readUShort();
				canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
				int totalPage = ceil((float)mapsize/(float)pageCount);
				if(totalPage == 0) totalPage = 1;
				canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
				canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
				canvas->doEvent(WCH_UI_UpdateData);
			}
		}
	}
}

/////////////////////////////////////////
//
//crJXJRecvConsortiaMemberRankingMethod
//
/////////////////////////////////////////
crJXJRecvConsortiaMemberRankingMethod::crJXJRecvConsortiaMemberRankingMethod():
	m_netType(GameClient_Game){}
crJXJRecvConsortiaMemberRankingMethod::crJXJRecvConsortiaMemberRankingMethod(const crJXJRecvConsortiaMemberRankingMethod& handle):
	crMethod(handle),
	m_canvasName(handle.m_canvasName)
{
}
void crJXJRecvConsortiaMemberRankingMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvConsortiaMemberRankingMethod::addParam(int i, const std::string& str)
{
	switch(i) 
	{
	case 0:
		m_canvasName = str;
		break;
	}
}

void crJXJRecvConsortiaMemberRankingMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameServer)
		{
			int playerid = m_this->getPlayerID();
			//返回信息
			crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
			ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
			if(playerData.valid() && m_this->getMainRole() && m_this->getMainRole()->getDataClass())
			{
				unsigned short start = m_stream->_readUShort();
				unsigned char querycount = m_stream->_readUChar();
				unsigned char shiliindex = m_stream->_readUChar();
				std::string name;
				ConsortiaLvRankItem *rankItem;
				void *param;
				crData *data = m_this->getDataClass();
				//crData *mainroledata = m_this->getMainRole()->getDataClass();
				data->getParam(WCHDATA_JXJConsortiaID,param);
				int mygroupid = *(int *)param;
				crData *serverData = crServerBrainHandle::getInstance()->getDataClass();
				serverData->excHandle(MAKECREPARAM(WCH_LockData,1));

				serverData->getParam(WCHDATA_JXJConsortiaLvRank,param);
				ConsortiaMemberCountRank* consortiaMemberCountRank = (ConsortiaMemberCountRank*)param;
				ConsortiaMemberCountRank tmpconsortiaMemberCountRank = *consortiaMemberCountRank;
				ConsortiaMemberCountRank::RankSet & memberCountRankSet = consortiaMemberCountRank->getRankSet();

				int count = CRCore::minimum((int)querycount,(int)(memberCountRankSet.size()-start));
				ConsortiaMemberCountRank::RankSet::iterator itr = memberCountRankSet.begin();

				for(;itr != memberCountRankSet.end(); ++itr)
				{
					if (itr->valid() == false) continue;
					rankItem = (ConsortiaLvRankItem *)( (*itr).get() );
					CRCore::ref_ptr<ConsortiaLvRankItem > tmprankItem = new ConsortiaLvRankItem(rankItem->m_id);
					tmprankItem->m_groupName = rankItem->m_groupName;
					tmprankItem->m_leaderName = rankItem->m_leaderName;
					tmprankItem->m_lv = rankItem->m_lv;
					tmprankItem->m_memberCount = rankItem->m_memberCount;
					tmprankItem->m_exploit = rankItem->m_exploit;
					tmprankItem->m_troops = rankItem->m_troops;
					tmprankItem->m_shili = rankItem->m_shili;
					tmpconsortiaMemberCountRank.updateRank(tmprankItem->getKey(),tmprankItem);
				}
				ConsortiaMemberCountRank::RankSet & tmpmemberCountRankSet = tmpconsortiaMemberCountRank.getRankSet();

				int index = 0;
				if (!m_stream->eof())
				{
					name = m_stream->_readString();
					itr = tmpmemberCountRankSet.begin();
					for(;itr != tmpmemberCountRankSet.end(); ++itr)
					{
						if (itr->valid() == false) continue;
						rankItem = (ConsortiaLvRankItem *)( (*itr).get() );
						if (shiliindex == 0 || rankItem->m_shili == shiliindex)
						{
							if (name == rankItem->m_groupName)
							{
								start = index;
								count = 1;
								break;
							}
							index++;		
						}
					}
			
				}
				if(count>0)
				{
					short myranking = -1;
					int recordcount = 0;
					int i = 0;
					unsigned short totalrecord = 0;
					unsigned char groupshiliid = 0;
					itr = tmpmemberCountRankSet.begin(); 

					for(;itr != tmpmemberCountRankSet.end(); ++itr)
					{
						if (itr->valid() == false) continue;
						rankItem = (ConsortiaLvRankItem *)( (*itr).get() );

						if (shiliindex == 0 || rankItem->m_shili == shiliindex)
						{
							if(i >= start && i < start + count) recordcount ++;
							if (rankItem->m_id == mygroupid) myranking = i;
							++i;
							++totalrecord;
						}
					}
					ref_ptr<crStreamBuf> stream = new crStreamBuf;
					crPlayerDataEventPacket packet;
					stream->createBuf(132);
					stream->_writeUChar((unsigned char)recordcount);
					std::string leadername;
					std::string groupName;
					unsigned char grouplv = 0;
					unsigned short groupmembercount = 0;
					int grouptroops = 0;
					int groupexploit = 0;
					itr = tmpmemberCountRankSet.begin(); 
					for ( i = 0;i < start + count && itr != tmpmemberCountRankSet.end(); ++itr)
					{
						if (itr->valid() == false) continue;
						rankItem = (ConsortiaLvRankItem * )(itr->get());
						if (rankItem == NULL) continue;
						if (shiliindex == 0 || rankItem->m_shili == shiliindex)
						{
							if(i>=start)
							{
								stream->_writeString(rankItem->m_groupName);//20
								stream->_writeString(rankItem->m_leaderName);//20
								stream->_writeUChar(rankItem->m_lv);//1
								stream->_writeUShort(rankItem->m_memberCount);//2
								stream->_writeInt(rankItem->m_troops);//4
								stream->_writeInt(rankItem->m_exploit);//4
								stream->_writeUChar(rankItem->m_shili);//1
								stream->_writeInt(i+1); //排名
							}
							++i;
						}
					}

					stream->_writeUShort(totalrecord);
					stream->_writeUShort(unsigned short(myranking + 1));
					crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvConsortiaMemberRanking,stream.get());
					gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
				}
				serverData->excHandle(MAKECREPARAM(WCH_LockData,0));
			}
		}
		else if(m_netType == GameClient_Game)
		{
			void *param;
			crData *data = m_this->getDataClass();
			data->getParam(WCHDATA_JXJVipLv,param);
			unsigned char viplv = *(unsigned char *)param;
			int pageCount = (int)(atoi(crGlobalHandle::gData()->gGameGlobalValue(WCHDATA_JXJRankingCount,viplv).c_str()));
			ref_ptr<crCanvasNode>canvas = crFilterRenderManager::getInstance()->findCanvas(m_canvasName);
			crData *canvasdata = canvas->getDataClass();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,1));
			canvasdata->getParam(WCHDATA_JXJConsortiaMemberRankingMap,param);
			GroupMemberRankingMap *rankingMap = (GroupMemberRankingMap *)param;
			rankingMap->clear();
			int count = (int)(m_stream->_readUChar());
			ref_ptr<crJXJGroupInfo> expRanking;
			for (int i = 0; i<count; i++)
			{
				expRanking = new crJXJGroupInfo;
				expRanking->setName(m_stream->_readString());
				expRanking->setCreatorName(m_stream->_readString());
				expRanking->setLv(m_stream->_readUChar());
				expRanking->setMemberCount(m_stream->_readUShort());
				expRanking->setGroupTroops(m_stream->_readInt());
				expRanking->setGroupExploit(m_stream->_readInt());
				expRanking->setShiliID(m_stream->_readUChar());
				expRanking->setRank(m_stream->_readInt());

				rankingMap->insert(std::make_pair(expRanking->getMemberCount(),expRanking));
			}
			unsigned short mapsize = m_stream->_readUShort();
			unsigned short myranking = m_stream->_readUShort();
			canvasdata->excHandle(MAKECREPARAM(WCH_LockData,0));
			int totalPage = ceil((float)mapsize/(float)pageCount);
			if(totalPage == 0) totalPage = 1;
			canvasdata->inputParam(WCHDATA_JXJRankingTotal,&totalPage);
			canvasdata->inputParam(WCHDATA_JXJMyRanking,&myranking);
			canvas->doEvent(WCH_UI_UpdateData);
		}
	}
}
/////////////////////////////////////////
//
//crJXJDeductCopperCashMethod
//
/////////////////////////////////////////
crJXJDeductCopperCashMethod::crJXJDeductCopperCashMethod():
	m_this(NULL),
	m_needdeduct(0)
{
}

crJXJDeductCopperCashMethod::crJXJDeductCopperCashMethod(const crJXJDeductCopperCashMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_needdeduct(0)
{
}

void crJXJDeductCopperCashMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_needdeduct = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_needdeduct = (int *)(LOCREPARAM(param64));
		}
		else
		{
			m_needdeduct = NULL;
		}
		break;
	}
}

void crJXJDeductCopperCashMethod::addParam(int i, const std::string& str)
{
}

void crJXJDeductCopperCashMethod::operator()(crHandle &handle)
{
	bool success = false;
	if (*m_needdeduct == 0)
	{
		success = true;
	}
	if(m_this)
	{	
		// 0：扣除成功|增加成功
		//-1：扣除失败
		int playerid = m_this->getPlayerID();
		crNetConductor *gameServer = crNetContainer::getInstance()->getNetConductor(GameServer); 
		ref_ptr<crGameServerPlayerData> playerData = dynamic_cast<crGameServerPlayerData *>(gameServer->getNetDataManager()->getPlayerData(playerid));
		if(playerData.valid())
		{
			crData *data = m_this->getDataClass();
			void *param;
			data->excHandle(MAKECREPARAM(WCH_LockData,1));
			data->getParam(WCHDATA_JXJCoppercash,param);
			int *coppercash = (int *)param;
			int addcash = 0;
			if (*coppercash >= *m_needdeduct)
			{
				if (*m_needdeduct > 0)
				{//扣除铜钱
					*coppercash -= *m_needdeduct;
				}
				else
				{//增加铜钱
					addcash = - (*m_needdeduct);
					INTLIMITADD(*coppercash,addcash,INT_MAX);
				}
				success = true;
			}
			else
			{//增加铜钱
				if (*m_needdeduct < 0)			// 这个条件成立?难道 *coppercash 还能为负数!!
				{
					addcash = - (*m_needdeduct);
					INTLIMITADD(*coppercash,addcash,INT_MAX);
					success = true;
				}
			}
			data->excHandle(MAKECREPARAM(WCH_LockData,0));

			ref_ptr<crStreamBuf> stream = new crStreamBuf;
			stream->createBuf(4);
			stream->_writeInt(*coppercash);
			crPlayerDataEventPacket packet;
			crPlayerDataEventPacket::buildReplyPacket(packet,playerid,WCH_JXJRecvDeductCopperCash,stream.get());
			if (playerData.valid())
			{
				gameServer->getNetManager()->sendPacket(playerData->getPlayerConnectServerAddress(),packet);
			}
		}
	}
	if (success)
	{
		*m_needdeduct = 0;
	}
	else
	{
		*m_needdeduct = -1;
	}
}
/////////////////////////////////////////
//
//crJXJCheckCopperCashMethod
//
/////////////////////////////////////////
crJXJCheckCopperCashMethod::crJXJCheckCopperCashMethod():
	m_this(NULL),
	m_needdeduct(0)
{
}

crJXJCheckCopperCashMethod::crJXJCheckCopperCashMethod(const crJXJCheckCopperCashMethod& handle):
	crMethod(handle),
	m_this(NULL),
	m_needdeduct(0)
{
}

void crJXJCheckCopperCashMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_needdeduct = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_needdeduct = (int *)(LOCREPARAM(param64));
		}
		else
		{
			m_needdeduct = NULL;
		}
		break;
	}
}

void crJXJCheckCopperCashMethod::addParam(int i, const std::string& str)
{
}

void crJXJCheckCopperCashMethod::operator()(crHandle &handle)
{
	bool success = false;
	if (m_needdeduct <= 0)
	{
		success = true;
	}
	if(m_this && m_needdeduct>0)
	{	
		// 0：检测成功
		//-1：检测失败
		crData *data = m_this->getDataClass();
		if(data)
		{
			void *param;
			int playerid = m_this->getPlayerID();
			crPlayerGameData *playerData = crMyPlayerData::getInstance()->getPlayerGameData();
			crData *data = playerData->getDataClass();
			data->getParam(WCHDATA_JXJCoppercash,param);
			int coppercash = *(int *)param;
			//检测铜钱
			if (coppercash >= *m_needdeduct)
			{
				success = true;
			}
		}
	}
	if (success)
	{
		*m_needdeduct = 0;
	}
	else
	{
		*m_needdeduct = -1;
	}
}
/////////////////////////////////////////
//
//crJXJRecvDeductCopperCashMethod
//
/////////////////////////////////////////
crJXJRecvDeductCopperCashMethod::crJXJRecvDeductCopperCashMethod():
	m_netType(GameClient_Game){}
crJXJRecvDeductCopperCashMethod::crJXJRecvDeductCopperCashMethod(const crJXJRecvDeductCopperCashMethod& handle):
	crMethod(handle)
{
}
void crJXJRecvDeductCopperCashMethod::inputParam(int i, void *param)
{
	switch(i) 
	{
	case 0:
		if(param == 0)
		{//释放
			m_this = NULL;
			m_stream = NULL;
		}
		break;
	case 1:
		m_this = (crPlayerGameData*)param;
		break;
	case 2:
		if(param)
		{
			CREPARAM& param64 = *(CREPARAM*)param;
			m_stream = (crStreamBuf *)(LOCREPARAM(param64));
			m_netType = HICREPARAM(param64);
		}
		else
		{
			m_stream = NULL;
		}
		break;
	}
}

void crJXJRecvDeductCopperCashMethod::addParam(int i, const std::string& str)
{
}

void crJXJRecvDeductCopperCashMethod::operator()(crHandle &handle)
{
	if(m_this && m_stream.valid())
	{
		if(m_netType == GameClient_Game)
		{
			void *param;
			int curcopper = m_stream->_readInt();
			crData *data = m_this->getDataClass();
			if (data)
			{
				data->getParam(WCHDATA_JXJCoppercash,param);
				int extra = curcopper - *(int *)param;
				data->inputParam(WCHDATA_JXJCoppercash,&curcopper);

				if(extra!=0)
					crBrain::getInstance()->doEvent(WCH_JXJClientUserRecvSomeValue,MAKECREPARAM(T_Copper,extra));
			}
		}
	}
}